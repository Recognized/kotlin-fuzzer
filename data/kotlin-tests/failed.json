{
    "count": 4529,
    "success": false,
    "codes": [
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_REFLECT\n// FILE: 1.kt\n\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\n\npackage test\n\nimport kotlin.reflect.*\n\nobject Delegate {\n    lateinit var property: KProperty<*>\n\n    operator fun getValue(instance: Any?, kProperty: KProperty<*>): List<String?> {\n        property = kProperty\n        return emptyList()\n    }\n}\n\n// FILE: 2.kt\n\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\n\npackage test\n\nfun foo() {\n    val x by Delegate\n    x\n}\n\n// FILE: test.kt\n\nimport test.*\nimport kotlin.test.assertEquals\n\nfun box(): String {\n    foo()\n    assertEquals(\"val x: kotlin.collections.List<kotlin.String?>\", Delegate.property.toString())\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_REFLECT\n// FILE: Test1.kt\n\n@file:kotlin.jvm.JvmName(\"Test\")\n@file:kotlin.jvm.JvmMultifileClass\npackage test\n\nimport kotlin.test.assertEquals\n\nfun getX() = 1\n\nfun box(): String {\n    assertEquals(\"getX\", ::getX.name)\n    assertEquals(\"getY\", ::getY.name)\n    assertEquals(\"getZ\", ::getZ.name)\n\n    assertEquals(1, ::getX.call())\n    assertEquals(239, ::getY.call())\n    assertEquals(42, ::getZ.callBy(emptyMap()))\n\n    return \"OK\"\n}\n\n// FILE: Test2.kt\n\n@file:kotlin.jvm.JvmName(\"Test\")\n@file:kotlin.jvm.JvmMultifileClass\npackage test\n\nfun getY() = 239\n\nfun getZ(value: Int = 42) = value\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n\n// WITH_REFLECT\n// FULL_JDK\n// FILE: 1.kt\n\n@file:kotlin.jvm.JvmName(\"Test\")\n@file:kotlin.jvm.JvmMultifileClass\npackage test\n\nimport kotlin.reflect.jvm.*\nimport kotlin.test.assertEquals\n\nfun testX() {\n    val field = ::x.javaField ?: throw AssertionError(\"No java field for ${::x.name}\")\n\n    try {\n        field.get(null)\n        throw AssertionError(\"Fail: field.get should fail because the field is private\")\n    }\n    catch (e: IllegalAccessException) {\n        // OK\n    }\n\n    field.setAccessible(true)\n    assertEquals(\"I am x\", field.get(null))\n    field.set(null, \"OK\")\n}\n\nfun testY() {\n    val field = ::y.javaField ?: throw AssertionError(\"No java field for ${::y.name}\")\n\n    assertEquals(\"I am const y\", field.get(null))\n\n    // Accessible = false should have no effect because the field is public\n    field.setAccessible(false)\n\n    assertEquals(\"I am const y\", field.get(null))\n}\n\nfun testZ() {\n    val field = refZ.javaField ?: throw AssertionError(\"No java field for ${refZ.name}\")\n\n\n    try {\n        field.get(null)\n        throw AssertionError(\"IllegalAccessError expected\")\n    }\n    catch (e: IllegalAccessException) {\n        // OK\n    }\n\n    field.setAccessible(true)\n    assertEquals(\"I am private const val Z\", field.get(null))\n}\n\nfun box(): String {\n    testX()\n    testY()\n    testZ()\n    return x\n}\n\n// FILE: 2.kt\n\n@file:kotlin.jvm.JvmName(\"Test\")\n@file:kotlin.jvm.JvmMultifileClass\npackage test\n\nvar x = \"I am x\"\nconst val y = \"I am const y\"\nprivate const val z = \"I am private const val Z\"\n\nval refZ = ::z"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n\n// KT-11447 Multifile declaration causes IAE: Method can not access a member of class\n// WITH_REFLECT\n// FILE: Test1.kt\n\n@file:kotlin.jvm.JvmName(\"Test\")\n@file:kotlin.jvm.JvmMultifileClass\npackage test\n\nimport kotlin.test.assertEquals\n\nvar x = 1\n\nfun box(): String {\n    assertEquals(\"x\", ::x.name)\n    assertEquals(\"y\", ::y.name)\n    assertEquals(\"MAGIC_NUMBER\", ::MAGIC_NUMBER.name)\n\n    assertEquals(1, ::x.call())\n    assertEquals(1, ::x.getter.call())\n\n    assertEquals(239, ::y.call())\n    assertEquals(239, ::y.getter.call())\n\n    assertEquals(42, ::MAGIC_NUMBER.call())\n    assertEquals(42, ::MAGIC_NUMBER.getter.call())\n\n    assertEquals(Unit, ::x.setter.call(2))\n    assertEquals(2, ::x.call())\n    assertEquals(2, ::x.getter.call())\n\n    return \"OK\"\n}\n\n// FILE: Test2.kt\n\n@file:kotlin.jvm.JvmName(\"Test\")\n@file:kotlin.jvm.JvmMultifileClass\npackage test\n\nval y = 239\n\nconst val MAGIC_NUMBER = 42\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.ExperimentalStdlibApi\n// TARGET_BACKEND: JS\n// IGNORE_BACKEND: JS_IR\n// WITH_REFLECT\n\n// MODULE: lib1\n// FILE: lib1.kt\nimport kotlin.reflect.typeOf\n\ninline fun <reified T> get() = typeOf<T>()\n\n// MODULE: lib2(lib1)\n// FILE: lib2.kt\ninline fun <reified U> get1() = get<U?>()\n\n// MODULE: lib3(lib1, lib2)\n// FILE: lib3.kt\nimport kotlin.reflect.KType\n\ninline fun <reified V> get2(): KType {\n    return get1<Map<in V?, Array<V>>>()\n}\n\n// MODULE: main(lib1, lib2, lib3)\n// FILE: lib4.kt\nimport kotlin.test.assertEquals\n\ninterface C\n\nfun box(): String {\n    assertEquals(\"C?\", get1<C>().toString())\n    assertEquals(\"Map<in C?, Array<C>>?\", get2<C>().toString())\n    assertEquals(\"Map<in List<C>?, Array<List<C>>>?\", get2<List<C>>().toString())\n\n    assertEquals(\"Short?\", get1<Short>().toString())\n    assertEquals(\"Map<in Short?, Array<Short>>?\", get2<Short>().toString())\n    assertEquals(\"Map<in List<Short>?, Array<List<Short>>>?\", get2<List<Short>>().toString())\n    assertEquals(\"Map<in List<dynamic>?, Array<List<dynamic>>>?\", get2<List<dynamic>>().toString())\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n\n// WITH_REFLECT\n// FILE: test.kt\n\nfun test2() {\n}\n\n// FILE: main.kt\n// See KT-10690 Exception in kotlin.reflect when trying to get kotlinFunction from javaMethod\n\nimport kotlin.reflect.jvm.javaMethod\nimport kotlin.reflect.jvm.kotlinFunction\n\nfun box(): String {\n    if (::box.javaMethod?.kotlinFunction == null)\n        return \"Fail box\"\n    if (::test1.javaMethod?.kotlinFunction == null)\n        return \"Fail test1\"\n    if (::test2.javaMethod?.kotlinFunction == null)\n        return \"Fail test2\"\n\n    return \"OK\"\n}\n\nfun test1() {\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// FILE: lateinit.kt\nprivate lateinit var s: String\n\nobject C {\n    fun setS(value: String) { s = value }\n    fun getS() = s\n}\n\n// FILE: test.kt\nimport kotlin.UninitializedPropertyAccessException\n\nfun box(): String {\n    var str2: String = \"\"\n    try {\n        str2 = C.getS()\n        return \"Should throw an exception\"\n    }\n    catch (e: UninitializedPropertyAccessException) {\n        return \"OK\"\n    }\n    catch (e: Throwable) {\n        return \"Unexpected exception: ${e::class}\"\n    }\n\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// MODULE: lib\n// FILE: common.kt\n\nclass C<T>(var t: T)\nclass G<T>(var t: T)\n\nvar <T> C<T>.live: T\n    get() {\n        return t\n    }\n    set(value) {\n        t = value\n    }\n\nvar <T> G<T>.live: T\n    get() {\n        return t\n    }\n    set(value) {\n        t = value\n    }\n\n// MODULE: main(lib)\n// FILE: main.kt\nimport kotlin.reflect.KMutableProperty0\n\nfun qux(text: KMutableProperty0<String>, s: String): String {\n    text.set(s)\n    return text.get()\n}\n\nfun box(): String {\n    val c = C(\"FAIL_C\")\n    val g = G(\"FAIL_G\")\n    return qux(c::live, \"O\") + qux(g::live, \"K\")\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// The non-IR backend attempts to call a non-existent accessor in class Test.\n// IGNORE_BACKEND: JVM\n\n// FILE: test.kt\n\nclass Test2 {\n    inline fun test() = Test.testStatic()\n}\n\n// FILE: test2.kt\n\npackage anotherPackage\n\nimport Test2\n\nfun box() = Test2().test()\n"
        },
        {
            "code": "// FILE: 1.kt\n\nimport b.B\nimport a.BSamePackage\n\nfun box() = if (B().test() == BSamePackage().test()) \"OK\" else \"fail\"\n\n// FILE: 2.kt\n\npackage a\n\nopen class A {\n    protected fun protectedFun(): String = \"OK\"\n}\n\nclass BSamePackage: A() {\n    fun test(): String {\n        val a = {\n            protectedFun()\n        }\n        return a()\n    }\n}\n\n// FILE: 3.kt\n\npackage b\n\nimport a.A\n\nclass B: A() {\n    fun test(): String {\n        val a = {\n            protectedFun()\n        }\n        return a()\n    }\n}\n"
        },
        {
            "code": "// FILE: test.kt\nimport b.B\n\nfun box() =\n        B().getOK()\n\n// FILE: a.kt\npackage a\n\nopen class A<T> {\n    protected fun getO(x: T) = \"O\"\n    protected fun getK(x: T) = \"K\"\n}\n\n// FILE: b.kt\npackage b\n\nimport a.A\n\nclass B : A<Long>() {\n    inner class Inner {\n        fun innerGetO() = getO(0L)\n    }\n\n    fun lambdaGetK() = { -> getK(0L) }\n\n    fun getOK() =\n            Inner().innerGetO() + lambdaGetK().invoke()\n}"
        },
        {
            "code": "// FILE: test.kt\nimport b.B\n\nfun box() =\n        B().getOK()\n\n// FILE: a.kt\npackage a\n\nopen class A<T> {\n    protected fun getO(x: T, z: String = \"\") = \"O\" + z\n    protected fun getK(x: T, z: String = \"\") = \"K\" + z\n}\n\n// FILE: b.kt\npackage b\n\nimport a.A\n\nclass B : A<Long>() {\n    inner class Inner {\n        fun innerGetO() = getO(0L)\n    }\n\n    fun lambdaGetK() = { -> getK(0L) }\n\n    fun getOK() =\n            Inner().innerGetO() + lambdaGetK().invoke()\n}"
        },
        {
            "code": "// FILE: a.kt\n\npackage a\n\nimport b.*\n\ninterface B {\n    companion object : A() {}\n\n    fun test() {\n        foo()\n    }\n}\n\nclass C : B\n\nfun box(): String {\n    C().test()\n    return result\n}\n\n// FILE: b.kt\n\npackage b\n\nvar result = \"fail\"\n\nabstract class A {\n    protected fun foo() {\n        result = \"OK\"\n    }\n}\n"
        },
        {
            "code": "// FILE: a.kt\n\npackage a\n\nimport b.*\n\nfun box(): String {\n    BB().ok()\n    return BB().OK\n}\n\n// FILE: b.kt\n\npackage b\n\npublic open class B {\n    public var OK: String = \"OK\"\n        protected set\n}\n\npublic class BB : B() {\n    public fun ok(): String = OK\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n\n// FILE: A.kt\npackage a\nimport b.*\n\nclass A {\n    fun foo() = ok\n\n    companion object : B()\n}\n\nfun box(): String {\n    return A().foo()\n}\n\n// FILE: B.kt\npackage b\n\nopen class B {\n    @JvmField protected val ok = \"OK\"\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// FILE: 1.kt\n\nimport test.A\nimport kotlin.test.assertEquals\n\nopen class B : A() {\n    fun box(): String {\n        val overriddenMethod: () -> String = {\n            method()\n        }\n        assertEquals(\"C.method\", overriddenMethod())\n\n        val superMethod: () -> String = {\n            super.method()\n        }\n        assertEquals(\"A.method\", superMethod())\n\n        val overriddenPropertyGetter: () -> String = {\n            property\n        }\n        assertEquals(\"C.property\", overriddenPropertyGetter())\n\n        val superPropertyGetter: () -> String = {\n            super.property\n        }\n        assertEquals(\"A.property\", superPropertyGetter())\n\n        val overriddenPropertySetter: () -> Unit = {\n            property = \"\"\n        }\n        overriddenPropertySetter()\n\n        val superPropertySetter: () -> Unit = {\n            super.property = \"\"\n        }\n        superPropertySetter()\n\n        assertEquals(\"C.property;A.property;\", state)\n\n        return \"OK\"\n    }\n}\n\nclass C : B() {\n    override fun method() = \"C.method\"\n    override var property: String\n        get() = \"C.property\"\n        set(value) { state += \"C.property;\" }\n}\n\nfun box() = C().box()\n\n// FILE: 2.kt\n\npackage test\n\nabstract class A {\n    public var state = \"\"\n\n    // These implementations should not be called, because they are overridden in C\n\n    protected open fun method(): String = \"A.method\"\n\n    protected open var property: String\n        get() = \"A.property\"\n        set(value) { state += \"A.property;\" }\n}\n"
        },
        {
            "code": "// FILE: a.kt\n\npackage a\n\nimport b.*\n\nclass B {\n    companion object : A() {}\n\n    init {\n        foo()\n    }\n}\n\nfun box(): String {\n    B()\n    return result\n}\n\n// FILE: b.kt\n\npackage b\n\nvar result = \"fail\"\n\nabstract class A {\n    protected fun foo() {\n        result = \"OK\"\n    }\n}\n"
        },
        {
            "code": "// FILE: A.kt\n\npackage first\nimport second.C\n\nopen class A {\n    protected open fun test(): String = \"FAIL (A)\"\n}\n\nfun box() = C().value()\n\n// FILE: B.kt\n\n// See also KT-8344: INVOKESPECIAL instead of INVOKEVIRTUAL in accessor\n\npackage second\n\nimport first.A\n\npublic abstract class B(): A() {\n    val value = {\n        test()\n    }\n}\n\nclass C: B() {\n    override fun test() = \"OK\"\n}\n"
        },
        {
            "code": "// FILE: a.kt\n\npackage test2\n\nimport test.Actor\nimport test.O2dScriptAction\n\nclass CompositeActor : Actor()\n\npublic open class O2dDialog : O2dScriptAction<CompositeActor>() {\n\n    fun test() = { owner }()\n\n    fun test2() = { calc() }()\n}\n\nfun box(): String {\n    if (O2dDialog().test() != null) return \"fail 1\"\n    if (O2dDialog().test2() != null) return \"fail 2\"\n\n    return \"OK\"\n}\n\n// FILE: b.kt\n\npackage test\n\nopen class Actor\n\nabstract public class O2dScriptAction<T : Actor> {\n    protected var owner: T? = null\n        private set\n\n    protected fun calc(): T? = null\n\n}\n"
        },
        {
            "code": "// FILE: test.kt\nimport base.*\n\nclass Derived : Base<Long>() {\n    inner class Inner {\n        fun foo() = this@Derived[0L]\n    }\n}\n\nfun box() = Derived().Inner().foo()\n\n// FILE: Base.kt\npackage base\n\nopen class Base<K> {\n    protected operator fun get(key: K) = \"OK\"\n}"
        },
        {
            "code": "// !LANGUAGE: +TrailingCommas\n\nfun foo(vararg x: Int) = false\nfun foo(x: Int) = true\n\nfun box(): String {\n    val x = foo(1)\n    val y = foo(1,)\n    return if (x && y) \"OK\" else \"ERROR\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: box.kt\n\npackage test\n\nimport b.bar\n\nfun box(): String = bar()\n\n// FILE: caller.kt\n\npackage b\n\nimport a.foo\n\nfun bar(): String = foo()\n\n// FILE: multifileClass.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nfun foo(): String = \"OK\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: 1/part.kt\n\n@file:JvmName(\"Foo\")\n@file:JvmMultifileClass\npackage test\n\nfun foo(): String = \"O\"\n\n// FILE: 2/part.kt\n\n@file:JvmName(\"Bar\")\n@file:JvmMultifileClass\npackage test\n\nfun bar(): String = \"K\"\n\n// FILE: box.kt\n\npackage test\n\nfun box(): String = foo() + bar()\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: box.kt\n\nimport a.*\n\nfun box(): String = OK\n\n// FILE: part1.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nval O: String = \"O\"\n\n// FILE: part2.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nval K: String = \"K\"\n\n// FILE: part3.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nval OK: String = O + K\n\n// FILE: irrelevant.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nval X: Nothing = throw AssertionError(\"X should not be initialized\")\n\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_LIGHT_ANALYSIS\n// WITH_RUNTIME\n// !INHERIT_MULTIFILE_PARTS\n// FILE: box.kt\n\nimport a.*\n\nfun box(): String = (::ok)()\n\n// FILE: part1.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nfun ok() = \"OK\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_LIGHT_ANALYSIS\n// WITH_RUNTIME\n// !INHERIT_MULTIFILE_PARTS\n// FILE: box.kt\n\nimport a.*\n\nfun box(): String = ok()\n\n// FILE: part1.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nprivate fun overlapping() = \"oops #1\"\n\n// FILE: part2.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nprivate fun overlapping() = \"OK\"\n\nfun ok() = overlapping()\n\n// FILE: part3.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nprivate fun overlapping() = \"oops #2\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_LIGHT_ANALYSIS\n// WITH_RUNTIME\n// !INHERIT_MULTIFILE_PARTS\n// FILE: box.kt\n\nimport a.*\n\nfun box(): String = okInline()\n\n// FILE: part1.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\ninternal const val ok = \"OK\"\n\ninternal inline fun okInline() =\n        ::ok.get()\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_LIGHT_ANALYSIS\n// WITH_RUNTIME\n// !INHERIT_MULTIFILE_PARTS\n// FILE: box.kt\n\nimport a.*\n\nfun box(): String = ::OK.get()\n\n// FILE: part1.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nconst val OK = \"OK\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_LIGHT_ANALYSIS\n// WITH_RUNTIME\n// !INHERIT_MULTIFILE_PARTS\n// FILE: box.kt\n\nimport a.*\n\nfun box(): String = OK.okRef.get()\n\n// FILE: part1.kt\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nprivate const val ok = \"OK\"\n\nobject OK {\n    val okRef = ::ok\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_REFLECT\n// FILE: 1.kt\n\nimport a.OK\n\nfun box(): String {\n    val okRef = ::OK\n\n    val annotations = okRef.annotations\n    if (annotations.size != 1) {\n        return \"Failed, annotations: $annotations\"\n    }\n\n    return okRef.get()\n}\n\n// FILE: 2.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nannotation class A\n\n@A\nconst val OK: String = \"OK\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: foo.kt\n@file:JvmName(\"Util\")\n@file:JvmMultifileClass\npackage test\n\nprivate const val x = \"O\"\n\nfun foo() = x\n\n// FILE: bar.kt\n@file:JvmName(\"Util\")\n@file:JvmMultifileClass\npackage test\n\nprivate const val x = \"K\"\n\nfun bar() = x\n\n// FILE: test.kt\npackage test\n\nfun box(): String = foo() + bar()\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: box.kt\n\npackage test\n\nimport a.foo\n\nfun box(): String = foo { \"OK\" }\n\n// FILE: foo.kt\n\n@file:[JvmName(\"A\") JvmMultifileClass]\npackage a\n\ninline fun foo(body: () -> String): String = zee(body())\n\n// FILE: zee.kt\n\n@file:[JvmName(\"A\") JvmMultifileClass]\npackage a\n\npublic fun zee(x: String): String = x\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: 1.kt\n\nimport a.*\n\nfun box(): String {\n    if (foo() != \"OK\") return \"Fail function\"\n    if (constOK != \"OK\") return \"Fail const\"\n    if (valOK != \"OK\") return \"Fail val\"\n    varOK = \"OK\"\n    if (varOK != \"OK\") return \"Fail var\"\n\n    return \"OK\"\n}\n\n// FILE: 2.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\nfun foo(): String = \"OK\"\nconst val constOK: String = \"OK\"\nval valOK: String = \"OK\"\nvar varOK: String = \"Hmmm?\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: A.kt\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"A\")\n\npackage test\n\npublic val <T> Array<out T>.foo: String\n    get() = this[0].toString() + this[1].toString()\n\n// FILE: B.kt\n\nimport test.foo\n\nfun box(): String = arrayOf('O', \"K\").foo\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !USE_EXPERIMENTAL: kotlin.ExperimentalMultiplatform\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: common.kt\n\n@OptionalExpectation\nexpect annotation class Anno(val s: String)\n\n// FILE: jvm.kt\n\n@file:Suppress(\"OPTIONAL_DECLARATION_USAGE_IN_NON_COMMON_SOURCE\") // TODO: support common sources in the test infrastructure\n\nimport java.lang.reflect.AnnotatedElement\n\n@Anno(\"Foo\")\nclass Foo @Anno(\"<init>\") constructor(@Anno(\"x\") x: Int) {\n    @Anno(\"bar\")\n    fun bar() {}\n\n    @Anno(\"getX\")\n    var x = x\n        @Anno(\"setX\")\n        set\n\n    @Anno(\"Nested\")\n    interface Nested\n}\n\nprivate fun check(element: AnnotatedElement) {\n    check(element.annotations)\n}\n\nprivate fun check(annotations: Array<Annotation>) {\n    val filtered = annotations.filterNot { it.annotationClass.java.name == \"kotlin.Metadata\" }\n    if (filtered.isNotEmpty()) {\n        throw AssertionError(\"Annotations should be empty: $filtered\")\n    }\n}\n\nfun box(): String {\n    val foo = Foo::class.java\n    check(foo)\n    check(Foo.Nested::class.java)\n    check(foo.declaredMethods.single { it.name == \"bar\" })\n    check(foo.declaredMethods.single { it.name == \"getX\" })\n    check(foo.declaredMethods.single { it.name == \"setX\" })\n    check(foo.constructors.single())\n    check(foo.constructors.single().parameterAnnotations.single())\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: common.kt\n\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\npackage test\n\nexpect class Foo {\n    val value: String\n}\n\n// FILE: jvm.kt\n\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\npackage test\n\nactual class Foo(actual val value: String)\n\nfun box(): String {\n    return Foo(\"OK\").value\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// IGNORE_BACKEND: JS\n// IGNORE_BACKEND: JS_IR\n\n// MODULE: common\n// FILE: common.kt\n\npackage test\n\nexpect enum class E\n\n// MODULE: jvm1(common)\n// FILE: jvm.kt\n\npackage test\n\nactual typealias E = F\n\nenum class F {\n    OK;\n}\n\n// MODULE: main(jvm1)\n// FILE: jvm2.kt\n\nimport test.E.*\n\nfun box(): String {\n    return OK.name\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect inline fun topLevel(a: String, b: Int = 0, c: () -> Double? = { null }): String\n\nexpect class Foo() {\n    inline fun member(a: String, b: Int = 0, c: () -> Double? = { null }): String\n}\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual inline fun topLevel(a: String, b: Int, c: () -> Double?): String = a + \",\" + b + \",\" + c()\n\nactual class Foo actual constructor() {\n    actual inline fun member(a: String, b: Int, c: () -> Double?): String = a + \",\" + b + \",\" + c()\n}\n\nfun box(): String {\n    assertEquals(\"OK,0,null\", topLevel(\"OK\"))\n    assertEquals(\"OK,42,null\", topLevel(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", topLevel(\"OK\", 42, { 3.14 }))\n\n    val foo = Foo()\n    assertEquals(\"OK,0,null\", foo.member(\"OK\"))\n    assertEquals(\"OK,42,null\", foo.member(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", foo.member(\"OK\", 42, { 3.14 }))\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect fun foo(j: Int, i: Int = -1)\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\n@JvmOverloads\nactual fun foo(j: Int, i: Int) {\n    assertEquals(j, i)\n}\n\nfun box(): String {\n    foo(-1)\n    foo(5, 5)\n    return J.test();\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n\n// FILE: lib.kt\n\npackage foo\n\nexpect interface H {\n    fun foo(x: String = \"default\"): String\n}\n\n// FILE: main.kt\npackage foo\n\nactual interface H {\n    actual fun foo(x: String): String\n}\n\ninterface I: H {\n    override fun foo(x: String): String = \"I.foo($x)\"\n}\n\ninterface J : I {\n    override fun foo(x: String): String\n}\n\ninterface K : J {\n    override fun foo(x: String): String = \"K.foo($x)\"\n}\n\nclass A : I\n\nclass B : K\n\nfun box(): String {\n    val a = A()\n    var r = a.foo()\n    if (r != \"I.foo(default)\") return \"fail: A.foo()\"\n    r = a.foo(\"Q\")\n    if (r != \"I.foo(Q)\") return \"fail A.foo(Q): $r\"\n\n    val b = B()\n    r = b.foo()\n    if (r != \"K.foo(default)\") return \"fail B.foo(): $r\"\n    r = b.foo(\"W\")\n    if (r != \"K.foo(W)\") return \"fail B.foo(W): $r\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect open class C() {\n    open fun f(p: Int = 1) : String\n    open fun f2(p1: Int = 1, p2: Int = 2) : String\n    open fun ff(p1: Int, p2: Int = 2) : String\n    open fun fff(p1: Int, p2: Int, p3: Int = 3) : String\n    open fun fffx(p1: Int, p2: Int = 4, p3: Int = 5) : String\n}\n// FILE: platform.kt\n\nimport kotlin.test.assertEquals\n\nactual open class C {\n    actual open fun f(p: Int) =  \"f\" + p\n    actual open fun f2(p1: Int, p2: Int) = \"f2\" + p1 + \"\" + p2\n    actual open fun ff(p1: Int, p2: Int) = \"ff\" + p1 + \"\" + p2\n    actual open fun fff(p1: Int, p2: Int, p3: Int) = \"fff\" + p1 + \"\" + p2 + \"\" + p3\n    actual open fun fffx(p1: Int, p2: Int, p3: Int) = \"fffx\" + p1 + \"\" + p2 + \"\" + p3\n}\n\nfun box(): String {\n\n    assertEquals(\"f1\", C().f())\n    assertEquals(\"f212\", C().f2())\n    assertEquals(\"ff12\", C().ff(1))\n    assertEquals(\"fff123\", C().fff(1, 2))\n    assertEquals(\"fffx345\", C().fffx(3))\n\n    return \"OK\"\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect fun topLevel(a: String, b: Int = 0, c: Double? = null): String\n\nexpect class Foo() {\n    fun member(a: String, b: Int = 0, c: Double? = null): String\n}\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual fun topLevel(a: String, b: Int, c: Double?): String = a + \",\" + b + \",\" + c\n\nactual class Foo actual constructor() {\n    actual fun member(a: String, b: Int, c: Double?): String = a + \",\" + b + \",\" + c\n}\n\nfun box(): String {\n    assertEquals(\"OK,0,null\", topLevel(\"OK\"))\n    assertEquals(\"OK,42,null\", topLevel(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", topLevel(\"OK\", 42, 3.14))\n\n    val foo = Foo()\n    assertEquals(\"OK,0,null\", foo.member(\"OK\"))\n    assertEquals(\"OK,42,null\", foo.member(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", foo.member(\"OK\", 42, 3.14))\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect open class A() {\n    fun member(a: String, b: Int = 0, c: Double? = null): String\n}\n\nexpect class B() : A\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual open class A actual constructor() {\n    actual fun member(a: String, b: Int, c: Double?): String = a + \",\" + b + \",\" + c\n}\n\nactual class B actual constructor() : A()\n\nfun box(): String {\n    val b = B()\n    assertEquals(\"OK,0,null\", b.member(\"OK\"))\n    assertEquals(\"OK,42,null\", b.member(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", b.member(\"OK\", 42, 3.14))\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nopen class A() {\n    fun member(a: String, b: Int = 0, c: Double? = null): String = a + \",\" + b + \",\" + c\n}\n\nexpect class B() : A\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual class B actual constructor() : A()\n\nfun box(): String {\n    val b = B()\n    assertEquals(\"OK,0,null\", b.member(\"OK\"))\n    assertEquals(\"OK,42,null\", b.member(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", b.member(\"OK\", 42, 3.14))\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect annotation class A1(val x: Int, val y: String = \"OK\")\n\nexpect annotation class A2(val x: Int = 42, val y: String = \"OK\")\n\nexpect annotation class A3(val x: Int, val y: String)\n\nexpect annotation class A4(val x: Int = 42, val y: String)\n\n@A1(0)\n@A2\n@A3\n@A4\nfun test() {}\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual annotation class A1(actual val x: Int, actual val y: String)\n\nactual annotation class A2(actual val x: Int, actual val y: String = \"OK\")\n\nactual annotation class A3(actual val x: Int = 42, actual val y: String = \"OK\")\n\nactual annotation class A4(actual val x: Int, actual val y: String = \"OK\")\n\nfun box(): String {\n    val anno = Class.forName(\"CommonKt\").getDeclaredMethod(\"test\").annotations\n\n    val a1 = anno.single { it.annotationClass == A1::class } as A1\n    assertEquals(0, a1.x)\n    assertEquals(\"OK\", a1.y)\n\n    val a2 = anno.single { it.annotationClass == A2::class } as A2\n    assertEquals(42, a2.x)\n    assertEquals(\"OK\", a2.y)\n\n    val a3 = anno.single { it.annotationClass == A3::class } as A3\n    assertEquals(42, a3.x)\n    assertEquals(\"OK\", a3.y)\n\n    val a4 = anno.single { it.annotationClass == A4::class } as A4\n    assertEquals(42, a4.x)\n    assertEquals(\"OK\", a4.y)\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect open class C() {\n    open fun f(p: Int = 2) : String\n}\n\n// FILE: platform.kt\n\nimport kotlin.test.assertEquals\n\nactual open class C {\n    actual open fun f(p: Int) = \"C\" + p\n}\n\nopen class D : C() {\n    override open fun f(p: Int) = \"D\" + p\n}\n\nfun box(): String {\n\n    assertEquals(\"C2\", C().f())\n    assertEquals(\"C9\", C().f(9))\n    assertEquals(\"D2\", D().f())\n    assertEquals(\"D5\", D().f(5))\n\n    return \"OK\"\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// IGNORE_BACKEND: NATIVE\n// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND: JVM\n\n// FILE: lib.kt\n\npackage foo\n\nexpect open class A {\n    open fun foo(x: Int = 20, y: Int = 3): Int\n}\n\n// FILE: main.kt\npackage foo\n\nactual open class A {\n    actual open fun foo(x: Int, y: Int) = x + y\n}\n\nopen class B : A() {\n    override fun foo(x: Int, y: Int) = 0\n\n    fun bar1() = super.foo()\n\n    fun bar2() = super.foo(30)\n\n    fun bar3() = super.foo(y = 4)\n}\n\nfun box(): String {\n    val v1 = B().bar1()\n    if (v1 != 23) return \"fail1: $v1\"\n\n    val v2 = B().bar2()\n    if (v2 != 33) return \"fail2: $v2\"\n\n    val v3 = B().bar3()\n    if (v3 != 24) return \"fail3: $v3\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect class Foo(a: String, b: Int = 0, c: Double? = null)\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual class Foo actual constructor(a: String, b: Int, c: Double?) {\n    val result: String = a + \",\" + b + \",\" + c\n}\n\nfun box(): String {\n    assertEquals(\"OK,0,null\", Foo(\"OK\").result)\n    assertEquals(\"OK,42,null\", Foo(\"OK\", 42).result)\n    assertEquals(\"OK,42,3.14\", Foo(\"OK\", 42, 3.14).result)\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect open class A() {\n    open fun f(p: Int = 1) : String\n}\n\nexpect open class B : A {\n    override open fun f(p: Int) : String\n}\n\n// FILE: platform.kt\n\nimport kotlin.test.assertEquals\n\nactual open class A {\n    actual open fun f(p: Int) = \"A\" + p\n}\n\nactual open class B : A() {\n    actual override open fun f(p: Int) = \"B\" + p\n}\n\nfun box(): String {\n\n    assertEquals(\"A1\", A().f())\n    assertEquals(\"A9\", A().f(9))\n    assertEquals(\"B1\", B().f())\n    assertEquals(\"B5\", B().f(5))\n\n    return \"OK\"\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !USE_EXPERIMENTAL: kotlin.ExperimentalMultiplatform\n// IGNORE_BACKEND: NATIVE\n// WITH_RUNTIME\n// MODULE: library\n// FILE: expected.kt\n\npackage a\n\n@OptionalExpectation\nexpect annotation class A(val x: Int)\n\n@OptionalExpectation\nexpect annotation class B(val s: String)\n\n// FILE: actual.kt\n\npackage a\n\nactual annotation class A(actual val x: Int)\n\n// MODULE: main(library)\n// FILE: main.kt\n\n@file:Suppress(\"OPTIONAL_DECLARATION_USAGE_IN_NON_COMMON_SOURCE\") // TODO: support common sources in the test infrastructure\n\npackage usage\n\nimport a.A\nimport a.B\n\n@A(42)\n@B(\"OK\")\nfun box(): String {\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: common.kt\n\nexpect class Foo(a: String = \"\", b: Int = 42)\n\n// FILE: jvm.kt\n\nimport kotlin.test.assertEquals\n\nactual class Foo actual constructor(a: String, b: Int) {\n    init {\n        assertEquals(\"\", a)\n        assertEquals(42, b)\n    }\n}\n\nfun box(): String {\n    J.test()\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: Foo.kt\npackage foo\n\nclass A2 {\n    fun doWork(job: () -> Unit) {\n        Runnable(job)\n    }\n}\n\n// FILE: kt17091.kt\nimport foo.A2\n\ntypealias Z = String\n\nclass A {\n    fun doWork(job: () -> Unit) {\n        java.lang.Runnable(job).run()\n    }\n}\n\nfun box(): String {\n    var result = \"fail\"\n    A().doWork { result = \"OK\" }\n\n    if (java.lang.Class.forName(\"Kt17091Kt\\$sam\\$java_lang_Runnable$0\") == null) return \"fail: can't find sam wrapper\"\n\n    if (java.lang.Class.forName(\"foo.A2\\$sam\\$java_lang_Runnable$0\") == null) return \"fail 2: can't find sam wrapper\"\n\n    return result\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: Foo.kt\npackage foo\nimport MyRunnable\n\nclass A {\n    inline fun doWork(noinline job: () -> Unit) {\n        Runnable(job).run()\n    }\n\n    fun doNoninlineWork(job: () -> Unit) {\n        Runnable(job).run()\n    }\n}\n\nclass B {\n    inline fun doWork(noinline job: () -> Unit) {\n        Runnable(job).run()\n    }\n\n    fun doNonInlineWork(job: () -> Unit) {\n        MyRunnable(job).run()\n    }\n}\n\n// FILE: test.kt\nimport foo.A\nimport foo.B\n\nfun classForName(name: String): Class<*>? =\n    try {\n        java.lang.Class.forName(name)\n    } catch (e: Throwable) {\n        null\n    }\n\nfun box(): String {\n    var result = false\n    A().doWork { result = true }\n    if (!result) return \"Fail 1\"\n\n    result = false\n    A().doNoninlineWork { result = true }\n    if (!result) return \"Fail 2\"\n\n    result = false\n    B().doWork { result = true }\n    if (!result) return \"Fail 3\"\n\n    result = false\n    B().doNonInlineWork { result = true }\n    if (!result) return \"Fail 4\"\n\n    val inlineWrapperA = classForName(\"foo.A\\$sam\\$i\\$java_lang_Runnable$0\")\n    if (inlineWrapperA == null) return \"Fail 5: Can't find sam wrapper\"\n    if (inlineWrapperA.modifiers and 1 == 0) return \"Fail 6: inline sam wrapper is non-public\"\n\n    val wrapperA = classForName(\"foo.A\\$sam\\$java_lang_Runnable$0\")\n    if (wrapperA == null) return \"Fail 7: Can't find sam wrapper\"\n    if (wrapperA.modifiers and 1 != 0) return \"Fail 8: non-inline sam wrapper is public\"\n\n    val inlineWrapperB = classForName(\"foo.B\\$sam\\$i\\$java_lang_Runnable$0\")\n    if (inlineWrapperB != null) return \"Fail 9: sam wrapper not cached\"\n\n    val wrapperB = classForName(\"foo.B\\$sam\\$MyRunnable$0\")\n    if (wrapperB == null) return \"Fail 10: Can't find sam wrapper\"\n    if (wrapperB.modifiers and 1 != 0) return \"Fail 11: non-inline sam wrapper is public\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: Foo.kt\n@file:JvmName(\"testXX\")\npackage test\n\nclass A2 {\n    fun doWork(job: () -> Unit) {\n        Runnable(job)\n    }\n}\n\n\n// FILE: kt17091_2.kt\n\n@file:JvmMultifileClass\n@file:JvmName(\"testX\")\npackage test\n\ntypealias Z = String\n\nclass A {\n    fun doWork(job: () -> Unit) {\n        Runnable(job).run()\n    }\n}\n\nfun box(): String {\n    var result = \"fail\"\n    A().doWork { result = \"OK\" }\n\n    if (java.lang.Class.forName(\"test.testX__Kt17091_2Kt\\$sam\\$java_lang_Runnable$0\") == null) return \"fail: can't find sam wrapper\"\n\n    if (java.lang.Class.forName(\"test.A2\\$sam\\$java_lang_Runnable$0\") == null) return \"fail 2: can't find sam wrapper\"\n\n    return result\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: kt22906_1.kt\npackage test\n\nclass C {\n    fun startTemplate(): String {\n        val y = object {\n            fun foo(): String {\n                val job = { \"OK\" }\n                return java.util.concurrent.Callable(job).call()\n            }\n\n        }\n        return y.foo()\n    }\n}\n\n// FILE: kt22906_2.kt\nimport test.*\n\nfun box(): String {\n    if (java.lang.Class.forName(\"test.C\\$sam\\$java_util_concurrent_Callable\\$0\") == null) return \"fail: can't find sam wrapper\"\n\n    return C().startTemplate()\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: kt22906_1.kt\npackage test\n\nclass C {\n    fun startTemplate(): String {\n        val y = object {\n            fun foo(): String {\n                val job = { \"OK\" }\n                return java.util.concurrent.Callable(job).call()\n            }\n\n        }\n        return y.foo()\n    }\n\n    fun foo() {\n        val y = object {\n            fun foo(): String {\n                val job = { \"OK2\" }\n                return java.util.concurrent.Callable(job).call()\n            }\n\n        }\n    }\n}\n\n// FILE: kt22906_2.kt\nimport test.*\n\nfun box(): String {\n    if (java.lang.Class.forName(\"test.C\\$sam\\$java_util_concurrent_Callable\\$0\") == null) return \"fail: can't find sam wrapper\"\n\n    return C().startTemplate()\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: Definitions.kt\nimport interop.*\n\nobject Definitions {\n    const val KT_CONSTANT = Interface.CONSTANT\n\n    val ktValue = Interface.CONSTANT\n}\n\nfun box(): String =\n    Definitions.ktValue\n\n// FILE: interop/Interface.java\npackage interop;\n\npublic class Interface {\n    public static final String CONSTANT = \"OK\";\n}\n"
        },
        {
            "code": "// FILE: Var.kt\npackage pvar\n\nopen class PVar<T>(private var value: T) {\n    protected operator fun getValue(thisRef: Any?, prop: Any?) = value\n\n    protected operator fun setValue(thisRef: Any?, prop: Any?, newValue: T) {\n        value = newValue\n    }\n}\n\n// FILE: test.kt\nimport pvar.*\n\nclass C : PVar<Long>(42L) {\n    inner class Inner {\n        var x by this@C\n    }\n}\n\nfun box(): String {\n    val inner = C().Inner()\n    inner.x = 1L\n    return \"OK\"\n}"
        },
        {
            "code": "// MODULE: lib\n// FILE: lib.kt\npackage lib\n\nclass Provider<T>(val _value: T) {\n    inline operator fun provideDelegate(thisRef: Any?, kProperty: Any?) =\n        Mut(_value)\n}\n\nclass Mut<T>(var _value: T) {\n\n    inline operator fun getValue(thisRef: Any?, kProperty: Any?) = _value\n\n    inline operator fun setValue(thisRef: Any?, kProperty: Any?, newValue: T) {\n        _value = newValue\n    }\n}\n\n// MODULE: main(lib)(lib)\n// FILE: main.kt\nimport lib.*\n\nclass C {\n    val delegatedVal by Mut(1)\n    var delegatedVar by Mut(2)\n\n    val delegatedValByProvider by Provider(1)\n    var delegatedVarByProvider by Provider(2)\n}\n\nval topLevelDelegatedVal by Mut(1)\nvar topLevelDelegatedVar by Mut(2)\n\nval topLevelDelegatedValByProvider by Provider(1)\nvar topLevelDelegatedVarByProvider by Provider(2)\n\nfun box(): String {\n    val localDelegatedVal by Mut(1)\n    var localDelegatedVar by Mut(2)\n\n    val localDelegatedValByProvider by Provider(1)\n    var localDelegatedVarByProvider by Provider(2)\n\n    val x = C()\n    if (x.delegatedVal != 1) throw AssertionError()\n    if (x.delegatedVar != 2) throw AssertionError()\n    x.delegatedVar = 3\n    if (x.delegatedVar != 3) throw AssertionError()\n\n    if (x.delegatedValByProvider != 1) throw AssertionError()\n    if (x.delegatedVarByProvider != 2) throw AssertionError()\n    x.delegatedVarByProvider = 3\n    if (x.delegatedVarByProvider != 3) throw AssertionError()\n\n    if (topLevelDelegatedVal != 1) throw AssertionError()\n    if (topLevelDelegatedVar != 2) throw AssertionError()\n    topLevelDelegatedVar = 3\n    if (topLevelDelegatedVar != 3) throw AssertionError()\n\n    if (topLevelDelegatedValByProvider != 1) throw AssertionError()\n    if (topLevelDelegatedVarByProvider != 2) throw AssertionError()\n    topLevelDelegatedVarByProvider = 3\n    if (topLevelDelegatedVarByProvider != 3) throw AssertionError()\n\n    if (localDelegatedVal != 1) throw AssertionError()\n    if (localDelegatedVar != 2) throw AssertionError()\n    localDelegatedVar = 3\n    if (localDelegatedVar != 3) throw AssertionError()\n\n    if (localDelegatedValByProvider != 1) throw AssertionError()\n    if (localDelegatedVarByProvider != 2) throw AssertionError()\n    localDelegatedVarByProvider = 3\n    if (localDelegatedVarByProvider != 3) throw AssertionError()\n\n    return \"OK\"\n}"
        },
        {
            "code": "// MODULE: lib\n// FILE: lib.kt\npackage lib\n\nclass Provider<T>(val _value: T) {\n    inline operator fun provideDelegate(thisRef: Any?, kProperty: Any) =\n        Mut(_value)\n}\n\nclass Mut<T>(var _value: T) {\n\n    inline operator fun getValue(thisRef: Any?, kProperty: Any) = _value\n\n    inline operator fun setValue(thisRef: Any?, kProperty: Any, newValue: T) {\n        _value = newValue\n    }\n}\n\n// MODULE: main(lib)(lib)\n// FILE: main.kt\nimport lib.*\n\nclass C {\n    val delegatedVal by Mut(1)\n    var delegatedVar by Mut(2)\n\n    val delegatedValByProvider by Provider(1)\n    var delegatedVarByProvider by Provider(2)\n}\n\nval topLevelDelegatedVal by Mut(1)\nvar topLevelDelegatedVar by Mut(2)\n\nval topLevelDelegatedValByProvider by Provider(1)\nvar topLevelDelegatedVarByProvider by Provider(2)\n\nfun box(): String {\n    val localDelegatedVal by Mut(1)\n    var localDelegatedVar by Mut(2)\n\n    val localDelegatedValByProvider by Provider(1)\n    var localDelegatedVarByProvider by Provider(2)\n\n    val x = C()\n    if (x.delegatedVal != 1) throw AssertionError()\n    if (x.delegatedVar != 2) throw AssertionError()\n    x.delegatedVar = 3\n    if (x.delegatedVar != 3) throw AssertionError()\n\n    if (x.delegatedValByProvider != 1) throw AssertionError()\n    if (x.delegatedVarByProvider != 2) throw AssertionError()\n    x.delegatedVarByProvider = 3\n    if (x.delegatedVarByProvider != 3) throw AssertionError()\n\n    if (topLevelDelegatedVal != 1) throw AssertionError()\n    if (topLevelDelegatedVar != 2) throw AssertionError()\n    topLevelDelegatedVar = 3\n    if (topLevelDelegatedVar != 3) throw AssertionError()\n\n    if (topLevelDelegatedValByProvider != 1) throw AssertionError()\n    if (topLevelDelegatedVarByProvider != 2) throw AssertionError()\n    topLevelDelegatedVarByProvider = 3\n    if (topLevelDelegatedVarByProvider != 3) throw AssertionError()\n\n    if (localDelegatedVal != 1) throw AssertionError()\n    if (localDelegatedVar != 2) throw AssertionError()\n    localDelegatedVar = 3\n    if (localDelegatedVar != 3) throw AssertionError()\n\n    if (localDelegatedValByProvider != 1) throw AssertionError()\n    if (localDelegatedVarByProvider != 2) throw AssertionError()\n    localDelegatedVarByProvider = 3\n    if (localDelegatedVarByProvider != 3) throw AssertionError()\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: Foo.kt\n\npackage foo\n\nopen class Foo() {\n    protected fun foo(value: Boolean = false) = if (!value) \"OK\" else \"fail5\"\n}\n\n// FILE: Bar.kt\n\npackage bar\n\nimport foo.Foo\n\nclass Bar() : Foo() {\n    fun execute(): String {\n        return { foo() } ()\n    }\n}\n\nfun box(): String {\n    return Bar().execute()\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// JVM_TARGET: 1.8\n//WITH_RUNTIME\n\n// FILE: 1.kt\npackage test\n\npublic inline fun <T, R> Iterable<T>.fold2(initial: R, operation: (R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    val list = listOf(\"O\", \"K\")\n    return list.fold2(\"\") {a, b -> a +b}\n}"
        },
        {
            "code": "// WITH_RUNTIME\n// MODULE: lib\n// FILE: lib.kt\nenum class Foo {\n    FOO() {\n        override fun foo() = \"foo\"\n       \n        override var xxx: String\n            get() =  \"xxx\"\n            set(value: String) {\n            }\n    };\n\n    abstract fun foo(): String\n    abstract var xxx: String\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\nimport kotlin.test.assertEquals\n\nfun box(): String {\n    assertEquals(Foo.FOO.foo(), \"foo\")\n    Foo.FOO.xxx = \"zzzz\"\n    assertEquals(Foo.FOO.xxx, \"xxx\")\n    assertEquals(Foo.FOO.toString(), \"FOO\")\n    assertEquals(Foo.valueOf(\"FOO\").toString(), \"FOO\")\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n// WITH_RUNTIME\n// TARGET_BACKEND: NATIVE\npackage test\n\nopen class A(val value: String)\n\nvar invokeOrder = \"\"\n\ninline fun inlineFun(\n        vararg constraints: A,\n        receiver: String = { invokeOrder += \" default receiver\"; \"DEFAULT\" }(),\n        init: String\n): String {\n    return constraints.map { it.value }.joinToString() + \", \" + receiver + \", \" + init\n}\n\n// FILE: 2.kt\nimport test.*\n\n\nvar result = \"\"\nfun box(): String {\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(constraints = *arrayOf({ invokeOrder += \"constraints\";A(\"C\") }()),\n                       receiver = { invokeOrder += \" receiver\"; \"R\" }(),\n                       init = { invokeOrder += \" init\"; \"I\" }())\n    if (result != \"C, R, I\") return \"fail 1: $result\"\n\n    if (invokeOrder != \"constraints receiver init\") return \"fail 2: $invokeOrder\"\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(init = { invokeOrder += \"init\"; \"I\" }(),\n                       constraints = *arrayOf({ invokeOrder += \"constraints\";A(\"C\") }()),\n                       receiver = { invokeOrder += \" receiver\"; \"R\" }()\n    )\n    if (result != \"C, R, I\") return \"fail 3: $result\"\n    //Change test after KT-17691 FIX\n    if (invokeOrder != \"init receiverconstraints\") return \"fail 4: $invokeOrder\"\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(init = { invokeOrder += \"init\"; \"I\" }(),\n                       constraints = *arrayOf({ invokeOrder += \" constraints\";A(\"C\") }()))\n    if (result != \"C, DEFAULT, I\") return \"fail 5: $result\"\n    if (invokeOrder != \"init constraints default receiver\") return \"fail 6: $invokeOrder\"\n\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\nfun box() = a.x\n\n// FILE: 2.kt\n\npackage a\n\ninternal val x: String = \"OK\"\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage thispackage\n\nimport otherpackage.*\n\nfun box(): String {\n    if (!localUse()) {\n        return \"local use failed\"\n    }\n    if (!fromOtherPackage()) {\n        return \"use from other package failed\"\n    }\n    return \"OK\"\n}\n\nfun localUse(): Boolean {\n    val c = Runnable::class.java\n    return (c.getName()!! == \"java.lang.Runnable\")\n}\n\n// FILE: 2.kt\n\npackage otherpackage\n\nfun fromOtherPackage(): Boolean {\n    val c = Runnable::class.java\n    return (c.getName()!! == \"java.lang.Runnable\")\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\nimport testing.ClassWithInternals\n\npublic class HelloServer() : ClassWithInternals() {\n    public override fun start() {\n        val test = foo() + someGetter //+ some\n    }\n}\n\nfun box() : String {\n    HelloServer().start()\n    return \"OK\"\n}\n\n// FILE: 2.kt\n\npackage testing; // There is no error if both files are in default package\n\npublic abstract class ClassWithInternals {\n   protected var some: Int = 0;\n   protected var someGetter: Int = 0\n      get() = 5\n\n   protected fun foo() : Int = 0\n\n   public abstract fun start() : Unit;\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage test2\n\nimport test.A\n\nclass C : A() {\n    fun a(): String {\n        return this.s\n    }\n}\n\npublic fun box(): String {\n    return C().a()\n}\n\n// FILE: 2.kt\n\npackage test\n\nopen class A {\n    @JvmField protected val s = \"OK\";\n}\n"
        },
        {
            "code": "// FILE: Outer.kt\n\npackage another\nopen class Outer {\n    protected class Stage(val run: () -> Unit)\n    protected class My(var stage: Stage? = null) {\n        fun initStage(f: () -> Unit): Stage {\n            stage = Stage(f)\n            return stage!!\n        }\n    }\n    protected fun my(init: My.() -> Unit): My {\n        val result = My()\n        result.init()\n        return result\n    }\n}\n\n// FILE: Main.kt\n\npackage other\nclass Derived : another.Outer() {\n    init {\n        my {\n            initStage { }\n        }\n    }\n}\n\nfun box(): String {\n    Derived()\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage test2\n\nimport test.A\n\npublic fun box(): String {\n    return B().test(B())\n}\n\npublic class B : A() {\n    public fun test(other:Any): String {\n        if (other is B && other.s == 2) {\n            return \"OK\"\n        }\n        return \"fail\"\n    }\n}\n\n// FILE: 2.kt\n\npackage test\n\nopen class A {\n    @JvmField protected val s = 2;\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ReleaseCoroutines\n// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// WITH_COROUTINES\n\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n    suspend fun bar(x: Int): String\n}\n\n// FILE: main.kt\nimport helpers.*\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nclass K : JavaClass() {\n    override suspend fun foo(x: Int): String = super.foo(x) + suspendCoroutine { it.resume(\"K\") }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"fail\"\n\n    builder {\n        // Changing the call to 'K().bar(1)' doesn't work because of KT-25036\n        result = K().foo(1)\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ReleaseCoroutines\n// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// WITH_COROUTINES\n\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n}\n\n// FILE: main.kt\nimport helpers.*\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"fail\"\n\n    builder {\n        result = JavaClass().foo(1)\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n\n// FILE: A1.kt\n\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@file:JvmPackageName(\"baz.foo.quux.bar\")\n@file:JvmName(\"Facade\")\n@file:JvmMultifileClass\npackage foo.bar\n\nval g: S? get() = f().substring(0, 0) + \"K\"\n\n// FILE: A2.kt\n\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@file:JvmPackageName(\"baz.foo.quux.bar\")\n@file:JvmName(\"Facade\")\n@file:JvmMultifileClass\npackage foo.bar\n\ninline fun <T> i(block: () -> T): T = block()\n\n// FILE: A3.kt\n\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@file:JvmPackageName(\"baz.foo.quux.bar\")\n@file:JvmName(\"Facade\")\n@file:JvmMultifileClass\npackage foo.bar\n\ntypealias S = String\n\nfun f(): String = \"O\"\n\n// FILE: B.kt\n\nimport foo.bar.*\n\nfun box(): S = i { f() + g }\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n\n// FILE: foo.kt\n\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@file:JvmPackageName(\"baz.foo.quux.bar\")\npackage foo.bar\n\nfun f(): String = \"O\"\n\nval g: String? get() = \"K\"\n\ninline fun <T> i(block: () -> T): T = block()\n\n// FILE: bar.kt\n\nimport foo.bar.*\n\nfun box(): String = i { f() + g }\n"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Int {\n    if (x == 0) {\n        return 0\n    } else if (x == 10) {\n        <!NON_TAIL_RECURSIVE_CALL!>test<!>(0)\n        return 1 + <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n    } else {\n        return test(x - 1)\n    }\n}\n\nfun box() : String = if (test(1000000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Int {\n    if (x == 10) {\n        return 1 + <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n    }\n    if (x > 0) {\n        return test(x - 1)\n    }\n    return 0\n}\n\nfun box() : String = if (test(1000000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Unit {\n    if (x == 1) {\n        test(x - 1)\n    } else if (x == 2) {\n        test(x - 1)\n        return\n    } else if (x == 3) {\n        <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n        if (x == 3) {\n            test(x - 1)\n        }\n        return\n    } else if (x > 0) {\n        test(x - 1)\n    }\n}\n\nfun box() : String {\n    test(1000000)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun test(counter : Int) : Int<!> {\n    if (counter == 0) return 0\n\n    try {\n        return <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(counter - 1)\n    } catch (any : Throwable) {\n        return -1\n    }\n}\n\nfun box() : String = if (test(3) == 0) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Int {\n    return if (x == 1) {\n        <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n        1 + <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n    } else if (x > 0) {\n        test(x - 1)\n    } else {\n        0\n    }\n}\n\nfun box() : String = if (test(1000000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun badTails(x : Int) : Int {\n    if (x < 50 && x != 10 && x > 0) {\n        return 1 + <!NON_TAIL_RECURSIVE_CALL!>badTails<!>(x - 1)\n    }\n    else if (x == 10) {\n        @Suppress(\"NON_TAIL_RECURSIVE_CALL\")\n        return 1 + badTails(x - 1)\n    } else if (x >= 50) {\n        return badTails(x - 1)\n    }\n    return 0\n}\n\nfun box(): String {\n    badTails(1000000)\n    return \"OK\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// IGNORE_BACKEND: JS_IR\n\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\nclass B {\n    inner class C {\n        tailrec fun h(counter : Int) {\n            if (counter > 0) {\n                this@C.h(counter - 1)\n            }\n        }\n\n        <!NO_TAIL_CALLS_FOUND!>tailrec fun h2(x : Any)<!> {\n            this@B.h2(\"no recursion\") // keep vigilance\n        }\n\n    }\n\n    fun makeC() : C = C()\n\n    fun h2(x : Any) {\n    }\n}\n\nfun box() : String {\n    B().makeC().h(1000000)\n    B().makeC().h2(0)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun test(counter : Int) : Int<!> {\n    if (counter == 0) return 0\n\n    try {\n        throw Exception()\n    } catch (e : Exception) {\n        return <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(counter - 1)\n    }\n}\n\nfun box() : String = if (test(3) == 0) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun withWhen(counter : Int) : Int =\n        when (counter) {\n            0 -> counter\n            50 -> 1 + <!NON_TAIL_RECURSIVE_CALL!>withWhen<!>(counter - 1)\n            else -> withWhen(counter - 1)\n        }\n\nfun box() : String = if (withWhen(100000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Int =\n    if (x == 1) {\n        <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n        1 + <!NON_TAIL_RECURSIVE_CALL!>test<!>(x - 1)\n    } else if (x > 0) {\n        test(x - 1)\n    } else {\n        0\n    }\n\nfun box() : String = if (test(1000000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\nclass A {\n    tailrec fun f1(c : Int) {\n        if (c > 0) {\n            this.f1(c - 1)\n        }\n    }\n\n    tailrec fun f2(c : Int) {\n        if (c > 0) {\n            f2(c - 1)\n        }\n    }\n\n    <!NO_TAIL_CALLS_FOUND!>tailrec fun f3(a : A)<!> {\n        a.<!NON_TAIL_RECURSIVE_CALL!>f3<!>(a) // non-tail recursion, could be potentially resolved by condition if (a == this) f3() else a.f3()\n    }\n}\n\nfun box() : String {\n    A().f1(1000000)\n    A().f2(1000000)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun test(counter : Int) : Int<!> {\n    if (counter == 0) return 0\n\n    try {\n        // do nothing\n    } finally {\n        if (counter > 0) {\n            return <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(counter - 1)\n        }\n    }\n\n    return -1\n}\n\nfun box() : String = if (test(3) == 0) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun noTails()<!> {\n    // nothing here\n}\n\nfun box(): String {\n    noTails()\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun test(counter : Int) : Int<!> {\n    if (counter == 0) return 0\n\n    try {\n        // do nothing\n    } finally {\n        return <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(counter - 1)\n    }\n}\n\nfun box() : String = if (test(3) == 0) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Int {\n    var z = if (x > 3) 3 else x\n    while (z > 0) {\n        if (z > 10) {\n            return test(x - 1)\n        }\n        <!NON_TAIL_RECURSIVE_CALL!>test<!>(0)\n        z = z - 1\n    }\n\n    return 1\n}\n\nfun box() : String = if (test(100000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(counter : Int) : Int? {\n    if (counter < 0) return null\n    if (counter == 0) return 777\n\n    return <!NON_TAIL_RECURSIVE_CALL!>test<!>(-1) ?: <!NON_TAIL_RECURSIVE_CALL!>test<!>(-2) ?: test(counter - 1)\n}\n\nfun box() : String =\n    if (test(100000) == 777) \"OK\"\n    else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\nopen class A {\n    open fun foo(s: String = \"OK\") = s\n}\n\nclass B : A() {\n    <!NO_TAIL_CALLS_FOUND!>override tailrec fun foo(s: String): String<!> {\n        return if (s == \"OK\") s else foo()\n    }\n}\n\nfun box() = B().foo(\"FAIL\")"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun withWhen2(counter : Int) : Int =\n        when {\n            counter == 0 -> counter\n            counter == 50 -> 1 + <!NON_TAIL_RECURSIVE_CALL!>withWhen2<!>(counter - 1)\n            <!NON_TAIL_RECURSIVE_CALL!>withWhen2<!>(0) == 0 -> withWhen2(counter - 1)\n            else -> 1\n        }\n\nfun box() : String = if (withWhen2(100000) == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// !LANGUAGE: -ProperComputationOrderOfTailrecDefaultParameters\n// TARGET_BACKEND: JVM\n// IGNORE_BACKEND: JVM_IR\n\nvar counter = 0\nfun calc(counter: Int) = if (counter % 2 == 0) \"K\" else \"O\"\n\n<!TAILREC_WITH_DEFAULTS!>tailrec fun test(x: Int, y: String = calc(counter++), z: String = calc(counter++)): String<!> {\n    if (x > 0)\n        return y + z\n\n    return test(x + 1)\n}\n\nfun box(): String {\n    return test(0)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// IGNORE_BACKEND: JS_IR\n\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun foo()<!> {\n    bar {\n        <!NON_TAIL_RECURSIVE_CALL!>foo<!>()\n    }\n}\n\nfun bar(a: Any) {}\n\nfun box(): String {\n    foo()\n    return \"OK\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// IGNORE_BACKEND: JS_IR\n\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun withWhen(counter : Int, d : Any) : Int =\n        when (counter) {\n            0 -> counter\n            1, 2 -> withWhen(counter - 1, \"1,2\")\n            in 3..49 -> withWhen(counter - 1, \"3..49\")\n            50 -> 1 + <!NON_TAIL_RECURSIVE_CALL!>withWhen<!>(counter - 1, \"50\")\n            !in 0..50 -> withWhen(counter - 1, \"!0..50\")\n            else -> withWhen(counter - 1, \"else\")\n        }\n\nfun box() : String = if (withWhen(100000, \"test\") == 1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\ntailrec fun test(x : Int) : Int {\n    if (x == 1) {\n        if (x != 1) {\n            <!NON_TAIL_RECURSIVE_CALL!>test<!>(0)\n            return test(0)\n        } else {\n            return test(x + <!NON_TAIL_RECURSIVE_CALL!>test<!>(0))\n        }\n    } else if (x > 0) {\n        return test(x - 1)\n    }\n    return -1\n}\n\nfun box() : String = if (test(1000000) == -1) \"OK\" else \"FAIL\""
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun test(go: Boolean) : Unit<!> {\n    if (!go) return\n    try {\n        <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(false)\n    } catch (any : Exception) {\n        <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(false)\n    } finally {\n        <!TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED!>test<!>(false)\n    }\n}\n\nfun box(): String {\n    test(true)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// TODO: muted automatically, investigate should it be ran for JS or not\n// DONT_RUN_GENERATED_CODE: JS\n// IGNORE_BACKEND: JS\n\n<!NO_TAIL_CALLS_FOUND!>tailrec fun foo()<!> {\n    fun bar() {\n        <!NON_TAIL_RECURSIVE_CALL!>foo<!>()\n    }\n}\n\nfun box(): String {\n    foo()\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: example/Hello.java\npackage example;\n\n@FunctionalInterface\npublic interface Hello<A> {\n    void invoke(A a);\n}\n\n// FILE: example/SomeJavaClass.java\npackage example;\n\npublic class SomeJavaClass<A> {\n    public void someFunction(Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n    }\n\n    public void plus(Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n    }\n\n    public void get(Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n    }\n}\n\n// FILE: main.kt\nimport example.SomeJavaClass\n\nfun box(): String {\n    val a: SomeJavaClass<out String> = SomeJavaClass()\n\n    var result = \"fail\"\n\n    // a::someFunction parameter has type of Nothing\n    // while it's completely safe to pass a lambda for a SAM\n    // since Hello is effectively contravariant by its parameter\n    a.someFunction {\n        result = it\n    }\n\n    if (result != \"OK\") return \"fail 1: $result\"\n    result = \"fail\"\n\n    a + {\n        result = it\n    }\n\n    if (result != \"OK\") return \"fail 2: $result\"\n    result = \"fail\"\n\n    a[{\n        result = it\n    }]\n\n    if (result != \"OK\") return \"fail 3: $result\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// TARGET_BACKEND: JVM\n\n// FILE: example/Hello.java\n\npackage example;\n\n@FunctionalInterface\npublic interface Hello<A> {\n    void invoke(A a);\n}\n\n// FILE: example/SomeJavaClass.java\npackage example;\n\npublic class SomeJavaClass<A> {\n    public void someFunction(Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n    }\n\n    public SomeJavaClass<A> plus(Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n        return this;\n    }\n\n    public void get(Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n    }\n\n    public void set(int i, Hello<A> hello) {\n        ((Hello)hello).invoke(\"OK\");\n    }\n}\n\n// FILE: main.kt\nimport example.SomeJavaClass\n\nfun box(): String {\n    var a: SomeJavaClass<out String> = SomeJavaClass()\n\n    var result = \"fail\"\n\n    a.someFunction {\n        result = it\n    }\n\n    if (result != \"OK\") return \"fail 1: $result\"\n    result = \"fail\"\n\n    a + {\n        result = it\n    }\n\n    if (result != \"OK\") return \"fail 2: $result\"\n    result = \"fail\"\n\n    a[{\n        result = it\n    }]\n\n    if (result != \"OK\") return \"fail 3: $result\"\n\n    result = \"fail\"\n\n    a += {\n        result = it\n    }\n\n    if (result != \"OK\") return \"fail 4: $result\"\n\n    result = \"fail\"\n\n    a[0] = { result = it }\n\n    if (result != \"OK\") return \"fail 5: $result\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// WITH_COROUTINES\n\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n    suspend fun bar(x: Int): String\n}\n\n// FILE: main.kt\nimport helpers.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nclass K : JavaClass() {\n    override suspend fun foo(x: Int): String = super.foo(x) + suspendCoroutine { it.resume(\"K\") }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"fail\"\n\n    builder {\n        // Changing the call to 'K().bar(1)' doesn't work because of KT-25036\n        result = K().foo(1)\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND: JVM, JS, NATIVE\n// WITH_RUNTIME\n// WITH_COROUTINES\n\nimport helpers.*\nimport kotlin.coroutines.experimental.*\n\nsuspend fun callLocal(): String {\n    val local = suspend fun() = \"OK\"\n    return local()\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var res = \"FAIL\"\n    builder {\n        res = callLocal()\n    }\n    return res\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// WITH_COROUTINES\n\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n}\n\n// FILE: main.kt\nimport helpers.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"fail\"\n\n    builder {\n        result = JavaClass().foo(1)\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\n// FILE: inlineMe.kt\n\npackage test\n\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n    suspend fun run1()\n    suspend fun run2()\n}\n\ninline fun inlineMe(crossinline c: suspend () -> Unit) = object : SuspendRunnable {\n    override suspend fun run() {\n        c(); c()\n    }\n    override suspend fun run1() {\n        c(); c()\n    }\n    override suspend fun run2() {\n        inlineMeInner()\n    }\n    inline suspend fun inlineMeInner() {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n    // TODO: call it from run1\n    inline suspend fun inlineMeCapturing() {\n        c(); c()\n    }\n}\n\ninline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }\n\ninline fun inlineMe3(crossinline c: suspend () -> Unit) = object: SuspendRunnable {\n    override suspend fun run() {\n        var sr = inlineMe {\n            c()\n            c()\n        }\n        sr.run()\n        sr.run1()\n        sr.run2()\n    }\n\n    override suspend fun run1() {\n    }\n    override suspend fun run2() {\n    }\n}\n\n// FILE: box.kt\n\nimport test.*\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        (A.call() as SuspendRunnable).run()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as SuspendRunnable).run()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call3() as SuspendRunnable).run()\n    }\n    StateMachineChecker.check(10)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe3 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(18)\n\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\n// FILE: inlineMe.kt\n\npackage test\n\ninline suspend fun inlineMe(crossinline c: suspend () -> Unit) { c(); c() }\n\ninline suspend fun inlineMe2(c: suspend () -> Unit) { c(); c() }\n\n// FILE: box.kt\n\nimport test.*\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    A.call(CheckStateMachineContinuation)\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    A.call2(CheckStateMachineContinuation)\n    StateMachineChecker.check(2)\n\n    StateMachineChecker.reset()\n    builder {\n        inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(4)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\n// FILE: inlineMe.kt\n\npackage test\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\ninline fun inlineMe(crossinline c: suspend () -> Unit) = object : SuspendRunnable {\n    override suspend fun run() {\n        c(); c()\n    }\n}\n\ninline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }\n\ninline fun inlineMe3(crossinline c: suspend () -> Unit) = object: SuspendRunnable {\n    override suspend fun run() {\n        var sr = inlineMe {\n            c()\n            c()\n        }\n        sr.run()\n        sr = inlineMe {\n            c()\n            c()\n        }\n        sr.run()\n    }\n}\n\n// FILE: box.kt\n\nimport test.*\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        (A.call() as SuspendRunnable).run()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as SuspendRunnable).run()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call3() as SuspendRunnable).run()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe3 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(16)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\n// FILE: inlineMe.kt\n\npackage test\n\ninline fun inlineMe(crossinline c: suspend () -> Unit) = suspend { c(); c() }\n\ninline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }\n\ninline fun inlineMe3(crossinline c: suspend () -> Unit) = suspend {\n    var sr = inlineMe {\n        c()\n        c()\n    }\n    sr()\n    sr = inlineMe {\n        c()\n        c()\n    }\n    sr()\n}\n\n// FILE: box.kt\n\nimport test.*\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        (A.call() as (suspend () -> Unit))()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as (suspend () -> Unit))()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call3() as (suspend () -> Unit))()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe3 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }()\n    }\n    StateMachineChecker.check(16)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inlineMe.kt\n\npackage test\n\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run1()\n    suspend fun run2()\n}\n\ninline fun inlineMe(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = object : SuspendRunnable {\n    override suspend fun run1() {\n        c1(); c1()\n    }\n    override suspend fun run2() {\n        c2(); c2()\n    }\n}\n\ninline fun inlineMe2(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = inlineMe({ c1(); c1() }) { c2(); c2() }\n\ninline fun inlineMe3(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = object : SuspendRunnable {\n    override suspend fun run1() {\n        val sr = inlineMe({ c1(); c1() }) { c2(); c2() }\n        sr.run1()\n        sr.run2()\n    }\n    override suspend fun run2() {\n        val sr = inlineMe2({ c1(); c1() }) { c2(); c2() }\n        sr.run1()\n        sr.run2()\n    }\n}\n\ninline fun inlineMe4(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = object : SuspendRunnable {\n    override suspend fun run1() {\n        val sr = suspend {\n            c1();\n            c2()\n        }\n        sr()\n        sr()\n    }\n    override suspend fun run2() {\n        val sr = object : SuspendRunnable {\n            override suspend fun run1() {\n                c1(); c1()\n            }\n            override suspend fun run2() {\n                c2(); c2()\n            }\n        }\n        sr.run1()\n        sr.run2()\n    }\n}\n\ninline fun inlineMe5(crossinline c1: suspend () -> Unit) = inlineMe({ c1(); c1() }) {\n    StateMachineChecker.suspendHere()\n}\n\n// FILE: box.kt\n\nimport test.*\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        (A.call() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call2() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call3() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call3() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(16)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call4() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call4() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call5() as SuspendRunnable).run1()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        (A.call5() as SuspendRunnable).run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe({\n                     StateMachineChecker.suspendHere()\n                     StateMachineChecker.suspendHere()\n                 }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe({\n                     StateMachineChecker.suspendHere()\n                     StateMachineChecker.suspendHere()\n                 }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(4)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe2 ({\n                       StateMachineChecker.suspendHere()\n                       StateMachineChecker.suspendHere()\n                   }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe2 ({\n                       StateMachineChecker.suspendHere()\n                       StateMachineChecker.suspendHere()\n                   }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe3 ({\n                       StateMachineChecker.suspendHere()\n                       StateMachineChecker.suspendHere()\n                   }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(16)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe3 ({\n                       StateMachineChecker.suspendHere()\n                       StateMachineChecker.suspendHere()\n                   }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(32)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe4 ({\n                       StateMachineChecker.suspendHere()\n                       StateMachineChecker.suspendHere()\n                   }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe4 ({\n                       StateMachineChecker.suspendHere()\n                       StateMachineChecker.suspendHere()\n                   }) {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe5 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run1()\n    }\n    StateMachineChecker.check(8)\n    StateMachineChecker.reset()\n\n    builder {\n        inlineMe5 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run2()\n    }\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    return \"OK\"\n}"
        },
        {
            "code": "// KJS_WITH_FULL_RUNTIME\n// WITH_RUNTIME\n// WITH_COROUTINES\n// COMMON_COROUTINES_TEST\n// FILE: promise.kt\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nclass Promise<T>(private val executor: ((T) -> Unit) -> Unit) {\n    private var value: Any? = null\n    private var thenList: MutableList<(T) -> Unit>? = mutableListOf()\n\n    init {\n        executor {\n            value = it\n            for (resolve in thenList!!) {\n                resolve(it)\n            }\n            thenList = null\n        }\n    }\n\n    fun <S> then(onFulfilled: (T) -> S): Promise<S> {\n        return Promise { resolve ->\n            if (thenList != null) {\n                thenList!!.add { resolve(onFulfilled(it)) }\n            }\n            else {\n                resolve(onFulfilled(value as T))\n            }\n        }\n    }\n}\n\n// FILE: queue.kt\nimport helpers.*\nprivate val queue = mutableListOf<() -> Unit>()\n\nfun <T> postpone(computation: () -> T): Promise<T> {\n    return Promise { resolve ->\n        queue += {\n            resolve(computation())\n        }\n    }\n}\n\nfun processQueue() {\n    while (queue.isNotEmpty()) {\n        queue.removeAt(0)()\n    }\n}\n\n// FILE: await.kt\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nprivate var log = \"\"\n\nprivate var inAwait = false\n\nsuspend fun <S> await(value: Promise<S>): S = suspendCoroutine { continuation ->\n    if (inAwait) {\n        throw IllegalStateException(\"Can't call await recursively\")\n    }\n    inAwait = true\n    postpone {\n        value.then { result ->\n            continuation.resume(result)\n        }\n    }\n    inAwait = false\n}\n\nsuspend fun <S> awaitAndLog(value: Promise<S>): S {\n    log += \"before await;\"\n    return await(value.then { result ->\n        log += \"after await: $result;\"\n        result\n    })\n}\n\nfun <T> async(c: suspend () -> T): Promise<T> {\n    return Promise { resolve ->\n        c.startCoroutine(handleResultContinuation(resolve))\n    }\n}\n\nfun <T> asyncOperation(resultSupplier: () -> T) = Promise<T> { resolve ->\n    log += \"before async;\"\n    postpone {\n        val result = resultSupplier()\n        log += \"after async $result;\"\n        resolve(result)\n    }\n}\n\nfun getLog() = log\n\n// FILE: main.kt\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nprivate fun test() = async<String> {\n    val o = await(asyncOperation { \"O\" })\n    val k = awaitAndLog(asyncOperation { \"K\" })\n    return@async o + k\n}\n\nfun box(): String {\n    val resultPromise = test()\n    var result: String? = null\n    resultPromise.then { result = it }\n    processQueue()\n\n    if (result != \"OK\") return \"fail1: $result\"\n    if (getLog() != \"before async;after async O;before async;before await;after async K;after await: K;\") return \"fail2: ${getLog()}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: NATIVE\n// WITH_COROUTINES\n// WITH_RUNTIME\n// COMMON_COROUTINES_TEST\n\n// MODULE: lib(support)\n// FILE: lib.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nvar continuation: () -> Unit = { }\nvar log = \"\"\nvar finished = false\n\nsuspend fun <T> foo(v: T): T = suspendCoroutineUninterceptedOrReturn { x ->\n    continuation = {\n        x.resume(v)\n    }\n    log += \"foo($v);\"\n    COROUTINE_SUSPENDED\n}\n\ninline suspend fun boo(v: String): String {\n    foo(\"!$v\")\n    log += \"boo($v);\"\n    return foo(v)\n}\n\ninline suspend fun bar(v: String): String {\n    val x = boo(v)\n    log += \"bar($x);\"\n    return x\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(handleResultContinuation {\n        continuation = { }\n        finished = true\n    })\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nsuspend fun baz() {\n    val a = bar(\"A\")\n    log += \"$a;\"\n    log += \"between bar;\"\n    val b = bar(\"B\")\n    log += \"$b;\"\n}\n\nval expectedString =\n        \"foo(!A);@;boo(A);foo(A);@;bar(A);A;\" +\n        \"between bar;\" +\n        \"foo(!B);@;boo(B);foo(B);@;bar(B);B;\"\n\nfun box(): String {\n    builder {\n        baz()\n    }\n\n    while (!finished) {\n        log += \"@;\"\n        continuation()\n    }\n\n    if (log != expectedString) return \"fail: $log\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// WITH_COROUTINES\n// WITH_RUNTIME\n// COMMON_COROUTINES_TEST\n\n// MODULE: lib(support)\n// FILE: lib.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nvar continuation: () -> Unit = { }\nvar log = \"\"\nvar finished = false\n\nclass C {\n    var v: String = \"\"\n\n    inline suspend fun bar() {\n        log += \"before bar($v);\"\n        foo(\"1:$v\")\n        log += \"inside bar($v);\"\n        foo(\"2:$v\")\n        log += \"after bar($v);\"\n    }\n}\n\nsuspend fun <T> foo(v: T): T = suspendCoroutineUninterceptedOrReturn { x ->\n    continuation = {\n        x.resume(v)\n    }\n    log += \"foo($v);\"\n    COROUTINE_SUSPENDED\n}\n\nfun C.builder(c: suspend C.() -> Unit) {\n    c.startCoroutine(this, handleResultContinuation {\n        continuation = { }\n        finished = true\n    })\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nsuspend fun C.baz() {\n    v = \"A\"\n    bar()\n    log += \"between bar;\"\n    v = \"B\"\n    bar()\n}\n\nval expectedString =\n        \"before bar(A);foo(1:A);@;inside bar(A);foo(2:A);@;after bar(A);\" +\n        \"between bar;\" +\n        \"before bar(B);foo(1:B);@;inside bar(B);foo(2:B);@;after bar(B);\"\n\nfun box(): String {\n    var c = C()\n\n    c.builder {\n        baz()\n    }\n\n    while (!finished) {\n        log += \"@;\"\n        continuation()\n    }\n\n    if (log != expectedString) return \"fail: $log\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: NATIVE\n// WITH_RUNTIME\n// WITH_COROUTINES\n// COMMON_COROUTINES_TEST\n// MODULE: lib\n// FILE: lib.kt\nsuspend inline fun foo(v: String): String = v\n\nsuspend inline fun bar(): String = foo(\"O\")\n\n// MODULE: main(lib, support)\n// FILE: main.kt\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"\"\n\n    builder {\n        result = bar()\n        result += foo(\"K\")\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// WITH_COROUTINES\n// WITH_RUNTIME\n// COMMON_COROUTINES_TEST\n\n// MODULE: lib(support)\n// FILE: lib.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nvar continuation: () -> Unit = { }\nvar log = \"\"\nvar finished = false\n\nsuspend fun <T> foo(v: T): T = suspendCoroutineUninterceptedOrReturn { x ->\n    continuation = {\n        x.resume(v)\n    }\n    log += \"foo($v);\"\n    COROUTINE_SUSPENDED\n}\n\ninline suspend fun bar(v: String) {\n    log += \"before bar($v);\"\n    foo(\"1:$v\")\n    log += \"inside bar($v);\"\n    foo(\"2:$v\")\n    log += \"after bar($v);\"\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(handleResultContinuation {\n        continuation = { }\n        finished = true\n    })\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nsuspend fun baz() {\n    bar(\"A\")\n    log += \"between bar;\"\n    bar(\"B\")\n}\n\nval expectedString =\n        \"before bar(A);foo(1:A);@;inside bar(A);foo(2:A);@;after bar(A);\" +\n        \"between bar;\" +\n        \"before bar(B);foo(1:B);@;inside bar(B);foo(2:B);@;after bar(B);\"\n\nfun box(): String {\n    builder {\n        baz()\n    }\n\n    while (!finished) {\n        log += \"@;\"\n        continuation()\n    }\n\n    if (log != expectedString) return \"fail: $log\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// WITH_COROUTINES\n// COMMON_COROUTINES_TEST\n// MODULE: controller(support)\n// FILE: controller.kt\npackage lib\nimport helpers.*\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nclass Controller {\n    suspend fun suspendHere(): String = suspendCoroutineUninterceptedOrReturn { x ->\n        x.resume(\"OK\")\n        COROUTINE_SUSPENDED\n    }\n}\n\n// MODULE: main(controller, support)\n// FILE: main.kt\nimport lib.*\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nfun builder(c: suspend Controller.() -> Unit) {\n    c.startCoroutine(Controller(), EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"\"\n\n    builder {\n        result = suspendHere()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// MODULE: lib\n// FILE: lib.kt\ninline fun foo(x: String = \"OK\"): String {\n    return x + x\n}\n\n// MODULE: main(lib, support)\n// FILE: main.kt\n// WITH_RUNTIME\n// WITH_COROUTINES\n// COMMON_COROUTINES_TEST\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nvar result = \"\"\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    builder {\n        result = foo()\n    }\n    if (result != \"OKOK\") return \"fail: $result\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// WITH_COROUTINES\n// WITH_RUNTIME\n// COMMON_COROUTINES_TEST\n\n// MODULE: lib(support)\n// FILE: lib.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nvar continuation: () -> Unit = { }\nvar log = \"\"\nvar finished = false\n\nsuspend fun <T> foo(v: T): T = suspendCoroutineUninterceptedOrReturn { x ->\n    continuation = {\n        x.resume(v)\n    }\n    log += \"foo($v);\"\n    COROUTINE_SUSPENDED\n}\n\ninterface I {\n    suspend fun bar()\n}\n\nclass A(val v: String) : I {\n    override inline suspend fun bar() {\n        log += \"before bar($v);\"\n        foo(\"1:$v\")\n        log += \"inside bar($v);\"\n        foo(\"2:$v\")\n        log += \"after bar($v);\"\n    }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(handleResultContinuation {\n        continuation = { }\n        finished = true\n    })\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nsuspend fun baz() {\n    val a = A(\"A\")\n    a.bar()\n\n    log += \"between bar;\"\n\n    val b: I = A(\"B\")\n    b.bar()\n}\n\nval expectedString =\n        \"before bar(A);foo(1:A);@;inside bar(A);foo(2:A);@;after bar(A);\" +\n        \"between bar;\" +\n        \"before bar(B);foo(1:B);@;inside bar(B);foo(2:B);@;after bar(B);\"\n\nfun box(): String {\n    builder {\n        baz()\n    }\n\n    while (!finished) {\n        log += \"@;\"\n        continuation()\n    }\n\n    if (log != expectedString) return \"fail: $log\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND: NATIVE\n// WITH_COROUTINES\n// WITH_RUNTIME\n// COMMON_COROUTINES_TEST\n\n// MODULE: lib(support)\n// FILE: lib.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nsuspend inline fun <R> inlined(\n    crossinline step: suspend () -> R\n): R = notInlined { step() }\n\nsuspend fun <R> notInlined(\n    block: suspend () -> R\n): R = block()\n\n// MODULE: main(lib, support)\n// FILE: main.kt\n// WITH_COROUTINES\n// WITH_RUNTIME\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nvar result = \"FAIL\"\n\nsuspend fun test() {\n    inlined {\n        result = \"OK\"\n    }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    builder {\n        test()\n    }\n    return result\n}"
        },
        {
            "code": "// WITH_RUNTIME\n// WITH_COROUTINES\n// COMMON_COROUTINES_TEST\n\n// FILE: stuff.kt\npackage stuff\nimport helpers.*\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nobject Host {\n    suspend fun suspendHere(): String = suspendCoroutineUninterceptedOrReturn { x ->\n        x.resume(\"OK\")\n        COROUTINE_SUSPENDED\n    }\n}\n\n\n// FILE: test.kt\nimport helpers.*\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport stuff.Host.suspendHere\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"\"\n\n    builder {\n        result = suspendHere()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// IGNORE_LIGHT_ANALYSIS\n\n// FILE: SingletonCollection.kt\npackage test\n\nopen class SingletonCollection<T>(val value: T) : AbstractCollection<T>() {\n    override val size = 1\n    override fun iterator(): Iterator<T> = listOf(value).iterator()\n\n    protected override fun toArray(): Array<Any?> =\n            arrayOf<Any?>(value)\n\n    protected override fun <E> toArray(a: Array<E>): Array<E> {\n        a[0] = value as E\n        return a\n    }\n}\n\n// FILE: box.kt\nimport test.*\n\nfun box(): String {\n    val jsc = JavaSingletonCollection(42) as java.util.Collection<Int>\n    val test3 = jsc.toArray()\n    if (test3[0] != 42) return \"Failed #3\"\n\n    val test4 = arrayOf<Any?>(0)\n    jsc.toArray(test4)\n    if (test4[0] != 42) return \"Failed #4\"\n\n    val jsc2 = JavaSingletonCollection2(42) as java.util.Collection<Int>\n    val test5 = jsc2.toArray()\n    if (test5[0] != 42) return \"Failed #5\"\n\n    val test6 = arrayOf<Any?>(0)\n    jsc2.toArray(test6)\n    if (test6[0] != 42) return \"Failed #6\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n\n// FILE: SingletonCollection.kt\npackage test\n\nopen class SingletonCollection<T>(val value: T) : AbstractCollection<T>() {\n    override val size = 1\n    override fun iterator(): Iterator<T> = listOf(value).iterator()\n\n    protected override final fun toArray(): Array<Any?> =\n            arrayOf<Any?>(value)\n\n    protected override final fun <E> toArray(a: Array<E>): Array<E> {\n        a[0] = value as E\n        return a\n    }\n}\n\n// FILE: DerivedSingletonCollection.kt\npackage test2\n\nimport test.*\n\nclass DerivedSingletonCollection<T>(value: T) : SingletonCollection<T>(value)\n\n// FILE: box.kt\nimport test.*\nimport test2.*\n\nfun box(): String {\n    val sc = SingletonCollection(42)\n\n    val test1 = (sc as java.util.Collection<Int>).toArray()\n    if (test1[0] != 42) return \"Failed #1\"\n\n    val test2 = arrayOf<Any?>(0)\n    (sc as java.util.Collection<Int>).toArray(test2)\n    if (test2[0] != 42) return \"Failed #2\"\n\n    val dsc = DerivedSingletonCollection(42)\n    val test3 = (dsc as java.util.Collection<Int>).toArray()\n    if (test3[0] != 42) return \"Failed #3\"\n\n    val test4 = arrayOf<Any?>(0)\n    (dsc as java.util.Collection<Int>).toArray(test4)\n    if (test4[0] != 42) return \"Failed #4\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage test\n\nclass A {}\n\nfun getMain(className: String): java.lang.reflect.Method {\n    val classLoader = A().javaClass.classLoader\n    return classLoader.loadClass(className).getDeclaredMethod(\"main\", Array<String>::class.java)\n}\n\nfun box(): String {\n    val bMain = getMain(\"pkg.AKt\")\n    val cMain = getMain(\"pkg.BKt\")\n\n    val args = Array(1, { \"\" })\n\n    bMain.invoke(null, args)\n    cMain.invoke(null, args)\n\n    return args[0]\n}\n\n\n\n// FILE: a.kt\n\npackage pkg\n\nfun main(args: Array<String>) {\n    args[0] += \"O\"\n}\n\n// FILE: b.kt\n\npackage pkg\n\nfun main(args: Array<String>) {\n    args[0] += \"K\"\n}\n"
        },
        {
            "code": "// FILE: box.kt\n\npackage a\n\nimport pack.*\n\nclass X : SomeClass()\n\nfun box(): String {\n    X()\n    return \"OK\"\n}\n\n// FILE: file1.kt\n\npackage kotlin.jvm\n\nprivate class SomeClass\n\n// FILE: file2.kt\n\npackage pack\n\npublic open class SomeClass\n"
        },
        {
            "code": "// See KT-9246 IllegalAccessError when trying to access protected nested class from parent class\n// FILE: a.kt\n\npackage a\n\nabstract class A {\n    protected class C {\n        fun result() = \"OK\"\n    }\n}\n\n// FILE: b.kt\n\npackage b\n\nimport a.A\n\nclass B : A() {\n    protected val c = A.C()\n    val result: String get() = c.result()\n}\n\nfun box(): String {\n    return B().result\n}\n"
        },
        {
            "code": "// See KT-8269 java.lang.IllegalAccessError on accessing protected inner class declared in Kotlin super class\n// TARGET_BACKEND: JVM\n// FILE: Test.kt\n\npackage com.company\n\nimport other.JavaClass\n\nopen class Test {\n    protected class ProtectedClass\n}\n\nfun box(): String {\n    JavaClass.test()\n    return \"OK\"\n}\n\n// FILE: other/JavaClass.java\n\npackage other;\n\nimport com.company.Test;\n\npublic class JavaClass {\n    static class JavaTest extends Test {\n        public static boolean foo(Object obj) {\n            return obj instanceof ProtectedClass;\n        }\n    }\n\n    public static void test() {\n        JavaTest.foo(new Object());\n    }\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JS_IR\n// MODULE: lib\n// FILE: lib.kt\n\npackage lib\n\ninternal fun foo() = 1\n\ninternal val bar = 2\n\ninternal class A {\n    internal fun baz(a: Int): Int {\n        return a * 10\n    }\n\n    internal val foo = 3\n\n    internal inner class B {\n        internal fun foo() = 4\n    }\n}\n\n// MODULE: main(lib)(lib)\n// FILE: main.kt\n\npackage main\n\nimport lib.*\n\nfun box(): String {\n    if (foo() != 1) return \"fail 1: ${foo()}\"\n    if (bar != 2) return \"fail 2: ${bar}\"\n    val a = A()\n    if (a.baz(10) != 100) return \"fail 3: ${a.baz(10)}\"\n    if (a.foo != 3) return \"fail 4: ${a.foo}\"\n    if (a.B().foo() != 4) return \"fail 5: ${a.B().foo()}\"\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: first/Foo.java\n\npackage first;\n\npublic class Foo {\n    protected static final int FOO = 42;\n}\n\n// FILE: bar.kt\n\npackage second\n\nimport first.Foo\n\nclass Bar : Foo() {\n    fun bar() = FOO\n}\n\n// @second/BarKt.class\n// 0 INVOKESTATIC\n// 0 GETSTATIC\n// 1 BIPUSH 42"
        },
        {
            "code": "// FILE: first/JavaSuperclass.java\n\npackage first;\n\npublic class JavaSuperclass {\n    public static final String CONSTANT = \"foo\";\n}\n\n// FILE: first/JavaSubclass.java\n\npackage first;\n\npublic class JavaSubclass extends JavaSuperclass {\n}\n\n// FILE: second/bar.kt\n\npackage second\n\nimport first.JavaSubclass\n\nfun bar() = JavaSubclass.CONSTANT\n\n// @second/BarKt.class\n// 0 INVOKESTATIC\n// 0 GETSTATIC\n// 1 LDC \"foo\""
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n\n// MODULE: lib\n// FILE: lib.kt\npackage lib\n\nclass Provider<T>(val _value: T) {\n    inline operator fun provideDelegate(thisRef: Any?, kProperty: Any?) =\n        Mut(_value)\n}\n\nclass Mut<T>(var _value: T) {\n\n    inline operator fun getValue(thisRef: Any?, kProperty: Any?) = _value\n\n    inline operator fun setValue(thisRef: Any?, kProperty: Any?, newValue: T) {\n        _value = newValue\n    }\n}\n\n// MODULE: main(lib)(lib)\n// FILE: main.kt\nimport lib.*\n\nclass C {\n    val delegatedVal by Mut(1)\n    var delegatedVar by Mut(2)\n    val delegatedValByProvider by Provider(1)\n    var delegatedVarByProvider by Provider(2)\n}\n\nval topLevelDelegatedVal by Mut(1)\nvar topLevelDelegatedVar by Mut(2)\nval topLevelDelegatedValByProvider by Provider(1)\nvar topLevelDelegatedVarByProvider by Provider(2)\n\nfun box(): String {\n    val localDelegatedVal by Mut(1)\n    var localDelegatedVar by Mut(2)\n    val localDelegatedValByProvider by Provider(1)\n    var localDelegatedVarByProvider by Provider(1)\n\n    val x = C()\n    if (x.delegatedVal != 1) throw AssertionError()\n    if (x.delegatedVar != 2) throw AssertionError()\n    x.delegatedVar = 3\n    if (x.delegatedVar != 3) throw AssertionError()\n\n    if (x.delegatedValByProvider != 1) throw AssertionError()\n    if (x.delegatedVarByProvider != 2) throw AssertionError()\n    x.delegatedVarByProvider = 3\n    if (x.delegatedVarByProvider != 3) throw AssertionError()\n\n    if (topLevelDelegatedVal != 1) throw AssertionError()\n    if (topLevelDelegatedVar != 2) throw AssertionError()\n    topLevelDelegatedVar = 3\n    if (topLevelDelegatedVar != 3) throw AssertionError()\n\n    if (topLevelDelegatedValByProvider != 1) throw AssertionError()\n    if (topLevelDelegatedVarByProvider != 2) throw AssertionError()\n    topLevelDelegatedVarByProvider = 3\n    if (topLevelDelegatedVarByProvider != 3) throw AssertionError()\n\n    if (localDelegatedVal != 1) throw AssertionError()\n    if (localDelegatedVar != 2) throw AssertionError()\n    localDelegatedVar = 3\n    if (localDelegatedVar != 3) throw AssertionError()\n\n    if (localDelegatedValByProvider != 1) throw AssertionError()\n    if (localDelegatedVarByProvider != 2) throw AssertionError()\n    localDelegatedVarByProvider = 3\n    if (localDelegatedVarByProvider != 3) throw AssertionError()\n\n    return \"OK\"\n}\n\n// @MainKt.class:\n// 0 \\$\\$delegatedProperties\n// 0 ANEWARRAY\n// 0 kotlin/reflect/KProperty\n// 0 final static synthetic \\[Lkotlin/reflect/KProperty; \\$\\$delegatedProperties\n// 0 kotlin/jvm/internal/PropertyReference0Impl\\.\\<init\\>\n// 0 kotlin/jvm/internal/MutablePropertyReference0Impl\\.\\<init\\>\n\n// @C.class:\n// 0 \\$\\$delegatedProperties\n// 0 ANEWARRAY\n// 0 kotlin/reflect/KProperty\n// 0 final static synthetic \\[Lkotlin/reflect/KProperty; \\$\\$delegatedProperties\n// 0 kotlin/jvm/internal/PropertyReference0Impl\\.\\<init\\>\n// 0 kotlin/jvm/internal/MutablePropertyReference0Impl\\.\\<init\\>\n"
        },
        {
            "code": "// FILE: otherFile.kt\n\n@file:[JvmName(\"Util\") JvmMultifileClass]\npackage test\n\ninternal fun internalInOtherFile() {}\npublic fun publicInOtherFile() {}\n\n// FILE: thisFile.kt\n\n@file:[JvmName(\"Util\") JvmMultifileClass]\npackage test\n\nfun foo() {\n    privateInThisFile()\n    internalInThisFile()\n    publicInThisFile()\n    internalInOtherFile()\n    publicInOtherFile()\n}\n\nprivate fun privateInThisFile() {}\n\ninternal fun internalInThisFile() {}\n\npublic fun publicInThisFile() {}\n\n// @test/Util__ThisFileKt.class:\n// 1 INVOKESTATIC test/Util__ThisFileKt.privateInThisFile\n// 1 INVOKESTATIC test/Util.internalInThisFile\n// 1 INVOKESTATIC test/Util.publicInThisFile\n// 1 INVOKESTATIC test/Util.internalInOtherFile\n// 1 INVOKESTATIC test/Util.publicInOtherFile\n"
        },
        {
            "code": "// FILE: otherFile.kt\n\n@file:[JvmName(\"Util\") JvmMultifileClass]\npackage test\n\npublic fun publicInOtherFile() {}\n\n// FILE: thisFile.kt\n\n@file:[JvmName(\"Util\") JvmMultifileClass]\npackage test\n\ninline fun foo(body: () -> Unit) {\n    publicInThisFile()\n    publicInOtherFile()\n    body()\n}\n\npublic fun publicInThisFile() {}\n\nfun bar() {\n    foo {}\n}\n\n// @test/Util__ThisFileKt.class:\n// 2 INVOKESTATIC test/Util.publicInThisFile\n// 2 INVOKESTATIC test/Util.publicInOtherFile\n"
        },
        {
            "code": "// !LANGUAGE: -InlineConstVals\n// IGNORE_BACKEND: JVM_IR\n// FILE: first/Foo.java\n\npackage first;\n\npublic class Foo {\n    protected static final int FOO = 42;\n}\n\n// FILE: bar.kt\n\npackage second\n\nimport first.Foo\n\nclass Bar : Foo() {\n    fun bar() = FOO\n}\n\n// @second/BarKt.class\n// 1 INVOKESTATIC\n// 0 GETSTATIC\n// 1 BIPUSH 42\n"
        },
        {
            "code": "// FILE: j/J.java\n\npackage j;\n\npublic class J {\n    public static final String ok() { return \"OK\"; }\n}\n\n// FILE: k.kt\nimport j.J\n\nfun foo(a: Any) {}\n\nfun test() {\n    val a = J.ok()\n    a!!\n    foo(a)\n    if (a == null) foo(\"NULL-1\")\n}\n\n// @KKt.class:\n// 0 IFNULL\n// 1 IFNONNULL\n// 0 NULL-1"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// FILE: j/J.java\n\npackage j;\n\npublic class J {\n    public static final String ok() { return \"OK\"; }\n}\n\n// FILE: k.kt\nimport j.J\n\nfun foo(a: Any) {}\n\nfun test() {\n    val a = J.ok()\n    foo(a)\n    if (a == null) foo(\"NULL-1\")\n}\n\n// @KKt.class:\n// 0 IFNULL\n// 0 IFNONNULL\n// 0 NULL-1"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// FILE: j/J.java\n\npackage j;\n\npublic class J {\n    public static final String ok() { return \"OK\"; }\n}\n\n// FILE: foo.kt\nfun foo(a: Any) {}\n\n// FILE: k.kt\nimport j.J\n\nfun test() {\n    val a = J.ok()\n    foo(a)\n    foo(a)\n}\n\n// @KKt.class:\n// 1 LDC \"a\"\n// 1 checkExpressionValueIsNotNull\n// 0 checkNotNullExpressionValue\n"
        },
        {
            "code": "// !API_VERSION: LATEST\n// IGNORE_BACKEND: JVM_IR\n// FILE: j/J.java\n\npackage j;\n\npublic class J {\n    public static final String ok() { return \"OK\"; }\n}\n\n// FILE: foo.kt\nfun foo(a: Any) {}\n\n// FILE: k.kt\nimport j.J\n\nfun test() {\n    val a = J.ok()\n    foo(a)\n    foo(a)\n}\n\n// @KKt.class:\n// 1 checkNotNullExpressionValue\n"
        },
        {
            "code": "// FILE: test/CallableDescriptor.java\npackage test;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic interface CallableDescriptor {\n    @NotNull\n    CallableDescriptor getOriginal();\n}\n\n// FILE: test/k.kt\npackage test\n\nfun <D : CallableDescriptor> D.overriddenTreeUniqueAsSequenceA(): Boolean {\n    return original in emptySet<D>()\n}\n\n// TODO: in fact, there should be an assertion, but it's missing because of https://youtrack.jetbrains.com/issue/KT-24210.\n// (This test's aim is not to check whether or not the assertion is generated, but to ensure that the behavior is deterministic.)\n// 0 checkExpressionValueIsNotNull\n// 0 checkNotNullExpressionValue\n"
        },
        {
            "code": "// WITH_REFLECT\n// FILE: test/J.java\n\npackage test;\n\npublic class J {\n    public final boolean b;\n    public char c;\n\n    public J() {\n        this.b = false;\n        this.c = '0';\n    }\n}\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.test.*\n\nfun box(): String {\n    assertEquals(\"val test.J.b: kotlin.Boolean\", (J::b).toString())\n    assertEquals(\"var test.J.c: kotlin.Char\", (J::c).toString())\n\n    assertTrue(J::b == J::b)\n    assertFalse(J::c == J::b)\n\n    assertTrue(J::b.hashCode() == J::b.hashCode())\n    assertFalse(J::b.hashCode() == J::c.hashCode())\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: test/JavaClass.java\n\npackage test;\n\npublic class JavaClass {\n    public enum E { ENTRY }\n    \n    public static String foo() { return \"OK\"; }\n}\n\n// FILE: 1.kt\n\npackage test\n\nfun box(): String {\n    return JavaClass.foo()!!\n}\n"
        },
        {
            "code": "// FILE: test/D.java\n\npackage test;\n\npublic class D {\n    protected String field = \"OK\";\n}\n\n// FILE: 1.kt\n\nimport test.D\n\nclass A : D() {\n    fun a(): String {\n        return {field!!}()\n    }\n}\n\nfun box(): String {\n    return A().a()\n}\n"
        },
        {
            "code": "// FILE: test/En.java\n\npackage test;\n\npublic enum En {\n    A;\n}\n\n// FILE: 1.kt\n\nimport test.*\n\nfun box() =\n    if (En.A.toString() == \"A\") \"OK\"\n    else \"fail\"\n"
        },
        {
            "code": "// FILE: test/Foo.java\n\npackage test;\n\npublic class Foo {\n    public enum MyEnum {\n        A;\n    }\n}\n\n// FILE: 1.kt\n\nimport test.*\nimport test.Foo.MyEnum.A\n\nfun box() =\n    if (Foo.MyEnum.A.toString() == \"A\" && A.toString() == \"A\") \"OK\"\n    else \"fail\"\n"
        },
        {
            "code": "// FILE: test/En.java\n\npackage test;\n\npublic enum En {\n    A;\n}\n\n// FILE: 1.kt\n\nimport test.En.A\n\nfun box() =\n    if (A.toString() == \"A\") \"OK\"\n    else \"fail\"\n"
        },
        {
            "code": "// FILE: test/E.java\n\npackage test;\n\nimport java.util.Set;\nimport java.util.EnumSet;\n\npublic enum E {\n    INSTANCE;\n    \n    public static int foo = 42;\n    \n    public static final Set<E> INSTANCES = EnumSet.of(INSTANCE);\n}\n\n// FILE: 1.kt\n\nimport test.E\n\nfun box(): String {\n    val instances = E.INSTANCES\n    if (E.foo != 42)\n        return \"Wrong foo ${E.foo}\"\n    if (instances.size != 1)\n        return \"Wrong size ${instances.size}\"\n    if (E.INSTANCES.iterator().next() != E.INSTANCE)\n        return \"Wrong instance ${E.INSTANCES.iterator().next()}\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: test/En.java\n\npackage test;\n\npublic enum En {\n    ENTRY;\n    \n    public static String foo() {\n        return \"OK\";\n    }\n}\n\n// FILE: 1.kt\n\nfun box() = test.En.foo()\n"
        },
        {
            "code": "// FILE: test/En.java\n\npackage test;\n\nimport java.lang.Override;\nimport java.lang.String;\n\npublic enum En {\n    A {\n        @Override\n        public String repr() {\n            return \"A\";\n        }\n    },\n    B;\n    \n    public String repr() {\n        return \"ololol\" + toString();\n    }\n}\n\n// FILE: 1.kt\n\nimport test.En.*\n\nfun box() =\n    if (A.repr() == \"A\" && B.repr() == \"olololB\") \"OK\"\n    else \"fail\"\n"
        },
        {
            "code": "// FILE: test/Foo.java\n\npackage test;\n\npublic class Foo {\n    private final String x;\n    private final String y;\n\n    public Foo(String x, String y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public Foo(String x) {\n        this(x, \"def_y\");\n    }\n\n    public Foo() {\n        this(\"def_x\");\n    }\n\n    @Override\n    public String toString() {\n        return x + \"#\" + y;\n    }\n}\n\n// FILE: 1.kt\n\nimport test.Foo;\n\nclass Child : Foo {\n    constructor(): super() {}\n    constructor(x: String): super(x) {}\n    constructor(x: String, y: String): super(x, y) {}\n}\n\nfun box(): String {\n    val c1 = Child().toString()\n    if (c1 != \"def_x#def_y\") return \"fail1: $c1\"\n\n    val c2 = Child(\"abc\").toString()\n    if (c2 != \"abc#def_y\") return \"fail2: $c2\"\n\n    val c3 = Child(\"abc\", \"def\").toString()\n    if (c3 != \"abc#def\") return \"fail3: $c3\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: test/Foo.java\n\npackage test;\n\npublic class Foo<T extends Number> {\n    public Foo(T number) {}\n}\n\n// FILE: 1.kt\n\nimport test.Foo\n\nclass Subclass : Foo<Int>(42) {\n}\n\nfun box(): String {\n    Subclass()\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\npublic class J {\n    protected String foo() {\n        return \"fail\";\n    }\n}\n\n// FILE: 1.kt\n\npackage protectedPackKotlin\n\nimport protectedPack.J\n\nclass Derived : J() {\n    protected override fun foo(): String? {\n        return \"OK\"\n    }\n\n    fun test(): String {\n        return foo()!!\n    }\n}\n\nfun box(): String {\n   return Derived().test()\n}\n"
        },
        {
            "code": "// FILE: test/Foo.java\n\npackage test;\n\npublic class Foo {\n    protected void foo(Runnable r) {\n        r.run();\n    }\n}\n\n// FILE: test.kt\n\npackage other\n\nimport test.Foo\n\nclass Bar : Foo() {\n    fun bar() {\n        foo {}\n        foo(Runnable {})\n        // super.foo {}\n        super.foo(Runnable {})\n        this.foo {}\n        this.foo(Runnable {})\n    }\n}\n\nfun box(): String {\n    Bar().bar()\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: protectedPack/A.java\npackage protectedPack;\n\npublic class A {\n    protected final String field;\n\n    public A(String value) {\n        field = value;\n    }\n}\n\n// FILE: B.kt\nimport protectedPack.A\n\nclass B(value: String) : A(value) {\n    inner class C : A(field) {\n        val result = field\n    }\n}\n\nfun box(): String = B(\"OK\").C().result\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\npublic class J {\n    protected String foo() {\n        return \"OK\";\n    }\n}\n\n// FILE: 1.kt\n\npackage protectedPack\n\nfun box(): String {\n    return J().foo()!!\n}\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\npublic class J {\n    protected static class Inner {\n        public String foo() {\n            return \"OK\";\n        }\n    }\n}\n\n// FILE: 1.kt\n\npackage protectedPack\n\nclass Derived : J() {\n    fun test(): String {\n        return J.Inner().foo()!!\n    }\n}\n\nfun box(): String {\n    return Derived().test()\n}\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\npublic class J {\n    protected String foo = \"OK\";\n}\n\n// FILE: 1.kt\n\npackage protectedPack\n\nfun box(): String {\n    return J().foo!!\n}\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\npublic class J {\n    String test() {\n        return \"OK\";\n    }\n}\n\n// FILE: 1.kt\n\npackage protectedPack\n\nfun box(): String {\n    return J().test()!!\n}\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\npublic class J {\n    String test = \"OK\";\n}\n\n// FILE: 1.kt\n\npackage protectedPack\n\nfun box(): String {\n    return J().test!!\n}\n"
        },
        {
            "code": "// FILE: protectedPack/J.java\n\npackage protectedPack;\n\nclass J {\n    public String test() {\n        return \"OK\";\n    }\n}\n\n// FILE: 1.kt\n\npackage protectedPack\n\nfun box(): String {\n    return J().test()!!\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface MComparator<T> {\n    fun compare(o1: T, o2: T): Int\n}\n\nopen class CustomerService {\n\n    fun <T> comparator() = object : MComparator<T> {\n        override fun compare(o1: T, o2: T): Int {\n            throw UnsupportedOperationException()\n        }\n    }\n\n    inline fun <T> comparator(crossinline z: () -> Int) = object : MComparator<T> {\n\n        override fun compare(o1: T, o2: T): Int {\n            return z()\n        }\n    }\n\n    fun callInline() =  comparator<String> { 1 }\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n\n    val comparable = CustomerService().comparator<String>()\n    val method = comparable.javaClass.getMethod(\"compare\", Any::class.java, Any::class.java)\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 2) return \"fail 1: ${genericParameterTypes.size}\"\n    if (genericParameterTypes[0].toString() != \"T\") return \"fail 2: ${genericParameterTypes[0]}\"\n    if (genericParameterTypes[1].toString() != \"T\") return \"fail 3: ${genericParameterTypes[1]}\"\n\n\n    val comparable2 = CustomerService().callInline()\n    val method2 = comparable2.javaClass.getMethod(\"compare\", Any::class.java, Any::class.java)\n    val genericParameterTypes2 = method2.genericParameterTypes\n    if (genericParameterTypes2.size != 2) return \"fail 1: ${genericParameterTypes2.size}\"\n\n    var name = (genericParameterTypes2[0] as Class<*>).name\n    if (name != \"java.lang.String\") return \"fail 5: ${name}\"\n    name = (genericParameterTypes2[1] as Class<*>).name\n    if (name != \"java.lang.String\") return \"fail 6: ${name}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface F<T> {\n    fun test(p: T) : Int\n}\n\ninline fun <T> Array<T>.copyOfRange1(crossinline toIndex: () -> Int) =\n        object : F<T> {\n            override fun test(p: T): Int {\n                return toIndex()\n            }\n        }\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\nimport java.util.*\n\npublic fun Array<out CharSequence>.slice1() = copyOfRange1 { 1 }\n\nfun box(): String {\n    val comparable = arrayOf(\"123\").slice1()\n    val method = comparable.javaClass.getMethod(\"test\", Any::class.java)\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 1) return \"fail 1: ${genericParameterTypes.size}\"\n    var name = (genericParameterTypes[0] as Class<*>).name\n    if (name != \"java.lang.CharSequence\") return \"fail 2: ${name}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\nopen class Test {\n\n    inline fun <Y> test(z: () -> () -> Y) = z()\n\n    fun <T> callInline(p: T)  = test<T> {\n        {\n            p\n        }\n    }\n}\n\n// FILE: 2.kt\n\n// NO_CHECK_LAMBDA_INLINING\n// FULL_JDK\n\nimport test.*\nimport java.util.*\n\n\nfun box(): String {\n    val result = Test().callInline(\"test\")\n\n    val method = result.javaClass.getMethod(\"invoke\")\n    val genericReturnType = method.genericReturnType\n    if (genericReturnType.toString() != \"T\") return \"fail 1: $genericReturnType\"\n\n    val method2 = Test::class.java.getMethod(\"callInline\", Any::class.java)\n    val genericParameterType = method2.genericParameterTypes.firstOrNull()\n\n    if (genericParameterType != genericReturnType) return \"fail 2: $genericParameterType != $genericReturnType\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\n\ninline fun stub() {\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\nimport java.util.*\n\n\nclass I<A>(val s: A)\nclass A<T : Any>(val elements: List<I<T>>) {\n    val p = elements.sortedBy { it.hashCode() }\n}\n\nfun box(): String {\n\n    A(listOf(I(\"1\"), I(\"2\"), I(\"3\"))).p\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\nclass B<T>\n\ninterface A {\n    fun <T> aTest(p: T): B<T>\n}\n\nopen class Test {\n\n    inline fun <reified T> test(crossinline z: () -> Int) = object : A {\n        override fun <T> aTest(p: T): B<T> {\n            z()\n            return B<T>()\n        }\n    }\n\n    fun callInline() =  test<String> { 1 }\n}\n\n// FILE: 2.kt\n\n// NO_CHECK_LAMBDA_INLINING\n// FULL_JDK\n\nimport test.*\nimport java.util.*\n\n\nfun box(): String {\n    val result = Test().callInline()\n    val method = result.javaClass.getMethod(\"aTest\", Any::class.java)\n    val genericReturnType = method.genericReturnType\n    if (genericReturnType.toString() != \"test.B<T>\") return \"fail 1: ${genericReturnType}\"\n\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 1) return \"fail 2: ${genericParameterTypes.size}\"\n    if (genericParameterTypes[0].toString() != \"T\") return \"fail 3: ${genericParameterTypes[0]}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\nimport java.util.*\n\nopen class CustomerService {\n\n    fun <T> comparator() = object : Comparator<T> {\n        override fun compare(o1: T, o2: T): Int {\n            throw UnsupportedOperationException()\n        }\n    }\n\n    inline fun <T> comparator(crossinline z: () -> Int) = object : Comparator<T> {\n\n        override fun compare(o1: T, o2: T): Int {\n            return z()\n        }\n\n    }\n\n    fun callInline() =  comparator<String> { 1 }\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\nimport java.util.*\n\nfun box(): String {\n\n    val comparable = CustomerService().comparator<String>()\n    val method = comparable.javaClass.getMethod(\"compare\", Any::class.java, Any::class.java)\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 2) return \"fail 1: ${genericParameterTypes.size}\"\n    if (genericParameterTypes[0].toString() != \"T\") return \"fail 2: ${genericParameterTypes[0]}\"\n    if (genericParameterTypes[1].toString() != \"T\") return \"fail 3: ${genericParameterTypes[1]}\"\n\n\n    val comparable2 = CustomerService().callInline()\n    val method2 = comparable2.javaClass.getMethod(\"compare\", Any::class.java, Any::class.java)\n    val genericParameterTypes2 = method2.genericParameterTypes\n    if (genericParameterTypes2.size != 2) return \"fail 4: ${genericParameterTypes2.size}\"\n    var name = (genericParameterTypes2[0] as Class<*>).name\n    if (name != \"java.lang.String\") return \"fail 5: ${name}\"\n    name = (genericParameterTypes2[1] as Class<*>).name\n    if (name != \"java.lang.String\") return \"fail 6: ${name}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface F<T> {\n    fun test(p: T) : Int\n}\n\ninline fun <T> Array<T>.copyOfRange1(crossinline toIndex: () -> Int) =\n        object : F<T> {\n            override fun test(p: T): Int {\n                return toIndex()\n            }\n        }\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\nimport java.util.*\n\npublic fun Array<*>.slice1() = copyOfRange1 { 1 }\n\nfun box(): String {\n    val comparable = arrayOf(\"123\").slice1()\n    val method = comparable.javaClass.getMethod(\"test\", Any::class.java)\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 1) return \"fail 1: ${genericParameterTypes.size}\"\n    var name = (genericParameterTypes[0] as Class<*>).name\n    if (name != \"java.lang.Object\") return \"fail 2: ${name}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface F<T> {\n    fun test(p: T) : Int\n}\n\ninline fun <T: Any?> Array<T>.copyOfRange1(crossinline toIndex: () -> Int) =\n        object : F<T> {\n            override fun test(p: T): Int {\n                return toIndex()\n            }\n        }\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\nimport java.util.*\n\npublic fun Array<in String>.slice1() = copyOfRange1 { 1 }\n\nfun box(): String {\n    val comparable = arrayOf(\"123\").slice1()\n    val method = comparable.javaClass.getMethod(\"test\", Any::class.java)\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 1) return \"fail 1: ${genericParameterTypes.size}\"\n    var name = (genericParameterTypes[0] as Class<*>).name\n    if (name != \"java.lang.Object\") return \"fail 2: ${name}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\nclass B<T>\n\ninterface A {\n    fun <T> aTest(p: T): B<T>\n}\n\nopen class Test {\n\n    inline fun <T> test(crossinline z: () -> Int) = object : A {\n        override fun <T> aTest(p: T): B<T> {\n            z()\n            return B<T>()\n        }\n    }\n\n    fun callInline() =  test<String> { 1 }\n}\n\n// FILE: 2.kt\n\n// NO_CHECK_LAMBDA_INLINING\n// FULL_JDK\n\nimport test.*\nimport java.util.*\n\n\nfun box(): String {\n    val result = Test().callInline()\n    val method = result.javaClass.getMethod(\"aTest\", Any::class.java)\n    val genericReturnType = method.genericReturnType\n    if (genericReturnType.toString() != \"test.B<T>\") return \"fail 1: ${genericReturnType}\"\n\n    val genericParameterTypes = method.genericParameterTypes\n    if (genericParameterTypes.size != 1) return \"fail 2: ${genericParameterTypes.size}\"\n    if (genericParameterTypes[0].toString() != \"T\") return \"fail 3: ${genericParameterTypes[0]}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\nvar s: Int = 1;\n\ninline fun Int.inlineMethod() : Int {\n    noInlineLambda()\n    return noInlineLambda()\n}\n\ninline fun Int.noInlineLambda() =  { s++ } ()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\nfun test1(): Int {\n    return 1.inlineMethod()\n}\n\nfun box(): String {\n    val result = test1()\n    if (result != 2) return \"test1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage zzz\n\n\ninline fun calc(crossinline lambda: () -> Int): Int {\n    return doCalc { lambda() }\n}\n\nfun doCalc(lambda2: () -> Int): Int {\n    return lambda2()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport zzz.*\n\nfun box(): String {\n\n    val p = { calc { 11 }} ()\n\n    val z = { calc { 12 }}()\n\n    if (p == z) return \"fail\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nopen class Base {\n    protected open val FOO = \"O\"\n\n    protected open fun test() = \"K\"\n}\n\nopen class P : Base() {\n\n    inline fun protectedProp(): String {\n        return FOO\n    }\n\n    inline fun protectedFun(): String {\n        return test()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A: P() {\n    override val FOO: String\n        get() = \"fail\"\n\n    override fun test(): String {\n        return \"fail\"\n    }\n}\n\nfun box() : String {\n    val p = P()\n    return p.protectedProp() + p.protectedFun()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass P {\n    private val FOO_PRIVATE = \"OK\"\n\n    final val FOO_FINAL = \"OK\"\n\n    private inline fun fooPrivate(): String {\n        return FOO_PRIVATE\n    }\n\n    private inline fun fooFinal(): String {\n        return FOO_FINAL\n    }\n\n    fun testPrivate(): String {\n        return fooPrivate()\n    }\n\n    fun testFinal(): String {\n        return fooFinal()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    val p = P()\n\n    if (p.testPrivate() != \"OK\") return \"fail 1 ${p.testPrivate()}\"\n\n    if (p.testFinal() != \"OK\") return \"fail 2 ${p.testFinal()}\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nprivate const val packageProp = \"O\"\n\ninternal inline fun packageInline(p: (String) -> String): String {\n    return p(packageProp)\n}\n\ninternal fun samePackageCall(): String {\n    return packageInline { it + \"K\"}\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val packageResult = packageInline { it + \"K\" }\n    if (packageResult != \"OK\") return \"package inline fail: $packageResult\"\n\n    val samePackageResult = samePackageCall()\n    if (samePackageResult != \"OK\") return \"same package inline fail: $samePackageResult\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nopen class P {\n    protected open val FOO = \"O\"\n\n    protected open fun test() = \"K\"\n\n    inline fun protectedProp(): String {\n        return FOO\n    }\n\n    inline fun protectedFun(): String {\n        return test()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A: P() {\n    override val FOO: String\n        get() = \"fail\"\n\n    override fun test(): String {\n        return \"fail\"\n    }\n}\n\nfun box() : String {\n    val p = P()\n    return p.protectedProp() + p.protectedFun()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nprivate val packageProp = \"O\"\n\nprivate fun packageFun() = \"K\"\n\ninternal inline fun packageInline(p: (String, String) -> String): String {\n    return p(packageProp, packageFun())\n}\n\ninternal fun samePackageCall(): String {\n    return packageInline { s, s2 -> s + s2 }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val packageResult = packageInline { a, b -> a + b }\n    if (packageResult != \"OK\") return \"package inline fail: $packageResult\"\n\n    val samePackageResult = samePackageCall()\n    if (samePackageResult != \"OK\") return \"same package inline fail: $samePackageResult\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A {\n\n    private fun method() = \"O\"\n\n    private val prop = \"K\"\n\n    fun test1(): String {\n        return call {\n            method() + prop\n        }\n    }\n\n    fun test2(): String {\n        return call {\n            call {\n                method() + prop\n            }\n        }\n    }\n}\n\nfun box(): String {\n    val a = A()\n    if (a.test1() != \"OK\") return \"fail 1: ${a.test1()}\"\n    return a.test2()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A {\n\n    private val prop : String = \"O\"\n        get() = call {field + \"K\" }\n\n    private val prop2 : String = \"O\"\n        get() = call { call {field + \"K\" } }\n\n    fun test1(): String {\n        return prop\n    }\n\n    fun test2(): String {\n        return prop2\n    }\n\n}\n\nfun box(): String {\n    val a = A()\n    if (a.test1() != \"OK\") return \"fail 1: ${a.test1()}\"\n    return a.test2()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(crossinline s: () -> String): String {\n    return { s() } ()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass A {\n\n    private val prop : String = \"O\"\n        get() = call {field + \"K\" }\n\n    private val prop2 : String = \"O\"\n        get() = call { call {field + \"K\" } }\n\n    fun test1(): String {\n        return prop\n    }\n\n    fun test2(): String {\n        return prop2\n    }\n\n}\n\nfun box(): String {\n    val a = A()\n    if (a.test1() != \"OK\") return \"fail 1: ${a.test1()}\"\n    return a.test2()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(crossinline s: () -> String): String {\n    return {\n        s()\n    }()\n}\n\nopen class Base {\n\n    protected open fun method(): String = \"O\"\n\n    protected open val prop = \"K\"\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass A : Base() {\n\n    override fun method() = \"fail method\"\n\n    override val prop = \"fail property\"\n\n    fun test1(): String {\n        return call {\n            super.method() + super.prop\n        }\n    }\n\n    fun test2(): String {\n        return call {\n            call {\n                super.method() + super.prop\n            }\n        }\n    }\n}\n\nfun box(): String {\n    val a = A()\n    if (a.test1() != \"OK\") return \"fail 1: ${a.test1()}\"\n    return a.test2()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(crossinline s: () -> String): String {\n    return {\n        s()\n    }()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass A {\n\n    private fun method() = \"O\"\n\n    private val prop = \"K\"\n\n    fun test1(): String {\n        return call {\n            method() + prop\n        }\n    }\n\n    fun test2(): String {\n        return call {\n            call {\n                method() + prop\n            }\n        }\n    }\n}\n\nfun box(): String {\n    val a = A()\n    if (a.test1() != \"OK\") return \"fail 1: ${a.test1()}\"\n    return a.test2()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(s: () -> String): String {\n    return s()\n}\n\nopen class Base {\n\n    protected open fun method(): String = \"O\"\n\n    protected open val prop = \"K\"\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A : Base() {\n\n    override fun method() = \"fail method\"\n\n    override val prop = \"fail property\"\n\n    fun test1(): String {\n        return call {\n            super.method() + super.prop\n        }\n    }\n\n    fun test2(): String {\n        return call {\n            call {\n                super.method() + super.prop\n            }\n        }\n    }\n}\n\nfun box(): String {\n    val a = A()\n    if (a.test1() != \"OK\") return \"fail 1: ${a.test1()}\"\n    return a.test2()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nopen class A {\n    open fun test() = \"OK\"\n}\n\nobject X : A() {\n    override fun test(): String {\n        return \"fail\"\n    }\n\n    inline fun doTest(): String {\n        return super.test()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return X.doTest()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nopen class A {\n    open val test = \"OK\"\n}\n\nobject X : A() {\n    override val test: String\n        get() = \"fail\"\n\n    inline fun doTest(): String {\n        return super.test\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return X.doTest()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// !INHERIT_MULTIFILE_PARTS\n// FILE: 1.kt\n\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\ninline fun foo(body: () -> String): String = bar(body())\n\npublic fun bar(x: String): String = x\n\ninline fun <reified T> inlineOnly(x: Any?): Boolean = x is T\n\n// FILE: 2.kt\n\nimport a.foo\nimport a.inlineOnly\n\nfun box(): String {\n    if (!inlineOnly<String>(\"OK\")) return \"fail 1\"\n   return foo { \"OK\" }\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\n@file:[JvmName(\"MultifileClass\") JvmMultifileClass]\npackage a\n\ninline fun foo(body: () -> String): String = bar(body())\n\npublic fun bar(x: String): String = x\n\ninline fun <reified T> inlineOnly(x: Any?): Boolean = x is T\n\n// FILE: 2.kt\n\nimport a.foo\nimport a.inlineOnly\n\nfun box(): String {\n    if (!inlineOnly<String>(\"OK\")) return \"fail 1\"\n   return foo { \"OK\" }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\ninline fun <R> doWork(crossinline job: ()-> R) : R {\n    val k = 10;\n    return notInline({k; job()})\n}\n\nfun <R> notInline(job: ()-> R) : R {\n    return job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    val result = doWork({11})\n    if (result != 11) return \"test1: ${result}\"\n\n    val result2 = doWork({12; result+1})\n    if (result2 != 12) return \"test2: ${result2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T, R> mfun(arg: T, f: (T) -> R) : R {\n    return f(arg)\n}\n\ninline fun <T> doSmth(a: T): String {\n    return a.toString()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(s: Long): String {\n    var result = \"OK\"\n    result = mfun(s) { a ->\n        result + doSmth(s) + doSmth(a)\n    }\n\n    return result\n}\n\nfun box(): String {\n    val result = test1(11.toLong())\n    if (result != \"OK1111\") return \"fail1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\ninline fun <R> doWork(crossinline job: ()-> R) : R {\n    return notInline({job()})\n}\n\nfun <R> notInline(job: ()-> R) : R {\n    return job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    val result = doWork({11})\n    if (result != 11) return \"test1: ${result}\"\n\n    val result2 = doWork({12; result+1})\n    if (result2 != 12) return \"test2: ${result2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Test {\n    private abstract class Base {\n        protected fun duplicate(s: String) = s + \"K\"\n\n        protected inline fun doInline(block: () -> String): String {\n            return duplicate(block())\n        }\n    }\n\n    private class Extender: Base() {\n        fun doSomething(): String {\n            return doInline { \"O\" }\n        }\n    }\n\n    fun run(): String {\n        return Extender().doSomething();\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    return Test().run()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nprivate val prop = \"O\"\n\nprivate fun test() = \"K\"\n\ninline internal fun inlineFun(): String {\n    return prop + test()\n}\n\nclass A () {\n    fun call() = inlineFun()\n}\n\n// FILE: 2.kt\n\nimport test.*\nfun box(): String {\n    return A().call();\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun call() = inlineFun2 { stub()}\n\ninternal inline fun inlineFun2(p: () -> Unit): String {\n    p()\n\n    return inlineFun {\n        test()\n    }\n}\n\nprivate fun stub() = \"fail\"\n\nprivate fun test() = \"OK\"\n\ninline internal fun inlineFun(p: () -> String): String {\n    return p()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return call()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"TestKt\")\npackage test\n\nprivate val prop = \"O\"\n\nprivate fun test() = \"K\"\n\ninline internal fun inlineFun(): String {\n    return prop + test()\n}\n\nclass A () {\n    fun call() = inlineFun()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return A().call();\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass C(private val a : String) {\n    internal inline fun g(x: (s: String) -> Unit) {\n        x(a)\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var r = \"fail\"\n    C(\"OK\").g { r = it }\n    return r\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nprivate class S {\n    fun a(): String {\n        return \"K\"\n    }\n\n    // This function exposes S which is a private class (package-private in the byte code)\n    // It can be accessed outside the `test` package, which may lead to IllegalAccessError.\n    // This behavior may be changed later\n    internal inline fun call(s: S.() -> String): String {\n        return call2(s)\n    }\n}\n\n@Suppress(\"PRIVATE_CLASS_MEMBER_FROM_INLINE\", \"EXPOSED_PARAMETER_TYPE\", \"EXPOSED_RECEIVER_TYPE\")\ninternal inline fun S.call2(s: S.() -> String): String {\n    return s() + a()\n}\n\ninternal fun call(): String {\n    return S().call {\n        \"O\"\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return call()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nobject X {\n    private fun f() { }\n\n    internal inline fun g(x: () -> Unit) {\n        x()\n        f()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var r = \"fail\"\n    X.g { r = \"OK\" }\n\n    return r;\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    fun call() = inlineFun2 { stub() }\n\n    internal inline fun inlineFun2(p: () -> Unit): String {\n        p()\n\n        return inlineFun {\n            test()\n        }\n    }\n\n    private fun stub() = \"fail\"\n\n    private fun test() = \"OK\"\n\n\n    inline internal fun inlineFun(p: () -> String): String {\n        return p()\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return A().call()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A() {\n    private val x = \"OK\"\n    internal inline fun foo(p: (String) -> Unit) {\n        p(x)\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var r = \"fail\"\n    A().foo { r = it }\n    return r\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nprivate class S {\n    fun a(): String {\n        return \"K\"\n    }\n}\n\n// This function exposes S which is a private class (package-private in the byte code)\n// It can be accessed outside the `test` package, which may lead to IllegalAccessError.\n// This behavior may be changed later\ninternal inline fun call(s: () -> String): String {\n    val s = test()\n    return s() + test2(s)\n}\n\nprivate fun test(): S {\n    return S()\n}\n\nprivate fun test2(s: S): String {\n    return s.a()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return call {\n        \"O\"\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nprivate class S public constructor() {\n    class Z {\n        fun a(): String {\n            return \"K\"\n        }\n    }\n}\n// This function exposes S.Z which is a class nested into a private class S (package-private in the byte code)\n// It can be accessed outside the `test` package now that S.Z. is public in the byte code, but it may be changed later\ninternal inline fun call(s: () -> String): String {\n    return s() + test().a()\n}\n\nprivate fun test(): S.Z {\n    return S.Z()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return call {\n        \"O\"\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass IntentionsBundle {\n    companion object {\n        internal inline fun message(): String {\n            return KEY + BUNDLE\n        }\n\n        private const val BUNDLE = \"K\"\n        protected const val KEY = \"O\"\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return IntentionsBundle.message()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// NO_CHECK_LAMBDA_INLINING\n// WITH_RUNTIME\n// FILE: 1.kt\npackage test\n\ninline fun test(s: () -> Unit) {\n    s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var encl1 = \"fail\";\n    var encl2 = \"fail\";\n    test {\n        {\n            val p = object {}\n            encl1 = p.javaClass.enclosingMethod.declaringClass.name\n            {\n\n                val p = object {}\n                encl2 = p.javaClass.enclosingMethod.declaringClass.name\n            }()\n        }()\n    }\n\n    if (encl1 != \"_2Kt\\$box\\$\\$inlined\\$test\\$lambda$1\") return \"fail 1: $encl1\"\n    if (encl2 != \"_2Kt\\$box\\$\\$inlined\\$test\\$lambda$1$2\") return \"fail 2: $encl2\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: NATIVE\n// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun foo1() = run {\n    {\n        \"OK\"\n    }\n}\n\nvar sideEffects = \"fail\"\n\ninline fun foo2() = run {\n    {\n        Runnable {\n            sideEffects = \"OK\"\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x1 = foo1()()\n    if (x1 != \"OK\") return \"fail 1: $x1\"\n\n    foo2()().run()\n\n    return sideEffects\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Z(public var s: Int)\n\noperator inline fun Z.plusAssign(lambda: () -> Int)  {\n    this.s += lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(s: Int): Int {\n    val z = Z(s)\n    z += {s}\n    return z.s\n}\n\nfun box(): String {\n    val result = test1(11)\n    if (result != 22) return \"fail1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun f(g: () -> Int) {}\ninline fun h(g: () -> Int) = run { f(g) }\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    h { 1 }\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> doSmth(a: T) : Boolean {\n    return a === a\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(s: Long): Boolean {\n    return doSmth(s)\n}\n\nfun test2(s: Int): Boolean {\n    return doSmth(s)\n}\n\ninline fun <T> test3(s: T): Boolean {\n    return doSmth(s)\n}\n\nfun box(): String {\n    if (!test1(11111.toLong())) return \"fail 1\"\n    if (!test2(11111)) return \"fail 2\"\n    if (!test3(11111)) return \"fail 3.1\"\n    if (!test3(\"11111\")) return \"fail 3.2\"\n    if (!test3(11111.3)) return \"fail 3.3\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <R> mfun(f: () -> R) {\n    f()\n    f()\n}\n\npublic inline fun String.toLowerCase2() : String = \"\"\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    mfun{ \"\".toLowerCase2() }\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> runIf(f: (T) -> T, start: T, stop: T, secondStart: T) : T {\n    if (f(start) == stop) {\n        return f(start)\n    }\n    return f(secondStart)\n}\n\n\ninline fun <T> runIf2(f: (T) -> T, start: T, stop: T, secondStart: T) : T {\n    val result = f(start)\n    if (result == stop) {\n        return result\n    }\n    return f(secondStart)\n}\n\ninline fun <T> runIfElse(f: (T) -> T, start: T, stop: T, secondStart: T) : T {\n    if (f(start) == stop) {\n        return f(start)\n    } else {\n        return f(secondStart)\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun testIf(): String {\n    if (runIf({it}, 11, 11, 12) != 11) return \"testIf 1 test fail\"\n    if (runIf({it}, 11, 1, 12) != 12) return \"testIf 2 test fail\"\n\n    if (runIf({if (it == 11) it else 12}, 11, 11, 0) != 11) return \"testIf 3 test fail\"\n    if (runIf({if (it == 11) it else 12}, 11, 1, 0) != 12) return \"testIf 4 test fail\"\n\n    return \"OK\"\n}\n\nfun testIf2(): String {\n    if (runIf2({it}, 11, 11, 12) != 11) return \"testIf2 1 test fail\"\n    if (runIf2({it}, 11, 1, 12) != 12) return \"testIf2 2 test fail\"\n\n    if (runIf2({if (it == 11) it else 12}, 11, 11, 0) != 11) return \"testIf2 3 test fail\"\n    if (runIf2({if (it == 11) it else 12}, 11, 1, 0) != 12) return \"testIf2 4 test fail\"\n\n    return \"OK\"\n}\n\nfun testIfElse(): String {\n    if (runIfElse({it}, 11, 11, 12) != 11) return \"testIfElse 1 test fail\"\n    if (runIfElse({it}, 11, 1, 12) != 12) return \"testIfElse 2 test fail\"\n\n    if (runIfElse({if (it == 11) it else 12}, 11, 11, 0) != 11) return \"testIfElse 3 test fail\"\n    if (runIfElse({if (it == 11) it else 12}, 11, 1, 0) != 12) return \"testIfElse 4 test fail\"\n    return \"OK\"\n}\n\nfun box(): String {\n    var result = testIf()\n    if (result != \"OK\") return \"fail1: ${result}\"\n\n    result = testIf2()\n    if (result != \"OK\") return \"fail2: ${result}\"\n\n    result = testIfElse()\n    if (result != \"OK\") return \"fail2: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    val x: Int\n    val res = myrun {\n        x = 42\n        {\n            x\n        }()\n    }\n    return if (res == 42 && x.inc() == 43) \"OK\" else \"Fail: ${x.inc()}\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun cond() = true\nfun test(s: String) = s\n\nfun box(): String {\n    val x: String\n    myrun {\n        x = if (cond()) test(\"OK\") else test(\"fail\")\n    }\n    return x\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x: Int\n    myrun {\n        myrun {\n            x = 42\n        }\n    }\n    return if (x.inc() == 43) \"OK\" else \"Fail: ${x.inc()}\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n// NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun myrun(noinline block: () -> Unit): Unit {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x: Long\n    myrun {\n        x = 42L\n    }\n    return if (x != 42L) \"FAIL\" else \"OK\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test(s: String) = s\n\nfun box(): String {\n    val x: String\n    myrun {\n        x = try { test(\"OK\") } catch (e: Exception) { test(\"fail\") }\n    }\n    return x\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n// FILE: 1.kt\npackage test\n\nimport kotlin.contracts.*\n\nclass A {\n    var res = \"FAIL\"\n\n    fun foo() {\n        bar {\n            res = \"OK\"\n        }\n    }\n\n    inline fun bar(crossinline not_exactly_once: () -> Unit) {\n        baz {\n            not_exactly_once()\n        }\n    }\n}\n\ninline fun baz(crossinline exactly_once: () -> Unit) {\n    contract {\n        callsInPlace(exactly_once, InvocationKind.EXACTLY_ONCE)\n    };\n\n    { exactly_once() }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val a = A()\n    a.foo()\n    return a.res\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x: Int\n    myrun {\n        x = 42\n    }\n    return if (x.inc() == 43) \"OK\" else \"Fail: ${x.inc()}\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x: Long\n    myrun {\n        x = 42L\n    }\n    return if (x.inc() == 43L) \"OK\" else \"Fail: ${x.inc()}\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test(b: Boolean): Int {\n    val x: Int\n\n    if (b) {\n        x = 1\n    } else {\n        myrun {\n            x = -1\n        }\n    }\n    return x\n}\n\nfun box(): String {\n    if (test(true) != 1) return \"Fail 1\"\n    if (test(false) != -1) return \"Fail 2\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\ninterface SomeOutputScreenCallbacks {\n    fun ontest()\n}\n\nclass OutputWorkScreenView(callbacks: SomeOutputScreenCallbacks) {\n    val root = vBox {\n        button(callbacks::ontest)\n    }\n}\n\ninline fun vBox(crossinline action: () -> Unit) {\n    contract {\n        callsInPlace(action, InvocationKind.EXACTLY_ONCE)\n    }\n    return { action() }()\n}\n\ninline fun button(onAction: () -> Unit) {\n    onAction()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var res = \"FAIL\"\n    OutputWorkScreenView(object : SomeOutputScreenCallbacks {\n        override fun ontest() {\n            res = \"OK\"\n        }\n    })\n    return res\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun myrun(crossinline block: () -> Unit): Unit {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    val l = { block() }\n    l()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x: Long\n    myrun {\n        x = 42L\n    }\n    return if (x != 42L) \"FAIL\" else \"OK\"\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: JVM_IR, JS_IR, NATIVE\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A {\n    val z: String\n    init {\n        myrun {\n            z = \"OK\"\n        }\n    }\n}\n\nfun box(): String {\n    return A().z\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test(xs: List<String>): String {\n    var result = \"\"\n\n    myrun L@ {\n        for (x in xs) {\n            val y: String\n            myrun {\n                y = x\n                if (y.length > 1) return@L\n            }\n            result += y\n        }\n    }\n\n    return result\n}\n\nfun box(): String {\n    return test(listOf(\"O\", \"K\", \"fail\"))\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n// NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A {\n    val x: String\n\n    constructor() {\n    }\n\n    init {\n        val o: String\n        val k: String = \"K\"\n        myrun { o = \"O\" }\n        fun baz() = o + k\n        x = baz()\n    }\n}\n\nfun box() = A().x\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// IGNORE_BACKEND: NATIVE\n\n// FILE: 1.kt\n\npackage test\n\nimport kotlin.contracts.*\n\npublic inline fun <R> myrun(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x: Long\n    myrun {\n        x = 42L\n        if (x == 42L) return \"OK\"\n    }\n    return \"fail\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage zzz\n\npublic class A(val a: Int, val b: Int)\n\noperator inline fun A.component1() = a\n\noperator inline fun A.component2() = b\n\n// FILE: 2.kt\n\nimport zzz.*\n\nfun box(): String {\n    var (p, l) = A(1, 11)\n\n    return if (p == 1 && l == 11) \"OK\" else \"fail: $p\"\n}\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nzzz/_1Kt\n*L\n1#1,11:1\n7#2:12\n9#2:13\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n6#1:12\n6#1:13\n*E"
        },
        {
            "code": "// FILE: 1.kt\n\npackage zzz\n\npublic class A(val p: Int)\n\noperator inline fun A.iterator() = (1..p).iterator()\n\n// FILE: 2.kt\n\nimport zzz.*\n\nfun box(): String {\n    var p = 0\n    for (i in A(5)) {\n        p += i\n    }\n\n    return if (p == 15) \"OK\" else \"fail: $p\"\n}\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nzzz/_1Kt\n*L\n1#1,14:1\n7#2:15\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n7#1:15\n*E\n"
        },
        {
            "code": "// FILE: 1.kt\n\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return object {\n        fun run () {\n            init()\n        }\n    }.run()\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n\nfun test(): String {\n    var res = \"Fail\"\n\n    call {\n        res = \"OK\"\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    return test()\n}\n//NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.smap\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\nbuilders/_1Kt$call$1\n*L\n1#1,14:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,22:1\n7#2,5:23\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n9#1,5:23\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\nbuilders/_1Kt$call$1\n+ 2 2.kt\n_2Kt\n*L\n1#1,14:1\n10#2,2:15\n*E\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return init()\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n\ninline fun test(): String {\n    var res = \"Fail\"\n\n    call {\n        {\n            res = \"OK\"\n        }()\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    return test()\n}\n//NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\n//TODO\n//7#1,3:26\n//10#1,6:30 - could be merged in one big interval due preprocessing of inline function\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,24:1\n7#1,3:26\n10#1,6:30\n7#2:25\n7#2:29\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n20#1,3:26\n20#1,6:30\n9#1:25\n20#1:29\n*E\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt$test$1$1\n*L\n1#1,24:1\n*E\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt$test$1$1\n*L\n1#1,24:1\n*E\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return init()\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n\ninline fun test(): String {\n    var res = \"Fail\"\n\n    call {\n        object {\n            fun run () {\n                res = \"OK\"\n            }\n        }.run()\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    return test()\n}\n//NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\n//7#1,3:28\n//10#1,8:32 - could be merged in one big interval due preprocessing of inline function\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,26:1\n7#1,3:28\n10#1,8:32\n7#2:27\n7#2:31\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n22#1,3:28\n22#1,8:32\n9#1:27\n22#1:31\n*E\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt$test$1$1\n*L\n1#1,26:1\n*E\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt$test$1$1\n*L\n1#1,26:1\n*E\n"
        },
        {
            "code": "//FILE: 1.kt\n\n\npackage test\ninline fun annotatedWith2(crossinline predicate: () -> Boolean) =\n        { any { predicate() } }()\n\n\ninline fun annotatedWith(crossinline predicate: () -> Boolean) =\n        annotatedWith2 { predicate() }\n\n\ninline fun any(s: () -> Boolean) {\n    s()\n}\n\n\n//FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n\n    annotatedWith { result = \"OK\"; true }\n\n    return result\n}\n\n\ninline fun test(z: () -> Unit) {\n    z()\n}\n\n\n// FILE: 2.smap\n//*L\n//1#1,15:1\n//17#1:19\n\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,18:1\n10#2:19\n6#2:20\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n7#1:19\n7#1:20\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$annotatedWith2$1\n+ 2 1.kt\ntest/_1Kt\n+ 3 2.kt\n_2Kt\n*L\n1#1,18:1\n14#2,2:19\n10#2:21\n7#3:22\n*E"
        },
        {
            "code": "// FILE: 1.kt\n\n\npackage builders\n//TODO there is a bug in asm it's skips linenumber on same line on reading bytecode\ninline fun call(crossinline init: () -> Unit) {\n    \"1\"; return init()\n}\n\ninline fun test(crossinline p: () -> String): String {\n    var res = \"Fail\"\n\n    call {\n        object {\n            fun run () {\n                res = p()\n            }\n        }.run()\n    }\n\n    return res\n}\n//TODO SHOULD BE LESS\n\n// FILE: 2.kt\n\nimport builders.*\n\n\nfun box(): String {\n    return test{\"OK\"}\n}\n//NO_CHECK_LAMBDA_INLINING\n\n//TODO\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return init()\n}\n\ninline fun test(): String {\n    var res = \"Fail\"\n\n    call {\n        object {\n            fun run () {\n                res = \"OK\"\n            }\n        }.run()\n    }\n\n    return res\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n\nfun box(): String {\n    return test()\n}\n//NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.sxmap\n\n//TODO SHOULD BE LESS\n\nSXMAP\nobjectOnInlineCallSite2.2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 objectOnInlineCallSite2.2.kt\nbuilders/BuildersPackage\n*L\n1#1,42:1\n*E\n\nSXMAP\nobjectOnInlineCallSite2.2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 objectOnInlineCallSite2.2.kt\nbuilders/BuildersPackage$objectOnInlineCallSite2_2$HASH$test$1$1\n*L\n1#1,42:1\n*E\n\n// FILE: 2.sxmap\n\nSXMAP\nobjectOnInlineCallSite2.1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 objectOnInlineCallSite2.1.kt\n_DefaultPackage\n+ 2 objectOnInlineCallSite2.2.kt\nbuilders/BuildersPackage\n*L\n1#1,32:1\n8#2,11:33\n*E\n\nSXMAP\nobjectOnInlineCallSite2.2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 objectOnInlineCallSite2.2.kt\nbuilders/BuildersPackage$objectOnInlineCallSite2_2$HASH$test$1$1\n*L\n1#1,42:1\n*E\n"
        },
        {
            "code": "\n// FILE: 1.kt\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return {\n        init()\n    }()\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n//NO_CHECK_LAMBDA_INLINING\nfun test(): String {\n    var res = \"Fail\"\n\n    call {\n        res = \"OK\"\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    return test()\n}\n\n// FILE: 1.smap\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\nbuilders/_1Kt$call$1\n*L\n1#1,12:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,21:1\n7#2:22\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n9#1:22\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\nbuilders/_1Kt$call$1\n+ 2 2.kt\n_2Kt\n*L\n1#1,12:1\n10#2,2:13\n*E\n"
        },
        {
            "code": "\n// FILE: 1.kt\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return init()\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n\nfun test(): String {\n    var res = \"Fail\"\n\n    call {\n        object {\n            fun run () {\n                res = \"OK\"\n            }\n        }.run()\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    return test()\n}\n//NO_CHECK_LAMBDA_INLINING\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\n//SMAP\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,26:1\n7#2:27\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n9#1:27\n*E"
        },
        {
            "code": "// FILE: 1.kt\n\n\npackage test\nabstract class Introspector {\n    abstract inner class SchemaRetriever(val transaction: String) {\n        inline fun inSchema(crossinline modifier: (String) -> Unit) =\n                { modifier.invoke(transaction) }()\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\nvar result = \"fail\"\n\nclass IntrospectorImpl() : Introspector() {\n    inner class SchemaRetriever(transaction: String) : Introspector.SchemaRetriever(transaction) {\n        internal fun retrieve() {\n            inSchema { schema -> result = schema }\n        }\n    }\n}\n\nfun box(): String {\n    IntrospectorImpl().SchemaRetriever(\"OK\").retrieve()\n\n    return result\n}\n\n\n// FILE: 1.smap\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/Introspector$SchemaRetriever$inSchema$1\n*L\n1#1,12:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\nIntrospectorImpl$SchemaRetriever\n+ 2 1.kt\ntest/Introspector$SchemaRetriever\n*L\n1#1,21:1\n8#2:22\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\nIntrospectorImpl$SchemaRetriever\n*L\n9#1:22\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/Introspector$SchemaRetriever$inSchema$1\n+ 2 2.kt\nIntrospectorImpl$SchemaRetriever\n*L\n1#1,12:1\n9#2:13\n*E"
        },
        {
            "code": "\n// FILE: 1.kt\n\npackage builders\n\ninline fun call(crossinline init: () -> Unit) {\n    return init()\n}\n//NO_CHECK_LAMBDA_INLINING\n\n// FILE: 2.kt\n\nimport builders.*\n\n\nfun test(): String {\n    var res = \"Fail\"\n\n    call {\n        {\n            res = \"OK\"\n        }()\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    return test()\n}\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,23:1\n7#2:24\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n9#1:24\n*E"
        },
        {
            "code": "\n// FILE: 1+ a.kt\n\npackage test\n\ninline fun inlineFun(lambda: () -> String): String {\n    return lambda()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return inlineFun { \"OK\" }\n}\n\n// FILE: 1+ a.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1+ a.kt\ntest/_1__aKt\n*L\n1#1,8:1\n7#2:9\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1:9\n*E"
        },
        {
            "code": "\n// FILE: 1.kt\n\npackage zzz\n\ninline fun nothing() {}\n\n// FILE: 2.kt\n\nfun box(): String {\n    return test {\n        \"K\"\n    }\n}\n\ninline fun test(p: () -> String): String {\n    var pd = \"\"\n    pd = \"O\"\n    return pd + p()\n}\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\n//TODO should be empty\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n*L\n1#1,15:1\n10#1,3:16\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n4#1,3:16\n*E\n"
        },
        {
            "code": "\n// FILE: 1+a.kt\n\npackage test\n\ninline fun inlineFun(lambda: () -> String): String {\n    return lambda()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return inlineFun { \"OK\" }\n}\n\n// FILE: 1+a.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1+a.kt\ntest/_1_aKt\n*L\n1#1,8:1\n7#2:9\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1:9\n*E"
        },
        {
            "code": "// FILE: 1.kt\n\nclass A {\n    inline fun foo() {}\n}\n\n// FILE: 2.kt\n\nfun box(): String {\n    A().foo()\n\n    return \"OK\"\n}\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nA\n*L\n1#1,9:1\n4#2:10\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n4#1:10\n*E"
        },
        {
            "code": "\n// FILE: + a.kt\n\npackage test\n\ninline fun inlineFun(lambda: () -> String): String {\n    return lambda()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return inlineFun { \"OK\" }\n}\n\n// FILE: + a.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 + a.kt\ntest/__aKt\n*L\n1#1,8:1\n7#2:9\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1:9\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n\npackage test\n\npublic val MASSERTIONS_ENABLED: Boolean = true\n\npublic inline fun massert(value: Boolean, lazyMessage: () -> String) {\n    if (MASSERTIONS_ENABLED) {\n        if (!value) {\n            val message = lazyMessage()\n            throw AssertionError(message)\n        }\n    }\n}\n\n\npublic inline fun massert(value: Boolean, message: Any = \"Assertion failed\") {\n    if (MASSERTIONS_ENABLED) {\n        if (!value) {\n            throw AssertionError(message)\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    massert(true)\n    massert(true) {\n        \"test\"\n    }\n\n    return \"OK\"\n}\n\n// FILE: 1.smap\n//TODO maybe do smth with default method body mapping\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,26:1\n19#1,6:27\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,14:1\n18#2,7:15\n9#2,7:22\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n6#1,7:15\n7#1,7:22\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\ninline fun kValue(crossinline s: () -> String) = { s() + \"K\" }()\n\ninline fun lParams(initParams: () -> String = {\n    { \"\" + kValue { \"O\" } }()\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return lParams()\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n35#1,2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,39:1\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n30#2:40\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1$1\n*L\n33#1:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n+ 2 1.kt\ntest/_1Kt$lParams$1$1\n*L\n1#1,39:1\n33#2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n*L\n1#1,39:1\n*E\n\n// FILE: 2.smap-nonseparate-compilation\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,8:1\n32#2,5:9\n33#3:14\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:9\n5#1:14\n*E\n\n// FILE: 2.smap-separate-compilation\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,8:1\n32#2,5:9\n33#3:14\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:9\n5#1:14\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n30#2:40\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1$1\n*L\n33#1:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n+ 2 1.kt\ntest/_1Kt$lParams$1$1\n*L\n1#1,39:1\n33#2:40\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n\n\npackage test\ninline fun inlineFun(capturedParam: String, lambda: () -> String = { capturedParam }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}\n\n// FILE: 1.smap\n//TODO maybe do smth with default method body mapping\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,11:1\n8#1:12\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$inlineFun$1\n*L\n1#1,11:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$inlineFun$1\n*L\n1#1,9:1\n7#2,2:10\n7#3:12\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n6#1,2:10\n6#1:12\n*E\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\ninline fun kValue() = \"K\"\n\ninline fun lParams(initParams: () -> String = {\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    \"O\" + kValue()\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n    //A lot of blank lines [Don't delete]\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return run {\n        lParams()\n    }\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,75:1\n71#1,2:76\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,75:1\n30#2:76\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n51#1:76\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,10:1\n32#2:11\n71#2,2:12\n30#2:15\n51#3:14\n69#3:16\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1:11\n5#1,2:12\n5#1:15\n5#1:14\n5#1:16\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n\n\npackage test\ninline fun inlineFun(capturedParam: String, crossinline lambda: () -> String = { capturedParam }): String {\n    return {\n        lambda()\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}\n\n// FILE: 1.smap\n//TODO maybe do smth with default method body mapping\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,13:1\n8#1:14\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$inlineFun$2\n*L\n1#1,13:1\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$inlineFun$1\n*L\n1#1,13:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,9:1\n7#2,2:10\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n6#1,2:10\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$inlineFun$2\n+ 2 1.kt\ntest/_1Kt$inlineFun$1\n*L\n1#1,13:1\n7#2:14\n*E\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\n\ninline fun lParams(initParams: () -> String = {\n    \"OK\"\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return run {\n        lParams()\n    }\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,38:1\n34#1,2:39\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,38:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,10:1\n31#2,5:11\n32#3:16\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:11\n5#1:16\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\ninline fun kValue(crossinline s: () -> String) = { s() + \"K\" }()\n\ninline fun lParams(initParams: () -> String = {\n    \"\" + kValue { \"O\" }\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return lParams()\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n35#1,2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n30#2:40\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n33#1:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n+ 2 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,39:1\n33#2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n*L\n1#1,39:1\n*E\n\n// FILE: 2.smap-nonseparate-compilation\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,8:1\n32#2,5:9\n30#2:15\n33#3:14\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:9\n5#1:15\n5#1:14\n*E\n\n// FILE: 2.smap-separate-compilation\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,8:1\n32#2,5:9\n30#2:15\n33#3:14\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:9\n5#1:15\n5#1:14\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n+ 2 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,39:1\n33#2:40\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\ninline fun kValue() = \"K\"\n\ninline fun lParams(initParams: () -> String = {\n    \"O\" + kValue()\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return run {\n        lParams()\n    }\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n35#1,2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n30#2:40\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n33#1:40\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,10:1\n32#2,5:11\n30#2:17\n33#3:16\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:11\n5#1:17\n5#1:16\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\n\ninline fun lParams(initParams: () -> String = {\n    \"OK\"\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return lParams()\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,38:1\n34#1,2:39\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,38:1\n*E\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,8:1\n31#2,5:9\n32#3:14\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:9\n5#1:14\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\n\npackage test\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\ninline fun kValue(crossinline s: () -> String) = { s() + \"K\" }()\n\ninline fun lParams(initParams: () -> String = {\n    \"\" + kValue { \"O\" }\n}): String {\n    val z = \"body\"\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return run {\n        lParams()\n    }\n}\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n35#1,2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,39:1\n30#2:40\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$lParams$1\n*L\n33#1:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n+ 2 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,39:1\n33#2:40\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n*L\n1#1,39:1\n*E\n\n// FILE: 2.smap-nonseparate-compilation\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,10:1\n32#2,5:11\n30#2:17\n33#3:16\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:11\n5#1:17\n5#1:16\n*E\n\n// FILE: 2.smap-separate-compilation\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n+ 3 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,10:1\n32#2,5:11\n30#2:17\n33#3:16\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n5#1,5:11\n5#1:17\n5#1:16\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$kValue$1\n+ 2 1.kt\ntest/_1Kt$lParams$1\n*L\n1#1,39:1\n33#2:40\n*E"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninline fun <reified T : Any> className() =  T::class.java.simpleName\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val z = className<String>()\n    if (z != \"String\") return \"fail: $z\"\n\n    return \"OK\"\n}\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,12:1\n6#2:13\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n6#1:13\n*E"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\ninline fun stub() {\n\n}\n\n// FILE: 2.kt\n\nfun box(): String {\n    return \"KO\".reversed()\n}\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n*L\n1#1,7:1\n*E\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n\npackage test\ninline fun stub() {\n\n}\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.InlineOnly\ninline val prop: String\n    get() = \"OK\"\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return prop\n}\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n*L\n1#1,8:1\n*E\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\n\npackage test\ninline val <reified T : Any> T.className: String; get() = T::class.java.simpleName\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val z = \"OK\".className\n    if (z != \"String\") return \"fail: $z\"\n\n    return \"OK\"\n}\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,12:1\n6#2:13\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n6#1:13\n*E"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n\npackage test\ninline fun inlineFun(capturedParam: String, noinline lambda: () -> String = { capturedParam }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}\n\n// FILE: 1.smap\n//TODO maybe do smth with default method body mapping\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt\n*L\n1#1,9:1\n6#1:10\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$inlineFun$1\n*L\n1#1,9:1\n*E\n\n// FILE: 2.TODO"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n\npackage builders\n\ninline fun init(init: () -> Unit) {\n    init()\n}\n\ninline fun initTag2(init: () -> Unit) {\n    val p = 1;\n    init()\n}\n//{val p = initTag2(init); return p} to remove difference in linenumber processing through MethodNode and MethodVisitor should be: = initTag2(init)\ninline fun head(init: () -> Unit) { val p = initTag2(init); return p}\n\n\ninline fun html(init: () -> Unit) {\n    return init(init)\n}\n\n// FILE: 2.kt\n\nimport builders.*\n\n\ninline fun test(): String {\n    var res = \"Fail\"\n\n    html {\n        head {\n            res = \"OK\"\n        }\n    }\n\n    return res\n}\n\n\nfun box(): String {\n    var expected = test();\n\n    return expected\n}\n\n// FILE: 1.smap\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\nbuilders/_1Kt\n*L\n1#1,22:1\n11#1,3:23\n7#1,2:26\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\nbuilders/_1Kt\n*L\n15#1,3:23\n19#1,2:26\n*E\n\n// FILE: 2.smap\n\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\nbuilders/_1Kt\n*L\n1#1,25:1\n7#1,3:40\n10#1:45\n11#1,2:49\n13#1:52\n15#1:54\n19#2:26\n7#2,9:27\n11#2,3:36\n8#2:39\n19#2:43\n7#2:44\n15#2:46\n11#2,2:47\n13#2:51\n8#2:53\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n20#1,3:40\n20#1:45\n20#1,2:49\n20#1:52\n20#1:54\n9#1:26\n9#1,9:27\n9#1,3:36\n9#1:39\n20#1:43\n20#1:44\n20#1:46\n20#1,2:47\n20#1:51\n20#1:53\n*E"
        },
        {
            "code": "\n// FILE: 1.kt\n\npackage test\n\ninline fun test(s: () -> Unit) {\n    val z = 1;\n    s()\n    val x = 1;\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    test {\n        result = \"O\"\n    }\n\n    test {\n        result += \"K\"\n    }\n\n    return result\n}\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,18:1\n7#2,4:19\n7#2,4:23\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n7#1,4:19\n11#1,4:23\n*E"
        },
        {
            "code": "\n// FILE: 1.kt\n\npackage test\n\ninline fun myrun(s: () -> Unit) {\n    val z = \"myrun\"\n    s()\n}\n\ninline fun test(crossinline s: () -> Unit) {\n    {\n        val z = 1;\n        myrun(s)\n        val x = 1;\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n\n    test {\n        result = \"OK\"\n    }\n\n    return result\n}\n\n\n// FILE: 1.smap\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$test$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,19:1\n7#2,3:20\n*E\n*S KotlinDebug\n*F\n+ 1 1.kt\ntest/_1Kt$test$1\n*L\n14#1,3:20\n*E\n\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,16:1\n12#2,6:17\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n8#1,6:17\n*E\n\nSMAP\n1.kt\nKotlin\n*S Kotlin\n*F\n+ 1 1.kt\ntest/_1Kt$test$1\n+ 2 1.kt\ntest/_1Kt\n+ 3 2.kt\n_2Kt\n*L\n1#1,19:1\n7#2,3:20\n9#3,2:23\n*E\n"
        },
        {
            "code": "\n// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun test(s: () -> Unit) {\n    val z = 1;\n    s()\n    val x = 1;\n}\n\n// FILE: 2.kt\n\nimport test.*\n\ninline fun test2(s: () -> String): String {\n    val z = 1;\n    val res = s()\n    return res\n}\n\nfun box(): String {\n    var result = \"fail\"\n\n    test {\n        {\n            result = test2 {\n                \"OK\"\n            }\n        }()\n    }\n\n    return result\n}\n\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,26:1\n7#2,4:27\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n14#1,4:27\n*E\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt$box$1$1\n+ 2 2.kt\n_2Kt\n*L\n1#1,26:1\n6#2,3:27\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt$box$1$1\n*L\n16#1,3:27\n*E"
        },
        {
            "code": "\n// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun test(s: () -> Unit) {\n    val z = 1;\n    s()\n    val x = 1;\n}\n\ninline fun test2(s: () -> String): String {\n    val z = 1;\n    val res = s()\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n\n    test {\n        {\n            result = test2 {\n                \"OK\"\n            }\n        }()\n    }\n\n    return result\n}\n\n\n// FILE: 1.smap\n\n// FILE: 2.smap\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,20:1\n7#2,4:21\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt\n*L\n8#1,4:21\n*E\n\nSMAP\n2.kt\nKotlin\n*S Kotlin\n*F\n+ 1 2.kt\n_2Kt$box$1$1\n+ 2 1.kt\ntest/_1Kt\n*L\n1#1,20:1\n13#2,3:21\n*E\n*S KotlinDebug\n*F\n+ 1 2.kt\n_2Kt$box$1$1\n*L\n10#1,3:21\n*E"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(t: Any?, p: KProperty<*>): String = \"O\"\n}\n\ninline fun test(crossinline s: () -> String): String {\n    val delegate = Delegate()\n    val o = object {\n        fun run(): String {\n            val prop: String by delegate\n            return prop + s()\n        }\n    }\n    return o.run()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test { \"K\" }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\n\ninline fun <T> mrun(lambda: () -> T): T = lambda()\n\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nobject Whatever {\n    operator fun getValue(thisRef: Any?, prop: Any?) = \"OK\"\n}\n\nfun box(): String {\n    val key by Whatever\n    return mrun {\n        object {\n            val keys = key\n        }.keys\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(t: Any?, p: KProperty<*>): String = \"OK\"\n}\n\ninline fun test(): String {\n    val b by Delegate()\n\n    return run {\n        b\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(t: Any?, p: KProperty<*>): String = \"OK\"\n}\n\ninline fun test(): String {\n    val prop: String by Delegate()\n    return prop\n}\n\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun inlineFun(vararg constraints: String, receiver: String = \"O\", init: String.() -> String): String {\n    return receiver.init()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun {\n        this + \"K\"\n    }\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n\npackage test\ninline fun inlineFun(vararg constraints: String, receiver: String = \"K\", init: String.() -> String): String {\n    return (constraints.joinToString() + receiver).init()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"O\") {\n        this\n    }\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun inlineFun(vararg constraints: String, init: String.() -> String): String {\n    return \"O\".init()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun {\n        this + \"K\"\n    }\n}\n\n"
        },
        {
            "code": "// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// FULL_JDK\n\npackage test\n\ninline fun inlineMe() {\n    assert(false) { \"FROM INLINED\" }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.*\n\nclass CheckerJvmAssertInlineFunctionAssertionsEnabled {\n    fun check() {\n        inlineMe()\n        throw RuntimeException(\"FAIL 0\")\n    }\n}\n\nclass Dummy\n\nfun enableAssertions(): CheckerJvmAssertInlineFunctionAssertionsEnabled {\n    val loader = Dummy::class.java.classLoader\n    loader.setClassAssertionStatus(\"CheckerJvmAssertInlineFunctionAssertionsEnabled\", true)\n    loader.setClassAssertionStatus(\"InlineKt\", false)\n    val c = loader.loadClass(\"CheckerJvmAssertInlineFunctionAssertionsEnabled\")\n    return c.newInstance() as CheckerJvmAssertInlineFunctionAssertionsEnabled\n}\n\nfun box(): String {\n    var c = enableAssertions()\n    try {\n        c.check()\n        return \"FAIL 2\"\n    } catch (ignore: AssertionError) {}\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\n\npackage test\n\nobject CrossinlineLambdaContainer {\n    inline fun call(b: Boolean, crossinline c: () -> Unit) {\n        val l = {\n            assert(b) { \"FROM INLINED\" }\n            c()\n        }\n        l()\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.CrossinlineLambdaContainer.call\n\ninterface Checker {\n    fun checkTrueTrue(): Boolean\n    fun checkTrueFalse(): Boolean\n    fun checkFalseTrue(): Boolean\n    fun checkFalseFalse(): Boolean\n    fun checkTrueWithMessageTrue(): Boolean\n    fun checkTrueWithMessageFalse(): Boolean\n    fun checkFalseWithMessageTrue(): Boolean\n    fun checkFalseWithMessageFalse(): Boolean\n}\n\nclass ShouldBeDisabled : Checker {\n    override fun checkTrueTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nclass ShouldBeEnabled : Checker {\n    override fun checkTrueTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nfun setDesiredAssertionStatus(v: Boolean): Checker {\n    val loader = Checker::class.java.classLoader\n    loader.setDefaultAssertionStatus(false)\n    loader.setPackageAssertionStatus(\"test\", v)\n    val c = loader.loadClass(if (v) \"ShouldBeEnabled\" else \"ShouldBeDisabled\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = setDesiredAssertionStatus(false)\n    if (c.checkTrueTrue()) return \"FAIL 00\"\n    if (c.checkTrueFalse()) return \"FAIL 01\"\n    if (c.checkTrueWithMessageTrue()) return \"FAIL 10\"\n    if (c.checkTrueWithMessageFalse()) return \"FAIL 11\"\n    if (c.checkFalseTrue()) return \"FAIL 20\"\n    if (c.checkFalseFalse()) return \"FAIL 21\"\n    if (c.checkFalseWithMessageTrue()) return \"FAIL 30\"\n    if (c.checkFalseWithMessageFalse()) return \"FAIL 31\"\n\n    c = setDesiredAssertionStatus(true)\n    if (c.checkTrueTrue()) return \"FAIL 100\"\n    if (c.checkTrueFalse()) return \"FAIL 101\"\n    if (c.checkTrueWithMessageTrue()) return \"FAIL 110\"\n    if (c.checkTrueWithMessageFalse()) return \"FAIL 111\"\n    if (c.checkFalseTrue()) return \"FAIL 120\"\n    if (c.checkFalseFalse()) return \"FAIL 121\"\n    if (c.checkFalseWithMessageTrue()) return \"FAIL 130\"\n    if (c.checkFalseWithMessageFalse()) return \"FAIL 131\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// FULL_JDK\npackage test\n\nclass A {\n    inline fun a() {\n        assert(false) { \"from inlined\" }\n    }\n}\n\nclass B {\n    inline fun b() {\n        A().a()\n        error(\"FAIL 0\")\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\nimport test.*\n\nclass Checker {\n    fun check() {\n        B().b()\n        error(\"FAIL 1\")\n    }\n}\n\nclass Dummy\n\nfun enableAssertions(): Checker {\n    val loader = Dummy::class.java.classLoader\n    loader.setDefaultAssertionStatus(true)\n    val c = loader.loadClass(\"Checker\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = enableAssertions()\n    try {\n        c.check()\n        return \"FAIL 2\"\n    } catch (ignore: AssertionError) {}\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\n\npackage test\n\nobject CrossinlineLambdaContainer {\n    inline fun call(crossinline c: () -> Boolean) {\n        Runnable { assert(c()) }.run()\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.CrossinlineLambdaContainer.call\n\ninterface Checker {\n    fun checkTrue(): Boolean\n    fun checkFalse(): Boolean\n}\n\nclass ShouldBeDisabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        call { hit = true; true }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        call { hit = true; false }\n        return hit\n    }\n}\n\nclass ShouldBeEnabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        call { hit = true; true }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        call { hit = true; false }\n        return hit\n    }\n}\n\nfun setDesiredAssertionStatus(v: Boolean): Checker {\n    val loader = Checker::class.java.classLoader\n    loader.setDefaultAssertionStatus(v)\n    val c = loader.loadClass(if (v) \"ShouldBeEnabled\" else \"ShouldBeDisabled\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = setDesiredAssertionStatus(false)\n    if (c.checkTrue()) return \"FAIL 0\"\n    if (c.checkFalse()) return \"FAIL 2\"\n    c = setDesiredAssertionStatus(true)\n    if (!c.checkTrue()) return \"FAIL 4\"\n    try {\n        c.checkFalse()\n        return \"FAIL 6\"\n    } catch (ignore: AssertionError) {\n    }\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\n\npackage test\n\nobject CrossinlineLambdaContainer {\n    inline fun call(crossinline c: () -> Unit) {\n        val l = { c() }\n        l()\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.CrossinlineLambdaContainer.call\n\ninterface Checker {\n    fun checkTrue(): Boolean\n    fun checkFalse(): Boolean\n    fun checkTrueWithMessage(): Boolean\n    fun checkFalseWithMessage(): Boolean\n}\n\nclass ShouldBeDisabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nclass ShouldBeEnabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nfun setDesiredAssertionStatus(v: Boolean): Checker {\n    val loader = Checker::class.java.classLoader\n    loader.setDefaultAssertionStatus(v)\n    val c = loader.loadClass(if (v) \"ShouldBeEnabled\" else \"ShouldBeDisabled\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = setDesiredAssertionStatus(false)\n    if (c.checkTrue()) return \"FAIL 0\"\n    if (c.checkTrueWithMessage()) return \"FAIL 1\"\n    if (c.checkFalse()) return \"FAIL 2\"\n    if (c.checkFalseWithMessage()) return \"FAIL 3\"\n    c = setDesiredAssertionStatus(true)\n    if (!c.checkTrue()) return \"FAIL 4\"\n    if (!c.checkTrueWithMessage()) return \"FAIL 5\"\n    try {\n        c.checkFalse()\n        return \"FAIL 6\"\n    } catch (ignore: AssertionError) {\n    }\n    try {\n        c.checkFalseWithMessage()\n        return \"FAIL 7\"\n    } catch (ignore: AssertionError) {\n    }\n\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// FULL_JDK\npackage test\n\nclass A {\n    inline fun doAssert() {\n        assert(false)\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\nimport test.*\n\nclass B {\n    companion object {\n        @JvmField\n        val triggered: Boolean = try {\n            A().doAssert()\n            false\n        } catch (e: AssertionError) {\n            true\n        }\n    }\n}\n\nclass Dummy\n\nfun box(): String {\n    val loader = Dummy::class.java.classLoader\n    loader.setDefaultAssertionStatus(false)\n    return if (loader.loadClass(\"B\").getField(\"triggered\").get(null) == true)\n        \"FAIL: assertion triggered\"\n    else\n        \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\n\npackage test\n\nobject CrossinlineLambdaContainer {\n    inline fun call(b: Boolean, crossinline c: () -> Unit) {\n        val l = {\n            assert(b) { \"FROM INLINED\" }\n            c()\n        }\n        l()\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.CrossinlineLambdaContainer.call\n\ninterface Checker {\n    fun checkTrueTrue(): Boolean\n    fun checkTrueFalse(): Boolean\n    fun checkFalseTrue(): Boolean\n    fun checkFalseFalse(): Boolean\n    fun checkTrueWithMessageTrue(): Boolean\n    fun checkTrueWithMessageFalse(): Boolean\n    fun checkFalseWithMessageTrue(): Boolean\n    fun checkFalseWithMessageFalse(): Boolean\n}\n\nclass ShouldBeDisabled : Checker {\n    override fun checkTrueTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nclass ShouldBeEnabled : Checker {\n    override fun checkTrueTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalseFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(true) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessageFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call(false) {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nfun setDesiredAssertionStatus(v: Boolean): Checker {\n    val loader = Checker::class.java.classLoader\n    loader.setDefaultAssertionStatus(v)\n    val c = loader.loadClass(if (v) \"ShouldBeEnabled\" else \"ShouldBeDisabled\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = setDesiredAssertionStatus(false)\n    if (c.checkTrueTrue()) return \"FAIL 00\"\n    if (c.checkTrueFalse()) return \"FAIL 01\"\n    if (c.checkTrueWithMessageTrue()) return \"FAIL 10\"\n    if (c.checkTrueWithMessageFalse()) return \"FAIL 11\"\n    if (c.checkFalseTrue()) return \"FAIL 20\"\n    if (c.checkFalseFalse()) return \"FAIL 21\"\n    if (c.checkFalseWithMessageTrue()) return \"FAIL 30\"\n    if (c.checkFalseWithMessageFalse()) return \"FAIL 31\"\n\n    c = setDesiredAssertionStatus(true)\n    if (!c.checkTrueTrue()) return \"FAIL 40\"\n    try {\n        c.checkTrueFalse()\n        return \"FAIL 41\"\n    } catch (ignore: AssertionError) {\n    }\n    if (!c.checkTrueWithMessageTrue()) return \"FAIL 50\"\n    try {\n        c.checkTrueWithMessageFalse()\n        return \"FAIL 51\"\n    } catch (ignore: AssertionError) {\n    }\n    try {\n        c.checkFalseTrue()\n        return \"FAIL 60\"\n    } catch (ignore: AssertionError) {\n    }\n    try {\n        c.checkFalseFalse()\n        return \"FAIL 61\"\n    } catch (ignore: AssertionError) {\n    }\n    try {\n        c.checkFalseWithMessageTrue()\n        return \"FAIL 70\"\n    } catch (ignore: AssertionError) {\n    }\n    try {\n        c.checkFalseWithMessageFalse()\n        return \"FAIL 71\"\n    } catch (ignore: AssertionError) {\n    }\n\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\n\npackage test\n\ninline fun call(c: () -> Unit) {\n    c()\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.*\n\ninterface Checker {\n    fun checkTrue(): Boolean\n    fun checkFalse(): Boolean\n    fun checkTrueWithMessage(): Boolean\n    fun checkFalseWithMessage(): Boolean\n}\n\nclass ShouldBeDisabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nclass ShouldBeEnabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l())\n        }\n        return hit\n    }\n\n    override fun checkTrueWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; true }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n\n    override fun checkFalseWithMessage(): Boolean {\n        var hit = false\n        val l = { hit = true; false }\n        call {\n            assert(l()) { \"BOOYA\" }\n        }\n        return hit\n    }\n}\n\nfun setDesiredAssertionStatus(v: Boolean): Checker {\n    val loader = Checker::class.java.classLoader\n    loader.setClassAssertionStatus(\"ShouldBeEnabled\", true)\n    loader.setClassAssertionStatus(\"ShouldBeDisabled\", false)\n    val c = loader.loadClass(if (v) \"ShouldBeEnabled\" else \"ShouldBeDisabled\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = setDesiredAssertionStatus(false)\n    if (c.checkTrue()) return \"FAIL 0\"\n    if (c.checkTrueWithMessage()) return \"FAIL 1\"\n    if (c.checkFalse()) return \"FAIL 2\"\n    if (c.checkFalseWithMessage()) return \"FAIL 3\"\n    c = setDesiredAssertionStatus(true)\n    if (!c.checkTrue()) return \"FAIL 4\"\n    if (!c.checkTrueWithMessage()) return \"FAIL 5\"\n    try {\n        c.checkFalse()\n        return \"FAIL 6\"\n    } catch (ignore: AssertionError) {\n    }\n    try {\n        c.checkFalseWithMessage()\n        return \"FAIL 7\"\n    } catch (ignore: AssertionError) {\n    }\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// FULL_JDK\npackage test\n\nvar result = \"OK\"\n\nclass State {\n\n    companion object {\n        inline fun inlineMe() {\n            assert(false) { \"FROM INLINED\" }\n        }\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\nimport test.*\n\nclass CheckerJvmAssertInlineFunctionAssertionsEnabled {\n    fun check() {\n        State.inlineMe()\n        throw RuntimeException(\"FAIL 0\")\n    }\n}\n\nclass Dummy\n\nfun enableAssertions(): CheckerJvmAssertInlineFunctionAssertionsEnabled {\n    val loader = Dummy::class.java.classLoader\n    loader.setDefaultAssertionStatus(true)\n    val c = loader.loadClass(\"CheckerJvmAssertInlineFunctionAssertionsEnabled\")\n    return c.newInstance() as CheckerJvmAssertInlineFunctionAssertionsEnabled\n}\n\nfun box(): String {\n    var c = enableAssertions()\n    try {\n        c.check()\n        return \"FAIL 2\"\n    } catch (ignore: AssertionError) {}\n    return result\n}\n"
        },
        {
            "code": "// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// FULL_JDK\n// TARGET_BACKEND: JVM\n\npackage test\n\ninline fun inlineMe() {\n    assert(false) { \"FROM INLINED\" }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.*\n\nclass CheckerJvmAssertInlineFunctionAssertionsDisabled {\n    fun check() {\n        inlineMe()\n        assert(false) { \"FROM INLINESITE\" }\n    }\n}\n\nclass Dummy\n\nfun disableAssertions(): CheckerJvmAssertInlineFunctionAssertionsDisabled {\n    val loader = Dummy::class.java.classLoader\n    loader.setClassAssertionStatus(\"CheckerJvmAssertInlineFunctionAssertionsDisabled\", false)\n    loader.setClassAssertionStatus(\"InlineKt\", false)\n    val c = loader.loadClass(\"CheckerJvmAssertInlineFunctionAssertionsDisabled\")\n    return c.newInstance() as CheckerJvmAssertInlineFunctionAssertionsDisabled\n}\n\nfun box(): String {\n    var c = disableAssertions()\n    c.check()\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: inline.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\n\npackage test\n\nobject CrossinlineLambdaContainer {\n    inline fun call(crossinline c: () -> Boolean) {\n        val l = { assert(c()) }\n        l()\n    }\n}\n\n// FILE: inlineSite.kt\n// KOTLIN_CONFIGURATION_FLAGS: ASSERTIONS_MODE=jvm\n\nimport test.CrossinlineLambdaContainer.call\n\ninterface Checker {\n    fun checkTrue(): Boolean\n    fun checkFalse(): Boolean\n}\n\nclass ShouldBeDisabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        call { hit = true; true }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        call { hit = true; false }\n        return hit\n    }\n}\n\nclass ShouldBeEnabled : Checker {\n    override fun checkTrue(): Boolean {\n        var hit = false\n        call { hit = true; true }\n        return hit\n    }\n\n    override fun checkFalse(): Boolean {\n        var hit = false\n        call { hit = true; false }\n        return hit\n    }\n}\n\nfun setDesiredAssertionStatus(v: Boolean): Checker {\n    val loader = Checker::class.java.classLoader\n    loader.setDefaultAssertionStatus(v)\n    val c = loader.loadClass(if (v) \"ShouldBeEnabled\" else \"ShouldBeDisabled\")\n    return c.newInstance() as Checker\n}\n\nfun box(): String {\n    var c = setDesiredAssertionStatus(false)\n    if (c.checkTrue()) return \"FAIL 0\"\n    if (c.checkFalse()) return \"FAIL 2\"\n    c = setDesiredAssertionStatus(true)\n    if (!c.checkTrue()) return \"FAIL 4\"\n    try {\n        c.checkFalse()\n        return \"FAIL 6\"\n    } catch (ignore: AssertionError) {\n    }\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\ninline fun <R> call(crossinline f: () -> R) : R {\n    return {f()} ()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun sameName(s: Long): Long {\n    return call {\n        s\n    }\n}\n\nfun sameName(s: Int): Int {\n    return call {\n        s\n    }\n}\n\nfun box(): String {\n    val result = sameName(1.toLong())\n    if (result != 1.toLong()) return \"fail1: ${result}\"\n\n    val result2 = sameName(2)\n    if (result2 != 2) return \"fail2: ${result2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun <R> call(crossinline f: () -> R) : R {\n    return { f() }()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\ninline fun sameName(s: Long): String = call { \"FAIL\" }\ninline fun sameName(s: Int): String = call { \"OK\" }\n\nfun box(): String {\n    val result = sameName(1)\n    sameName(1L)\n    return result\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <R> mfun(f: () -> R) {\n    f()\n}\n\nfun noInline(suffix: String, l: (s: String) -> Unit)  {\n    l(suffix)\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\nimport java.util.*\n\nfun test1(prefix: String): String {\n    var result = \"fail\"\n    mfun {\n        noInline(\"start\") {\n            if (it.startsWith(prefix)) {\n                result = \"OK\"\n            }\n        }\n    }\n\n    return result\n}\n\nfun box(): String {\n    if (test1(\"start\") != \"OK\") return \"fail1\"\n    if (test1(\"nostart\") != \"fail\") return \"fail2\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\ninline fun <R> doWork(crossinline job: ()-> R) : R {\n    val k = 10;\n    return notInline({k; job()})\n}\n\ninline fun <R> doWork(crossinline job: ()-> R, crossinline job2: () -> R) : R {\n    val k = 10;\n    return notInline({k; job(); job2()})\n}\n\nfun <R> notInline(job: ()-> R) : R {\n    return job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun testSameCaptured() : String {\n    var result = 0;\n    result = doWork({result+=1; result}, {result += 11; result})\n    return if (result == 12) \"OK\" else \"fail ${result}\"\n}\n\ninline fun testSameCaptured(crossinline lambdaWithResultCaptured: () -> Unit) : String {\n    var result = 1;\n    result = doWork({result+=11; lambdaWithResultCaptured(); result})\n    return if (result == 12) \"OK\" else \"fail ${result}\"\n}\n\nfun box(): String {\n    if (testSameCaptured() != \"OK\") return \"test1 : ${testSameCaptured()}\"\n\n    var result = 0;\n    if (testSameCaptured{result += 1111} != \"OK\") return \"test2 : ${testSameCaptured{result = 1111}}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun concat(suffix: String, l: (s: String) -> Unit)  {\n    l(suffix)\n}\n\nfun <T> noInlineFun(arg: T, f: (T) -> Unit) {\n    f(arg)\n}\n\ninline fun doSmth(a: String): String {\n    return a.toString()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(param: String): String {\n    var result = \"fail1\"\n    noInlineFun(param) { a ->\n        concat(\"start\") {\n            result = doSmth(a).toString()\n        }\n    }\n\n    return result\n}\n\nfun test11(param: String): String {\n    var result = \"fail1\"\n    noInlineFun(\"stub\") { a ->\n        concat(\"start\") {\n            result = doSmth(param).toString()\n        }\n    }\n\n    return result\n}\n\ninline fun test2(crossinline param: () -> String): String {\n    var result = \"fail1\"\n    noInlineFun(\"stub\") { a ->\n        concat(param()) {\n            result = doSmth(param()).toString()\n        }\n    }\n\n    return result\n}\n\ninline fun test22(crossinline param: () -> String): String {\n    var result = \"fail1\"\n    {{result = param()}()}()\n\n    return result\n}\n\n\nfun box(): String {\n    if (test1(\"start\") != \"start\") return \"fail1: ${test1(\"start\")}\"\n    if (test1(\"nostart\") != \"nostart\") return \"fail2: ${test1(\"nostart\")}\"\n    if (test11(\"start\") != \"start\") return \"fail3: ${test11(\"start\")}\"\n\n    if (test2({\"start\"}) != \"start\") return \"fail4: ${test2({\"start\"})}\"\n    if (test22({\"start\"}) != \"start\") return \"fail5: ${test22({\"start\"})}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> doSmth(a: T) : String {\n    return {a.toString()}()\n}\n\ninline fun <T> doSmth2(a: T) : String {\n    return {{a.toString()}()}()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(s: Long): String {\n    return doSmth(s)\n}\n\nfun test2(s: Int): String {\n    return doSmth2(s)\n}\n\nfun box(): String {\n    var result = test1(11.toLong())\n    if (result != \"11\") return \"fail1: ${result}\"\n\n    result = test2(11)\n    if (result != \"11\") return \"fail2: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\ndata class Address(\n        val createdTimeMs: Long = 0,\n        val firstName: String = \"\",\n        val lastName: String = \"\"\n)\n\ninline fun String.switchIfEmpty(provider: () -> String): String {\n    return if (isEmpty()) provider() else this\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val address = Address()\n    val result = address.copy(\n            firstName = address.firstName.switchIfEmpty { \"O\" },\n            lastName = address.lastName.switchIfEmpty { \"K\" }\n    )\n\n    return result.firstName + result.lastName\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nvar value: Int = 0\n\ninline var Int.z: Int\n    get() = this + ++value\n    set(p: Int) { value = p + this}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    val v = 11.z\n    if (v != 12) return \"fail 1: $v\"\n\n    11.z = v + 2\n\n    if (value != 25) return \"fail 2: $value\"\n    var p = 11.z\n\n    if (p != 37)  return \"fail 3: $p\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// WITH_RUNTIME\n// WITH_REFLECT\n// FILE: 1.kt\npackage test\n\nvar bvalue: String = \"\"\n\ninline var <reified T : Any> T.value: String\n    get() = T::class.simpleName!! + bvalue\n    set(p: String) {\n        bvalue = p\n    }\n\n// FILE: 2.kt\nimport test.*\n\nclass O\n\nfun box(): String {\n    val o = O()\n    val value1 = o.value\n    if (value1 != \"O\") return \"fail 1: $value1\"\n\n    o.value = \"K\"\n    return o.value\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nvar result = 1\n\ninline var z: Int\n    get() = result\n    set(value)  {\n        result = value\n    }\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    z += 1\n    if (z != 2) return \"fail 1: $z\"\n\n    var p = z++\n    if (result != 3) return \"fail 2: $result\"\n    if (p != 2) return \"fail 3: $p\"\n\n    p = ++z\n    if (result != 4) return \"fail 4: $result\"\n    if (p != 4) return \"fail 5: $p\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nvar value: Int = 0\n\ninline var z: Int\n    get() = ++value\n    set(p: Int) { value = p }\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    val v = z\n    if (value != 1) return \"fail 1: $value\"\n\n    z = v + 2\n\n    if (value != 3) return \"fail 2: $value\"\n    var p = z\n\n    if (value != 4)  return \"fail 3: $value\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test(var result: Int)\n\nclass A {\n    var result = Test(1)\n\n    inline var z: Test\n        get() = result\n        set(value) {\n            result = value\n        }\n}\n\noperator fun Test.plus(p: Int): Test {\n    return Test(result + p)\n}\n\noperator fun Test.inc(): Test {\n    return Test(result + 1)\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    val a = A()\n    a.z = Test(1)\n    a.z += 1\n    if (a.result.result != 2) return \"fail 1: ${a.result.result}\"\n\n    var p = a.z++\n    if (a.result.result != 3) return \"fail 2: ${a.result.result}\"\n    if (p.result != 2) return \"fail 3: ${p.result}\"\n\n    p = ++a.z\n    if (a.result.result != 4) return \"fail 4: ${a.result.result}\"\n    if (p.result != 4) return \"fail 5: ${p.result}\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// WITH_RUNTIME\n// WITH_REFLECT\n// FILE: 1.kt\npackage test\n\ninline val <reified T: Any> T.value: String\n    get() = T::class.simpleName!!\n\n// FILE: 2.kt\nimport test.*\n\nclass OK\n\nfun box(): String {\n    return OK().value ?: \"fail\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass A {\n    var result = 1\n    \n    inline var z: Int\n        get() = result\n        set(value) {\n            result = value\n        }\n\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    val a = A()\n    a.z += 1\n    if (a.z != 2) return \"fail 1: $a.z\"\n\n    var p = a.z++\n    if (a.z != 3) return \"fail 2: $a.z\"\n    if (p != 2) return \"fail 3: $p\"\n\n    p = ++a.z\n    if (a.z != 4) return \"fail 4: $a.z\"\n    if (p != 4) return \"fail 5: $p\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test(var result: Int)\n\nvar result = Test(1)\n\ninline var z: Test\n    get() = result\n    set(value)  {\n        result = value\n    }\n\noperator fun Test.plus(p: Int): Test {\n    return Test(result + p)\n}\n\noperator fun Test.inc(): Test {\n    return Test(result + 1)\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    z = Test(1)\n    z += 1\n    if (result.result != 2) return \"fail 1: ${result.result}\"\n\n    var p = z++\n    if (result.result != 3) return \"fail 2: ${result.result}\"\n    if (p.result != 2) return \"fail 3: ${p.result}\"\n\n    p = ++z\n    if (result.result != 4) return \"fail 4: ${result.result}\"\n    if (p.result != 4) return \"fail 5: ${p.result}\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// PROPERTY_NOT_USED: p1\n// PROPERTY_NOT_READ_FROM: p2\n// PROPERTY_NOT_WRITTEN_TO: p3\n// CHECK_NOT_CALLED: get_p4\n// CHECK_NOT_CALLED: set_p4\n// CHECK_NOT_CALLED: get_p5\n// CHECK_NOT_CALLED: set_p6\n// PROPERTY_NOT_USED: p7\n// PROPERTY_NOT_READ_FROM: p8\n// PROPERTY_NOT_WRITTEN_TO: p9\n// CHECK_NOT_CALLED: get_p10_s8ev3o$\n// CHECK_NOT_CALLED: set_p10_rksjo2$\n// CHECK_NOT_CALLED: get_p11_s8ev3o$\n// CHECK_NOT_CALLED: set_p12_rksjo2$\n// CHECK_NOT_CALLED: get_p13\n// CHECK_NOT_CALLED: set_p13\n// CHECK_NOT_CALLED: get_p14\n// CHECK_NOT_CALLED: set_p15\n\n// FILE: 1.kt\npackage test\n\nvar a = 0\n\ninline var p1: Int\n    get() = a + 10000\n    set(v: Int) {\n        a = v + 100\n    }\n\nvar p2: Int\n    inline get() = a + 20000\n    set(v: Int) {\n        a = v + 200\n    }\n\nvar p3: Int\n    get() = a + 30000\n    inline set(v: Int) {\n        a = v + 300\n    }\n\ninline var Int.p4: Int\n    get() = this * 100 + a + 40000\n    set(v: Int) {\n        a = this + v + 400\n    }\n\nvar Int.p5: Int\n    inline get() = this * 100 + a + 50000\n    set(v: Int) {\n        a = this + v + 500\n    }\n\nvar Int.p6: Int\n    get() = this * 100 + a + 60000\n    inline set(v: Int) {\n        a = this + v + 600\n    }\n\nclass A {\n    inline var p7: Int\n        get() = a + 70000\n        set(v: Int) {\n            a = v + 700\n        }\n\n    var p8: Int\n        inline get() = a + 80000\n        set(v: Int) {\n            a = v + 800\n        }\n\n    var p9: Int\n        get() = a + 90000\n        inline set(v: Int) {\n            a = v + 900\n        }\n\n    inline var Int.p10: Int\n        get() = this * 100 + a + 100000\n        set(v: Int) {\n            a = this + v + 1000\n        }\n\n    var Int.p11: Int\n        inline get() = this * 100 + a + 110000\n        set(v: Int) {\n            a = this + v + 1100\n        }\n\n    var Int.p12: Int\n        get() = this * 100 + a + 120000\n        inline set(v: Int) {\n            a = this + v + 1200\n        }\n}\n\ninline var A.p13: Int\n    get() = a + 130000\n    set(v: Int) {\n        a = v + 1300\n    }\n\nvar A.p14: Int\n    inline get() = a + 140000\n    set(v: Int) {\n        a = v + 1400\n    }\n\nvar A.p15: Int\n    get() = a + 150000\n    inline set(v: Int) {\n        a = v + 1500\n    }\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    p1 = 1\n    if (p1 != 10101) return \"test1: $p1\"\n    p2 = 2\n    if (p2 != 20202) return \"test2: $p2\"\n    p3 = 3\n    if (p3 != 30303) return \"test3: $p3\"\n\n    4000000.p4 = 4\n    if (4000000.p4 != 404040404) return \"test4: ${4000000.p4}\"\n    5000000.p5 = 5\n    if (5000000.p5 != 505050505) return \"test5: ${5000000.p5}\"\n    6000000.p6 = 6\n    if (6000000.p6 != 606060606) return \"test6: ${6000000.p6}\"\n\n\n    val a = A()\n\n    a.p7 = 7\n    if (a.p7 != 70707) return \"test7: ${a.p7}\"\n    a.p8 = 8\n    if (a.p8 != 80808) return \"test8: ${a.p8}\"\n    a.p9 = 9\n    if (a.p9 != 90909) return \"test9: ${a.p9}\"\n\n    with (a) {\n        10000000.p10 = 10\n        if (10000000.p10 != 1010101010) return \"test10: ${10000000.p10}\"\n        11000000.p11 = 11\n        if (11000000.p11 != 1111111111) return \"test11: ${11000000.p11}\"\n        12000000.p12 = 12\n        if (12000000.p12 != 1212121212) return \"test12: ${12000000.p12}\"\n    }\n\n    a.p13 = 13\n    if (a.p13 != 131313) return \"test13: ${a.p13}\"\n    a.p14 = 14\n    if (a.p14 != 141414) return \"test14: ${a.p14}\"\n    a.p15 = 15\n    if (a.p15 != 151515) return \"test15: ${a.p15}\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass A {\n    var result = 1\n    \n    inline var Int.z: Int\n        get() = result\n        set(value) {\n            result = value + this\n        }\n\n}\n\n// FILE: 2.kt\nimport test.*\n\n\nfun box(): String {\n    with(A()) {\n        1.z += 0\n        if (1.z != 2) return \"fail 1: $result\"\n\n        var p = 1.z++\n        if (1.z != 4) return \"fail 2: $result\"\n        if (p != 2) return \"fail 3: $p\"\n\n        p = ++1.z\n        if (1.z != 6) return \"fail 4: $result\"\n        if (p != 6) return \"fail 5: $p\"\n    }\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nvar result = 1\n\ninline var Int.z: Int\n    get() = result\n    set(value)  {\n        result = value + this\n    }\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    1.z += 0\n    if (result != 2) return \"fail 1: $result\"\n\n    var p = 1.z++\n    if (result != 4) return \"fail 2: $result\"\n    if (p != 2) return \"fail 3: $p\"\n\n    p = ++1.z\n    if (result != 6) return \"fail 4: $result\"\n    if (p != 6) return \"fail 5: $p\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(f: () -> Unit) {\n    try {\n        f()\n    }\n    finally {\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    foo {\n        try {\n            return \"OK\"\n        } catch(e: Exception) {\n            return \"fail 1\"\n        }\n    }\n\n    return \"fail 2\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun a(b: () -> String) : String {\n    return b()\n}\n\ninline fun test(l: () -> String): String {\n    return l()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun test1() : String {\n    return a {\n        test {\n            return@a \"OK\"\n        }\n    }\n}\n\nfun test2() : String {\n    return test z@ {\n        return@z \"OK\"\n    }\n}\n\nfun test3() : String {\n    return test {\n        return@test \"OK\"\n    }\n}\n\nfun test4() : String {\n    return a z@ {\n        test {\n            return@z \"OK\"\n        }\n    }\n}\n\n\n\nfun box() : String {\n    if (test1() != \"OK\") return \"fail 1: ${test1()}\"\n\n    if (test2() != \"OK\") return \"fail 2: ${test2()}\"\n\n    if (test3() != \"OK\") return \"fail 3: ${test3()}\"\n\n    if (test4() != \"OK\") return \"fail 4: ${test4()}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// MODULE: lib\n// FILE: lib.kt\n\npackage utils\n\ninline fun foo(a: Int) {\n    try {\n        if (a > 0) throw Exception()\n        log(\"foo($a)\")\n    }\n    catch (e: Exception) {\n        bar(a)\n    }\n}\n\ninline fun bar(a: Int) {\n    myRun {\n        log(\"bar($a) #1\")\n        if (a == 2) return\n        log(\"bar($a) #2\")\n    }\n}\n\nvar LOG: String = \"\"\n\nfun log(s: String): String {\n    LOG += s + \";\"\n    return LOG\n}\n\ninline fun myRun(f: () -> Unit) = f()\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport utils.*\n\nfun box(): String {\n    foo(0)\n    if (LOG != \"foo(0);\") return \"fail1: $LOG\"\n    LOG = \"\"\n\n    foo(1)\n    if (LOG != \"bar(1) #1;bar(1) #2;\") return \"fail2: $LOG\"\n    LOG = \"\"\n\n    foo(2)\n    if (LOG != \"bar(2) #1;\") return \"fail3: $LOG\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <R> mySynchronized(lock: Any, block: () -> R): R {\n    monitorCall(lock)\n    try {\n        return block()\n    }\n    finally {\n        monitorCall(lock)\n    }\n}\n\nfun monitorCall(lock: Any) {\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\npublic class ClassA {\n    val LOCK = \"__LOCK__\"\n\n    var result = \"fail\"\n\n    fun test(name1: String?, name2: String, cond: Boolean) {\n        mySynchronized (LOCK) {\n            var name = name1\n\n            if (name == null) {\n                if (cond) {\n                    result = \"NLR\" + name2\n                    return\n                }\n\n                name = name2\n            }\n\n            result = name + name2\n\n            val length = name.length\n        }\n    }\n}\n\nfun box(): String {\n    val classA = ClassA()\n    classA.test(null, \"2\", true)\n    if (classA.result != \"NLR2\") return \"fail 1: ${classA.result}\"\n\n    classA.test(null, \"K\", false)\n    if (classA.result != \"KK\") return \"fail 1: ${classA.result}\"\n\n\n    classA.test(\"O\", \"K\", false)\n    return classA.result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun baz(x: Int) {}\n\ninline fun <T> foo(action: () -> T): T {\n    baz(0)\n    try {\n        return action()\n    } finally {\n        baz(1)\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\ninline fun <T> bar(arg: String, action: () -> T) {\n    try {\n        action()\n    } finally {\n        arg.length\n    }\n}\n\nfun box(): String {\n    foo() {\n        bar(\"\") {\n            return \"OK\"\n        }\n    }\n\n    return \"fail\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun takeWhileSize(initialSize: Int , block: (String) -> Int) {\n    val current = \"PARAM\"\n\n    try {\n        if (1 >= initialSize) {\n            try {\n                block(current)\n            } finally {\n                val i = \"INNER FINALLY\"\n            }\n        } else {\n            val e = \"ELSE\"\n        }\n    } finally {\n        val o =  \"OUTER FINALLY\"\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\n\nfun box(): String {\n    takeWhileSize(1) {\n        return \"OK\"\n    }\n\n    return \"fail\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun a(b: () -> String) : String {\n    return b()\n}\n\ninline fun test(l: () -> String): String {\n    return l()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun test1(): String {\n    return a {\n        try {\n            test {\n                return@a \"OK\"\n            }\n        }\n        finally {\n\n        }\n    }\n}\n\nfun test2(): String {\n\n    return test z@ {\n        try {\n            return@z \"OK\"\n        }\n        finally {\n\n        }\n    }\n\n}\n\nfun test3(): String {\n    return test {\n        try {\n            return@test \"OK\"\n        }\n        finally {\n\n        }\n    }\n}\n\n\nfun test4(): String {\n    return a z@ {\n        try {\n            test {\n                return@z \"OK\"\n            }\n        }\n        finally {\n\n        }\n    }\n}\n\n\nfun box(): String {\n    if (test1() != \"OK\") return \"fail 1: ${test1()}\"\n\n    if (test2() != \"OK\") return \"fail 2: ${test2()}\"\n\n    if (test3() != \"OK\") return \"fail 3: ${test3()}\"\n\n    if (test4() != \"OK\") return \"fail 4: ${test4()}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// MODULE: lib\n// FILE: lib.kt\n\npackage utils\n\ninline fun foo(a: Int) {\n    bar(a)\n}\n\ninline fun bar(a: Int) {\n    try {\n        if (a > 0) throw Exception()\n        log(\"foo($a) #1\")\n    }\n    catch (e: Exception) {\n        myRun {\n            log(\"foo($a) #2\")\n            if (a > 1) return\n            log(\"foo($a) #3\")\n        }\n    }\n    log(\"foo($a) #4\")\n}\n\nvar LOG: String = \"\"\n\nfun log(s: String): String {\n    LOG += s + \";\"\n    return LOG\n}\n\ninline fun myRun(f: () -> Unit) = f()\n\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nimport utils.*\n\nfun box(): String {\n    foo(0)\n    if (LOG != \"foo(0) #1;foo(0) #4;\") return \"fail1: $LOG\"\n    LOG = \"\"\n\n    foo(1)\n    if (LOG != \"foo(1) #2;foo(1) #3;foo(1) #4;\") return \"fail2: $LOG\"\n    LOG = \"\"\n\n    foo(2)\n    if (LOG != \"foo(2) #2;\") return \"fail3: $LOG\"\n    LOG = \"\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\npackage test\n\nclass A {\n    var field = 0\n\n    inline fun a(f: () -> Any): Any {\n        try {\n            val value = f()\n            return value\n        } finally {\n            field--\n        }\n    }\n\n    private inline fun b(rule: () -> Unit) {\n        try {\n            rule()\n        } catch (fail: Throwable) {}\n    }\n\n    fun c(vararg functions: () -> Any): Any = a {\n        for (function in functions) {\n            b { return function() }\n        }\n        throw RuntimeException()\n    }\n}\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    val a = A()\n    a.c ({ \"OK\" })\n    if (a.field != -1) return \"fail 1: ${a.field}\"\n\n    try {\n        a.c({ null!! })\n    } catch (e: RuntimeException) {\n        // OK\n    } catch (e: Throwable) {\n        return \"fail 2: $e\"\n    }\n\n    return a.c ({ \"OK\" }) as String\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCall(block: ()-> Unit, finallyBlock1: ()-> Unit) {\n    try {\n         block()\n    } finally {\n        finallyBlock1()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder, doReturn: Int): String {\n    doCall (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OF_FINALLY1\"\n                return \"OF_FINALLY1\"\n            }\n    )\n\n    return \"LOCAL\";\n}\n\n\nfun test2(h: Holder, doReturn: Int): String {\n    doCall (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                try {\n                    h.value += \", OF_FINALLY1\"\n                    return \"OF_FINALLY1\"\n                } finally {\n                    h.value += \", OF_FINALLY1_FINALLY\"\n                }\n            }\n    )\n\n    return \"FAIL\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test10 = test1(h, 0)\n    if (test10 != \"OF_FINALLY1\" || h.value != \"OK_NONLOCAL, OF_FINALLY1\") return \"test10: ${test10}, holder: ${h.value}\"\n\n    h = Holder()\n    val test11 = test1(h, 1)\n    if (test11 != \"OF_FINALLY1\" || h.value != \"LOCAL, OF_FINALLY1\") return \"test11: ${test11}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h, 0)\n    if (test2 != \"OF_FINALLY1\" || h.value != \"OK_NONLOCAL, OF_FINALLY1, OF_FINALLY1_FINALLY\") return \"test20: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test21 = test2(h, 1)\n    if (test21 != \"OF_FINALLY1\" || h.value != \"LOCAL, OF_FINALLY1, OF_FINALLY1_FINALLY\") return \"test21: ${test21}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport Kind.*\n\nenum class Kind {\n    LOCAL,\n    EXTERNAL,\n    GLOBAL\n}\n\nclass Holder {\n    var value: String = \"\"\n}\n\nval FINALLY_CHAIN = \"in local finally, in external finally, in global finally\"\n\nclass Internal(val value: String)\n\nclass External(val value: String)\n\nclass Global(val value: String)\n\nfun test1(intKind: Kind, extKind: Kind, holder: Holder): Global {\n    holder.value = \"\"\n    try {\n        var externalResult = doCall ext@ {\n\n            try {\n                val internalResult = doCall int@ {\n                    try {\n                        if (intKind == Kind.GLOBAL) {\n                            return@test1 Global(\"internal -> global\")\n                        }\n                        else if (intKind == EXTERNAL) {\n                            return@ext External(\"internal -> external\")\n                        }\n                        return@int Internal(\"internal -> local\")\n                    }\n                    finally {\n                        holder.value += \"in local finally\"\n                    }\n                }\n\n                if (extKind == GLOBAL || extKind == EXTERNAL) {\n                    return Global(\"external -> global\")\n                }\n\n                External(internalResult.value + \": external -> local\");\n\n            }\n            finally {\n                holder.value += \", in external finally\"\n            }\n        }\n\n        return Global(externalResult.value + \": exit\")\n    }\n    finally {\n        holder.value += \", in global finally\"\n    }\n\n\n}\n\nfun box(): String {\n    var holder = Holder()\n\n    var test1 = test1(LOCAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> local: external -> local: exit\") return \"test1: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test2: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test3: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(LOCAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"external -> global\") return \"test4: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test5: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test6: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(LOCAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"external -> global\") return \"test7: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test8: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test9: ${test1},  finally = ${holder.value}\"\n\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(): String {\n    try {\n        doCall {\n            try {\n                doCall {\n                    val a = 1\n                    if (1 == 1) {\n                        return \"a\"\n                    }\n                    else if (2 == 2) {\n                        return \"b\"\n                    }\n                }\n\n                return \"d\"\n            }\n            finally {\n                \"1\"\n            }\n        }\n\n    }\n    finally {\n        \"2\"\n    }\n    return \"f\"\n}\n\nfun box(): String {\n    test1()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Holder {\n    var value: String = \"\"\n}\n\ninline fun <R> doCall(block: ()-> R, h: Holder) : R {\n    try {\n        return block()\n    } finally {\n        h.value += \", in doCall finally\"\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport Kind.*\n\nenum class Kind {\n    LOCAL,\n    EXTERNAL,\n    GLOBAL\n}\n\nval FINALLY_CHAIN = \"in local finally, in doCall finally, in external finally, in doCall finally, in global finally\"\n\nclass Internal(val value: String)\n\nclass External(val value: String)\n\nclass Global(val value: String)\n\nfun test1(intKind: Kind, extKind: Kind, holder: Holder): Global {\n    holder.value = \"\"\n    try {\n        var externalResult = doCall (ext@ {\n            try {\n\n                val internalResult = doCall (int@ {\n                    try {\n                        if (intKind == Kind.GLOBAL) {\n                            return@test1 Global(\"internal -> global\")\n                        }\n                        else if (intKind == EXTERNAL) {\n                            return@ext External(\"internal -> external\")\n                        }\n                        return@int Internal(\"internal -> local\")\n                    }\n                    finally {\n                        holder.value += \"in local finally\"\n                    }\n                }, holder)\n\n                if (extKind == GLOBAL || extKind == EXTERNAL) {\n                    return Global(\"external -> global\")\n                }\n\n                External(internalResult.value + \": external -> local\");\n\n            }\n            finally {\n                holder.value += \", in external finally\"\n            }\n        }, holder)\n\n        return Global(externalResult.value + \": exit\")\n    }\n    finally {\n        holder.value += \", in global finally\"\n    }\n\n\n}\n\nfun box(): String {\n    var holder = Holder()\n\n    var test1 = test1(LOCAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> local: external -> local: exit\") return \"test1: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test2: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test3: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(LOCAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"external -> global\") return \"test4: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test5: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test6: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(LOCAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"external -> global\") return \"test7: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test8: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test9: ${test1},  finally = ${holder.value}\"\n\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\npublic class Holder(var value: String = \"\") {\n\n    operator fun plusAssign(s: String?) {\n        if (value.length != 0) {\n            value += \" -> \"\n        }\n        value += s\n    }\n\n    override fun toString(): String {\n        return value\n    }\n\n}\n\npublic inline fun <R> doCall(h: Holder, block: ()-> R) {\n    try {\n        block()\n    } finally {\n        h += \"inline fun finally\"\n    }\n}\n\npublic inline fun <R> doCallWithException(h: Holder, block: ()-> R) {\n    try {\n        block()\n    } finally {\n        h += \"inline fun finally\"\n        throw RuntimeException(\"fail\");\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport kotlin.test.*\n\nfun test1(): Holder {\n    val h = Holder(\"\")\n\n    try {\n        doCall(h) {\n            h += \"in lambda body\"\n            return h\n        }\n    }\n    finally {\n        h += \"in call site finally\"\n    }\n\n    h += \"local\"\n    return h\n}\n\nfun test1Lambda(): Holder {\n    val h = Holder(\"\")\n\n    doCall(h) {\n        try {\n            h += \"in lambda body\"\n            return h\n        }\n        finally {\n            h += \"in lambda finally\"\n        }\n    }\n\n\n    h += \"local\"\n    return h\n}\n\nfun test2(h: Holder): Holder {\n    try {\n        doCallWithException(h) {\n            h += \"in lambda body\"\n            return h\n        }\n    }\n    finally {\n        h += \"in call site finally\"\n    }\n\n    h += \"local\"\n    return h\n}\n\nfun test2Lambda(h: Holder): Holder {\n\n    doCallWithException(h) {\n        try {\n            h += \"in lambda body\"\n            return h\n        }\n        finally {\n            h += \"in lambda finally\"\n        }\n    }\n\n    h += \"local\"\n    return h\n}\n\nfun box(): String {\n    val test = test1()\n    if (test.value != \"in lambda body -> inline fun finally -> in call site finally\") return \"fail 1: $test\"\n\n    val testLambda = test1Lambda()\n    if (testLambda.value != \"in lambda body -> in lambda finally -> inline fun finally\") return \"fail 1 lambda: $testLambda\"\n\n    var h = Holder()\n    assertError(2, h, \"in lambda body -> inline fun finally -> in call site finally\") {\n        test2(h)\n    }\n\n    h = Holder()\n    assertError(22, h, \"in lambda body -> in lambda finally -> inline fun finally\") {\n        test2Lambda(h)\n    }\n\n    return \"OK\"\n}\n\n\ninline fun assertError(index: Int, h: Holder, expected: String, l: (h: Holder) -> Holder) {\n    try {\n        l(h)\n        fail(\"fail $index: no error\")\n    }\n    catch (e: Exception) {\n        assertEquals(expected, h.value, \"failed on $index\")\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\npublic class Holder(var value: String = \"\") {\n\n    operator fun plusAssign(s: String?) {\n        if (value.length != 0) {\n            value += \" -> \"\n        }\n        value += s\n    }\n\n    override fun toString(): String {\n        return value\n    }\n\n}\n\npublic inline fun <R> doCall(h: Holder, block: ()-> R) : R {\n    try {\n        return block()\n    } finally {\n        h += \"inline fun finally\"\n    }\n}\n\npublic inline fun <R> doCallWithException(h: Holder, block: ()-> R) : R {\n    try {\n        return block()\n    } finally {\n        h += \"inline fun finally\"\n        throw RuntimeException(\"fail\");\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport kotlin.test.*\n\nfun test1(): Holder {\n    val h = Holder(\"\")\n\n    try {\n        val internalResult = doCall(h) {\n            h += \"in lambda body\"\n            return h\n        }\n    }\n    finally {\n        h += \"in call site finally\"\n    }\n\n    h += \"local\"\n    return h\n}\n\nfun test1Lambda(): Holder {\n    val h = Holder(\"\")\n\n    val internalResult = doCall(h) {\n        try {\n            h += \"in lambda body\"\n            return h\n        }\n        finally {\n            h += \"in lambda finally\"\n        }\n    }\n\n\n    h += \"local\"\n    return h\n}\n\nfun test2(h: Holder): Holder {\n    try {\n        val internalResult = doCallWithException(h) {\n            h += \"in lambda body\"\n            return h\n        }\n    }\n    finally {\n        h += \"in call site finally\"\n    }\n\n    h += \"local\"\n    return h\n}\n\nfun test2Lambda(h: Holder): Holder {\n\n    val internalResult = doCallWithException(h) {\n        try {\n            h += \"in lambda body\"\n            return h\n        }\n        finally {\n            h += \"in lambda finally\"\n        }\n    }\n\n    h += \"local\"\n    return h\n}\n\nfun box(): String {\n    val test = test1()\n    if (test.value != \"in lambda body -> inline fun finally -> in call site finally\") return \"fail 1: $test\"\n\n    val testLambda = test1Lambda()\n    if (testLambda.value != \"in lambda body -> in lambda finally -> inline fun finally\") return \"fail 1 lambda: $testLambda\"\n\n    var h = Holder()\n    assertError(2, h, \"in lambda body -> inline fun finally -> in call site finally\") {\n        test2(h)\n    }\n\n    h = Holder()\n    assertError(22, h, \"in lambda body -> in lambda finally -> inline fun finally\") {\n        test2Lambda(h)\n    }\n\n    return \"OK\"\n}\n\n\ninline fun assertError(index: Int, h: Holder, expected: String, l: (h: Holder) -> Holder) {\n    try {\n        l(h)\n        fail(\"fail $index: no error\")\n    }\n    catch (e: Exception) {\n        assertEquals(expected, h.value, \"failed on $index\")\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\npublic inline fun <T, R> T.mylet(block: (T) -> R): R {\n    return block(this)\n}\n\n// FILE: 2.kt\nimport test.*\n\nvar message = \"\"\n\nfun foo(root: String): String {\n    try {\n        return root.let { _ ->\n            try {\n                if (!random()) {\n                    return root\n                }\n                return \"fail $root\"\n            } catch (e: Exception) {\n                message += \"Exception $e\"\n            }\n            \"fail\"\n        }\n    } finally {\n        message += \"Finally block\"\n    }\n}\n\nvar fail = false\n\nfun random() = fail\n\nfun box(): String {\n    var okResult =  foo(\"OK\")\n    if (okResult != \"OK\") return \"fail 1: $okResult\"\n    if (message != \"Finally block\") return \"fail 2: $message\"\n\n    message = \"\"\n    fail = true\n    if (foo(\"OK\") != \"fail OK\") return \"fail 3: ${foo(\"OK\")}\"\n    if (message != \"Finally block\" ) return \"fail 4: $message\"\n\n    return okResult\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\npublic inline fun <T, R> T.mylet(block: (T) -> R): R {\n    return block(this)\n}\n\n// FILE: 2.kt\nimport test.*\n\nvar message = \"\"\n\nfun foo(root: String): String {\n    try {\n        return root.let { _ ->\n            try {\n                if (!random()) {\n                    return root\n                }\n                return \"fail $root\"\n            } catch (e: Exception) {\n                message += \"${e.message} \"\n            }\n            \"fail\"\n        }\n    } finally {\n        message += \"Finally block\"\n    }\n}\n\nvar exception = false\n\nfun random() = if (exception) error(\"Exception\") else false\n\nfun box(): String {\n    var okResult =  foo(\"OK\")\n    if (okResult != \"OK\") return \"fail 1: $okResult\"\n    if (message != \"Finally block\") return \"fail 2: $message\"\n\n    message = \"\"\n    exception = true\n    if (foo(\"OK\") != \"fail\") return \"fail 3: ${foo(\"OK\")}\"\n    if (message != \"Exception Finally block\" ) return \"fail 4: $message\"\n\n    return okResult\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\npublic inline fun <T> T.myapply(block: T.() -> Unit): T {\n    block()\n    return this\n}\n\n\n// FILE: 2.kt\nimport test.*\n\nclass Test(val value: () -> String) {\n    fun test(): String {\n        try {\n            myapply {\n                try {\n                    return value()\n                } catch (e: Exception) {\n                } catch (e: Throwable) {\n                }\n            }\n        } finally {\n\n        }\n\n        return \"fail\"\n    }\n}\n\nfun box(): String {\n    return Test { \"OK\" }.test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\npublic inline fun <T, R> T.mylet(block: (T) -> R): R {\n    return block(this)\n}\n\n// FILE: 2.kt\nimport test.*\n\nvar message = \"\"\n\nfun foo(root: String) {\n    try {\n        return root.let { _ ->\n            try {\n                if (!random()) {\n                    message += root\n                    return\n                }\n                message += \"fail $root\"\n            } catch (e: Exception) {\n                message += \"Exception $e\"\n            }\n            \"fail\"\n        }\n    } finally {\n        message += \" Finally block\"\n    }\n}\n\nvar fail = false\n\nfun random() = fail\n\nfun box(): String {\n    foo(\"OK\")\n    if (message != \"OK Finally block\") return \"fail 1: $message\"\n\n    message = \"\"\n    fail = true\n    foo(\"OK\")\n    if (message != \"fail OK Finally block\" ) return \"fail 2: $message\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, finallyBlock: ()-> Unit) : R {\n    try {\n        return block()\n    } finally {\n        finallyBlock()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder): String {\n    val localResult = doCall ({\n        return \"OK_NONLOCAL\"\n    }, {\n        h.value = \"OK_FINALLY\"\n    })\n\n    return \"FAIL\";\n}\n\n\nfun test2(h: Holder): String {\n    val localResult = doCall (lambda@ {\n      h.value += \"OK_LOCAL\"\n      return@lambda \"OK_LOCAL\"\n    }, {\n      h.value += \", OK_FINALLY\"\n      return \"OK_FINALLY\"\n    })\n\n    return \"FAIL\";\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall ({\n      h.value += \"OK_NONLOCAL\"\n      return \"OK_NONLOCAL\"\n    }, {\n      h.value += \", OK_FINALLY\"\n      return \"OK_FINALLY\"\n    })\n\n    return \"FAIL\";\n}\n\n\nfun box(): String {\n    var h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"OK_NONLOCAL\" || h.value != \"OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_FINALLY\" || h.value != \"OK_LOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Holder {\n    var value: String = \"\"\n}\n\ninline fun doCall(block: ()-> Unit, block2: ()-> Unit, finallyBlock2: ()-> Unit, res: Holder) {\n    try {\n        try {\n            block()\n            block2()\n        }\n        finally {\n            finallyBlock2()\n        }\n    } finally {\n        res.value += \", DO_CALL_EXT_FINALLY\"\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(h: Holder, doReturn: Int): String {\n    doCall (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_NONLOCAL2\"\n                return \"OK_NONLOCAL2\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n            },\n            h\n    )\n\n    return \"LOCAL\";\n}\n\n\nfun test2(h: Holder, doReturn: Int): String {\n    doCall (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                try {\n                    h.value += \", OK_NONLOCAL2\"\n                    return \"OK_NONLOCAL2\"\n                } finally {\n                    h.value += \", OK_NONLOCAL2_FINALLY\"\n                }\n            },\n            {\n                h.value += \", OK_FINALLY\"\n            },\n            h\n    )\n\n    return \"FAIL\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test10 = test1(h, 0)\n    if (test10 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY, DO_CALL_EXT_FINALLY\") return \"test10: ${test10}, holder: ${h.value}\"\n\n    h = Holder()\n    val test11 = test1(h, 1)\n    if (test11 != \"OK_NONLOCAL2\" || h.value != \"LOCAL, OK_NONLOCAL2, OK_FINALLY, DO_CALL_EXT_FINALLY\") return \"test11: ${test11}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h, 0)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY, DO_CALL_EXT_FINALLY\") return \"test20: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test21 = test2(h, 1)\n    if (test21 != \"OK_NONLOCAL2\" || h.value != \"LOCAL, OK_NONLOCAL2, OK_NONLOCAL2_FINALLY, OK_FINALLY, DO_CALL_EXT_FINALLY\") return \"test21: ${test21}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, finallyLambda: ()-> Unit) : R {\n    try {\n        return block()\n    } finally {\n        finallyLambda()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport Kind.*\n\nenum class Kind {\n    LOCAL,\n    EXTERNAL,\n    GLOBAL\n}\n\nclass Holder {\n    var value: String = \"\"\n}\n\nval FINALLY_CHAIN = \"in local finally, in declaration local finally, in external finally, in declaration external finally, in global finally\"\n\nclass Internal(val value: String)\n\nclass External(val value: String)\n\nclass Global(val value: String)\n\nfun test1(intKind: Kind, extKind: Kind, holder: Holder): Global {\n    holder.value = \"\"\n    try {\n        var externalResult = doCall (ext@ {\n\n            try {\n                val internalResult = doCall (int@ {\n                    try {\n                        if (intKind == Kind.GLOBAL) {\n                            return@test1 Global(\"internal -> global\")\n                        }\n                        else if (intKind == EXTERNAL) {\n                            return@ext External(\"internal -> external\")\n                        }\n                        return@int Internal(\"internal -> local\")\n                    }\n                    finally {\n                        holder.value += \"in local finally\"\n                    }\n                }, {\n                    holder.value += \", in declaration local finally\"\n                })\n                if (extKind == GLOBAL || extKind == EXTERNAL) {\n                    return Global(\"external -> global\")\n                }\n\n                External(internalResult.value + \": external -> local\");\n\n            }\n            finally {\n                holder.value += \", in external finally\"\n            }\n        }, {\n            holder.value += \", in declaration external finally\"\n        })\n\n        return Global(externalResult.value + \": exit\")\n    }\n    finally {\n        holder.value += \", in global finally\"\n    }\n\n\n}\n\nfun box(): String {\n    var holder = Holder()\n\n    var test1 = test1(LOCAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> local: external -> local: exit\") return \"test1: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test2: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, LOCAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test3: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(LOCAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"external -> global\") return \"test4: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test5: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, EXTERNAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test6: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(LOCAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"external -> global\") return \"test7: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(EXTERNAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> external: exit\") return \"test8: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(GLOBAL, GLOBAL, holder).value\n    if (holder.value != FINALLY_CHAIN || test1 != \"internal -> global\") return \"test9: ${test1},  finally = ${holder.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCall(block: ()-> Int, exception: (e: Exception)-> Unit, finallyBlock: ()-> Int, res: Int = -111) : Int {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\npublic inline fun <R> doCall2(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R, res: R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder): Int {\n    val localResult = doCall2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return 2\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAILT\")\n\n    return -1;\n}\n\nfun test1(h: Holder): Int {\n    val localResult = doCall2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return 1\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return -1;\n}\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                2\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                3\n            })\n\n    return \"\" + localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                3\n            })\n\n    return \"\" + localResult;\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            })\n\n    return \"\" + localResult;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != 2 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test1(h)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder {\n    public var value: String = \"\"\n}\n\npublic inline fun doCall(block: ()-> Int, exception: (e: Exception)-> Unit, finallyBlock: ()-> Int, h : Holder, res: Int = -111) : Int {\n    try {\n        try {\n            return block()\n        }\n        catch (e: Exception) {\n            exception(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } finally {\n        h.value += \", INLINE_CALL_FINALLY\"\n    }\n    return res\n}\n\npublic inline fun <R> doCall2(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R, res: R, h : Holder) : R {\n    try {\n        try {\n            return block()\n        }\n        catch (e: Exception) {\n            exception(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } finally {\n        h.value += \", INLINE_CALL_FINALLY\"\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\n\nfun test0(h: Holder): Int {\n    val localResult = doCall2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return 2\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\", h)\n\n    return -1;\n}\n\nfun test1(h: Holder): Int {\n    val localResult = doCall2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return 1\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\", h)\n\n    return -1;\n}\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                2\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                3\n            }, h)\n\n    return \"\" + localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                3\n            }, h)\n\n    return \"\" + localResult;\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            }, h)\n\n    return \"\" + localResult;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != 2 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, INLINE_CALL_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test1(h)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY, INLINE_CALL_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY, INLINE_CALL_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, INLINE_CALL_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, INLINE_CALL_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, finallyBlock: ()-> R) : R {\n    try {\n        block()\n    } finally {\n        return finallyBlock()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                \"OK_LOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            })\n\n    return \"FAIL\";\n}\n\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                \"OK_NONLOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            })\n\n    return \"FAIL\";\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\n\nfun box(): String {\n    var h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"OK_FINALLY\" || h.value != \"OK_LOCAL, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, finallyBlock: ()-> Unit) : R {\n    try {\n        return block()\n    } finally {\n        finallyBlock()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder) {\n    val localResult = doCall (\n            {\n                h.value = \"OK_NONLOCAL\"\n                return\n            }, {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n}\n\n\nfun test2(h: Holder) {\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                \"OK_LOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                return\n            })\n}\n\nfun test3(h: Holder) {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return\n            }, {\n                h.value += \", OK_FINALLY\"\n                return\n            })\n}\n\n\nfun box(): String {\n    var h = Holder()\n    test1(h)\n    if (h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test1 holder: ${h.value}\"\n\n    h = Holder()\n    test2(h)\n    if (h.value != \"OK_LOCAL, OK_FINALLY\") return \"test2 holder: ${h.value}\"\n\n    h = Holder()\n    test3(h)\n    if (h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test3 holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, finallyBlock: ()-> R) : R {\n    try {\n        return block()\n    } finally {\n        return finallyBlock()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                \"OK_LOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            })\n\n    return \"FAIL\";\n}\n\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            lambda@ {\n                h.value += \"OK_NONLOCAL\"\n                return@lambda \"OK_NONLOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            }, {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            })\n\n    return \"FAIL\";\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall<String> (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            l2@ {\n                h.value += \", OK_FINALLY\"\n                return@l2 \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\n\nfun box(): String {\n    var h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"OK_FINALLY\" || h.value != \"OK_LOCAL, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, finallyBlock: ()-> Unit) {\n    try {\n        block()\n    } finally {\n        finallyBlock()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder): String {\n    doCall ({\n        return \"OK_NONLOCAL\"\n    }, {\n        h.value = \"OK_FINALLY\"\n    })\n\n    return \"FAIL\";\n}\n\n\nfun test2(h: Holder): String {\n    doCall ({\n      h.value += \"OK_LOCAL\"\n      \"OK_LOCAL\"\n    }, {\n      h.value += \", OK_FINALLY\"\n      return \"OK_FINALLY\"\n    })\n\n    return \"FAIL\";\n}\n\nfun test3(h: Holder): String {\n    doCall ({\n      h.value += \"OK_NONLOCAL\"\n      return \"OK_NONLOCAL\"\n    }, {\n      h.value += \", OK_FINALLY\"\n      return \"OK_FINALLY\"\n    })\n\n    return \"FAIL\";\n}\n\n\nfun box(): String {\n    var h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"OK_NONLOCAL\" || h.value != \"OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_FINALLY\" || h.value != \"OK_LOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCall(block: ()-> Unit, finallyBlock1: ()-> Unit, finallyBlock2: ()-> Unit) {\n    try {\n        try {\n            block()\n        }\n        finally {\n            finallyBlock1()\n        }\n    } finally {\n        finallyBlock2()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder): String {\n    doCall (\n            {\n                h.value += \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n            }\n    )\n\n    return \"LOCAL\";\n}\n\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n            })\n\n    return \"FAIL\";\n}\n\nfun test3(h: Holder): String {\n    doCall (\n            {\n                h.value += \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n                return \"OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n            })\n\n    return \"FAIL\";\n}\n\nfun test4(h: Holder): String {\n    doCall (\n            {\n                h.value += \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n                return \"OK_FINALLY2\"\n            })\n\n    return \"FAIL\";\n}\n\nfun test5(h: Holder): String {\n    doCall (\n            {\n                h.value += \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n                  return \"OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n                return \"OK_FINALLY2\"\n            })\n\n    return \"FAIL\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"LOCAL\" || h.value != \"OK_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_FINALLY1\" || h.value != \"OK_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY2\" || h.value != \"OK_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    h = Holder()\n    val test5 = test5(h)\n    if (test5 != \"OK_FINALLY2\" || h.value != \"OK_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test5: ${test5}, holder: ${h.value}\"\n\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCall(block: ()-> Unit, block2: ()-> Unit, finallyBlock2: ()-> Unit) {\n    try {\n         block()\n         block2()\n    } finally {\n        finallyBlock2()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\n\nfun test1(h: Holder, doReturn: Int): String {\n    doCall (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_NONLOCAL2\"\n                return \"OK_NONLOCAL2\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n            }\n    )\n\n    return \"LOCAL\";\n}\n\n\nfun test2(h: Holder, doReturn: Int): String {\n    doCall (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                try {\n                    h.value += \", OK_NONLOCAL2\"\n                    return \"OK_NONLOCAL2\"\n                } finally {\n                    h.value += \", OK_NONLOCAL2_FINALLY\"\n                }\n            },\n            {\n                h.value += \", OK_FINALLY\"\n            }\n    )\n\n    return \"FAIL\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test10 = test1(h, 0)\n    if (test10 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test10: ${test10}, holder: ${h.value}\"\n\n    h = Holder()\n    val test11 = test1(h, 1)\n    if (test11 != \"OK_NONLOCAL2\" || h.value != \"LOCAL, OK_NONLOCAL2, OK_FINALLY\") return \"test11: ${test11}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h, 0)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test20: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test21 = test2(h, 1)\n    if (test21 != \"OK_NONLOCAL2\" || h.value != \"LOCAL, OK_NONLOCAL2, OK_NONLOCAL2_FINALLY, OK_FINALLY\") return \"test21: ${test21}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCall(block: ()-> Long, exception: (e: Exception)-> Unit, finallyBlock: ()-> Long, res: Long = -1111.toLong()) : Long {\n    try {\n        block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\npublic inline fun <R> doCall2(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R, res: R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder): Long {\n    val localResult = doCall2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return 1.toLong()\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return 2.toLong()\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return -1.toLong()\n}\n\nfun test1(h: Holder): Long {\n    val localResult = doCall2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return 1.toLong()\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return -1.toLong()\n}\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                2.toLong()\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                3.toLong()\n            })\n\n    return \"\" + localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                3.toLong()\n            })\n\n    return \"\" + localResult;\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            })\n\n    return \"\" + localResult;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != 2.toLong() || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test1(h)\n    if (test1 != 1.toLong() || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun  doCall(block: ()-> String, exception: (e: Exception)-> Unit) : String {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    }\n    return \"Fail in doCall\"\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            })\n\n    return localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            })\n\n    return localResult;\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            })\n\n    return localResult;\n}\n\nfun test5(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NONLOCAL\"\n                    if (true) {\n                        throw RuntimeException()\n                    }\n                    h.value += \"fail\"\n                    return \"OK_NONLOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION\"\n                    if (true) {\n                        throw RuntimeException(\"EXCEPTION\")\n                    }\n                    h.value += \"fail\"\n\n                    return \"OK_EXCEPTION\"\n                })\n\n        return localResult;\n    } catch (e: RuntimeException) {\n        if (e.message != \"EXCEPTION\") {\n            return \"FAIL in exception: \" + e.message\n        } else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n}\n\nfun box(): String {\n    var h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    h = Holder()\n    val test5 = test5(h)\n    if (test5 != \"CATCHED_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION\") return \"test5: ${test5}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> mysynchronized(lock: Any, block: () -> R): R {\n    try {\n        return block()\n    }\n    finally {\n        //do nothing\n        1\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun call(): String {\n    return nonLocal()\n}\n\ninline fun nonLocal(): String {\n    mysynchronized(\"__LOCK__\") {\n        return \"nonLocal\"\n    }\n    return \"local\"\n}\n\nfun box(): String {\n    val call = call()\n    if (call != \"nonLocal\") return \"fail $call\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCallAlwaysBreak(block: (i: Int)-> Int) : Int {\n    var res = 0;\n    for (i in 1..10) {\n        try {\n            block(i)\n        } finally {\n            break;\n        }\n    }\n    return res\n}\n\npublic val z: Boolean = true\n\npublic inline fun doCallAlwaysBreak2(block: (i: Int)-> Int) : Int {\n    var res = 0;\n    for (i in 1..10) {\n        try {\n            res = block(i)\n        } finally {\n            if (z)\n                break\n        }\n    }\n    return res\n}\n\n//public inline fun doCallAlwaysBreak2(block: (i: Int)-> Int) : Int {\n//    var res = 0;\n//    for (i in 1..10) {\n//        try {\n//            res += block(i)\n//        } finally {\n//            if (z)\n//                break\n//        }\n//    }\n//    return res\n//}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(): Int {\n    var s = 0\n    doCallAlwaysBreak {\n        s += it*it\n        s\n    }\n    return s;\n}\n\nfun test11(): Int {\n    return doCallAlwaysBreak {\n        return -100\n    }\n}\n\nfun test2(): Int {\n    return doCallAlwaysBreak2 {\n        return -100\n    }\n}\n\nfun test22(): Int {\n    var s = 0\n    doCallAlwaysBreak {\n        s += it*it\n        s\n    }\n    return s;\n}\n\n\n\nfun box(): String {\n    val test1 = test1()\n    if (test1 != 1) return \"test1: ${test1}\"\n\n    val test11 = test11()\n    if (test11 != 0) return \"test11: ${test11}\"\n\n    val test2 = test2()\n    if (test2 != 0) return \"test2: ${test2}\"\n\n    val test22 = test22()\n    if (test22 != 1) return \"test22: ${test22}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, exception: (e: Exception)-> Unit, finallyBlock: ()-> String, res: String = \"Fail\") : String {\n    try {\n        block()\n    } catch (e: Exception1) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test01(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                throw Exception1(\"1\")\n                \"OK_NON_LOCAL_RES\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                try {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                } catch(e: RuntimeException) {\n                    h.value += \", OK_CATCHED\"\n                }\n                \"OK_FINALLY_RES\"\n            }, \"FAIL\")\n\n    return localResult;\n}\nfun box(): String {\n    var h = Holder()\n    val test01 = test01(h)\n    if (test01 != \"OK_EXCEPTION1\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY, OK_CATCHED\") return \"test01: ${test01}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCallAlwaysBreak(block: (i: Int)-> Int) : Int {\n    var res = 0;\n    for (i in 1..10) {\n        try {\n            res = block(i)\n        } finally {\n            continue;\n        }\n    }\n    return res\n}\n\npublic val z: Boolean = true\n\npublic inline fun doCallAlwaysBreak2(block: (i: Int)-> Int) : Int {\n    var res = 0;\n    for (i in 1..10) {\n        try {\n            res = block(i)\n        } finally {\n            if (z)\n                continue\n        }\n    }\n    return res\n}\n\n//public inline fun doCallAlwaysBreak2(block: (i: Int)-> Int) : Int {\n//    var res = 0;\n//    for (i in 1..10) {\n//        try {\n//            res += block(i)\n//        } finally {\n//            if (z)\n//                continue\n//        }\n//    }\n//    return res\n//}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(): Int {\n    var s = 0\n    doCallAlwaysBreak {\n        s += it*it\n        s\n    }\n    return s;\n}\n\nfun test11(): Int {\n    return doCallAlwaysBreak {\n        return -100\n    }\n}\n\nfun test2(): Int {\n    return doCallAlwaysBreak2 {\n        return -100\n    }\n}\n\nfun test22(): Int {\n    var s = 0\n    doCallAlwaysBreak {\n        s += it*it\n        s\n    }\n    return s;\n}\n\n\nfun box(): String {\n    val test1 = test1()\n    if (test1 != 385) return \"test1: ${test1}\"\n\n    val test11 = test11()\n    if (test11 != 0) return \"test11: ${test11}\"\n\n    val test2 = test2()\n    if (test2 != 0) return \"test2: ${test2}\"\n\n    val test22 = test22()\n    if (test22 != 385) return \"test22: ${test22}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, exception1: (e: Exception)-> Unit, exception2: (e: Exception)-> Unit, finallyBlock: ()-> String,\n                         exception3: (e: Exception)-> Unit, exception4: (e: Exception)-> Unit, finallyBlock2: ()-> String, res: String = \"Fail\") : String {\n    try {\n        try {\n            block()\n        }\n        catch (e: Exception1) {\n            exception1(e)\n        }\n        catch (e: Exception2) {\n            exception2(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } catch (e: Exception1) {\n        exception3(e)\n    }\n    catch (e: Exception2) {\n        exception4(e)\n    }\n    finally {\n        finallyBlock2()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder, throwEx1: Boolean, throwEx2: Boolean, throwEx3: Boolean = false, throwEx4: Boolean = false): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                if (throwEx1) {\n                    throw Exception1(\"1\")\n                }\n                if (throwEx2) {\n                    throw Exception2(\"1\")\n                }\n                return \"OK_NON_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                if (throwEx3) {\n                    throw Exception1(\"3_1\")\n                }\n                if (throwEx4) {\n                    throw Exception2(\"4_1\")\n                }\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                if (throwEx3) {\n                    throw Exception1(\"3_2\")\n                }\n                if (throwEx4) {\n                    throw Exception2(\"4_2\")\n                }\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n                \"OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION3\"\n                return \"OK_EXCEPTION3\"\n            },\n            {\n                h.value += \", OK_EXCEPTION4\"\n                return \"OK_EXCEPTION4\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n                \"OK_FINALLY2\"\n            })\n\n    return localResult;\n\n    return \"FAIL\";\n}\n\nfun box(): String {\n    var h = Holder()\n    var test0 = test0(h, false, false)\n    if (test0 != \"OK_NON_LOCAL\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_1: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, false)\n    if (test0 != \"OK_EXCEPTION1\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY1, OK_FINALLY2\") return \"test0_2: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, true)\n    if (test0 != \"OK_EXCEPTION2\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY1, OK_FINALLY2\") return \"test0_3: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, false, true, false)\n    if (test0 != \"OK_EXCEPTION3\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY1, OK_EXCEPTION3, OK_FINALLY2\") return \"test0_4: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, false, false, true)\n    if (test0 != \"OK_EXCEPTION4\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY1, OK_EXCEPTION4, OK_FINALLY2\") return \"test0_5: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, true, true, false)\n    if (test0 != \"OK_EXCEPTION3\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY1, OK_EXCEPTION3, OK_FINALLY2\") return \"test0_6: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, true, false, true)\n    if (test0 != \"OK_EXCEPTION4\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY1, OK_EXCEPTION4, OK_FINALLY2\") return \"test0_7: ${test0}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, finallyBlock: ()-> String,\n                         finallyBlock2: ()-> String, res: String = \"Fail\") : String {\n    try {\n        try {\n            block()\n        }\n        finally {\n            if (true) {\n                finallyBlock()\n                /*External finally would be injected here*/\n                return res + \"_INNER_FINALLY\"\n            }\n        }\n    } finally {\n        finallyBlock2()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(\n        h: Holder,\n        throwExternalFinEx1: Boolean = false,\n        res: String = \"Fail\"\n): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NON_LOCAL\"\n                    return \"OK_NON_LOCAL\"\n                },\n                {\n                    h.value += \", OK_FINALLY1\"\n                    \"OK_FINALLY1\"\n                },\n                {\n                    h.value += \", OK_FINALLY2\"\n                    if (throwExternalFinEx1) {\n                        throw Exception1(\"EXCEPTION_IN_EXTERNAL_FINALLY\")\n                    }\n                    \"OK_FINALLY2\"\n                }, res)\n        return localResult;\n    } catch(e: Exception1) {\n        return e.message!!\n    } catch(e: Exception2) {\n        return e.message!!\n    }\n}\n\nfun box(): String {\n    var h = Holder()\n    var test0 = test0(h, res = \"OK\")\n    if (test0 != \"OK_INNER_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_1: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, throwExternalFinEx1 = true, res = \"OK\")\n    if (test0 != \"EXCEPTION_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_2: ${test0}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\npublic interface MCloseable {\n    public open fun close()\n}\n\npublic inline fun <T : MCloseable, R> T.muse(block: (T) -> R): R {\n    try {\n        return block(this)\n    } finally {\n        this.close()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport kotlin.test.assertEquals\n\nclass MyException(message: String) : Exception(message)\n\nclass Holder(var value: String) {\n    operator fun plusAssign(s: String?) {\n        value += s\n        if (s != \"closed\") {\n            value += \"->\"\n        }\n    }\n}\n\nclass Test() : MCloseable {\n\n    val status = Holder(\"\")\n\n    private fun jobFun() {\n        status += \"called\"\n    }\n\n    fun nonLocalWithExceptionAndFinally(): Holder {\n        muse {\n            try {\n                jobFun()\n                throw MyException(\"exception\")\n            }\n            catch (e: MyException) {\n                status += e.message\n                return status\n            }\n            finally {\n                status += \"finally\"\n            }\n        }\n        return Holder(\"fail\")\n    }\n\n    override fun close() {\n        status += \"closed\"\n        throw MyException(\"error\")\n    }\n}\n\nfun box() : String {\n    assertError(1, \"called->exception->finally->closed\") {\n        nonLocalWithExceptionAndFinally()\n    }\n\n    return \"OK\"\n}\n\ninline fun assertError(index: Int, expected: String, l: Test.()->Unit) {\n    val testLocal = Test()\n    try {\n        testLocal.l()\n        throw AssertionError(\"fail $index: no error\")\n    } catch (e: Exception) {\n        assertEquals(expected, testLocal.status.value, \"failed on $index\")\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, exception1: (e: Exception)-> Unit, finallyBlock: ()-> String,\n                         exception3: (e: Exception)-> Unit, finallyBlock2: ()-> String, res: String = \"Fail\") : String {\n    try {\n        try {\n            block()\n        }\n        catch (e: Exception1) {\n            exception1(e)\n        }\n        finally {\n            if (true) {\n                finallyBlock()\n                /*External finally would be injected here*/\n                return res + \"_INNER_FINALLY\"\n            }\n        }\n    } catch (e: Exception2) {\n        exception3(e)\n    }\n    finally {\n        finallyBlock2()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(\n        h: Holder,\n        throwExceptionInTry: Boolean,\n        throwInternalEx2: Boolean = false,\n        throwInternalFinEx1: Boolean = false,\n        throwInternalFinEx2: Boolean = false,\n        throwExternalFinEx1: Boolean = false,\n        throwExternalFinEx2: Boolean = false,\n        res: String = \"Fail\"\n): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NON_LOCAL\"\n                    if (throwExceptionInTry) {\n                        throw Exception1(\"1\")\n                    }\n                    return \"OK_NON_LOCAL\"\n                },\n                {\n                    h.value += \", OK_INTERNAL_EXCEPTION1\"\n                    if (throwInternalEx2) {\n                        throw Exception2(\"2_1\")\n                    }\n                    return \"OK_INTERNAL_EXCEPTION1\"\n                },\n                {\n                    h.value += \", OK_FINALLY1\"\n                    if (throwInternalFinEx1) {\n                        throw Exception1(\"EXCEPTION_IN_INTERNAL_FINALLY\")\n                    }\n                    if (throwInternalFinEx2) {\n                        throw Exception2(\"EXCEPTION222_IN_INTERNAL_FINALLY\")\n                    }\n                    \"OK_FINALLY1\"\n                },\n                {\n                    h.value += \", OK_EXTERNAL_EXCEPTION2\"\n                    return \"OK_EXTERNAL_EXCEPTION2\"\n                },\n                {\n                    h.value += \", OK_FINALLY2\"\n                    if (throwExternalFinEx1) {\n                        throw Exception1(\"EXCEPTION_IN_EXTERNAL_FINALLY\")\n                    }\n                    if (throwExternalFinEx2) {\n                        throw Exception2(\"EXCEPTION222_IN_EXTERNAL_FINALLY\")\n                    }\n                    \"OK_FINALLY2\"\n                }, res)\n        return localResult;\n    } catch(e: Exception1) {\n        return e.message!!\n    } catch(e: Exception2) {\n        return e.message!!\n    }\n}\n\nfun box(): String {\n    var h = Holder()\n    var test0 = test0(h, false, throwExternalFinEx1 = false, res = \"OK\")\n    if (test0 != \"OK_INNER_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_1: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, throwExternalFinEx1 = true, res = \"OK\")\n    if (test0 != \"EXCEPTION_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_2: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, throwExternalFinEx2 = true, res = \"OK\")\n    if (test0 != \"EXCEPTION222_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_4: ${test0}, holder: ${h.value}\"\n\n\n\n\n    h = Holder()\n    test0 = test0(h, true, throwExternalFinEx1 = true, res = \"OK\")\n    if (test0 != \"EXCEPTION_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_FINALLY2\") return \"test0_3: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, throwInternalEx2 = true, throwExternalFinEx1 = true, res = \"OK\")\n    if (test0 != \"EXCEPTION_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_FINALLY2\") return \"test0_5: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, throwInternalEx2 = true, throwExternalFinEx2 = true, res = \"OK\")\n    if (test0 != \"EXCEPTION222_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_FINALLY2\") return \"test0_6: ${test0}, holder: ${h.value}\"\n\n\n\n    h = Holder()\n    test0 = test0(h, false, throwInternalFinEx1 = true)\n    if (test0 != \"EXCEPTION_IN_INTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_7: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, throwInternalFinEx1 = true, throwExternalFinEx2 = true)\n    if (test0 != \"EXCEPTION222_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_FINALLY2\") return \"test0_71: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, throwInternalFinEx2 = true)\n    if (test0 != \"OK_EXTERNAL_EXCEPTION2\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_EXTERNAL_EXCEPTION2, OK_FINALLY2\") return \"test0_8: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, throwInternalFinEx2 = true, throwExternalFinEx2 = true)\n    if (test0 != \"EXCEPTION222_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, OK_EXTERNAL_EXCEPTION2, OK_FINALLY2\") return \"test0_81: ${test0}, holder: ${h.value}\"\n\n\n\n    h = Holder()\n    test0 = test0(h, true, throwInternalFinEx1 = true)\n    if (test0 != \"EXCEPTION_IN_INTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_FINALLY2\") return \"test0_9: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, throwInternalFinEx1 = true, throwExternalFinEx2 = true)\n    if (test0 != \"EXCEPTION222_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_FINALLY2\") return \"test0_10: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, throwInternalFinEx2 = true)\n    if (test0 != \"OK_EXTERNAL_EXCEPTION2\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_EXTERNAL_EXCEPTION2, OK_FINALLY2\") return \"test0_11: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, throwInternalFinEx2 = true, throwExternalFinEx2 = true)\n    if (test0 != \"EXCEPTION222_IN_EXTERNAL_FINALLY\" || h.value != \"OK_NON_LOCAL, OK_INTERNAL_EXCEPTION1, OK_FINALLY1, OK_EXTERNAL_EXCEPTION2, OK_FINALLY2\") return \"test0_12: ${test0}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R, res: R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"Fail\")\n\n    return localResult;\n}\n\nfun test1(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                throw RuntimeException()\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"OK\")\n\n    return localResult;\n}\n\nfun test2(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return localResult;\n}\n\nfun test3(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return localResult;\n}\n\nfun test4(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return localResult;\n}\n\nfun test5(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n                return \"OK_NONLOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                if (true) {\n                    throw RuntimeException()\n                }\n                h.value += \"fail\"\n\n                return \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                return \"OK_FINALLY\"\n            }, \"FAIL\")\n\n    return localResult;\n}\n\n\nfun test6(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NONLOCAL\"\n                    if (true) {\n                        throw RuntimeException()\n                    }\n                    h.value += \"fail\"\n                    return \"OK_NONLOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION\"\n                    if (true) {\n                        throw RuntimeException()\n                    }\n                    h.value += \"fail\"\n\n                    return \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    \"OK_FINALLY\"\n                },\n                \"FAIL1\")\n    } catch (e: Exception) {\n        return \"OK\"\n    }\n\n    return \"FAIL2\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != \"OK_LOCAL\" || h.value != \"OK_LOCAL, OK_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n\n    h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"OK\" || h.value != \"OK_LOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"OK_EXCEPTION\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    h = Holder()\n    val test5 = test5(h)\n    if (test5 != \"OK_FINALLY\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test5: ${test5}, holder: ${h.value}\"\n\n    h = Holder()\n    val test6 = test6(h)\n    if (test6 != \"OK\" || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test6: ${test6}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        return finallyBlock()\n    }\n}\n\npublic inline fun <R> doCall2(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    throw RuntimeException(\"fail\")\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NON_LOCAL\"\n                    return \"OK_NON_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION\"\n                    \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                    \"OK_FINALLY\"\n                })\n\n        return localResult;\n    } catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        } else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test1(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw RuntimeException(\"FAIL\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION\"\n                    \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                    \"OK_FINALLY\"\n                })\n    } catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        } else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test2(h: Holder): String {\n\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                throw RuntimeException()\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\nfun test3(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw RuntimeException(\"FAIL\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION\"\n                    throw RuntimeException(\"FAIL_EX\")\n                    \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                    \"OK_FINALLY\"\n                })\n    } catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        } else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test4(h: Holder): String {\n    try {\n        val localResult = doCall2 (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw RuntimeException(\"FAIL\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION\"\n                    throw RuntimeException(\"EXCEPTION\")\n                    \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    \"OK_FINALLY\"\n                })\n    } catch (e: RuntimeException) {\n        if (e.message != \"EXCEPTION\") {\n            return \"FAIL in exception: \" + e.message\n        } else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\n\n\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != \"CATCHED_EXCEPTION\" || h.value != \"OK_NON_LOCAL, OK_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n\n    h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"OK_FINALLY\" || h.value != \"OK_LOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, exception: (e: Exception)-> Unit, exception2: (e: Exception)-> Unit, finallyBlock: ()-> String, res: String = \"Fail\") : String {\n    try {\n        block()\n    } catch (e: Exception1) {\n        exception(e)\n    } catch (e: Exception2) {\n        exception2(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\npublic inline fun <R> doCall2(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    throw RuntimeException(\"fail\")\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NON_LOCAL\"\n                    return \"OK_NON_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION1\"\n                    return \"OK_EXCEPTION1\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION2\"\n                    return \"OK_EXCEPTION2\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                    \"OK_FINALLY\"\n                })\n\n        return localResult;\n    }\n    catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        }\n        else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test01(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                throw Exception1(\"1\")\n                return \"OK_NON_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\nfun test02(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                throw Exception2(\"1\")\n                return \"OK_NON_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\nfun test1(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw Exception1(\"FAIL\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION1\"\n                    return \"OK_EXCEPTION1\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION2\"\n                    return \"OK_EXCEPTION2\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                    \"OK_FINALLY\"\n                }, \"Fail\")\n    }\n    catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        }\n        else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test2(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw Exception1(\"1\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION1\"\n                    throw Exception2(\"2\")\n                    \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION2\"\n                    \"OK_EXCEPTION2\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    \"OK_FINALLY\"\n                })\n        return localResult;\n    }\n    catch (e: Exception2) {\n        return \"CATCHED_EXCEPTION\"\n    }\n\n    return \"Fail\";\n}\n\nfun test3(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw Exception2(\"FAIL\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION1\"\n                    return \"OK_EXCEPTION1\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION2\"\n                    return \"OK_EXCEPTION2\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                    \"OK_FINALLY\"\n                }, \"Fail\")\n    }\n    catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        }\n        else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test4(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_LOCAL\"\n                    throw Exception2(\"1\")\n                    \"OK_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION1\"\n                    return \"OK_EXCEPTION\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION2\"\n                    throw Exception1(\"1\")\n                    \"OK_EXCEPTION2\"\n                },\n                {\n                    h.value += \", OK_FINALLY\"\n                    \"OK_FINALLY\"\n                })\n        return localResult;\n    }\n    catch (e: Exception1) {\n        return \"CATCHED_EXCEPTION\"\n    }\n\n    return \"Fail\";\n}\n\n\nfun test5(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_LOCAL\"\n                throw Exception2(\"FAIL\")\n                \"OK_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION\"\n                throw RuntimeException(\"FAIL_EX\")\n                \"OK_EXCEPTION\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            })\n\n\n    return localResult;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != \"CATCHED_EXCEPTION\" || h.value != \"OK_NON_LOCAL, OK_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test01 = test01(h)\n    if (test01 != \"OK_EXCEPTION1\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY\") return \"test01: ${test01}, holder: ${h.value}\"\n\n    h = Holder()\n    val test02 = test02(h)\n    if (test02 != \"OK_EXCEPTION2\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY\") return \"test02: ${test02}, holder: ${h.value}\"\n\n\n    h = Holder()\n    val test1 = test1(h)\n    if (test1 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION1, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h)\n    if (test2 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION1, OK_FINALLY\") return \"test2: ${test2}, holder: ${h.value}\"\n\n\n    h = Holder()\n    val test3 = test3(h)\n    if (test3 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION2, OK_FINALLY\") return \"test3: ${test3}, holder: ${h.value}\"\n\n    h = Holder()\n    val test4 = test4(h)\n    if (test4 != \"CATCHED_EXCEPTION\" || h.value != \"OK_LOCAL, OK_EXCEPTION2, OK_FINALLY\") return \"test4: ${test4}, holder: ${h.value}\"\n\n    h = Holder()\n    val test5 = test5(h)\n    if (test5 != \"OK_EXCEPTION2\" || h.value != \"OK_LOCAL, OK_EXCEPTION2, OK_FINALLY\") return \"test5: ${test5}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, exception1: (e: Exception)-> Unit, exception2: (e: Exception)-> Unit, finallyBlock: ()-> String,\n                         exception3: (e: Exception)-> Unit, exception4: (e: Exception)-> Unit, finallyBlock2: ()-> String, res: String = \"Fail\") : String {\n    try {\n        try {\n            block()\n        }\n        catch (e: Exception1) {\n            exception1(e)\n        }\n        catch (e: Exception2) {\n            exception2(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } catch (e: Exception1) {\n        exception3(e)\n    }\n    catch (e: Exception2) {\n        exception4(e)\n    }\n    finally {\n        finallyBlock2()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder, throwEx1: Boolean, throwEx2: Boolean, throwEx3: Boolean = false, throwEx4: Boolean = false): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                if (throwEx1) {\n                    throw Exception1(\"1\")\n                }\n                if (throwEx2) {\n                    throw Exception2(\"1\")\n                }\n                return \"OK_NON_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                if (throwEx3) {\n                    throw Exception1(\"3_1\")\n                }\n                if (throwEx4) {\n                    throw Exception2(\"4_1\")\n                }\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                if (throwEx3) {\n                    throw Exception1(\"3_2\")\n                }\n                if (throwEx4) {\n                    throw Exception2(\"4_2\")\n                }\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                h.value += \", OK_FINALLY1\"\n                try {\n                    try {\n                        throw Exception1(\"fail\")\n                    }\n                    catch (e: RuntimeException) {\n                        h.value += \", CATCHED1\"\n                    }\n                    finally {\n                        h.value += \", ADDITIONAL\"\n                    }\n                } finally {\n                    h.value += \" FINALLY1\"\n                }\n                \"OK_FINALLY1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION3\"\n                return \"OK_EXCEPTION3\"\n            },\n            {\n                h.value += \", OK_EXCEPTION4\"\n                return \"OK_EXCEPTION4\"\n            },\n            {\n                h.value += \", OK_FINALLY2\"\n                try {\n                    try {\n                        throw Exception1(\"fail2\")\n                    } catch (e: RuntimeException) {\n                        h.value += \", CATCHED2\"\n                    } finally {\n                        h.value += \", ADDITIONAL\"\n                    }\n                } finally {\n                    h.value += \" FINALLY2\"\n                }\n                \"OK_FINALLY2\"\n            })\n\n    return localResult;\n\n    return \"FAIL\";\n}\n\nfun box(): String {\n    var h = Holder()\n    var test0 = test0(h, false, false)\n    if (test0 != \"OK_NON_LOCAL\" || h.value != \"OK_NON_LOCAL, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_1: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, false)\n    if (test0 != \"OK_EXCEPTION1\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_2: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, true)\n    if (test0 != \"OK_EXCEPTION2\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_3: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, false, true, false)\n    if (test0 != \"OK_EXCEPTION3\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_EXCEPTION3, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_4: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, true, false, false, true)\n    if (test0 != \"OK_EXCEPTION4\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_EXCEPTION4, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_5: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, true, true, false)\n    if (test0 != \"OK_EXCEPTION3\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_EXCEPTION3, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_6: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, false, true, false, true)\n    if (test0 != \"OK_EXCEPTION4\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY1, CATCHED1, ADDITIONAL FINALLY1, OK_EXCEPTION4, OK_FINALLY2, CATCHED2, ADDITIONAL FINALLY2\") return \"test0_7: ${test0}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, exception: (e: Exception)-> Unit, exception2: (e: Exception)-> Unit, finallyBlock: ()-> String, res: String = \"Fail\") : String {\n    try {\n        block()\n    } catch (e: Exception1) {\n        exception(e)\n    } catch (e: Exception2) {\n        exception2(e)\n    } finally {\n        finallyBlock()\n    }\n    return res\n}\n\npublic inline fun <R> doCall2(block: ()-> R, exception: (e: Exception)-> Unit, finallyBlock: ()-> R) : R {\n    try {\n        return block()\n    } catch (e: Exception) {\n        exception(e)\n    } finally {\n        finallyBlock()\n    }\n    throw RuntimeException(\"fail\")\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: String = \"\"\n}\n\nfun test0(h: Holder): String {\n    try {\n        val localResult = doCall (\n                {\n                    h.value += \"OK_NON_LOCAL\"\n                    return \"OK_NON_LOCAL\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION1\"\n                    return \"OK_EXCEPTION1\"\n                },\n                {\n                    h.value += \", OK_EXCEPTION2\"\n                    return \"OK_EXCEPTION2\"\n                },\n                {\n                    try {\n                        h.value += \", OK_FINALLY\"\n                        throw RuntimeException(\"FINALLY\")\n                        \"OK_FINALLY\"\n                    } finally {\n                        h.value += \", OK_FINALLY_INNER\"\n                    }\n                })\n\n        return localResult;\n    }\n    catch (e: RuntimeException) {\n        if (e.message != \"FINALLY\") {\n            return \"FAIL in exception: \" + e.message\n        }\n        else {\n            return \"CATCHED_EXCEPTION\"\n        }\n    }\n\n    return \"FAIL\";\n}\n\nfun test01(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                throw Exception1(\"1\")\n                return \"OK_NON_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                try {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                } catch(e: RuntimeException) {\n                    h.value += \", OK_CATCHED\"\n                } finally {\n                    h.value += \", OK_FINALLY_INNER\"\n                }\n                \"OK_FINALLY\"\n            })\n\n    return localResult;\n}\n\nfun test02(h: Holder): String {\n    val localResult = doCall (\n            {\n                h.value += \"OK_NON_LOCAL\"\n                throw Exception2(\"1\")\n                return \"OK_NON_LOCAL\"\n            },\n            {\n                h.value += \", OK_EXCEPTION1\"\n                return \"OK_EXCEPTION1\"\n            },\n            {\n                h.value += \", OK_EXCEPTION2\"\n                return \"OK_EXCEPTION2\"\n            },\n            {\n                try {\n                    h.value += \", OK_FINALLY\"\n                    throw RuntimeException(\"FINALLY\")\n                } catch(e: RuntimeException) {\n                    h.value += \", OK_CATCHED\"\n                } finally {\n                    h.value += \", OK_FINALLY_INNER\"\n                }\n                \"OK_FINALLY\"\n            }, \"OK\")\n\n    return localResult;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h)\n    if (test0 != \"CATCHED_EXCEPTION\" || h.value != \"OK_NON_LOCAL, OK_FINALLY, OK_FINALLY_INNER\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test01 = test01(h)\n    if (test01 != \"OK_EXCEPTION1\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION1, OK_FINALLY, OK_CATCHED, OK_FINALLY_INNER\") return \"test01: ${test01}, holder: ${h.value}\"\n\n    h = Holder()\n    val test02 = test02(h)\n    if (test02 != \"OK_EXCEPTION2\" || h.value != \"OK_NON_LOCAL, OK_EXCEPTION2, OK_FINALLY, OK_CATCHED, OK_FINALLY_INNER\") return \"test02: ${test02}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun doCall(block: (i: Int)-> Int, fblock: (i: Int)-> Unit) : Int {\n    var res = 0;\n    for (i in 1..10) {\n        try {\n            res = block(i)\n        } finally {\n            for (i in 1..10) {\n                fblock(i)\n            }\n        }\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder {\n    var value: Int = 0\n}\n\nfun test1(): Int {\n    var s = 0\n    doCall (\n            {\n                s += it * it\n                s\n            },\n            {\n                s += it\n            }\n    )\n    return s;\n}\n\nfun test11(h: Holder): Int {\n    return doCall (\n            {\n                return -100\n            }, {\n                h.value += it\n            })\n}\n\n\nfun box(): String {\n    val test1 = test1()\n    if (test1 != 935) return \"test1: ${test1}\"\n\n    val h = Holder()\n    val test11 = test11(h)\n    if (test11 != -100 && h.value != 55) return \"test11: ${test11} holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder(var value: String = \"\") {\n\n    operator fun plusAssign(s: String?) {\n        if (value.length != 0) {\n            value += \" -> \"\n        }\n        value += s\n    }\n\n    override fun toString(): String {\n        return value\n    }\n\n}\n\npublic class Exception1(message: String) : RuntimeException(message)\n\npublic class Exception2(message: String) : RuntimeException(message)\n\npublic inline fun doCall(block: ()-> String, finallyBlock: ()-> String,\n                         tryBlock2: ()-> String, catchBlock2: ()-> String, res: String = \"Fail\") : String {\n    try {\n        block()\n    }\n    finally {\n        finallyBlock()\n        try {\n            tryBlock2()\n        } catch (e: Exception) {\n            catchBlock2()\n        }\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun test0(\n        h: Holder,\n        throwExternalFinEx1: Boolean = false,\n        res: String = \"Fail\"\n): String {\n    try {\n        val localResult = doCall (\n                {\n                    h += \"OK_NON_LOCAL\"\n                    return \"OK_NON_LOCAL\"\n                },\n                {\n                    h += \"OK_FINALLY1\"\n                    \"OK_FINALLY1\"\n                },\n                {\n                    h += \"innerTryBlock\"\n                    if (throwExternalFinEx1) {\n                        throw Exception1(\"EXCEPTION_IN_EXTERNAL_FINALLY\")\n                    }\n                    \"innerTryBlock\"\n                },\n                {\n                    h += \"CATCHBLOCK\"\n                    \"CATCHBLOCK\"\n                },\n                res)\n        return localResult;\n    } catch(e: Exception1) {\n        return e.message!!\n    } catch(e: Exception2) {\n        return e.message!!\n    }\n}\n\nfun box(): String {\n    var h = Holder()\n    var test0 = test0(h, res = \"OK\")\n    if (test0 != \"OK_NON_LOCAL\" || h.value != \"OK_NON_LOCAL -> OK_FINALLY1 -> innerTryBlock\") return \"test0_1: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    test0 = test0(h, throwExternalFinEx1 = true, res = \"OK\")\n    if (test0 != \"OK_NON_LOCAL\" || h.value != \"OK_NON_LOCAL -> OK_FINALLY1 -> innerTryBlock -> CATCHBLOCK\") return \"test0_2: ${test0}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\npublic inline fun <T, R> T.mylet(block: (T) -> R): R {\n    return block(this)\n}\n\n// FILE: 2.kt\nimport test.*\n\nvar message = \"\"\n\nfun foo(root: String) {\n    try {\n        root.let { _ ->\n            try {\n                if (!random()) {\n                    message += root\n                    return\n                }\n                message += \"fail $root\"\n                return\n            } catch (e: Exception) {\n                message += \"${e.message}\"\n            }\n            \"fail\"\n        }\n    } finally {\n        message += \" Finally block\"\n    }\n}\n\nvar exception = false\n\nfun random() = if (exception) error(\"Exception\") else false\n\nfun box(): String {\n    foo(\"OK\")\n    if (message != \"OK Finally block\") return \"fail 1: $message\"\n\n    message = \"\"\n    exception = true\n    foo(\"OK\")\n    if (message != \"Exception Finally block\" ) return \"fail 2: $message\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Holder {\n    var value: String = \"\"\n}\n\ninline fun <R> doCall(block: ()-> R, h: Holder) : R {\n    try {\n        return block()\n    } finally {\n        h.value += \", in doCall finally\"\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nval FINALLY_CHAIN = \"in local finally, in doCall finally, in external finally, in doCall finally, in global finally\"\n\nfun test1(holder: Holder, p: Int): String {\n    holder.value = \"start\"\n    return test2(holder) { i ->\n        if (p == i) {\n            return \"call $i\"\n        }\n    }\n}\n\ninline fun test2(holder: Holder, l: (s: Int) -> Unit): String {\n    try {\n        l(0)\n        var externalResult = doCall (ext@ {\n            l(1)\n            try {\n                l(2)\n                val internalResult = doCall (int@ {\n                    l(3)\n                    try {\n                        l(4)\n                        return \"fail\"\n                    }\n                    finally {\n                        holder.value += \", in local finally\"\n                    }\n                }, holder)\n            }\n            finally {\n                holder.value += \", in external finally\"\n            }\n        }, holder)\n\n        return \"fail\"\n    }\n    finally {\n        holder.value += \", in global finally\"\n    }\n}\n\nfun box(): String {\n    var holder = Holder()\n\n    var test1 = test1(holder, 0)\n    if (holder.value != \"start, in global finally\" || test1 != \"call 0\") return \"test1: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(holder, 1)\n    if (holder.value != \"start, in doCall finally, in global finally\" || test1 != \"call 1\")\n        return \"test2: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(holder, 2)\n    if (holder.value != \"start, in external finally, in doCall finally, in global finally\" || test1 != \"call 2\")\n        return \"test3: ${test1},  finally = ${holder.value}\"\n\n\n    test1 = test1(holder, 3)\n    if (holder.value != \"start, in doCall finally, in external finally, in doCall finally, in global finally\" || test1 != \"call 3\")\n        return \"test4: ${test1},  finally = ${holder.value}\"\n\n    test1 = test1(holder, 4)\n    if (holder.value != \"start, in local finally, in doCall finally, in external finally, in doCall finally, in global finally\" || test1 != \"call 4\")\n        return \"test5: ${test1},  finally = ${holder.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder {\n    public var value: String = \"\"\n}\n\npublic inline fun doCall2_2(block: () -> String, res: String, h: Holder): String {\n    try {\n        return doCall2_1(block, {\n            h.value += \", OK_EXCEPTION\"\n            return \"OK_EXCEPTION\"\n        }, res, h)\n    } finally{\n        h.value += \", DO_CALL_2_2_FINALLY\"\n    }\n}\n\npublic inline fun <R> doCall2_1(block: () -> R, exception: (e: Exception) -> Unit, res: R, h: Holder): R {\n    try {\n        return doCall2<R>(block, exception, {\n            h.value += \", OK_FINALLY\"\n            \"OK_FINALLY\"\n        }, res, h)\n    } finally {\n        h.value += \", DO_CALL_2_1_FINALLY\"\n    }\n}\n\npublic inline fun <R> doCall2(block: () -> R, exception: (e: Exception) -> Unit, finallyBlock: () -> Unit, res: R, h: Holder): R {\n    try {\n        try {\n            return block()\n        }\n        catch (e: Exception) {\n            exception(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } finally {\n        h.value += \", DO_CALL_2_FINALLY\"\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun test0(h: Holder, throwException: Boolean): Int {\n    val localResult = doCall2_2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (throwException) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            \"FAIL\",\n            h\n    )\n\n    return -1;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h, true)\n    if (test0 != -1 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, DO_CALL_2_FINALLY, DO_CALL_2_1_FINALLY, DO_CALL_2_2_FINALLY\")\n        return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test0(h, false)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY, DO_CALL_2_FINALLY, DO_CALL_2_1_FINALLY, DO_CALL_2_2_FINALLY\")\n        return \"test1: ${test1}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Holder {\n    var value: String = \"\"\n}\n\ninline fun doCall_1(block: ()-> Unit, h: Holder) {\n    try {\n        doCall(block) {\n            h.value += \", OF_FINALLY1\"\n            return\n        }\n    } finally {\n        h.value += \", DO_CALL_1_FINALLY\"\n    }\n}\n\ninline fun doCall_2(block: ()-> Unit, h: Holder) {\n    try {\n        doCall(block) {\n            try {\n                h.value += \", OF_FINALLY1\"\n                return\n            }\n            finally {\n                h.value += \", OF_FINALLY1_FINALLY\"\n            }\n        }\n    } finally {\n        h.value += \", DO_CALL_1_FINALLY\"\n    }\n}\n\ninline fun doCall(block: ()-> Unit, finallyBlock1: ()-> Unit) {\n    try {\n         block()\n    } finally {\n        finallyBlock1()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(h: Holder, doReturn: Int): String {\n    doCall_1 (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            h\n    )\n\n    return \"TEST1\";\n}\n\nfun test2(h: Holder, doReturn: Int): String {\n    doCall_2 (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            h\n    )\n\n    return \"TEST2\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test10 = test1(h, 0)\n    if (test10 != \"TEST1\" || h.value != \"OK_NONLOCAL, OF_FINALLY1, DO_CALL_1_FINALLY\") return \"test10: ${test10}, holder: ${h.value}\"\n\n    h = Holder()\n    val test11 = test1(h, 1)\n    if (test11 != \"TEST1\" || h.value != \"LOCAL, OF_FINALLY1, DO_CALL_1_FINALLY\") return \"test11: ${test11}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h, 0)\n    if (test2 != \"TEST2\" || h.value != \"OK_NONLOCAL, OF_FINALLY1, OF_FINALLY1_FINALLY, DO_CALL_1_FINALLY\") return \"test20: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test21 = test2(h, 1)\n    if (test21 != \"TEST2\" || h.value != \"LOCAL, OF_FINALLY1, OF_FINALLY1_FINALLY, DO_CALL_1_FINALLY\") return \"test21: ${test21}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Holder {\n    var value: String = \"\"\n}\n\ninline fun doCall_1(block: ()-> Unit, h: Holder) {\n    try {\n        doCall(block) {\n            h.value += \", OF_FINALLY1\"\n        }\n    } finally {\n        h.value += \", DO_CALL_1_FINALLY\"\n    }\n}\n\ninline fun doCall_2(block: ()-> Unit, h: Holder) {\n    try {\n        doCall(block) {\n            try {\n                h.value += \", OF_FINALLY1\"\n            }\n            finally {\n                h.value += \", OF_FINALLY1_FINALLY\"\n            }\n        }\n    } finally {\n        h.value += \", DO_CALL_1_FINALLY\"\n    }\n}\n\ninline fun doCall(block: ()-> Unit, finallyBlock1: ()-> Unit) {\n    try {\n         block()\n    } finally {\n        finallyBlock1()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(h: Holder, doReturn: Int): String {\n    doCall_1 (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            h\n    )\n\n    return \"TEST1\";\n}\n\nfun test2(h: Holder, doReturn: Int): String {\n    doCall_2 (\n            {\n                if (doReturn < 1) {\n                    h.value += \"OK_NONLOCAL\"\n                    return \"OK_NONLOCAL\"\n                }\n                h.value += \"LOCAL\"\n                \"OK_LOCAL\"\n            },\n            h\n    )\n\n    return \"TEST2\";\n}\n\nfun box(): String {\n    var h = Holder()\n    val test10 = test1(h, 0)\n    if (test10 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OF_FINALLY1, DO_CALL_1_FINALLY\") return \"test10: ${test10}, holder: ${h.value}\"\n\n    h = Holder()\n    val test11 = test1(h, 1)\n    if (test11 != \"TEST1\" || h.value != \"LOCAL, OF_FINALLY1, DO_CALL_1_FINALLY\") return \"test11: ${test11}, holder: ${h.value}\"\n\n    h = Holder()\n    val test2 = test2(h, 0)\n    if (test2 != \"OK_NONLOCAL\" || h.value != \"OK_NONLOCAL, OF_FINALLY1, OF_FINALLY1_FINALLY, DO_CALL_1_FINALLY\") return \"test20: ${test2}, holder: ${h.value}\"\n\n    h = Holder()\n    val test21 = test2(h, 1)\n    if (test21 != \"TEST2\" || h.value != \"LOCAL, OF_FINALLY1, OF_FINALLY1_FINALLY, DO_CALL_1_FINALLY\") return \"test21: ${test21}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder {\n    public var value: String = \"\"\n}\n\npublic inline fun <R> doCall2_2(block: () -> R, res: R, h: Holder): R {\n    return doCall2_1(block, {\n        h.value += \", OK_EXCEPTION\"\n        \"OK_EXCEPTION\"\n    }, res, h)\n}\n\npublic inline fun <R> doCall2_1(block: () -> R, exception: (e: Exception) -> Unit, res: R, h: Holder): R {\n    return doCall2<R>(block, exception, {\n        h.value += \", OK_FINALLY\"\n        \"OK_FINALLY\"\n    }, res)\n}\n\npublic inline fun <R> doCall2(block: () -> R, exception: (e: Exception) -> Unit, finallyBlock: () -> Unit, res: R): R {\n    try {\n        return block()\n    }\n    catch (e: Exception) {\n        exception(e)\n    }\n    finally {\n        finallyBlock()\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun test0(h: Holder, throwException: Boolean): Int {\n    val localResult = doCall2_2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (throwException) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            \"FAIL\",\n            h\n    )\n\n    return -1;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h, true)\n    if (test0 != -1 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test0(h, false)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder {\n    public var value: String = \"\"\n}\n\npublic inline fun <R> doCall2_2(block: () -> R, res: R, h: Holder): R {\n    return doCall2_1(block, {\n        h.value += \", OK_EXCEPTION\"\n        \"OK_EXCEPTION\"\n    }, res, h)\n}\n\npublic inline fun <R> doCall2_1(block: () -> R, exception: (e: Exception) -> Unit, res: R, h: Holder): R {\n    return doCall2<R>(block, exception, {\n        h.value += \", OK_FINALLY\"\n        \"OK_FINALLY\"\n    }, res, h)\n}\n\npublic inline fun <R> doCall2(block: () -> R, exception: (e: Exception) -> Unit, finallyBlock: () -> Unit, res: R, h: Holder): R {\n    try {\n        try {\n            return block()\n        }\n        catch (e: Exception) {\n            exception(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } finally {\n        h.value += \", DO_CALL_2_FINALLY\"\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun test0(h: Holder, throwException: Boolean): Int {\n    val localResult = doCall2_2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (throwException) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            \"FAIL\",\n            h\n    )\n\n    return -1;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h, true)\n    if (test0 != -1 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, DO_CALL_2_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test0(h, false)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY, DO_CALL_2_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder {\n    public var value: String = \"\"\n}\n\npublic inline fun doCall2_2(block: () -> String, res: String, h: Holder): String {\n    try {\n        return doCall2_1(block, {\n            h.value += \", OK_EXCEPTION\"\n            return \"OK_EXCEPTION\"\n        }, res, h)\n    } finally{\n        h.value += \", DO_CALL_2_2_FINALLY\"\n    }\n}\n\npublic inline fun <R> doCall2_1(block: () -> R, exception: (e: Exception) -> Unit, res: R, h: Holder): R {\n    try {\n        return doCall2<R>(block, exception, {\n            try {\n                h.value += \", OK_FINALLY\"\n                \"OK_FINALLY\"\n            } finally {\n                h.value += \", OK_FINALLY_NESTED\"\n            }\n        }, res, h)\n    } finally {\n        h.value += \", DO_CALL_2_1_FINALLY\"\n    }\n}\n\npublic inline fun <R> doCall2(block: () -> R, exception: (e: Exception) -> Unit, finallyBlock: () -> Unit, res: R, h: Holder): R {\n    try {\n        try {\n            return block()\n        }\n        catch (e: Exception) {\n            exception(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } finally {\n        h.value += \", DO_CALL_2_FINALLY\"\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun test0(h: Holder, throwException: Boolean): Int {\n    val localResult = doCall2_2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (throwException) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            \"FAIL\",\n            h\n    )\n\n    return -1;\n}\n\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h, true)\n\n    if (test0 != -1 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, OK_FINALLY_NESTED, DO_CALL_2_FINALLY, DO_CALL_2_1_FINALLY, DO_CALL_2_2_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test0(h, false)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY, OK_FINALLY_NESTED, DO_CALL_2_FINALLY, DO_CALL_2_1_FINALLY, DO_CALL_2_2_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Holder {\n    public var value: String = \"\"\n}\n\npublic inline fun <R> doCall2_2(block: () -> R, res: R, h: Holder): R {\n    try {\n        return doCall2_1(block, {\n            h.value += \", OK_EXCEPTION\"\n            \"OK_EXCEPTION\"\n        }, res, h)\n    } finally{\n        h.value += \", DO_CALL_2_2_FINALLY\"\n    }\n}\n\npublic inline fun <R> doCall2_1(block: () -> R, exception: (e: Exception) -> Unit, res: R, h: Holder): R {\n    try {\n        return doCall2<R>(block, exception, {\n            h.value += \", OK_FINALLY\"\n            \"OK_FINALLY\"\n        }, res, h)\n    } finally {\n        h.value += \", DO_CALL_2_1_FINALLY\"\n    }\n}\n\npublic inline fun <R> doCall2(block: () -> R, exception: (e: Exception) -> Unit, finallyBlock: () -> Unit, res: R, h: Holder): R {\n    try {\n        try {\n            return block()\n        }\n        catch (e: Exception) {\n            exception(e)\n        }\n        finally {\n            finallyBlock()\n        }\n    } finally {\n        h.value += \", DO_CALL_2_FINALLY\"\n    }\n    return res\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun test0(h: Holder, throwException: Boolean): Int {\n    val localResult = doCall2_2 (\n            {\n                h.value += \"OK_NONLOCAL\"\n                if (throwException) {\n                    throw RuntimeException()\n                }\n                return 1\n            },\n            \"FAIL\",\n            h\n    )\n\n    return -1;\n}\n\nfun box(): String {\n    var h = Holder()\n    val test0 = test0(h, true)\n    if (test0 != -1 || h.value != \"OK_NONLOCAL, OK_EXCEPTION, OK_FINALLY, DO_CALL_2_FINALLY, DO_CALL_2_1_FINALLY, DO_CALL_2_2_FINALLY\") return \"test0: ${test0}, holder: ${h.value}\"\n\n    h = Holder()\n    val test1 = test0(h, false)\n    if (test1 != 1 || h.value != \"OK_NONLOCAL, OK_FINALLY, DO_CALL_2_FINALLY, DO_CALL_2_1_FINALLY, DO_CALL_2_2_FINALLY\") return \"test1: ${test1}, holder: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\npublic inline fun <T> T.myapply(block: T.() -> Unit): T {\n    block()\n    return this\n}\n\n\n// FILE: 2.kt\nimport test.*\nvar globalResult = \"\"\n\nclass Test(val value: () -> String) {\n    fun test(): String {\n        globalResult = \"\"\n        try {\n            myapply {\n                try {\n                    return value()\n                } catch (e: Exception) {\n                    globalResult += \"Exception\"\n                } catch (e: Throwable) {\n                    globalResult += \"Throwable\"\n                }\n            }\n        } finally {\n            globalResult += \" Finally\"\n        }\n\n        return globalResult\n    }\n}\n\nfun box(): String {\n    Test { throw RuntimeException(\"123\")}.test()\n    if (globalResult != \"Exception Finally\") {\n        return \"fail 1: $globalResult\"\n    }\n\n    Test { throw Throwable(\"123\") }.test()\n    if (globalResult != \"Throwable Finally\") {\n        return \"fail 2: $globalResult\"\n    }\n\n    val result = Test { \"OK\" }.test()\n\n    if (globalResult != \" Finally\") {\n        return \"fail 3: $globalResult\"\n    }\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Z {}\n\nfun test1(nonLocal: String): String {\n\n    val localResult = doCall {\n        return nonLocal\n    }\n}\n\nfun box(): String {\n    val test2 = test1(\"OK_NONLOCAL\")\n    if (test2 != \"OK_NONLOCAL\") return \"test2: ${test2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <R> doCall(p: () -> R) {\n    p()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A {\n    var result = 0;\n\n    var field: Int\n        get() {\n            doCall { return 1 }\n            return 2\n        }\n        set(v: Int) {\n            doCall {\n                result = v / 2\n                return\n            }\n            result = v\n        }\n}\n\n\nfun box(): String {\n\n    val a = A()\n    if (a.field != 1) return \"fail 1: ${a.field}\"\n\n    a.field = 4\n    if (a.result != 2) return \"fail 2: ${a.result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(local: Int, nonLocal: String, doNonLocal: Boolean): String {\n\n    val localResult = doCall {\n        if (doNonLocal) {\n            return nonLocal\n        }\n        local\n    }\n\n    if (localResult == 11) {\n        return \"OK_LOCAL\"\n    }\n    else {\n        return \"LOCAL_FAILED\"\n    }\n}\n\nfun test2(local: Int, nonLocal: String, doNonLocal: Boolean): String {\n\n    val localResult = doCall {\n        if (doNonLocal) {\n            return@test2 nonLocal\n        }\n        local\n    }\n\n    if (localResult == 11) {\n        return \"OK_LOCAL\"\n    }\n    else {\n        return \"LOCAL_FAILED\"\n    }\n}\n\nfun box(): String {\n    var test1 = test1(11, \"fail\", false)\n    if (test1 != \"OK_LOCAL\") return \"test1: ${test1}\"\n\n    test1 = test1(-1, \"OK_NONLOCAL\", true)\n    if (test1 != \"OK_NONLOCAL\") return \"test2: ${test1}\"\n\n    var test2 = test2(11, \"fail\", false)\n    if (test2 != \"OK_LOCAL\") return \"test1: ${test2}\"\n\n    test2 = test2(-1, \"OK_NONLOCAL\", true)\n    if (test2 != \"OK_NONLOCAL\") return \"test2: ${test2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Holder(var value: Int)\n\nfun test1(holder: Holder, doNonLocal: Boolean) {\n    holder.value = -1;\n\n    val localResult = doCall {\n        if (doNonLocal) {\n            holder.value = 1000\n            return\n        }\n        10\n    }\n\n    holder.value = localResult\n}\n\n\nfun box(): String {\n    val h = Holder(-1)\n\n    test1(h, false)\n    if (h.value != 10) return \"test1: ${h.value}\"\n\n    test1(h, true)\n    if (h.value != 1000) return \"test2: ${h.value}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(local: Int, nonLocal: String, doNonLocal: Boolean): String {\n\n    val localResult = doCall(\n            fun (): Int {\n                if (doNonLocal) {\n                    return@test1 nonLocal\n                }\n                return local\n            })\n\n    if (localResult == 11) {\n        return \"OK_LOCAL\"\n    }\n    else {\n        return \"LOCAL_FAILED\"\n    }\n}\n\nfun test2(local: Int, nonLocal: String, doNonLocal: Boolean): String {\n\n    val localResult = doCall(\n            xxx@ fun(): Int {\n                if (doNonLocal) {\n                    return@test2 nonLocal\n                }\n                return@xxx local\n            })\n\n    if (localResult == 11) {\n        return \"OK_LOCAL\"\n    }\n    else {\n        return \"LOCAL_FAILED\"\n    }\n}\n\nfun test3(local: Int, nonLocal: String, doNonLocal: Boolean): String {\n\n    val localResult = doCall(\n            yy@ fun(): Int {\n                if (doNonLocal) {\n                    return@test3 nonLocal\n                }\n                return@yy local\n            })\n\n    if (localResult == 11) {\n        return \"OK_LOCAL\"\n    }\n    else {\n        return \"LOCAL_FAILED\"\n    }\n}\n\nfun box(): String {\n    var test1 = test1(11, \"fail\", false)\n    if (test1 != \"OK_LOCAL\") return \"test1: ${test1}\"\n\n    test1 = test1(-1, \"OK_NONLOCAL\", true)\n    if (test1 != \"OK_NONLOCAL\") return \"test2: ${test1}\"\n\n    var test2 = test2(11, \"fail\", false)\n    if (test2 != \"OK_LOCAL\") return \"test1: ${test2}\"\n\n    test2 = test2(-1, \"OK_NONLOCAL\", true)\n    if (test2 != \"OK_NONLOCAL\") return \"test2: ${test2}\"\n\n    var test3 = test3(11, \"fail\", false)\n    if (test3 != \"OK_LOCAL\") return \"test1: ${test3}\"\n\n    test3 = test3(-1, \"OK_NONLOCAL\", true)\n    if (test3 != \"OK_NONLOCAL\") return \"test2: ${test3}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(f: () -> Unit) {\n    try {\n        f()\n    }\n    finally {\n        1\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nvar p = \"fail\"\n\nfun test1() {\n    foo {\n        try {\n            p = \"O\"\n            return\n        } catch(e: Exception) {\n            return\n        } finally {\n            p += \"K\"\n        }\n    }\n}\n\nfun box(): String {\n    test1()\n    return p\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(nonLocal: String): String {\n    val localResult = doCall<String> {\n        return nonLocal\n    }\n\n    return \"NON_LOCAL_FAILED\"\n}\n\n\nfun box(): String {\n    return test1(\"OK\")\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport Kind.*\n\nenum class Kind {\n    LOCAL,\n    EXTERNAL,\n    GLOBAL\n}\n\nclass Internal(val value: String)\n\nclass External(val value: String)\n\nclass Global(val value: String)\n\nfun test1(intKind: Kind, extKind: Kind): Global {\n\n    var externalResult = doCall ext@ {\n\n        val internalResult = doCall int@ {\n            if (intKind == Kind.GLOBAL) {\n                return@test1 Global(\"internal -> global\")\n            } else if (intKind == EXTERNAL) {\n                return@ext External(\"internal -> external\")\n            }\n            return@int Internal(\"internal -> local\")\n        }\n\n        if (extKind == GLOBAL || extKind == EXTERNAL) {\n            return Global(\"external -> global\")\n        }\n\n        External(internalResult.value + \": external -> local\");\n    }\n\n    return Global(externalResult.value + \": exit\")\n}\n\nfun box(): String {\n    var test1 = test1(LOCAL, LOCAL).value\n    if (test1 != \"internal -> local: external -> local: exit\") return \"test1: ${test1}\"\n\n    test1 = test1(EXTERNAL, LOCAL).value\n    if (test1 != \"internal -> external: exit\") return \"test2: ${test1}\"\n\n    test1 = test1(GLOBAL, LOCAL).value\n    if (test1 != \"internal -> global\") return \"test3: ${test1}\"\n\n\n    test1 = test1(LOCAL, EXTERNAL).value\n    if (test1 != \"external -> global\") return \"test4: ${test1}\"\n\n    test1 = test1(EXTERNAL, EXTERNAL).value\n    if (test1 != \"internal -> external: exit\") return \"test5: ${test1}\"\n\n    test1 = test1(GLOBAL, EXTERNAL).value\n    if (test1 != \"internal -> global\") return \"test6: ${test1}\"\n\n\n    test1 = test1(LOCAL, GLOBAL).value\n    if (test1 != \"external -> global\") return \"test7: ${test1}\"\n\n    test1 = test1(EXTERNAL, GLOBAL).value\n    if (test1 != \"internal -> external: exit\") return \"test8: ${test1}\"\n\n    test1 = test1(GLOBAL, GLOBAL).value\n    if (test1 != \"internal -> global\") return \"test9: ${test1}\"\n\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(b: Boolean): String {\n    val localResult = doCall local@ {\n        if (b) {\n            return@local \"local\"\n        } else {\n            return \"nonLocal\"\n        }\n    }\n\n    return \"localResult=\" + localResult;\n}\n\nfun test2(nonLocal: String): String {\n    val localResult = doCall {\n        return nonLocal\n    }\n}\n\nfun box(): String {\n    val test1 = test1(true)\n    if (test1 != \"localResult=local\") return \"test1: ${test1}\"\n\n    val test2 = test1(false)\n    if (test2 != \"nonLocal\") return \"test2: ${test2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(b: Boolean): String {\n    val localResult = doCall ((local@ {\n        if (b) {\n            return@local \"local\"\n        } else {\n            return \"nonLocal\"\n        }\n    }))\n\n    return \"result=\" + localResult;\n}\n\nfun test2(nonLocal: String): String {\n    val localResult = doCall {\n        return nonLocal\n    }\n}\n\nfun box(): String {\n    val test1 = test1(true)\n    if (test1 != \"result=local\") return \"test1: ${test1}\"\n\n    val test2 = test1(false)\n    if (test2 != \"nonLocal\") return \"test2: ${test2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic fun <R> noInlineCall(block: ()-> R) : R {\n    return block()\n}\n\npublic inline fun <R> notUsed(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(b: Boolean): String {\n    val localResult = noInlineCall local@ {\n        if (b) {\n            return@local 1\n        } else {\n            return@local 2\n        }\n        3\n    }\n\n    return \"result=\" + localResult;\n}\n\nfun box(): String {\n    val test1 = test1(true)\n    if (test1 != \"result=1\") return \"test1: ${test1}\"\n\n    val test2 = test1(false)\n    if (test2 != \"result=2\") return \"test2: ${test2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doCall(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(b: Boolean): String {\n    val localResult = doCall local@ {\n        if (b) {\n            return@local \"local\"\n        } else {\n            return \"nonLocal\"\n        }\n    }\n\n    return \"localResult=\" + localResult;\n}\n\nfun test2(nonLocal: String): String {\n    val localResult = doCall {\n        return nonLocal\n    }\n}\n\nfun box(): String {\n    val test1 = test1(true)\n    if (test1 != \"localResult=local\") return \"test1: ${test1}\"\n\n    val test2 = test1(false)\n    if (test2 != \"nonLocal\") return \"test2: ${test2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\ninline fun <reified T : Enum<T>> myValues(): String {\n    val values = enumValues<T>()\n    return values.joinToString(\"\")\n}\n\nenum class Z {\n    O, K\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValues<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\ninline fun <reified Y : Enum<Y>> myValues2(): String {\n    val values = { enumValues<Y>() }()\n    return values.joinToString(\"\")\n}\n\ninline fun <reified T : Enum<T>> myValues(): String {\n    return myValues2<T>()\n}\n\nenum class Z {\n    O, K\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValues<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun myValueOf(): String {\n    return enumValueOf<Z>(\"OK\").name\n}\n\nenum class Z {\n    OK\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValueOf()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun stub() {}\n\nenum class Z {\n    OK\n}\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return  { enumValueOf<Z>(\"OK\").name  } ()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T : Enum<T>> myValueOf(): String {\n    return { enumValueOf<T>(\"OK\") }().name\n}\n\nenum class Z {\n    OK\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValueOf<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T : Enum<T>> myValueOf(): String {\n    return myValueOf2<T>()\n}\n\ninline fun <reified Y : Enum<Y>> myValueOf2(): String {\n    return enumValueOf<Y>(\"OK\").name\n}\n\n\nenum class Z {\n    OK\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValueOf<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\ninline fun <reified T : Enum<T>> myValues(): Array<T> {\n    return enumValues<T>()\n}\n\nenum class Z {\n    O, K;\n\n    val myParam = name\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(myValues<Z>())\n}\n\nfun test(myValues: Array<Z>): String {\n    return myValues.map { it.myParam }.joinToString (\"\");\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <reified X : Enum<X>> myValueOf(): String {\n    return enumValueOf<X>(\"OK\").name\n}\n\nenum class Z {\n    OK\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValueOf<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\ninline fun <reified Y : Enum<Y>> myValues2(): String {\n    val values = enumValues<Y>()\n    return values.joinToString(\"\")\n}\n\ninline fun <reified T : Enum<T>> myValues(): String {\n    return myValues2<T>()\n}\n\nenum class Z {\n    O, K\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValues<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <reified Z : Enum<Z>> myValueOf(): String {\n    return myValueOf2<Z>()\n}\n\ninline fun <reified Y : Enum<Y>> myValueOf2(): String {\n    return { enumValueOf<Y>(\"OK\").name }()\n}\n\n\nenum class Z {\n    OK\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValueOf<Z>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\ninline fun myValues(): String {\n    val values = enumValues<Z>()\n    return values.joinToString(\"\")\n}\n\nenum class Z {\n    O, K\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValues()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nvar result = \"\"\n\ninline fun <reified T : Enum<T>> renderOptions(render: (T) -> String) {\n    val values = enumValues<T>()\n    for (v in values) {\n        result += render(v)\n    }\n}\n\nenum class Z {\n    O, K;\n\n    val myParam = name\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    renderOptions<Z> {\n        it.myParam\n    }\n    return result\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\ninline fun <reified T : Enum<T>> myValues(): String {\n    val values = { enumValues<T>() }()\n    return values.joinToString(\"\")\n}\n\nenum class Z {\n    O, K\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return myValues<Z>()\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun Double.test(a: Int, b: Long, c: () -> String): String {\n    return \"${this}_${a}_${b}_${c()}\"\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var invokeOrder = \"\";\n    val expectedResult = \"1.0_0_1_L\"\n    val expectedInvokeOrder = \"1_0_L\"\n    var l = 1L\n    var i = 0\n\n    var result = 1.0.test(b = {invokeOrder += \"1_\"; l}(), a = {invokeOrder+=\"0_\"; i}(), c = {invokeOrder += \"L\"; \"L\"})\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 1: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n    invokeOrder = \"\";\n    result = 1.0.test(b = {invokeOrder += \"1_\"; l}(), c = {invokeOrder += \"L\"; \"L\"}, a = {invokeOrder+=\"0_\"; i}())\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 2: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n    invokeOrder = \"\";\n    result = 1.0.test(c = {invokeOrder += \"L\"; \"L\"}, b = {invokeOrder += \"1_\"; l}(), a = {invokeOrder+=\"0_\"; i}())\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 3: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n    invokeOrder = \"\";\n    result = 1.0.test(a = {invokeOrder+=\"0_\"; i}(), c = {invokeOrder += \"L\"; \"L\"}, b = {invokeOrder += \"1_\"; l}())\n    if (invokeOrder != \"0_1_L\" || result != expectedResult) return \"fail 4: $invokeOrder != 0_1_L or $result != $expectedResult\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun Double.test(a: Int, b: Long, crossinline c: () -> String): String {\n\n    return { \"${this}_${a}_${b}_${c()}\"} ()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var invokeOrder = \"\";\n    val expectedResult = \"1.0_0_1_9\"\n    val expectedInvokeOrder = \"1_0_9\"\n    var l = 1L\n    var i = 0\n    val captured = 9L\n\n    var result = 1.0.test(b = {invokeOrder += \"1_\"; l}(), a = {invokeOrder+=\"0_\"; i}(), c = {invokeOrder += \"$captured\"; \"$captured\"})\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 1: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n    invokeOrder = \"\";\n    result = 1.0.test(b = {invokeOrder += \"1_\"; l}(), c = {invokeOrder += \"${captured}\"; \"${captured}\"}, a = {invokeOrder+=\"0_\"; i}())\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 2: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n    invokeOrder = \"\";\n    result = 1.0.test(c = {invokeOrder += \"${captured}\"; \"${captured}\"}, b = {invokeOrder += \"1_\"; l}(), a = {invokeOrder+=\"0_\"; i}())\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 3: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n    invokeOrder = \"\";\n    result = 1.0.test(a = {invokeOrder+=\"0_\"; i}(), c = {invokeOrder += \"${captured}\"; \"${captured}\"}, b = {invokeOrder += \"1_\"; l}())\n    if (invokeOrder != \"0_1_9\" || result != expectedResult) return \"fail 4: $invokeOrder != 0_1_9 or $result != $expectedResult\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun test(a: String, b: String, c: () -> String): String {\n    return a + b + c();\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var res = \"\";\n    var call = test(b = {res += \"K\"; \"K\"}(), a = {res+=\"O\"; \"O\"}(), c = {res += \"L\"; \"L\"})\n    if (res != \"KOL\" || call != \"OKL\") return \"fail 1: $res != KOL or $call != OKL\"\n\n    res = \"\";\n    call = test(b = {res += \"K\"; \"K\"}(), c = {res += \"L\"; \"L\"}, a = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"OKL\") return \"fail 2: $res != KOL or $call != OKL\"\n\n\n    res = \"\";\n    call = test(c = {res += \"L\"; \"L\"}, b = {res += \"K\"; \"K\"}(), a = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"OKL\") return \"fail 3: $res != KOL or $call != OKL\"\n\n    return \"OK\"\n\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n// WITH_RUNTIME\n// IGNORE_BACKEND: NATIVE\npackage test\n\nopen class A(val value: String)\n\nvar invokeOrder = \"\"\n\ninline fun inlineFun(\n        vararg constraints: A,\n        receiver: String = { invokeOrder += \" default receiver\"; \"DEFAULT\" }(),\n        init: String\n): String {\n    return constraints.map { it.value }.joinToString() + \", \" + receiver + \", \" + init\n}\n\n// FILE: 2.kt\nimport test.*\n\n\nvar result = \"\"\nfun box(): String {\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(constraints = *arrayOf({ invokeOrder += \"constraints\";A(\"C\") }()),\n                       receiver = { invokeOrder += \" receiver\"; \"R\" }(),\n                       init = { invokeOrder += \" init\"; \"I\" }())\n    if (result != \"C, R, I\") return \"fail 1: $result\"\n\n    //Change test after KT-17691 FIX; and remove cloned test for Native (enable this).\n    if (invokeOrder != \" receiver initconstraints\") return \"fail 2: $invokeOrder\"\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(init = { invokeOrder += \"init\"; \"I\" }(),\n                       constraints = *arrayOf({ invokeOrder += \"constraints\";A(\"C\") }()),\n                       receiver = { invokeOrder += \" receiver\"; \"R\" }()\n    )\n    if (result != \"C, R, I\") return \"fail 3: $result\"\n    //Change test after KT-17691 FIX\n    if (invokeOrder != \"init receiverconstraints\") return \"fail 4: $invokeOrder\"\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(init = { invokeOrder += \"init\"; \"I\" }(),\n                       constraints = *arrayOf({ invokeOrder += \" constraints\";A(\"C\") }()))\n    if (result != \"C, DEFAULT, I\") return \"fail 5: $result\"\n    if (invokeOrder != \"init constraints default receiver\") return \"fail 6: $invokeOrder\"\n\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\nclass Z(val p: String) {\n\n    inline fun test(a: String, b: String, c: () -> String): String {\n        return a + b + c() + p;\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var res = \"\";\n    var call = Z(\"Z\").test(a = {res += \"K\"; \"K\"}(), b = {res+=\"O\"; \"O\"}(), c = {res += \"L\"; \"L\"})\n    if (res != \"KOL\" || call != \"KOLZ\") return \"fail 1: $res != KOL or $call != KOLZ\"\n\n    res = \"\";\n    call = Z(\"Z\").test(a = {res += \"K\"; \"K\"}(), c = {res += \"L\"; \"L\"}, b = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"KOLZ\") return \"fail 2: $res != KOL or $call != KOLZ\"\n\n\n    res = \"\";\n    call = Z(\"Z\").test(c = {res += \"L\"; \"L\"}, a = {res += \"K\"; \"K\"}(), b = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"KOLZ\") return \"fail 3: $res != KOL or $call != KOLZ\"\n\n    return \"OK\"\n\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun test(a: String, b: String, c: () -> String): String {\n    return a + b + c();\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nvar res = \"\"\n\nfun String.id() = this\n\nval receiver: String\n    get() {\n        res += \"L\"\n        return \"L\"\n    }\n\n\nfun box(): String {\n    res = \"\"\n    var call = test(b = { res += \"K\"; \"K\" }(), a = { res += \"O\"; \"O\" }(), c = receiver::id)\n    if (res != \"KOL\" || call != \"OKL\") return \"fail 1: $res != KOL or $call != OKL\"\n\n    res = \"\"\n    call = test(b = { res += \"K\"; \"K\" }(), c = receiver::id, a = { res += \"O\"; \"O\" }())\n    if (res != \"KLO\" || call != \"OKL\") return \"fail 2: $res != KLO or $call != OKL\"\n\n\n    res = \"\"\n    call = test(c = receiver::id, b = { res += \"K\"; \"K\" }(), a = { res += \"O\"; \"O\" }())\n    if (res != \"LKO\" || call != \"OKL\") return \"fail 3: $res != LKO or $call != OKL\"\n\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\nclass Z(val p: String) {\n     inline fun test(a: String, b: String, c: () -> String): String {\n        return a + b + c() + p;\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var res = \"\";\n    var call = Z(\"Z\").test(b = {res += \"K\"; \"K\"}(), a = {res+=\"O\"; \"O\"}(), c = {res += \"L\"; \"L\"})\n    if (res != \"KOL\" || call != \"OKLZ\") return \"fail 1: $res != KOL or $call != OKLZ\"\n\n    res = \"\";\n    call = Z(\"Z\").test(b = {res += \"K\"; \"K\"}(), c = {res += \"L\"; \"L\"}, a = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"OKLZ\") return \"fail 2: $res != KOL or $call != OKLZ\"\n\n\n    res = \"\";\n    call = Z(\"Z\").test(c = {res += \"L\"; \"L\"}, b = {res += \"K\"; \"K\"}(), a = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"OKLZ\") return \"fail 3: $res != KOL or $call != OKLZ\"\n\n    return \"OK\"\n\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nopen class A(val value: String)\n\nvar invokeOrder = \"\"\n\ninline fun inlineFun(\n        receiver: String = { invokeOrder += \" default receiver\"; \"DEFAULT\" }(),\n        init: String,\n        vararg constraints: A\n): String {\n    return constraints.map { it.value }.joinToString() + \", \" + receiver + \", \" + init\n}\n\n// FILE: 2.kt\nimport test.*\n\n\nvar result = \"\"\nfun box(): String {\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(constraints = *arrayOf({ invokeOrder += \"constraints\";A(\"C\") }()),\n                       receiver = { invokeOrder += \" receiver\"; \"R\" }(),\n                       init = { invokeOrder += \" init\"; \"I\" }())\n    if (result != \"C, R, I\") return \"fail 1: $result\"\n\n    //Change test after KT-17691 FIX\n    if (invokeOrder != \" receiver initconstraints\") return \"fail 2: $invokeOrder\"\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(init = { invokeOrder += \"init\"; \"I\" }(),\n                       constraints = *arrayOf({ invokeOrder += \"constraints\";A(\"C\") }()),\n                       receiver = { invokeOrder += \" receiver\"; \"R\" }()\n    )\n    if (result != \"C, R, I\") return \"fail 3: $result\"\n    //Change test after KT-17691 FIX\n    if (invokeOrder != \"init receiverconstraints\") return \"fail 4: $invokeOrder\"\n\n    result = \"\"\n    invokeOrder = \"\"\n    result = inlineFun(init = { invokeOrder += \"init\"; \"I\" }(),\n                       constraints = *arrayOf({ invokeOrder += \" constraints\";A(\"C\") }()))\n    if (result != \"C, DEFAULT, I\") return \"fail 5: $result\"\n    if (invokeOrder != \"init constraints default receiver\") return \"fail 6: $invokeOrder\"\n\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun test(a: Int, b: Long, crossinline c: () -> String): String {\n    return { \"${a}_${b}_${c()}\"} ()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var invokeOrder = \"\";\n    val expectedResult = \"0_1_9\"\n    val expectedInvokeOrder = \"1_0_9\"\n    var l = 1L\n    var i = 0\n    val captured = 9L\n\n    var result = test(b = {invokeOrder += \"1_\"; l}(), a = {invokeOrder+=\"0_\"; i}(), c = {invokeOrder += \"$captured\"; \"$captured\"})\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 1: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n    invokeOrder = \"\";\n    result = test(b = {invokeOrder += \"1_\"; l}(), c = {invokeOrder += \"$captured\"; \"$captured\"}, a = {invokeOrder+=\"0_\"; i}())\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 2: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n    invokeOrder = \"\";\n    result = test(c = {invokeOrder += \"$captured\"; \"$captured\"}, b = {invokeOrder += \"1_\"; l}(), a = {invokeOrder+=\"0_\"; i}())\n    if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 3: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n    invokeOrder = \"\";\n    result = test(a = {invokeOrder+=\"0_\"; i}(), c = {invokeOrder += \"$captured\"; \"$captured\"}, b = {invokeOrder += \"1_\"; l}())\n    if (invokeOrder != \"0_1_9\" || result != expectedResult) return \"fail 4: $invokeOrder != 0_1_9 or $result != $expectedResult\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun test(a: String, b: Long, c: () -> String): String {\n    return a + b + c();\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nvar res = \"\"\n\nfun String.id() = this\n\nval receiver: String\n    get() {\n        res += \"L\"\n        return \"L\"\n    }\n\n\nfun box(): String {\n    res = \"\"\n    var call = test(b = { res += \"K\"; 1L }(), a = { res += \"O\"; \"O\" }(), c = receiver::id)\n    if (res != \"KOL\" || call != \"O1L\") return \"fail 1: $res != KOL or $call != O1L\"\n\n    res = \"\"\n    call = test(b = { res += \"K\"; 1L }(), c = receiver::id, a = { res += \"O\"; \"O\" }())\n    if (res != \"KLO\" || call != \"O1L\") return \"fail 2: $res != KLO or $call != O1L\"\n\n\n    res = \"\"\n    call = test(c = receiver::id, b = { res += \"K\"; 1L }(), a = { res += \"O\"; \"O\" }())\n    if (res != \"LKO\" || call != \"O1L\") return \"fail 3: $res != LKO or $call != O1L\"\n\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nclass Z {\n    inline fun Double.test(a: Int, b: Long, c: () -> String): String {\n        return \"${this}_${a}_${b}_${c()}\"\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    with (Z()) {\n        var invokeOrder = \"\";\n        val expectedResult = \"1.0_0_1_L\"\n        val expectedInvokeOrder = \"1_0_L\"\n        var l = 1L\n        var i = 0\n\n        var result = 1.0.test(b = { invokeOrder += \"1_\"; l }(), a = { invokeOrder += \"0_\"; i }(), c = { invokeOrder += \"L\"; \"L\" })\n        if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 1: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n        invokeOrder = \"\";\n        result = 1.0.test(b = { invokeOrder += \"1_\"; l }(), c = { invokeOrder += \"L\"; \"L\" }, a = { invokeOrder += \"0_\"; i }())\n        if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 2: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n        invokeOrder = \"\";\n        result = 1.0.test(c = { invokeOrder += \"L\"; \"L\" }, b = { invokeOrder += \"1_\"; l }(), a = { invokeOrder += \"0_\"; i }())\n        if (invokeOrder != expectedInvokeOrder || result != expectedResult) return \"fail 3: $invokeOrder != $expectedInvokeOrder or $result != $expectedResult\"\n\n\n        invokeOrder = \"\";\n        result = 1.0.test(a = { invokeOrder += \"0_\"; i }(), c = { invokeOrder += \"L\"; \"L\" }, b = { invokeOrder += \"1_\"; l }())\n        if (invokeOrder != \"0_1_L\" || result != expectedResult) return \"fail 4: $invokeOrder != 0_1_L or $result != $expectedResult\"\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun test(a: String, b: String, c: () -> String): String {\n    return a + b + c();\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var res = \"\";\n    var call = test(a = {res += \"K\"; \"K\"}(), b = {res+=\"O\"; \"O\"}(), c = {res += \"L\"; \"L\"})\n    if (res != \"KOL\" || call != \"KOL\") return \"fail 1: $res != KOL or $call != KOL\"\n\n    res = \"\";\n    call = test(a = {res += \"K\"; \"K\"}(), c = {res += \"L\"; \"L\"}, b = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"KOL\") return \"fail 2: $res != KOL or $call != KOL\"\n\n\n    res = \"\";\n    call = test(c = {res += \"L\"; \"L\"}, a = {res += \"K\"; \"K\"}(), b = {res+=\"O\"; \"O\"}())\n    if (res != \"KOL\" || call != \"KOL\") return \"fail 3: $res != KOL or $call != KOL\"\n\n    return \"OK\"\n\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun test(cond: Boolean, crossinline cif: () -> String): String {\n    return if (cond) {\n        { cif() }()\n    }\n    else {\n        cif()\n    }\n}\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val s = \"OK\"\n    return test(true) {\n        {\n            s\n        }()\n    }\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun bar(crossinline y: () -> String) = {\n    { { call(y) }() }()\n}\n\npublic inline fun <T> call(f: () -> T): T = f()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return bar {\"OK\"} ()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nabstract class A<R> {\n    abstract fun getO() : R\n\n    abstract fun getK() : R\n}\n\n\ninline fun <R> doWork(job: ()-> R) : R {\n    return job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box() : String {\n    val o = \"O\"\n    val p = \"GOOD\"\n    val result = doWork {\n        val k = \"K\"\n        val s = object : A<String>() {\n\n            val param = p;\n\n            override fun getO(): String {\n                return o;\n            }\n\n            override fun getK(): String {\n                return k;\n            }\n        }\n\n        s.getO() + s.getK() + s.param\n    }\n\n    if (result != \"OKGOOD\") return \"fail $result\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun inline1(crossinline action: () -> Unit) {\n    { action () }\n    action();\n}\n\ninline fun inline2(crossinline action: () -> Unit) = { action() }\n\n\n// FILE: 2.kt\nimport test.*\n\nvar result = \"fail\"\nfun box(): String {\n    inline1 { inline2 { result =\"OK\" }() }\n\n    return result\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninternal class A {\n    inline fun doSomething(): String  {\n        return {\n            \"OK\"\n        }()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return A().doSomething()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninternal interface A<T> {\n    fun run(): T;\n}\n\ninternal inline fun bar(crossinline y: () -> String) = object : A<String> {\n    override fun run() : String {\n        return call(y)\n    }\n}\n\npublic inline fun <T> call(crossinline f: () -> T): T = object : A<T> {\n    override fun run() : T {\n        return f()\n    }\n}.run()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return bar { \"OK\" }.run()\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\nenum class X {\n    A,\n    B\n}\n\ninline fun test(x: X, s: (X) -> String): String {\n    return s(x)\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test(X.A) {\n        when(it) {\n            X.A-> \"O\"\n            X.B-> \"K\"\n        }\n    } + test(X.B) {\n        when(it) {\n            X.A-> \"O\"\n            X.B-> \"K\"\n        }\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nenum class X {\n    A,\n    B\n}\n\nenum class Y {\n    A,\n    B\n}\n\ninline fun test(e: X): String {\n    return when(e) {\n        X.A-> \"O\"\n        X.B-> \"K\"\n    }\n}\n\nfun funForAdditionalMappingArrayInMappingFile(e: Y): String {\n    return when(e) {\n        Y.A-> \"O\"\n        Y.B-> \"K\"\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test(X.A) + test(X.B)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nenum class X {\n    A,\n    B\n}\n\ninline fun test(e: X): String {\n    return when(e) {\n        X.A-> \"O\"\n        X.B-> \"K\"\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test(X.A) + test(X.B)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nenum class X {\n    A,\n    B\n}\n\nenum class Y {\n    A,\n    B\n}\n\nfun funForAdditionalMappingArrayInMappingFile(e: Y): String {\n    return when(e) {\n        Y.A-> \"O\"\n        Y.B-> \"K\"\n    }\n}\n\ninline fun test(e: X): String {\n    return when(e) {\n        X.A-> \"O\"\n        X.B-> \"K\"\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test(X.A) + test(X.B)\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: NATIVE\n// FILE: 1.kt\npackage test\n\ninline fun <reified T> makeRunnable(noinline lambda: ()->Unit) : Runnable {\n    return Runnable(lambda)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n\n    makeRunnable<String> { result = \"OK\" }.run()\n\n    return result\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    object {\n                        val inflater = prop\n                    }.inflater\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> inlineFun(arg: T, crossinline f: (T) -> Unit) {\n    {\n        f(arg)\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val param = \"start\"\n    var result = \"fail\"\n    inlineFun(\"1\")  { c ->\n        {\n            inlineFun(\"2\") { a ->\n                {\n                    result = param + c + a\n                }()\n            }\n        }()\n    }\n\n    return if (result == \"start12\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> inlineFun(arg: T, crossinline f: (T) -> Unit) {\n    {\n        f(arg)\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val param = \"start\"\n    var result = \"fail\"\n\n    inlineFun(\"2\") { a ->\n        {\n            result = param + a\n        }()\n    }\n\n\n    return if (result == \"start2\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun <T> inlineFun(arg: T, f: (T) -> Unit) {\n    f(arg)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val param = \"start\"\n    var result = \"fail\"\n    inlineFun(\"1\")  { c ->\n        {\n            inlineFun(\"2\") { a ->\n                {\n                    {\n                        result = param + c + a\n                    }()\n                }()\n            }\n        }()\n    }\n\n    return if (result == \"start12\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface  A {\n    fun run()\n}\n\ninline fun testNested(crossinline f: (String) -> Unit) {\n    object : A {\n        override fun run() {\n            f(\"OK\")\n        }\n    }.run()\n}\n\ninline fun test(crossinline f: (String) -> Unit) {\n    testNested { it ->  { f(it) }()}\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    test { it -> result = it }\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> inlineFun(arg: T, crossinline f: (T) -> Unit) {\n    {\n        f(arg)\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val param = \"start\"\n    var result = \"fail\"\n    inlineFun(\"1\")  { c ->\n        {\n            inlineFun(\"2\") { a ->\n                {\n                    {\n                        result = param + c + a\n                    }()\n                }()\n            }\n        }()\n    }\n\n    return if (result == \"start12\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface  A {\n    fun run()\n}\n\ninline fun testNested(crossinline f: (String) -> Unit) {\n    object : A {\n        override fun run() {\n            f(\"OK\")\n        }\n    }.run()\n}\n\nfun test(f: (String) -> Unit) {\n    testNested { it ->  { f(it) }()}\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    test { it -> result = it }\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun inline1(crossinline action: () -> Unit) {\n    { action () }\n    action();\n}\n\ninline fun inline2(crossinline action: () -> Unit) = {\n    action()\n}\n\n\n// FILE: 2.kt\nimport test.*\n\nvar result = \"fail\"\nfun box(): String {\n    inline1 {\n        inline2 { { result =\"OK\" }() }()\n    }\n\n    return result\n}\n\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\nannotation class MethodAnnotation\n\ninline fun reproduceIssue(crossinline s: () -> String): String {\n    val obj = object {\n        @MethodAnnotation fun annotatedMethod(): String {\n            return s()\n        }\n    }\n    val annotatedMethod = obj::class.java.declaredMethods.first { it.name == \"annotatedMethod\" }\n    if (annotatedMethod.annotations.isEmpty()) return \"fail: can't find annotated method\"\n    return obj.annotatedMethod()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return reproduceIssue { \"OK\" }\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM\n// FILE: 1.kt\npackage test\n\nopen class C(val x: () -> String)\n\ninline fun f(crossinline g: () -> String) = object : C({ g() }) {}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String = f { \"OK\" }.x()\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\nabstract class A<R> {\n    abstract fun getO() : R\n\n    abstract fun getK() : R\n\n    abstract fun getParam() : R\n}\n\ninline fun <R> doWork(crossinline jobO: ()-> R, crossinline jobK: ()-> R, param: R) : A<R> {\n    val s = object : A<R>() {\n\n        override fun getO(): R {\n            return jobO()\n        }\n        override fun getK(): R {\n            return  jobK()\n        }\n\n        override fun getParam(): R {\n            return param\n        }\n    }\n    return s;\n}\n\ninline fun <R> doWorkInConstructor(crossinline jobO: ()-> R, crossinline jobK: ()-> R, param: R) : A<R> {\n    val s = object : A<R>() {\n\n        val p = param;\n\n        val o1 = jobO()\n\n        val k1 = jobK()\n\n        override fun getO(): R {\n            return o1\n        }\n        override fun getK(): R {\n            return k1\n        }\n\n        override fun getParam(): R {\n            return p\n        }\n    }\n    return s;\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(): String {\n    val o = \"O\"\n\n    val result = doWork ({o}, {\"K\"}, \"GOOD\")\n\n    return result.getO() + result.getK() + result.getParam()\n}\n\nfun test2() : String {\n    //same names as in object\n    val o1 = \"O\"\n    val k1 = \"K\"\n\n    val result = doWorkInConstructor ({o1}, {k1}, \"GOOD\")\n\n    return result.getO() + result.getK() + result.getParam()\n}\n\nfun box() : String {\n    val result1 = test1();\n    if (result1 != \"OKGOOD\") return \"fail1 $result1\"\n\n    val result2 = test2();\n    if (result2 != \"OKGOOD\") return \"fail2 $result2\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\npublic inline fun myRun(block: () -> Unit) {\n    return block()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    var res = \"\"\n    myRun {\n        val x = object {\n            fun foo() {\n                res = \"OK\"\n            }\n        }\n        object {\n            fun bar() = x.foo()\n        }.bar()\n    }\n\n    return res\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninternal class A {\n    inline fun doSomething(s: String): String  {\n        return {\n            s\n        }()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return A().doSomething(\"OK\")\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n\npackage test\n\ninline fun foo(value: String, crossinline s: () -> String): String {\n    val x = { value }\n    return java.util.concurrent.Callable(x).call() + { s() }()\n}\n\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return foo(\"O\") { \"K\" }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n\npackage test\nimport java.util.concurrent.Executors\n\ninline fun doWork(noinline job: ()-> Unit) {\n    Executors.callable(job).call()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    var result = \"fail\"\n    doWork { result = \"OK\" }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n\npackage test\n\nimport java.util.concurrent.Callable\n\nfun test(): String  = \"\"\n\ninline fun String.switchMapOnce(crossinline mapper: (String) -> String): String {\n    Callable(::test)\n    return { mapper(this) }()\n}\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    return \"O\".switchMapOnce {\n\n        \"K\".switchMapOnce {\n            \"OK\"\n        }\n    }\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n\npackage test\nimport java.util.concurrent.Executors\n\ninline fun doWork(noinline job: ()-> Unit) {\n    Executors.callable(job).call()\n    Executors.callable(job).call()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    var result = \"\"\n    var value = 1\n    doWork { result += if (value++ == 1) \"O\" else \"K\" }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n\npackage test\nimport java.util.concurrent.Executors\n\ninline fun doWork(noinline job: ()-> Unit) {\n    { Executors.callable(job).call() } ()\n    Executors.callable(job).call()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    var result = \"\"\n    var value = 1\n    doWork { result += if (value++ == 1) \"O\" else \"K\" }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n\npackage test\n\ninline fun doWork(job: ()-> Unit) {\n    job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\nimport java.util.concurrent.Executors\n\nfun box() : String {\n    var result = \"fail\"\n    doWork {\n        val job = { result = \"OK\" }\n        Executors.callable(job).call()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun f(crossinline g: () -> Unit) = Runnable(object : () -> Unit {\n    override fun invoke() = g()\n})\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    var result = \"FAIL\"\n    f { result = \"OK\" }.run()\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface Run {\n    fun run(): String\n}\n\ninline fun i2(crossinline s: () -> String): Run {\n    return i1 {\n        object : Run {\n            override fun run(): String {\n                return s()\n            }\n        }.run()\n    }\n}\n\ninline fun i1(crossinline s: () -> String): Run {\n    return object : Run {\n        override fun run(): String {\n            return s()\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\ninline fun i4(crossinline s: () -> String): Run {\n    return i3 {\n        object : Run {\n            override fun run(): String {\n                return s()\n            }\n        }.run()\n    }\n}\n\ninline fun i3(crossinline s: () -> String): Run {\n    return i2 {\n        object : Run {\n            override fun run(): String {\n                return s()\n            }\n        }.run()\n    }\n}\n\nfun box(): String {\n    val i4 = i4 { \"OK\" }\n    return i4.run()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninterface Foo {\n    fun call(): String\n}\n\ninline fun f(crossinline g: () -> String) = object: Foo {\n    fun <T> foo() = g()\n    fun <T> bar() = \"K\"\n    override fun call(): String = foo<String>() + bar<String>()\n}\n\n// FILE: 2.kt\nimport test.*\n\nval x = f { \"O\" }\n\nfun box() : String {\n    return x.call()\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    inlineFun {\n                        noInline {\n                            object {\n                                val inflater = prop\n                            }.inflater\n                        }\n                    }\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun inline1(crossinline action: () -> Unit) {\n    action();\n    { action() }()\n}\n\ninline fun inline2(crossinline action: () -> Unit) = { action() }\n\n\n// FILE: 2.kt\nimport test.*\n\nvar result = \"fail\"\nfun box(): String {\n    inline1 { inline2 { result = \"OK\" }() }\n\n    return result\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface IZ {\n    fun z()\n}\n\ninterface IZZ : IZ {\n    fun zz()\n}\n\ninline fun implZZ(zImpl: IZ, crossinline zzImpl: () -> Unit): IZZ =\n        object : IZZ, IZ by zImpl {\n            override fun zz() = zzImpl()\n        }\n\n\n// FILE: 2.kt\n\nimport test.*\n\nvar result = \"fail\";\n\nobject ZImpl : IZ {\n    override fun z() {\n        result = \"O\"\n    }\n}\n\nfun box(): String {\n    val zz = implZZ(ZImpl) { result += \"K\" }\n    zz.z()\n    zz.zz()\n    return result\n}\n\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    val param = \"start\"\n    var result = \"fail\"\n    var addParam = \"_additional_\"\n\n    inline fun inlineFun(arg: String, crossinline f: (String) -> Unit) {\n        {\n            f(arg + addParam)\n        }()\n    }\n\n    fun box(): String {\n        inlineFun(\"1\") { c ->\n            {\n                inlineFun(\"2\") { a ->\n                    {\n                        result = param + c + a\n                    }()\n                }\n            }()\n        }\n\n        return if (result == \"start1_additional_2_additional_\") \"OK\" else \"fail: $result\"\n    }\n\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().box()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    val param = \"start\"\n    var result = \"fail\"\n    var addParam = \"_additional_\"\n\n    inline fun inlineFun(arg: String, crossinline f: (String) -> Unit) {\n        {\n            f(arg + addParam)\n        }()\n    }\n\n    fun box(): String {\n        {\n            inlineFun(\"1\") { c ->\n                inlineFun(\"2\") { a ->\n                    {\n                        {\n                            result = param + c + a\n                        }()\n                    }()\n                }\n\n            }\n        }()\n\n        return if (result == \"start1_additional_2_additional_\") \"OK\" else \"fail: $result\"\n    }\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().box()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    val param = \"start\"\n    var result = \"fail\"\n    var addParam = \"_additional_\"\n\n    inline fun inlineFun(arg: String, crossinline f: (String) -> Unit) {\n        {\n            f(arg + addParam)\n        }()\n    }\n\n\n    fun box(): String {\n        inlineFun(\"2\") { a ->\n            {\n                result = param + a\n            }()\n        }\n        return if (result == \"start2_additional_\") \"OK\" else \"fail: $result\"\n    }\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().box()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    val param = \"start\"\n    var result = \"fail\"\n    var addParam = \"_additional_\"\n\n    inline fun inlineFun(arg: String, crossinline f: (String) -> Unit) {\n        {\n            f(arg + addParam)\n        }()\n    }\n\n\n    fun box(): String {\n        {\n            inlineFun(\"2\") { a ->\n                {\n                    result = param + a\n                }()\n            }\n        }()\n        return if (result == \"start2_additional_\") \"OK\" else \"fail: $result\"\n    }\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().box()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    val param = \"start\"\n    var result = \"fail\"\n    var addParam = \"_additional_\"\n\n    inline fun inlineFun(arg: String, f: (String) -> Unit) {\n        f(arg + addParam)\n    }\n\n    fun box(): String {\n        inlineFun(\"1\") { c ->\n            {\n                inlineFun(\"2\") { a ->\n                    {\n                        {\n                            result = param + c + a\n                        }()\n                    }()\n                }\n            }()\n        }\n\n        return if (result == \"start1_additional_2_additional_\") \"OK\" else \"fail: $result\"\n    }\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().box()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface A {\n    fun run()\n}\n\nclass B(val o: String, val k: String) {\n\n    inline fun testNested(crossinline f2: (String) -> Unit, crossinline f3: (String) -> Unit) {\n        object : A {\n            override fun run() {\n                f2(o)\n                f3(k)\n            }\n        }.run()\n    }\n\n    inline fun test(crossinline f: (String) -> Unit) {\n        testNested ({ it ->  f(it + o) }) { it -> f(it + k) }\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"\"\n    B(\"O\", \"K\").test { it -> result += it }\n    return if (result == \"OOKK\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface A {\n    fun run()\n}\n\nclass B(val o: String, val k: String) {\n\n    inline fun testNested(crossinline f: (String) -> Unit) {\n        object : A {\n            override fun run() {\n                f(o)\n            }\n        }.run()\n    }\n\n    inline fun test(crossinline f: (String) -> Unit) {\n        testNested { it -> { f(it + k) }() }\n    }\n\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    B(\"O\", \"K\").test { it -> result = it }\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface A {\n    fun run()\n}\n\nclass B(val o: String, val k: String) {\n\n    inline fun testNested(crossinline f: (String) -> Unit) {\n        object : A {\n            override fun run() {\n                f(o)\n            }\n        }.run()\n    }\n\n    inline fun test(crossinline f: (String) -> Unit) {\n        testNested { it -> { f(it + \"K\") }() }\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    B(\"O\", \"fail\").test { it -> result = it }\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface A {\n    fun run()\n}\n\nclass B(val o: String, val k: String) {\n\n    inline fun testNested(crossinline f: (String) -> Unit, crossinline f2: (String) -> Unit) {\n        object : A {\n            override fun run() {\n                f(o)\n                f2(k)\n            }\n        }.run()\n    }\n\n    inline fun test(crossinline f: (String) -> Unit) {\n        call {\n            f(\"start\");\n            {\n                testNested ({ it -> { f(it + o) }() }) { it -> { f(it + k) }() }\n            }()\n        }\n    }\n\n    inline fun call(f: () -> Unit) {\n        f()\n    }\n\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"\"\n    B(\"O\", \"K\").test { it -> result += it }\n    return if (result == \"startOOKK\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface A {\n    fun run()\n}\n\nclass B(val o: String, val k: String) {\n\n    inline fun testNested(crossinline f: (String) -> Unit, crossinline f2: (String) -> Unit) {\n        object : A {\n            override fun run() {\n                f(o)\n                f2(k)\n            }\n        }.run()\n    }\n\n    inline fun test(crossinline f: (String) -> Unit) {\n        call {\n            {\n                testNested ({ it -> { f(it + o) }() }) { it -> { f(it + k) }() }\n            }()\n        }\n    }\n\n    inline fun call(f: () -> Unit) {\n        f()\n    }\n\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"\"\n    B(\"O\", \"K\").test { it -> result += it }\n    return if (result == \"OOKK\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n    val param = \"start\"\n    var result = \"fail\"\n    var addParam = \"_additional_\"\n\n    inline fun inlineFun(arg: String, crossinline f: (String) -> Unit) {\n        {\n            f(arg + addParam)\n        }()\n    }\n\n    fun box(): String {\n        inlineFun(\"1\")  { c ->\n            {\n                inlineFun(\"2\") { a ->\n                    {\n                        {\n                            result = param + c + a\n                        }()\n                    }()\n                }\n            }()\n        }\n\n        return if (result == \"start1_additional_2_additional_\") \"OK\" else \"fail: $result\"\n    }\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().box()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface  A {\n    fun run()\n}\n\nclass B(val o: String, val k: String) {\n\n    inline fun testNested(crossinline f: (String) -> Unit) {\n        object : A {\n            override fun run() {\n                f(o)\n            }\n        }.run()\n    }\n\n    fun test(f: (String) -> Unit) {\n        testNested { it -> { f(it + k) }() }\n    }\n\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    B(\"O\", \"K\").test { it -> result = it }\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nopen class A(val value: String)\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    object : A(prop) {\n\n                    }.value\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass W(val value: Any)\n\ninline fun W.safe(crossinline body : Any.() -> Unit) {\n    {\n        this.value?.body()\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    W(\"OK\").safe {\n        {\n            result = this as String\n        }()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nopen class Entity(val value: String)\n\npublic abstract class Task<T>() {\n    abstract fun calc(): T\n}\n\nfun <Self : Entity> nullableTask(factory: () -> Task<Self>): Task<Self> {\n    return factory()\n}\n\ninline fun<reified Self : Entity> Self.directed(): Task<Self> =\n        nullableTask {\n            object : Task<Self>() {\n                override fun calc(): Self = this@directed\n            }\n        }\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\n//KT-7490\nimport test.*\n\nfun box(): String {\n    return Entity(\"OK\").directed().calc().value\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    inlineFun {\n                        object {\n                            val inflater = prop\n                        }.inflater\n                    }\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nabstract class A<R>(val param: R) {\n    abstract fun getO() : R\n\n    abstract fun getK() : R\n}\n\n\ninline fun <R> doWork(job: ()-> R) : R {\n    return job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box() : String {\n    val o = \"O\"\n    val result = doWork {\n        val k = \"K\"\n        val s = object : A<String>(\"11\") {\n            override fun getO(): String {\n                return o;\n            }\n\n            override fun getK(): String {\n                return k;\n            }\n        }\n\n        s.getO() + s.getK() + s.param\n    }\n\n    if (result != \"OK11\") return \"fail $result\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n//WITH_RUNTIME\n//FULL_JDK\n// FILE: 1.kt\npackage test\n\ninline fun crashMe(crossinline callback: () -> Unit): Function0<Unit> {\n    return object: Function0<Unit> {\n        override fun invoke() {\n            callback()\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport java.lang.reflect.Modifier\n\nvar result = \"fail\"\n\n\nfun box(): String {\n    val crashMe = crashMe { result = \"OK\" }\n    val modifiers = crashMe::class.java.getDeclaredConstructor().modifiers\n    if (!Modifier.isPublic(modifiers)) return \"fail $modifiers\"\n\n    crashMe.invoke()\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun bar(crossinline y: () -> String) = {\n    call(y)\n}\n\npublic inline fun <T> call(f: () -> T): T = f()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return bar {\"OK\"} ()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface Run {\n    fun run(): String\n}\n\ninternal class A {\n    inline fun doSomething(): Run  {\n        return object : Run {\n            override fun run(): String =  \"OK\"\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return A().doSomething().run()\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\ninline fun inlineCall(p: () -> Unit) {\n    p()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var gene = \"g1\"\n\n    inlineCall {\n        val value = 10.0\n        inlineCall {\n            {\n                value\n                gene = \"OK\"\n            }()\n        }\n    }\n\n    return gene\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Person(val name: String) {\n\n    fun sayName() = doSayName { name }\n\n    inline fun doSayName(crossinline call: () -> String): String {\n        return nestedSayName1 { nestedSayName2 { call() } }\n    }\n\n    fun nestedSayName1(call: () -> String) = call()\n\n    inline fun nestedSayName2(call: () -> String)  = call()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return Person(\"OK\").sayName()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Person(val name: String) {\n\n    fun sayName() = doSayName { name }\n\n    inline fun doSayName(crossinline call: () -> String): String {\n        return nestedSayName1 { name + Person(\"sub\").nestedSayName2 { call() } }\n    }\n\n    fun nestedSayName1(call: () -> String) = call()\n\n    inline fun nestedSayName2(call: () -> String)  = name + call()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    val res = Person(\"OK\").sayName()\n    if (res != \"OKsubOK\")  return \"fail: $res\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun Person.sayName() = doSayName { name }\n\nclass Person(val name: String)\n\ninline fun Person.doSayName(crossinline call: () -> String): String {\n    return companyName { parsonName { call() } }\n}\n\ninline fun Person.parsonName(call: () -> String) = call()\n\nfun Person.companyName(call: () -> String) = call()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return Person(\"OK\").sayName()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A {\n\n    fun callK(): String {\n        return \"K\"\n    }\n\n    fun callO(): String {\n        return \"O\"\n    }\n\n    fun testCall(): String = test { callO() }\n\n    inline fun test(crossinline l: () -> String): String {\n        return {\n            l() + callK()\n        }()\n    }\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return A().testCall()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Company(val name: String) {\n    fun sayName() = Person(\"test\").doSayName { name }\n}\n\nclass Person(val name: String) {\n\n    inline fun doSayName(crossinline call: () -> String): String {\n        return companyName { parsonName { call() } }\n    }\n\n    inline fun parsonName(call: () -> String) = call()\n\n    fun companyName(call: () -> String) = call()\n\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return Company(\"OK\").sayName()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic enum class X { A, B }\n\npublic inline fun switch(x: X): String = when (x) {\n    X.A -> \"O\"\n    X.B -> \"K\"\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return switch(X.A) + switch(X.B)\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\n\npackage test\n\npublic inline fun <T, R> T.myLet(f: (T) -> R): R = f(this)\n\n// FILE: 2.kt\n\nimport test.*\n\ninterface foo {\n    fun bar(): String\n}\n\nfun box(): String {\n    val baz = \"OK\".myLet {\n        object : foo {\n            override fun bar() = it\n        }\n    }\n    return baz.bar()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                inlineFun2 {\n                    object {\n                        val inflater = prop\n                    }.inflater\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\ninline fun <T> inlineFun2(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n// NO_CHECK_LAMBDA_INLINING\npackage test\n\nclass A {\n    val foo = fun(call: () -> Unit) =\n        ext {\n            fun send() {\n                call()\n            }\n\n            bar {\n                send()\n            }\n        }\n\n    fun bar(body: () -> Unit) {\n        body()\n    }\n\n    inline fun A.ext(init: X.() -> Unit) {\n        return X().init()\n    }\n\n    class X\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    A().foo { result = \"OK\" }\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Test(val _member: String) {\n    val _parameter: Z<Z<String>> =  test {\n        object : Z<Z<String>> {\n            override val property = test {\n                object : Z<String> {\n                    override val property = _member\n                }\n            }\n        }\n    }\n}\n\ninterface Z<T> {\n    val property: T\n}\n\ninline fun <T> test(s: () -> Z<T>): Z<T> {\n    return s()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n\n    val test = Test(\"OK\")\n\n    return test._parameter.property.property\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// WITH_RUNTIME\n// FILE: 1.kt\npackage test\n\nfun <T> T.noInline(p: (T) -> Unit) {\n    p(this)\n}\n\ninline fun inlineCall(p: () -> Unit) {\n    p()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val loci = listOf(\"a\", \"b\", \"c\")\n    var gene = \"g1\"\n\n    inlineCall {\n        val value = 10.0\n        loci.forEach {\n            var locusMap = 1.0\n            {\n                locusMap = value\n                gene = \"OK\"\n            }()\n        }\n    }\n    return gene\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass W(val value: Any)\n\ninline fun W.safe(crossinline body : Any.() -> Unit) {\n    {\n        this.value?.body()\n    }()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    W(\"OK\").safe {\n        result = this as String\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nopen class A(val value: String)\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    inlineFun {\n                        object : A(prop) {\n\n                        }.value\n                    }\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun bar(crossinline y: () -> String) = {\n    { { call(y) }() }()\n}\n\npublic inline fun <T> call(crossinline f: () -> T): T = {{ f() }()}()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    val bar1 = bar {\"123\"} ()\n    val bar2 = bar2 { \"1234\" } ()\n    return if (bar1 == \"123\" && bar2 == \"1234\") \"OK\" else \"fail: $bar1 $bar2\"\n}\n\ninline fun bar2(crossinline y: () -> String) = {\n    { { call(y) }() }()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_REFLECT\n// FILE: 1.kt\n\npackage test\n\ninline fun inf(crossinline cif: Any.() -> String): () -> String {\n    return {\n        object : () -> String {\n            override fun invoke() = cif()\n        }\n    }()\n}\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val simpleName = inf {\n        javaClass.simpleName\n    }()\n\n    if (simpleName != \"\" ) return \"fail 1: $simpleName\"\n\n    val name = inf {\n        javaClass.name\n    }()\n\n    if (name != \"_2Kt\\$box$\\$inlined\\$inf$2$1\" ) return \"fail 2: $name\"\n\n\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// WITH_RUNTIME\n// FILE: 1.kt\npackage test\n\n\n\ninline fun inlineFun(p: () -> Unit) {\n    p()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\npublic fun box(): String {\n    var z = \"fail\"\n    inlineFun {\n        val obj = object  {\n            val _delegate by lazy {\n                z = \"OK\"\n            }\n        }\n\n        obj._delegate\n    }\n\n    return z;\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Test(val _member: String) {\n    val _parameter: Z =  test {\n        object : Z {\n            override val property = _member\n        }\n    }\n}\n\ninterface Z {\n    val property: String\n}\n\ninline fun test(s: () -> Z): Z {\n    return s()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n\n    val test = Test(\"OK\")\n\n    return test._parameter.property\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nopen class A(val value: String)\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    inlineFun {\n                        noInline {\n                            object : A(prop) {\n\n                            }.value\n                        }\n                    }\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Test {\n\n    val prop: String = \"OK\"\n\n    fun test() =\n            inlineFun {\n                noInline {\n                    noInline {\n                        object {\n                            val inflater = prop\n                        }.inflater\n                    }\n                }\n            }\n}\n\ninline fun <T> inlineFun(init: () -> T): T {\n    return init()\n}\n\nfun <T> noInline(init: () -> T): T {\n    return init()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    return Test().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\nabstract class A<R>(val param : R) {\n    abstract fun getO() : R\n\n    abstract fun getK() : R\n}\n\ninline fun <R> doWork(crossinline jobO: ()-> R, crossinline jobK: ()-> R, param: R) : A<R> {\n    val s = object : A<R>(param) {\n\n        override fun getO(): R {\n            return jobO()\n        }\n        override fun getK(): R {\n            return  jobK()\n        }\n    }\n    return s;\n}\n\ninline fun <R> doWorkInConstructor(crossinline jobO: ()-> R, crossinline jobK: ()-> R, crossinline param: () -> R) : A<R> {\n    val s = object : A<R>(param()) {\n        val o1 = jobO()\n\n        val k1 = jobK()\n\n        override fun getO(): R {\n            return o1\n        }\n        override fun getK(): R {\n            return k1\n        }\n    }\n    return s;\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(): String {\n    val o = \"O\"\n\n    val result = doWork ({o}, {\"K\"}, \"11\")\n\n    return result.getO() + result.getK() + result.param\n}\n\nfun test2() : String {\n    //same names as in object\n    val o1 = \"O\"\n    val k1 = \"K\"\n    val param = \"11\"\n    val result = doWorkInConstructor ({o1}, {k1}, {param})\n\n    return result.getO() + result.getK() + result.param\n}\n\nfun box() : String {\n    val result1 = test1();\n    if (result1 != \"OK11\") return \"fail1 $result1\"\n\n    val result2 = test2();\n    if (result2 != \"OK11\") return \"fail2 $result2\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun String.fire(message: String? = null) {\n    val res = this + message!!\n}\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\n\nimport test.*\n\nfun box(): String {\n    val receiver = \"receiver\"\n    \"\".let {\n        {\n            receiver.fire()\n        }\n    }\n    return \"OK\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\nannotation class FieldAnnotation\n\ninline fun reproduceIssue(crossinline s: () -> String): String {\n    val obj = object {\n        @field:FieldAnnotation val annotatedField = \"O\"\n        fun method(): String {\n            return annotatedField + s()\n        }\n    }\n    val annotatedMethod = obj::class.java.declaredFields.first { it.name == \"annotatedField\" }\n    if (annotatedMethod.annotations.isEmpty()) return \"fail: can't find annotated field\"\n    return obj.method()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return reproduceIssue { \"K\" }\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun linearLayout2(init: X.() -> Unit) {\n    return X().init()\n}\n\nvar result = \"fail\"\nclass X {\n    fun calc() {\n        result = \"OK\"\n    }\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass A  {\n    fun test() {\n        linearLayout2 {\n            {\n                apply2 {\n                    this@linearLayout2::calc\n                }()\n            }()\n        }\n    }\n\n    public fun <T, Z> T.apply2(block: T.() -> Z): Z {\n        return block()\n    }\n\n}\n\nfun box(): String {\n    A().test()\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n// IGNORE_BACKEND: JS\n// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\npackage test\n\npublic inline fun <T> T.myalso(block: (T) -> Unit): T {\n    block(this)\n    return this\n}\n\npublic inline fun <T, R : Any> Iterable<T>.mymapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nvar result = -1;\n\nfun box(): String {\n    fff()\n    return if (result == 1) \"OK\" else \"fail $result\"\n}\n\nfun fff(): Int {\n    val y = 0\n    return 0.myalso {\n        fun increase(x: Int): Int = x + y\n\n        val values = listOf(1).mymapNotNull { something(::increase, it) }\n        result = values[0]!!\n    }\n}\n\nfun something(increase: (Int) -> Int, x: Int): Int? {\n    return increase(x)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// FILE: 1.kt\npackage test\n\nclass Foo<T> {\n    inner class Inner<P>(val a: T, val b: P)\n}\n\ninline fun <A, B> foo(a: A, b: B, foo: Foo<A>, x: (Foo<A>, A, B) -> Foo<A>.Inner<B>): Foo<A>.Inner<B> = x(foo, a, b)\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n\n    val foo = foo<String, String>(\"O\", \"K\", Foo<String>(), Foo<String>::Inner)\n    return foo.a + foo.b\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(p: Int, s: Int.(Int) -> Int): Int {\n    return p.s(p)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    return if (call(10, Int::calc) == 100) \"OK\" else \"fail\"\n}\n\nfun Int.calc(p: Int) : Int {\n    return p * this\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A(val z: Int) {\n    fun calc() = z\n}\n\ninline fun call(p: A, s: A.() -> Int): Int {\n    return p.s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    val call = call(A(11), A::calc)\n    return if (call == 11) \"OK\" else \"fail\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A(val z: Int) {\n    fun calc() = z\n\n    fun test() = call(A(z), A::calc)\n}\n\ninline fun call(p: A, s: A.() -> Int): Int {\n    return p.s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    val call = A(11).test()\n    return if (call == 11) \"OK\" else \"fail\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage test\n\nclass Foo(@JvmField val a: String)\n\ninline fun test(s: (Foo) -> String): String {\n    return s(Foo(\"OK\"))\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(Foo::a)\n}"
        },
        {
            "code": "// Enable when callable references to builtin members and using lambdas as extension lambdas (KT-13312) is supported\n// FILE: 1.kt\n\npackage test\n\ninline fun call(p: String, s: String.() -> Int): Int {\n    return p.s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    return if (call(\"123\", String::length) == 3) \"OK\" else \"fail\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun call(p: Int, s: (Int) -> Int): Int {\n    return s(p)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    return if (call(10, ::calc) == 5) \"OK\" else \"fail\"\n}\n\nfun calc(p: Int) : Int {\n    return p / 2\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo(val a: String)\n\ninline fun <T> test(receiver: T, selector: (T) -> String): String {\n    return selector(receiver)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(Foo(\"OK\"), Foo::a)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: () -> String, z: String) = x() + z\n\nfun String.id() = this\n\n// FILE: 2.kt\n\nimport test.*\n\nfun String.test() : String {\n    return foo(this::id, \"K\")\n}\n\n\nfun box() : String {\n    return \"O\".test()\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass Foo<T> {\n    inner class Inner<P>(val a: T, val b: P)\n}\n\ninline fun <A, B> foo(a: A, b: B, x: (A, B) -> Foo<A>.Inner<B>): Foo<A>.Inner<B> = x(a, b)\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val z = Foo<String>()\n    val foo = foo(\"O\", \"K\", z::Inner)\n    return foo.a + foo.b\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <R> map(transform: () -> R): R {\n    return transform()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nval Int.myInc\n    get() = this + 1\n\nfun box(): String {\n    val result = map(2::myInc)\n    return if (result == 3) \"OK\" else \"fail $result\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo(val a: String)\n\ninline fun test(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(Foo(\"OK\")::a)\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM\n// FILE: 1.kt\npackage test\n\nclass X {\n    val result: String\n        inline get() = \"OK\"\n\n    fun x(): String {\n        return go(::result)\n    }\n}\n\ninline fun go(f: () -> String): String = f()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return X().x()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\ninline fun foo(x: () -> String) = x()\n\nfun String.id() = this\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() = foo(\"OK\"::id)\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass X {\n    val result: String\n        get() = \"OK\"\n\n    fun x(): String {\n        return go(::result)\n    }\n}\n\ninline fun go(f: () -> String): String = f()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return X().x()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T, R> T.map(transform: (T) -> R): R {\n    return transform(this)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = 1.map(3L::plus)\n    return if (result == 4L) \"OK\" else \"fail $result\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun go(f: () -> String) = f()\n\nfun String.id(): String = this\n\nfun foo(x: String, y: String): String {\n    return go((x + y)::id)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() = foo(\"O\", \"K\")\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <R> map(transform: () -> R): R {\n    return transform()\n}\n\n// FILE: 2.kt\n\nimport test.*\nval Long.myInc\n    get() = this + 1\n\nfun box(): String {\n    val result = map(2L::myInc)\n    return if (result == 3L) \"OK\" else \"fail $result\"\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage test\n\nclass Foo(@JvmField val a: String)\n\ninline fun test(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(Foo(\"OK\")::a)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo(val z: String)\n\nval Foo.a: String\n    get() = z\n\ninline fun test(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(Foo(\"OK\")::a)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo(val a: String) {\n\n    fun test() = a\n}\n\ninline fun test(a: String, b: () -> String, c: () -> String, d: String): String {\n    return a + b() + c() + d\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nvar effects = \"\"\n\nfun create(a: String): Foo {\n    effects += a\n    return Foo(a)\n}\n\nfun box(): String {\n    val result = test(create(\"A\").a, create(\"B\")::a, create(\"C\")::test, create(\"D\").a)\n    if (result != effects) return \"fail 1: $effects != $result\"\n\n    return if (result == \"ABCD\") \"OK\" else \"fail 2: $result\"\n}"
        },
        {
            "code": "// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\n// FILE: 1.kt\n\npackage test\n\ninline fun stub(f: () -> String): String = f()\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A(val z: String) {\n    fun map(s: String) = z + s\n}\n\n\nfun box(): String {\n    val a = A(\"O\")\n    val s = arrayOf(\"K\")\n    return s.map(a::map).first()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nobject Foo {\n    val a: String = \"OK\"\n}\n\ninline fun test(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(Foo::a)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo {\n    fun foo() = \"OK\"\n    fun foo2() = \"OK2\"\n}\n\ninline fun inlineFn(a: String, crossinline fn: () -> String, x: Long = 1, crossinline fn2: () -> String, c: String): String {\n    return a + fn() + x + fn2() + c\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nprivate val foo = Foo()\n\nfun box(): String {\n    val result = inlineFn(\"a\", foo::foo, 5, foo::foo2, \"end\")\n    return if (result == \"aOK5OK2end\") \"OK\" else \"fail: $result\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: (String) -> String, z: String) = x(z)\n\nfun String.id() = this\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    var zeroSlot = \"fail\";\n    val z = \"O\"\n    return foo(z::plus, \"K\")\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// KJS_WITH_FULL_RUNTIME\n// FILE: 1.kt\n\npackage test\n\ninline fun stub(f: () -> String): String = f()\n\n// FILE: 2.kt\n\nimport test.*\n\nclass A(val z: String) {\n    fun filter(s: String) = z == s\n}\n\n\nfun box(): String {\n    val a = A(\"OK\")\n    val s = arrayOf(\"OK\")\n    return s.filter(a::filter).first()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun go(f: () -> String) = f()\n\nfun String.id(): String = this\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val x = \"OK\"\n    return go(x::id)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: () -> String, z: String) = x() + z\n\nfun String.id() = this\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    var zeroSlot = \"fail\";\n    val z = \"O\"\n    return foo(z::id, \"K\")\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nobject Foo {\n    val a: String = \"OK\"\n}\n\ninline fun test(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.Foo.a\nimport test.test\n\nfun box(): String {\n    return test(::a)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T, R> T.map(transform: (T) -> R): R {\n    return transform(this)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = 1.map(2::plus)\n    return if (result == 3) \"OK\" else \"fail $result\"\n}"
        },
        {
            "code": "// Enable when callable references to builtin members and using lambdas as extension lambdas (KT-13312) is supported\n// FILE: 1.kt\n\npackage test\n\ninline fun call(a: String, b: String, s: String.(String) -> String): String {\n    return a.s(b)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    return call(\"O\", \"K\", String::plus)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nval a: String\n    get() = \"OK\"\n\ninline fun test(s: () -> String): String {\n    return s()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test(::a)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A(val z: Int) {\n    fun calc() = z\n}\n\ninline fun call(p: Int, s: (Int) -> A): Int {\n    return s(p).z\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    val call = call(11, ::A)\n    return if (call == 11) \"OK\" else \"fail\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> inlineFun(arg: T, f: (T) -> Unit) {\n    f(arg)\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\ninline fun test1(crossinline param: () -> String): String {\n    var result = \"fail\"\n    inlineFun(\"1\")  { c ->\n        {\n            inlineFun(\"2\") { a ->\n                {\n                    {\n                        result = param() + c + a\n                    }()\n                }()\n            }\n        }()\n    }\n\n    return result\n}\n\n\ninline fun test2(crossinline param: () -> String): String {\n    var result = \"fail\"\n    inlineFun(\"2\") { a ->\n        {\n            {\n                result = param() + a\n            }()\n        }()\n    }\n\n    return result\n}\n\ninline fun test3(crossinline param: () -> String): String {\n    var result = \"fail\"\n    inlineFun(\"2\") { d ->\n        inlineFun(\"1\") { c ->\n            {\n                inlineFun(\"2\") { a ->\n                    {\n                        {\n                            result = param() + c + a\n                        }()\n                    }()\n                }\n            }()\n        }\n    }\n\n    return result\n}\n\n\nfun box(): String {\n    if (test1({\"start\"}) != \"start12\") return \"fail1: ${test1({\"start\"})}\"\n    if (test2({\"start\"}) != \"start2\") return \"fail2: ${test2({\"start\"})}\"\n    if (test3({\"start\"}) != \"start12\") return \"fail3: ${test3({\"start\"})}\"\n\n    var captured1 = \"sta\";\n    val captured2 = \"rt\";\n    if (test1({captured1 + captured2}) != \"start12\") return \"fail4: ${test1({captured1 + captured2})}\"\n    if (test2({captured1 + captured2}) != \"start2\") return \"fail5: ${test2({captured1 + captured2})}\"\n    if (test3({captured1 + captured2}) != \"start12\") return \"fail6: ${test3({captured1 + captured2})}\"\n\n    return {\n        if (test1 { captured1 + captured2 } != \"start12\") \"fail7: ${test1 { captured1 + captured2 }}\"\n        else if (test2 { captured1 + captured2 } != \"start2\") \"fail8: ${test2 { captured1 + captured2 }}\"\n        else if (test3 { captured1 + captured2 } != \"start12\") \"fail9: ${test3 { captured1 + captured2 }}\"\n        else \"OK\"\n    } ()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> inlineFun(arg: T, f: (T) -> Unit) {\n    f(arg)\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(param: String): String {\n    var result = \"fail\"\n    inlineFun(\"1\")  { c ->\n        {\n            inlineFun(\"2\") { a ->\n                {\n                    {\n                        result = param + c + a\n                    }()\n                }()\n            }\n        }()\n    }\n\n    return result\n}\n\n\nfun test2(param: String): String {\n    var result = \"fail\"\n    inlineFun(\"2\") { a ->\n        {\n            {\n                result = param + a\n            }()\n        }()\n    }\n\n    return result\n}\n\nfun test3(param: String): String {\n    var result = \"fail\"\n    inlineFun(\"2\") { d ->\n        inlineFun(\"1\") { c ->\n            {\n                inlineFun(\"2\") { a ->\n                    {\n                        {\n                            result = param + c + a\n                        }()\n                    }()\n                }\n            }()\n        }\n    }\n\n    return result\n}\n\n\nfun box(): String {\n    if (test1(\"start\") != \"start12\") return \"fail1: ${test1(\"start\")}\"\n    if (test2(\"start\") != \"start2\") return \"fail2: ${test2(\"start\")}\"\n    if (test3(\"start\") != \"start12\") return \"fail3: ${test3(\"start\")}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: 1.kt\n\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@file:JvmPackageName(\"baz.foo.quux.bar\")\npackage foo.bar\n\nfun f(): String = \"O\"\n\nval g: String? get() = \"K\"\n\ninline fun <T> i(block: () -> T): T = block()\n\n// FILE: 2.kt\n\nimport foo.bar.*\n\nfun box(): String = i { f() + g }\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun calc() = \"OK\"\n\ninline fun String.test() = this\n\nfun test(\n        p1: String = \"1\",\n        p2: String = \"2\",\n        p3: String = \"3\",\n        p4: String = \"4\",\n        p5: String = \"5\",\n        p6: String = \"6\",\n        p7: String = \"7\",\n        p8: String = \"8\",\n        p9: String = \"9\",\n        p10: String = \"10\",\n        p11: String = \"11\",\n        p12: String = \"12\",\n        p13: String = \"13\",\n        p14: String = \"O\".test(),\n        p15: String = \"15\",\n        p16: String = \"16\",\n        p17: String = \"17\",\n        p18: String = \"18\",\n        p19: String = \"19\",\n        p20: String = \"20\",\n        p21: String = \"21\",\n        p22: String = \"22\",\n        p23: String = \"23\",\n        p24: String = \"24\",\n        p25: String = \"25\",\n        p26: String = \"26\",\n        p27: String = \"27\",\n        p28: String = \"28\",\n        p29: String = \"29\",\n        p30: String = \"30\",\n        p31: String = \"31\",\n        p32: String = \"32\",\n        p33: String = \"K\".test()\n): String {\n    return p14 + p33\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\npackage test\n\nvar res = \"\"\n\ninline fun inlineFun(vararg s : () -> String = arrayOf({ \"OK\" })) {\n    for (p in s) {\n        res += p()\n    }\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    inlineFun()\n    return res\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun getStringInline(): String {\n    return \"OK\"\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun testCompilation(arg: String = getStringInline()): String {\n    return arg\n}\n\ninline fun testCompilationInline(arg: String = getStringInline()): String {\n    return arg\n}\n\nfun box(): String {\n    var result = testCompilation()\n    if (result != \"OK\") return \"fail1: ${result}\"\n\n    result = testCompilation(\"OKOK\")\n    if (result != \"OKOK\") return \"fail2: ${result}\"\n\n\n    result = testCompilationInline()\n    if (result != \"OK\") return \"fail3: ${result}\"\n\n    result = testCompilationInline(\"OKOK\")\n    if (result != \"OKOK\") return \"fail4: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun calc() = \"OK\"\n\ninline fun String.test() = this\n\nclass Test(\n        p1: String = \"1\",\n        p2: String = \"2\",\n        p3: String = \"3\",\n        p4: String = \"4\",\n        p5: String = \"5\",\n        p6: String = \"6\",\n        p7: String = \"7\",\n        p8: String = \"8\",\n        p9: String = \"9\",\n        p10: String = \"10\",\n        p11: String = \"11\",\n        p12: String = \"12\",\n        p13: String = \"13\",\n        val p14: String = \"O\".test(),\n        p15: String = \"15\",\n        p16: String = \"16\",\n        p17: String = \"17\",\n        p18: String = \"18\",\n        p19: String = \"19\",\n        p20: String = \"20\",\n        p21: String = \"21\",\n        p22: String = \"22\",\n        p23: String = \"23\",\n        p24: String = \"24\",\n        p25: String = \"25\",\n        p26: String = \"26\",\n        p27: String = \"27\",\n        p28: String = \"28\",\n        p29: String = \"29\",\n        p30: String = \"30\",\n        p31: String = \"31\",\n        p32: String = \"32\",\n        val p33: String = \"K\".test()\n)\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val test = Test()\n    return test.p14 + test.p33\n}"
        },
        {
            "code": "// FILE: 1.kt\n//NO_CHECK_LAMBDA_INLINING\n\npackage test\n\nobject TimeUtil {\n    inline fun waitForEx(retryWait: Int = 200,\n                         action: () -> Boolean) {\n        var now = 1L\n        if (now++ <= 3) {\n            action()\n        }\n\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nvar result = \"fail\"\n\nfun box(): String {\n    TimeUtil.waitForEx(\n            action = {\n                try {\n                    result = \"OK\"\n                    true\n                }\n                catch (t: Throwable) {\n                    false\n                }\n            })\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun emptyFun(arg: String = \"O\") {\n\n}\n\ninline fun simpleFun(arg: String = \"O\"): String {\n    val r = arg;\n    return r;\n}\n\n\ninline fun simpleDoubleFun(arg: Double = 1.0): Double {\n    val r = arg + 1;\n    return r;\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun testCompilation(): String {\n    emptyFun()\n    emptyFun(\"K\")\n\n    return \"OK\"\n}\n\nfun simple(): String {\n    return simpleFun() + simpleFun(\"K\")\n}\n\nfun box(): String {\n    var result = testCompilation()\n    if (result != \"OK\") return \"fail1: ${result}\"\n\n    result = simple()\n    if (result != \"OK\") return \"fail2: ${result}\"\n\n    var result2 = simpleDoubleFun(2.0)\n    if (result2 != 2.0 + 1.0) return \"fail3: ${result2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\ninline fun <T> simpleFun(arg: String = \"O\", lambda: (String) -> T): T {\n    return lambda(arg)\n}\n\n\ninline fun <T> simpleFunR(lambda: (String) -> T, arg: String = \"O\"): T {\n    return lambda(arg)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun simple(): String {\n    val k = \"K\"\n    return simpleFun(lambda = {it + \"O\"}) + simpleFun(\"K\", {k + it})\n}\n\nfun simpleR(): String {\n    val k = \"K\"\n    return simpleFunR({it + \"O\"}) + simpleFunR({k + it}, \"K\")\n}\n\nfun box(): String {\n\n    var result = simple()\n    if (result != \"OOKK\") return \"fail1: ${result}\"\n\n    result = simpleR()\n    if (result != \"OOKK\") return \"fail2: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Z(public val value: Int = 0) {\n\n    inline public fun run(p1: String? = null): String? {\n        return p1 + value\n    }\n\n\n    inline public fun run(p1: String = \"\", lambda: (a: String, b: Int) -> String, p2: Int = 0): String {\n        return lambda(p1, p2)\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (Z().run() != \"null0\") return \"fail 1: ${Z().run()}\"\n\n    if (Z().run(\"OK\") != \"OK0\") return \"fail 2\"\n\n    if (Z().run(\"OK\", { a, b -> a + b }, 1) != \"OK1\") return \"fail 3\"\n\n    if (Z().run(lambda = { a: String, b: Int -> a + b }) != \"0\") return \"fail 4\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun calc() = \"OK\"\n\ninline fun test(\n        p1: String = \"1\",\n        p2: String = \"2\",\n        p3: String = \"3\",\n        p4: String = \"4\",\n        p5: String = \"5\",\n        p6: String = \"6\",\n        p7: String = \"7\",\n        p8: String = \"8\",\n        p9: String = \"9\",\n        p10: String = \"10\",\n        p11: String = \"11\",\n        p12: String = \"12\",\n        p13: String = \"13\",\n        p14: String = \"14\",\n        p15: String = \"15\",\n        p16: String = \"16\",\n        p17: String = \"17\",\n        p18: String = \"18\",\n        p19: String = \"19\",\n        p20: String = \"20\",\n        p21: String = \"21\",\n        p22: String = \"22\",\n        p23: String = \"23\",\n        p24: String = \"24\",\n        p25: String = \"25\",\n        p26: String = \"26\",\n        p27: String = \"27\",\n        p28: String = \"28\",\n        p29: String = \"29\",\n        p30: String = \"30\",\n        p31: String = \"31\",\n        p32: String = \"32\",\n        p33: String = \"33\"\n): String {\n    return p1 + \" \" + p2 + \" \" + p3 + \" \" + p4 + \" \" + p5 + \" \" + p6 + \" \" +\n           p7 + \" \" + p8 + \" \" + p9 + \" \" + p10 + \" \" + p11 + \" \" + p12 + \" \" + p13 + \" \" + p14 + \" \" +\n           p15 + \" \" + p16 + \" \" + p17 + \" \" + p18 + \" \" + p19 + \" \" + p20 + \" \" + p21 + \" \" +\n           p22 + \" \" + p23 + \" \" + p24 + \" \" + p25 + \" \" + p26 + \" \" + p27 + \" \" + p28 + \" \" +\n           p29 + \" \" + p30 + \" \" + p31 + \" \" + p32 + \" \" + p33\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (test() != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\")\n        return \"fail 1: ${test()}\"\n\n    if (test(p20 = \"OK\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 OK 21 22 23 24 25 26 27 28 29 30 31 32 33\")\n        return \"fail 2: ${test(p20 = \"OK\")}\"\n\n    if (test(p20 = \"O\", p22 = \"K\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 O 21 K 23 24 25 26 27 28 29 30 31 32 33\")\n        return \"fail 3: ${test(p20 = \"O\", p22 = \"K\")}\"\n\n    if (test(p20 = \"O\", p22 = \"K\", p32 = \"23\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 O 21 K 23 24 25 26 27 28 29 30 31 23 33\")\n        return \"fail 4: ${test(p20 = \"O\", p22 = \"K\", p32 = \"23\")}\"\n\n    if (test(p20 = \"O\", p22 = \"K\", p32 = \"33\", p33 =\"32\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 O 21 K 23 24 25 26 27 28 29 30 31 33 32\")\n        return \"fail 4: ${test(p20 = \"O\", p22 = \"K\", p32 = \"33\", p33 =\"32\")}\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun calc() = \"OK\"\n\n/*open modifier for method handle check in default method*/\nopen class A {\n    inline fun test(p: String = calc()): String {\n        return p\n    }\n\n    inline fun String.testExt(p: String = \"K\"): String {\n        return this + p\n    }\n\n    fun callExt(): String {\n        return \"O\".testExt()\n    }\n\n    fun callExt(arg: String): String {\n        return \"O\".testExt(arg)\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box() : String {\n    if (A().callExt() != \"OK\") return \"fail 1: ${A().callExt()}\"\n    if (A().callExt(\"O\") != \"OO\") return \"fail 2: ${A().callExt(\"O\")}\"\n    if (A().test(\"KK\") != \"KK\") return \"fail 3: ${A().test(\"KK\")}\"\n\n    return A().test()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nfun calc() = \"OK\"\n\ninline fun test(\n        p1: String = \"1\",\n        p2: String = \"2\",\n        p3: String = \"3\",\n        p4: String = \"4\",\n        p5: String = \"5\",\n        p6: String = \"6\",\n        p7: String = \"7\",\n        p8: String = \"8\",\n        p9: String = \"9\",\n        p10: String = \"10\",\n        p11: String = \"11\",\n        p12: String = \"12\",\n        p13: String = \"13\",\n        p14: String = \"14\",\n        p15: String = \"15\",\n        p16: String = \"16\",\n        p17: String = \"17\",\n        p18: String = \"18\",\n        p19: String = \"19\",\n        p20: String = \"20\",\n        p21: String = \"21\",\n        p22: String = \"22\",\n        p23: String = \"23\",\n        p24: String = \"24\",\n        p25: String = \"25\",\n        p26: String = \"26\",\n        p27: String = \"27\",\n        p28: String = \"28\",\n        p29: String = \"29\",\n        p30: String = \"30\",\n        p31: String = \"31\",\n        p32: String = \"32\"\n): String {\n    return p1 + \" \" + p2 + \" \" + p3 + \" \" + p4 + \" \" + p5 + \" \" + p6 + \" \" +\n           p7 + \" \" + p8 + \" \" + p9 + \" \" + p10 + \" \" + p11 + \" \" + p12 + \" \" + p13 + \" \" + p14 + \" \" +\n           p15 + \" \" + p16 + \" \" + p17 + \" \" + p18 + \" \" + p19 + \" \" + p20 + \" \" + p21 + \" \" +\n           p22 + \" \" + p23 + \" \" + p24 + \" \" + p25 + \" \" + p26 + \" \" + p27 + \" \" + p28 + \" \" +\n           p29 + \" \" + p30 + \" \" + p31 + \" \" + p32\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (test() != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32\")\n        return \"fail 1: ${test()}\"\n\n    if (test(p20 = \"OK\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 OK 21 22 23 24 25 26 27 28 29 30 31 32\")\n        return \"fail 2: ${test(p20 = \"OK\")}\"\n\n    if (test(p20 = \"O\", p22 = \"K\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 O 21 K 23 24 25 26 27 28 29 30 31 32\")\n        return \"fail 3: ${test(p20 = \"O\", p22 = \"K\")}\"\n\n    if (test(p20 = \"O\", p22 = \"K\", p32 = \"23\") != \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 O 21 K 23 24 25 26 27 28 29 30 31 23\")\n        return \"fail 4: ${test(p20 = \"O\", p22 = \"K\", p32 = \"23\")}\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\n@Suppress(\"NULLABLE_INLINE_PARAMETER\")\ninline fun build(func: () -> Unit, pathFunc: (() -> String)? = null) {\n    func()\n\n    pathFunc?.invoke()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    build ({ result = \"OK\" })\n\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun build(noinline pathFunc: (() -> String)? = null) {\n    pathFunc?.invoke()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    build ()\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun build(func: () -> Unit, noinline pathFunc: (() -> String)? = null) {\n    func()\n\n    pathFunc?.invoke()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    build({ result = \"OK\" })\n\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n//WITH_RUNTIME\n\npackage test\n\nclass SceneContainer2() {\n\n    inline fun pushTo(time: Long = 0.seconds, transition: String = \"TR\"): String {\n        return \"OK\"\n    }\n}\n\ninline val Number.seconds: Long get() = this.toLong()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return SceneContainer2().pushTo(time = 0.2.seconds)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo {\n    fun foo() = \"OK\"\n}\n\ninline fun inlineFn(crossinline fn: () -> String, x: Int? = 1): String {\n    return fn()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nprivate val foo = Foo()\n\nfun box(): String {\n    return inlineFn(foo::foo)\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun log(lazyMessage: () -> Any?) {\n    lazyMessage()\n}\n\ninline fun z(): Boolean {\n    \"zzz\"\n    return true\n}\n\n// FILE: 2.kt\n\nimport test.*\n\ninline fun getOrCreate(\n        z : Boolean = z(),\n        s: () -> String\n) {\n    log { s() }\n}\n\n\nfun box(): String {\n    var z = \"fail\"\n    getOrCreate { z = \"OK\"; z }\n\n    return z\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Measurements\n{\n    inline fun measure(key: String, logEvery: Long = -1, divisor: Int = 1, body: () -> Unit): String {\n        body()\n        return key\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var s1 = \"\"\n    val s2 = Measurements().measure(\"K\") {\n        s1 = \"O\"\n    }\n\n    return s1 + s2\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo {\n    fun foo() = \"O\"\n}\n\ninline fun inlineFn(crossinline fn: () -> String, x: String = \"X\"): String {\n    return fn() + x\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nprivate val foo = Foo()\n\nfun box(): String {\n    return inlineFn(foo::foo, \"K\")\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo {\n    fun foo() = \"O\"\n}\n\ninline fun inlineFn(crossinline fn: () -> String, x: String = \"K\"): String {\n    return fn() + x\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nprivate val foo = Foo()\n\nfun box(): String {\n    return inlineFn(foo::foo)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass Foo {\n    fun foo() = \"OK\"\n}\n\ninline fun inlineFn(crossinline fn: () -> String, x: Long = 1L): String {\n    return fn()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nprivate val foo = Foo()\n\nfun box(): String {\n    return inlineFn(foo::foo)\n}"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(crossinline inlineLambda: () -> String, noinline noInlineLambda: () -> String = { inlineLambda() }): String {\n    return noInlineLambda()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    return inlineFun({ \"OK\" })\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun f(\n    wait: Int = 0,\n    action: (Int) -> Unit\n): String {\n    var millis: Long = 1\n    try {\n    } catch (e: Throwable) {\n        millis = millis\n    }\n    return \"OK\"\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    var x = 0\n    return f {\n        x++\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun log(lazyMessage: () -> Any?) {\n    lazyMessage()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\ninline fun getOrCreate(\n        z : Boolean = false,\n        s: () -> String\n) {\n    log { s() }\n}\n\n\nfun box(): String {\n    var z = \"fail\"\n    getOrCreate { z = \"OK\"; z }\n\n    return z\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun a(s1: String = \"s1\", s2: String = \"s2\", body: (a1: String, a2: String) -> String) = body(s1, s2)\n\ninline fun String.b(body: (a1: String, a2: String) -> String) = a(s2 = this,  body = body)\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val z = \"OK\".b { a, b ->\n        a + b\n    }\n\n    return if (z == \"s1OK\") \"OK\" else \"fail $z\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n    fun ok() = value\n}\n\ninline fun inlineFun(a: A, lambda: (A) -> String = A::ok): String {\n    return lambda(a)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(A(\"OK\"))\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nfun foo(a: Number): String = \"OK\"\n\ninline fun inlineFun(s: (Double) -> String = ::foo): String {\n    return s(1.0)\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nfun ok() = \"OK\"\n\ninline fun inlineFun(lambda: () -> String = ::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nprivate val ok = \"OK\"\n\ninternal inline fun inlineFun(lambda: () -> String = ::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\npackage test\n\nfun ok() = \"OK\"\n\nobject A {\n    fun ok() = \"OK\"\n}\n\ninline fun stub() {}\n\n\n// FILE: 2.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\nimport test.A.ok\n\ninline fun inlineFun(lambda: () -> String = ::ok): String {\n    return lambda()\n}\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nfun ok() = \"OK\"\n\nobject A {\n    fun ok() = \"OK\"\n}\n\ninline fun inlineFun(lambda: () -> String = A::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val ok: String)\n\ninline fun inlineFun(a: A, lambda: (A) -> String = A::ok): String {\n    return lambda(a)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(A(\"OK\"))\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n    fun ok() = value\n}\n\ninline fun inlineFun(a: A, lambda: () -> String = a::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(A(\"OK\"))\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nval Long.myInc\n    get() = this + 1\n\n\ninline fun inlineFun(lambda: () -> Long = 1L::myInc): Long {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = inlineFun()\n    return if (result == 2L) return \"OK\" else \"fail $result\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(a: Int, lambda: (Int) -> Int = 1::plus): Int {\n    return lambda(a)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = inlineFun(2)\n    return if (result == 3) return \"OK\" else \"fail $result\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nobject A {\n    val ok = \"OK\"\n}\n\ninline fun inlineFun(lambda: () -> String = A::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n    fun ok() = value\n}\n\ninline fun inlineFun(a: String, lambda: (String) -> A = ::A): A {\n    return lambda(a)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\").value\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nval ok = \"OK\"\n\ninline fun inlineFun(lambda: () -> String = ::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n\n    inner class Inner {\n        fun ok() = value\n    }\n}\n\ninline fun inlineFun(a: A, lambda: () -> A.Inner = a::Inner): A.Inner {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(A(\"OK\")).ok()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nval Int.myInc\n    get() = this + 1\n\n\ninline fun inlineFun(lambda: () -> Int = 1::myInc): Int {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = inlineFun()\n    return if (result == 2) return \"OK\" else \"fail $result\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nopen class Base\n\nclass Child(val value: String) : Base()\n\nfun foo(a: Base): Child = a as Child\n\n\ninline fun inlineFun(s: (Child) -> Base = ::foo): Base {\n    return s(Child(\"OK\"))\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return (inlineFun() as Child).value\n}"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\npackage test\n\nobject A {\n    val ok = \"OK\"\n}\ninline fun stub() {}\n\n\n// FILE: 2.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\nimport test.A.ok\n\ninline fun inlineFun(lambda: () -> String = ::ok): String {\n    return lambda()\n}\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val ok: String)\n\ninline fun inlineFun(a: A, lambda: () -> String = a::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(A(\"OK\"))\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nprivate fun ok() = \"OK\"\n\ninternal inline fun inlineFun(lambda: () -> String = ::ok): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(a: Int, lambda: (Int) -> Int = 1::plus): Int {\n    return lambda(a)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = inlineFun(2)\n    return if (result == 3) return \"OK\" else \"fail $result\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(param: String, lambda: String.() -> String = { this }): String {\n    return param.lambda()\n}\n\n// FILE: 2.kt\n// CHECK_CONTAINS_NO_CALLS: box\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(crossinline inlineLambda: () -> String, noinline noInlineLambda: () -> String = { inlineLambda() }): String {\n    return noInlineLambda()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda scope=inlineFun\nimport test.*\n\nfun box(): String {\n    return inlineFun ({ \"OK\" })\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun String.inlineFun(crossinline lambda: () -> String, crossinline dlambda: () -> String = { this }): String {\n    return {\n        \"${this} ${lambda()} ${dlambda()}\"\n    }()\n}\n\n// FILE: 2.kt\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda_0 scope=test\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda scope=test\nimport test.*\n\nfun String.test(): String = \"INLINE\".inlineFun({ this })\n\nfun box(): String {\n    val result = \"TEST\".test()\n    return if (result == \"INLINE TEST INLINE\") \"OK\" else \"fail 1: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(crossinline inlineLambda: () -> String = { \"OK\" }, noinline noInlineLambda: () -> String = { inlineLambda() }): String {\n    return noInlineLambda()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda_0 scope=box\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninterface Call {\n    fun run(): String\n}\n\ninline fun test(p: String, s: () -> Call = {\n    object : Call {\n        override fun run() = p\n    } as Call\n}) = s()\n\nval same = test(\"O\")\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test(\"K\")\n    return same.run() + inlined.run()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n\n    inline fun String.inlineFun(crossinline lambda: () -> String = { this }): String {\n        return {\n            \"$value ${this} ${lambda()}\"\n        }()\n    }\n}\n\n// FILE: 2.kt\n//WITH_RUNTIME\n// CHECK_CALLED_IN_SCOPE: function=A$inlineFun$lambda scope=box\n// CHECK_CALLED_IN_SCOPE: function=A$inlineFun$lambda_0 scope=box\nimport test.*\n\nfun box(): String {\n    val result = with(A(\"VALUE\")) { \"OK\".inlineFun() }\n    return if (result == \"VALUE OK OK\") \"OK\" else \"fail 1: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// TARGET_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n//WITH_RUNTIME\npackage test\n\nobject X {\n    @JvmStatic\n    inline fun inlineFun(capturedParam: String, lambda: () -> String = { capturedParam }): String {\n        return lambda()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return X.inlineFun(\"OK\")\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n\n    inline fun inlineFun(lambda: () -> String = { value }): String {\n        return lambda()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n// CHECK_CONTAINS_NO_CALLS: box\nfun box(): String {\n    return A(\"OK\").inlineFun()\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun test(p: String, s: () -> () -> String = { { p } }) =\n        s()\n\nval same = test(\"O\")\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test(\"K\")\n    return same() + inlined()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(lambda: () -> Any = { \"OK\" as Any }): Any {\n    return lambda()\n}\n\n// FILE: 2.kt\n// CHECK_CONTAINS_NO_CALLS: box except=throwCCE;isType\n\nimport test.*\n\nfun box(): String {\n    return inlineFun() as String\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun String.inlineFun(crossinline lambda: () -> String = { { this }() }): String {\n    return {\n        {\n            this + lambda()\n        }()\n    }()\n}\n\n// FILE: 2.kt\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda scope=box\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda_0 scope=box\n\nimport test.*\n\nfun box(): String {\n    val result = \"OK\".inlineFun()\n    return if (result == \"OKOK\") \"OK\" else \"fail 1: $result\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(capturedParam: String, lambda: () -> String = { capturedParam }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n// CHECK_CONTAINS_NO_CALLS: box\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(action: () -> Any = { \"OK\" }): Any {\n    return action()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return inlineFun() as String\n}"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun String.inlineFun(crossinline lambda: () -> String = { this }): String {\n    return {\n        this + lambda()\n    }()\n}\n\n// FILE: 2.kt\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda scope=box\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda_0 scope=box\n\nimport test.*\n\nfun box(): String {\n    val result = \"OK\".inlineFun()\n    return if (result == \"OKOK\") \"OK\" else \"fail 1: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n    inline fun String.inlineFun(crossinline lambda: () -> String = { { this }() }): String {\n        return {\n            {\n                this + lambda()\n            }()\n        }()\n    }\n}\n\n// FILE: 2.kt\n//WITH_RUNTIME\n// CHECK_CALLED_IN_SCOPE: function=A$inlineFun$lambda scope=box\n// CHECK_CALLED_IN_SCOPE: function=A$inlineFun$lambda_0 scope=box\nimport test.*\n\nfun box(): String {\n    val result = with(A(\"VALUE\")) { \"OK\".inlineFun() }\n    return if (result == \"OKOK\") \"OK\" else \"fail 1: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// CHECK_CONTAINS_NO_CALLS: test\npackage test\n\n//problem in test framework\ninline fun inlineFunStub(){}\n\ninterface A {\n    val value: String\n\n    fun test() = inlineFun()\n\n    private inline fun inlineFun(lambda: () -> String = { value }): String {\n        return lambda()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass B : A {\n    override val value: String = \"OK\"\n}\n\nfun box(): String {\n    return B().test()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass Item\n\ninline fun inlineFun(number: String, getItem: ((String) -> String?) = { null }): String {\n    return number + (getItem(number) ?: \"\")\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun test(p: String, s: () -> () -> () -> String = { { { p } } }) =\n        s()\n\nval same = test(\"O\")\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test(\"K\")\n    return same()() + inlined()()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(capturedParam: String, lambda: () -> Any = { capturedParam as Any }): Any {\n    return lambda()\n}\n\n// FILE: 2.kt\n// CHECK_CONTAINS_NO_CALLS: box except=throwCCE;isType\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\") as String\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun <T> test(p: T, s: () -> () -> T = { { p } }) =\n        s()\n\nval same = test(\"O\")\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test(\"K\")\n    return same() + inlined()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: bar$default\npackage test\n\ninline fun bar(f: () -> String = { \"OK\" }) = f()\n// FILE: 2.kt\n\nimport test.*\n// SKIP_INLINE_CHECK_IN: foo$default\ninline fun foo(f: () -> String = { bar() }) = f()\n\nfun box(): String {\n    return foo()\n}\n\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// WITH_RUNTIME\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: enumOrThrow$default\npackage test\n\nenum class TarEnum {\n    OK\n}\ninline fun <reified T : Enum<T>> String?.enumOrNull(): T? {\n    this ?: return null\n    return enumValues<T>().firstOrNull { it.name == this }\n}\n\ninline fun <reified T : Enum<T>> String?.enumOrThrow(handleNull: () -> Throwable = { IllegalArgumentException(\"Enum type ${T::class.java} not contain value=$this\") }): T {\n    return this.enumOrNull<T>() ?: throw handleNull()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return \"OK\".enumOrThrow<TarEnum>()!!.name\n}"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun test(s: () -> () -> String = { { \"OK\" } }) =\n        s()\n\nval same = test()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test()\n    if (same() != \"OK\") return \"fail 1: ${same()}\"\n    return inlined()\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninterface Call {\n    fun run(): String\n}\n\ninline fun test(s: () -> Call = {\n    object : Call {\n        override fun run() = \"OK\"\n    } as Call\n}) = s()\n\nval same = test()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test()\n    if (same.run() != \"OK\") return \"fail 1: ${same.run()}\"\n    return inlined.run()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\ninline fun inlineFun(lambda: () -> String = { \"OK\" }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n// CHECK_CONTAINS_NO_CALLS: box\n\nimport test.*\n\nfun box(): String {\n    return inlineFun()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nclass A(val value: String) {\n\n    inline fun String.inlineFun(crossinline lambda: () -> String, crossinline dlambda: () -> String = { this }): String {\n        return {\n            \"$value ${this} ${lambda()} ${dlambda()}\"\n        }()\n    }\n}\n\n// FILE: 2.kt\n//WIH_RUNTIME\n// CHECK_CALLED_IN_SCOPE: function=A$inlineFun$lambda scope=test\n// CHECK_CALLED_IN_SCOPE: function=A$inlineFun$lambda_0 scope=test\nimport test.*\n\nfun String.test(): String = with(A(\"VALUE\")) { \"INLINE\".inlineFun({ this@test }) }\n\nfun box(): String {\n    val result = \"TEST\".test()\n    return if (result == \"VALUE INLINE TEST INLINE\") \"OK\" else \"fail 1: $result\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\ninline fun test(s: () -> () -> () -> String = { { { \"OK\" } } }) =\n        s()\n\nval same = test()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val inlined = test()\n    if (same()() != \"OK\") return \"fail 1: ${same()()}\"\n    return inlined()()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\nopen class A(val value: String)\n\nclass B(value: String): A(value)\n\ninline fun <T : A> inlineFun(capturedParam: T, lambda: () -> T = { capturedParam }): T {\n    return lambda()\n}\n\n// FILE: 2.kt\n// CHECK_CONTAINS_NO_CALLS: box\n\nimport test.*\n\nfun box(): String {\n    return inlineFun(B(\"O\")).value + inlineFun(A(\"K\")).value\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: lParams$default\npackage test\n\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n//A lot of blank lines [Don't delete]\n\n\ninline fun lParams(initParams: () -> String = { \"OK\" }): String {\n    return initParams()\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return run {\n        lParams()\n    }\n}\n\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\npackage test\n\n\nopen class Base\nclass Child(val value: String): Base()\n\ninline fun inlineFun(s: (Child) -> Base = { a: Base -> a as Child}): Base {\n    return s(Child(\"OK\"))\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return (inlineFun() as Child).value\n}"
        },
        {
            "code": "// FILE: 1.kt\n// NO_CHECK_LAMBDA_INLINING\npackage test\n\ninterface Call {\n    fun run(): String\n}\n\ninline fun test(p: String, s: () -> Call = {\n    object : Call {\n        override fun run() = p\n    }\n}) = s()\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    return test(\"OK\").run()\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun inlineFun(capturedParam: String, noinline lambda: () -> String = { capturedParam }): String {\n    return call(lambda)\n}\n\nfun call(lambda: () -> String ) = lambda()\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\n// CHECK_CALLED_IN_SCOPE: function=inlineFun$lambda scope=box\n// CHECK_CALLED_IN_SCOPE: function=call scope=box\nimport test.*\n\nfun box(): String {\n    return inlineFun(\"OK\")\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nvar result = \"fail\"\n\nobject TimeUtil {\n\n    fun waitForAssert(z: String) {\n        waitForEx(\n                action = {\n                    result = z\n                    result\n                })\n    }\n\n    inline fun waitForEx(retryWait: Int = 200,\n                         action: () -> String) {\n        var now = 1L\n        now++\n        action()\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    TimeUtil.waitForAssert(\"OK\")\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline public fun String.run(p1: String? = null): String {\n    return this + p1\n}\n\ninline public fun String.run(p1: String = \"\", lambda: (a: String, b: Int) -> String, p2: Int = 0): String {\n    return lambda(p1, p2) + this\n}\n\npublic class Z(val value: Int = 0) {\n\n    inline public fun String.run(p1: String? = null): String? {\n        return this + p1\n    }\n\n    inline public fun String.run(p1: String = \"\", lambda: (a: String, b: Int) -> String, p2: Int = 0): String {\n        return lambda(p1, p2) + this\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun testExtensionInClass() : String {\n\n    var res = with(Z(1)) { \"1\".run(\"OK\") }\n    if (res != \"1OK\") return \"failed in class 1: $res\"\n\n    res = with(Z(1)) { \"1\".run() }\n    if (res != \"1null\") return \"failed in class 2: $res\"\n\n    res = with(Z(2)) { \"3\".run(\"OK\", { a, b -> a + b + value }, 1) }\n    if (res != \"OK123\") return \"failed in class 3: $res\"\n\n    res = with(Z(3)) { \"4\".run(lambda = { a, b -> a + b + value }) }\n    if (res != \"034\") return \"failed in class 4: $res\"\n\n    return \"OK\"\n}\n\nfun box(): String {\n\n    var res = \"1\".run(\"OK\")\n    if (res != \"1OK\") return \"failed 1: $res\"\n\n    res = \"1\".run()\n    if (res != \"1null\") return \"failed 2: $res\"\n\n    res = \"3\".run(\"OK\", { a, b -> a + b}, 1)\n    if (res != \"OK13\") return \"failed 3: $res\"\n\n    res = \"4\".run(lambda = { a, b -> a + b})\n    if (res != \"04\") return \"failed 4: $res\"\n\n    return testExtensionInClass()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nvar res = 1\n\nclass A {\n\n    inline operator fun Int.get(z: Int, p: () -> Int) = this + z + p()\n\n    inline operator fun Int.set(z: Int, p: () -> Int, l: Int) {\n        res = this + z + p() + l\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun box(): String {\n\n    val z = 1;\n\n    with(A()) {\n\n        val p = z[2, { 3 }]\n        if (p != 6) return \"fail 1: $p\"\n\n        val captured = 3;\n        z[2, { captured }] = p\n        if (res != 12) return \"fail 2: $res\"\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nvar res = 1\n\ninline operator fun Int.get(z: Int, p: () -> Int, defaultt: Int = 100) = this + z + p() + defaultt\n\ninline operator fun Int.set(z: Int, p: () -> Int, l: Int/*, x : Int = 1000*/) {\n    res = this + z + p() + l /*+ x*/\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun box(): String {\n\n    val z = 1;\n\n    val p = z[2, { 3 }]\n    if (p != 106) return \"fail 1: $p\"\n\n    val captured = 3;\n    z[2, { captured } ] = p\n    if (res != 112) return \"fail 2: $res\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nvar res = 1\n\ninline operator fun Int.get(z: Int, p: () -> Int) = this + z + p()\n\ninline operator fun Int.set(z: Int, p: () -> Int, l: Int) {\n    res = this + z + p() + l\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun box(): String {\n\n    val z = 1;\n\n    val p = z[2, { 3 }]\n    if (p != 6) return \"fail 1: $p\"\n\n    val captured = 3;\n    z[2, { captured } ] = p\n    if (res != 12) return \"fail 2: $res\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nvar res = 1\n\nclass A {\n\n    inline operator fun Int.get(z: Int, p: () -> Int, defaultt: Int = 100) = this + z + p() + defaultt\n\n    inline operator fun Int.set(z: Int, p: () -> Int, l: Int/*, x : Int = 1000*/) {\n        res = this + z + p() + l /*+ x*/\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun box(): String {\n\n    val z = 1;\n\n    with(A()) {\n\n        val p = z[2, { 3 }]\n        if (p != 106) return \"fail 1: $p\"\n\n        val captured = 3;\n        z[2, { captured }] = p\n        if (res != 112) return \"fail 2: $res\"\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nvar res = 1\n\ninline operator fun Int.get(z: Int, p: Int) = this + z + p\n\ninline operator fun Int.set(z: Int, p: Int, l: Int) {\n    res = this + z + p + l\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun box(): String {\n\n    val z = 1;\n\n    val p = z[2, 3]\n    if (p != 6) return \"fail 1: $p\"\n\n    z[2, 3] = p\n    if (res != 12) return \"fail 2: $res\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nvar res = 1\n\nclass A {\n\n    inline operator fun Int.get(z: Int, p: Int) = this + z + p\n\n    inline operator fun Int.set(z: Int, p: Int, l: Int) {\n        res = this + z + p + l\n    }\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun box(): String {\n\n    with(A()) {\n        val z = 1;\n\n        val p = z[2, 3]\n        if (p != 6) return \"fail 1: $p\"\n\n        z[2, 3] = p\n        if (res != 12) return \"fail 2: $res\"\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\n\npublic class Data()\n\npublic class Input(val d: Data) : Closeable {\n    public fun data() : Int = 100\n}\npublic  class Output(val d: Data) : Closeable {\n    public fun doOutput(data: Int): Int = data\n}\n\npublic interface Closeable {\n    open public fun close() {}\n}\n\npublic inline fun <R> use(block: ()-> R) : R {\n    return block()\n}\n\npublic fun <R> useNoInline(block: ()-> R) : R {\n    return block()\n}\n\n\npublic fun Input.copyTo(output: Output, size: Int): Long {\n    return output.doOutput(this.data()).toLong()\n}\n\n\npublic inline fun <T> with2(receiver : T, crossinline body :  T.() -> Unit) : Unit = {receiver.body()}()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun Data.test1(d: Data) : Long  {\n    val input = Input(this)\n    var result = 10.toLong()\n    with(input) {\n         result = use<Long>{\n            val output = Output(d)\n             use<Long>{\n                data()\n                copyTo(output, 10)\n            }\n        }\n    }\n    return result\n}\n\nfun Data.test2(d: Data) : Long  {\n    val input = Input(this)\n    var result = 10.toLong()\n    with2(input) {\n        result = use<Long>{\n            val output = Output(d)\n            useNoInline<Long>{\n                data()\n                copyTo(output, 10)\n            }\n        }\n    }\n    return result\n}\n\n\nfun box(): String {\n\n    val result = Data().test1(Data())\n    if (result != 100.toLong()) return \"test1: ${result}\"\n\n    val result2 = Data().test2(Data())\n    if (result2 != 100.toLong()) return \"test2: ${result2}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// NO_CHECK_LAMBDA_INLINING\n// FILE: 1.kt\npackage test\n\npublic inline fun <T> with2(receiver: T,  body: T.() -> String) =  receiver.body()\n\n// FILE: 2.kt\nimport test.*\n\nfun <T : Any> test(item: T?, defaultLink: T.() -> String): String {\n    return with2(\"\") {\n        item?.defaultLink() ?: \"fail\"\n    }\n}\n\nfun box(): String {\n    return test(\"O\") {\n        this + \"K\"\n    }\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\npublic class Input(val s1: String, val s2: String) {\n    public fun iterator() : Iterator<String> {\n        return arrayListOf(s1, s2).iterator()\n    }\n}\n\npublic inline fun <T, R> T.use(block: ()-> R) : R {\n    return block()\n}\n\npublic inline fun <T, R> T.use2(block: ()-> R) : R {\n    return block()\n}\n\npublic inline fun Input.forEachLine(block: () -> Unit): Unit {\n    use { use2 (block) }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport java.util.*\n\n\nfun sample(): Input {\n    return Input(\"Hello\", \"World\");\n}\n\nfun testForEachLine() {\n    val list = ArrayList<String>()\n    val reader = sample()\n\n    reader.forEachLine{\n        list.add(\"111\")\n    }\n}\n\n\nfun box(): String {\n    testForEachLine()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\npublic inline fun <T> with2(receiver: T, body: T.() -> String) =  receiver.body()\n\n// FILE: 2.kt\nimport test.*\n\ninline fun <T : Any> test(item: T?, defaultLink: T.() -> String): String {\n    return with2(\"\") {\n        item?.defaultLink() ?: \"fail\"\n    }\n}\n\nfun box(): String {\n    return test(\"O\") {\n        this + \"K\"\n    }\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\npublic class Input(val s1: String, val s2: String) {\n    public fun iterator() : Iterator<String> {\n        return arrayListOf(s1, s2).iterator()\n    }\n}\n\npublic inline fun <T, R> T.use(block: (T)-> R) : R {\n    return block(this)\n}\n\npublic inline fun Input.forEachLine(block: (String) -> Unit): Unit {\n    useLines { lines -> lines.forEach(block) }\n}\n\npublic inline fun Input.useLines(block2: (Iterator<String>) -> Unit): Unit {\n        this.use{ block2(it.iterator()) }\n}\n\n// FILE: 2.kt\n\nimport test.*\nimport java.util.*\n\n\nfun sample(): Input {\n    return Input(\"Hello\", \"World\");\n}\n\nfun testForEachLine() {\n    val list = ArrayList<String>()\n    val reader = sample()\n\n    reader.forEachLine{\n        list.add(it)\n    }\n}\n\n\nfun box(): String {\n    testForEachLine()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Data()\n\npublic class Input(val d: Data) : Closeable {\n    public fun data() : Int = 100\n}\npublic  class Output(val d: Data) : Closeable {\n    public fun doOutput(data: Int): Int = data\n}\n\npublic interface Closeable {\n    open public fun close() {}\n}\n\npublic inline fun <T: Closeable, R> T.use(block: (T)-> R) : R {\n    var closed = false\n    try {\n        return block(this)\n    } catch (e: Exception) {\n        closed = true\n        try {\n            this.close()\n        } catch (closeException: Exception) {\n\n        }\n        throw e\n    } finally {\n        if (!closed) {\n            this.close()\n        }\n    }\n}\n\n\npublic fun Input.copyTo(output: Output, size: Int): Long {\n    return output.doOutput(this.data()).toLong()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\nfun Data.test1(d: Data) : Long  {\n    val input2 = Input(this)\n    val input = Input(this)\n    return input.use<Input, Long>{\n        val output = Output(d)\n        output.use<Output,Long>{\n            input.copyTo(output, 10)\n        }\n    }\n}\n\n\nfun box(): String {\n\n    val result = Data().test1(Data())\n    if (result != 100.toLong()) return \"test1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: String) = x\n\ninline fun processRecords(s: String?, block: String.(String) -> String) = s?.block(foo(\"O\"))\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String? {\n    return processRecords(\"O\") { this + \"K\" }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: String, y: String) = x + y\n\nclass A {\n    fun test(s: String) = s\n}\n\ninline fun processRecords(block: (String) -> String): String {\n    return A().test(block(foo(\"O\", foo(\"K\", \"1\"))))\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = processRecords { \"B\" + it }\n\n    return if (result == \"BOK1\") \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: String) = x\n\ninline fun processRecords(block: (String) -> String) = block(foo(\"O\"))\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return processRecords { ext -> ext + \"K\" }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nobject ContentTypeByExtension {\n    inline fun processRecords(crossinline operation: (String) -> String) =\n            listOf(\"O\", \"K\").map {\n                val ext = B(it)\n                operation(ext.toLowerCase())\n            }.joinToString(\"\")\n}\n\n\n\n\ninline fun A.toLowerCase(): String = (this as B).value\n\nopen class A\n\nopen class B(val value: String) : A()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return ContentTypeByExtension.processRecords { ext -> ext }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: String) = x\n\nfun test(a: String, s: String) = s\n\n\ninline fun processRecords(block: (String, String) -> String): String {\n    return test(\"stub\", block(foo(\"O\"), foo(\"K\")))\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return processRecords { a, b -> a + b}\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nobject ContentTypeByExtension {\n    inline fun processRecords(crossinline operation: (String) -> String) =\n             {\n                val ext = B(\"OK\")\n                operation(ext.toLowerCase())\n            }()\n}\n\n\n\n\ninline fun A.toLowerCase(): String = (this as B).value\n\nopen class A\n\nopen class B(val value: String) : A()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return ContentTypeByExtension.processRecords { ext -> ext }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun foo(x: String) = x\n\nclass A {\n    fun test(s: String) = s\n}\n\ninline fun processRecords(block: (String) -> String): String {\n    return A().test(block(foo(\"K\")))\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return processRecords { \"O\" + it }\n}\n"
        },
        {
            "code": "// for android\n// FILE: 1.kt\npackage test\n\nvar res =  \"fail\"\n\ninline fun foo(x: (Int, Station) -> Unit) {\n    x(1, Station(\"a\", \"b\", \"c\"))\n    res = \"O\"\n}\n\ninline fun foo2(x: (Int, StationInt) -> Unit) {\n    x(1, StationInt(1, 2, 3))\n    res += \"K\"\n}\n\ndata class Station(\n        val id: String,\n        val name: String,\n        val distance: String)\n\ndata class StationInt(\n        val id: Int,\n        val name: Int,\n        val distance: Int)\n\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    foo { i, (a1, a2, a3) -> a3 + i }\n    foo2 { i, (a1, a2, a3) -> i + a3 }\n    return res\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun inline(s: () -> String): String {\n    return s()\n}\n\nclass InlineAll {\n\n    inline fun inline(s: () -> String): String {\n        return s()\n    }\n\n    companion object {\n        inline fun inline(s: () -> String): String {\n            return s()\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun testClassObjectCall(): String {\n    return InlineAll.inline({\"classobject\"})\n}\n\nfun testInstanceCall(): String {\n    val inlineX = InlineAll()\n    return inlineX.inline({\"instance\"})\n}\n\nfun testPackageCall(): String {\n    return inline({\"package\"})\n}\n\nfun box(): String {\n    if (testClassObjectCall() != \"classobject\") return \"test1: ${testClassObjectCall()}\"\n    if (testInstanceCall() != \"instance\") return \"test2: ${testInstanceCall()}\"\n    if (testPackageCall() != \"package\") return \"test3: ${testPackageCall()}\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// FILE: 1.kt\n\npackage test\n\nobject Host {\n\n    inline val <reified T : Any>  T.foo: String\n        get() = T::class.java.simpleName\n}\n\n// FILE: 2.kt\n\nimport test.Host.foo\n\nclass OK\n\nfun box(): String {\n    return OK().foo\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// FILE: 1.kt\npackage test\n\nclass WeakReference<T>(val value: T)\n\ninline fun <K, V> MutableMap<K, WeakReference<V>>.getOrPutWeak(key: K, defaultValue: ()->V): V {\n    val value = get(key)?.value\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, WeakReference(answer))\n        answer\n    } else {\n        value\n    }\n}\n\n\n// FILE: 2.kt\nimport test.*\n\nclass LabelHolder {\n\n    fun test(): String {\n        return \"hello\".label\n    }\n\n    private val labels = hashMapOf<String?, WeakReference<String>>()\n\n    private val String?.label: String\n        get(): String = labels.getOrPutWeak(this) { \"OK\" }\n}\n\nfun box(): String {\n    return LabelHolder().test()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\n\ninline fun <R> doWork(crossinline job: ()-> R) : R {\n    return notInline({job()})\n}\n\nfun <R> notInline(job: ()-> R) : R {\n    return job()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport  test.*\n\nval s = doWork({11})\n\nfun box(): String {\n    if (s != 11) return \"test1: ${s}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nobject Host {\n    // private final foo()V\n    inline fun <reified T> foo(): String {\n        return \"OK\"\n    }\n}\n\n\n// FILE: 2.kt\n\nimport test.Host.foo\n\nfun box(): String {\n    return foo<Any>()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\nclass C<T>(val value: T) {\n    var inserting: Boolean = false\n    fun nextSlot(): Any? = null\n    fun startNode(key: Any?) {}\n    fun endNode() {}\n    fun emitNode(node: Any?) {}\n    fun useNode(): T = value\n    fun skipValue() {}\n    fun updateValue(value: Any?) {}\n}\n\nclass B<T>(val composer: C<T>, val node: T) {\n    inline fun <V> bar(value: V, block: T.(V) -> Unit) = with(composer) {\n        if (inserting || nextSlot() != value) {\n            updateValue(value)\n            node.block(value)\n        } else skipValue()\n    }\n}\n\nclass A<T>(val composer: C<T>) {\n    inline fun foo(key: Any, ctor: () -> T, update: B<T>.() -> Unit) = with(composer) {\n        startNode(key)\n        val node = if (inserting)\n            ctor().also { emitNode(it) }\n        else useNode() as T\n        B(this, node).update()\n        endNode()\n    }\n}\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    val a = A(C(\"foo\"))\n    val str = \"OK\"\n    var result = \"fail\"\n    a.foo(\n        123,\n        { \"abc\" },\n        {\n            bar(str) { }\n            result = \"OK\"\n        }\n    )\n\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> String.test(default: T, cb: String.(T) -> T): T = cb(default)\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val p = \"\".test(50.0) {\n        it\n    }\n\n    return if (p == 50.0) \"OK\" else \"fail $p\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun foo(x: (Int, Station) -> Unit) {\n    x(1, Station(null, \"\", 1))\n}\n\ndata class Station(\n        val id: String?,\n        val name: String,\n        val distance: Int)\n\n\n// FILE: 2.kt\nimport test.*\n\nfun box(): String {\n    foo { i, (a1, a2, a3) -> i + a3 }\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\npublic class Data()\n\npublic inline fun <T, R> T.use(block: (T)-> R) : R {\n    return block(this)\n}\n\npublic inline fun use2() : Int {\n    val s = 100\n    return s\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass Z {}\n\nfun test1() : Int {\n    val input = Z()\n    return input.use<Z, Int>{\n        100\n    }\n}\n\nfun test2() : Int {\n    val x = 1000\n    return use2() + x\n}\n\n\nfun box(): String {\n    if (test1() != 100) return \"test1: ${test1()}\"\n    if (test2() != 1100) return \"test1: ${test2()}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass W(val value: Any)\n\ninline fun W.safe(body : Any.() -> Unit) {\n    this.value?.body()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var result = \"fail\"\n    W(\"OK\").safe {\n        result = this as String\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nenum class MyEnum {\n    K;\n\n    //TODO: KT-4693\n    inline fun <T> doSmth(a: T) : String {\n        return a.toString() + K.name\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(): String {\n    return MyEnum.K.doSmth(\"O\")\n}\n\nfun box(): String {\n    val result = test1()\n    if (result != \"OK\") return \"fail1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun f(g: (Int) -> Int) = g(2)\n\ninline fun h() = 1\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val result = f { it + h() }\n    return if (result == 3) \"OK\" else \"fail: $result\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <T> doSmth(a: T) : String {\n    return a.toString()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(s: Long): String {\n    return doSmth(s)\n}\n\nfun box(): String {\n    val result = test1(11.toLong())\n    if (result != \"11\") return \"fail1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun Double.run(body : Double.() -> String): String {\n    return this.body()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var captured = \"fail\"\n    return 1.0.run {\n        if (this == 1.0) {\n             \"OK\"\n        } else captured\n    }\n\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun doSmth(vararg a: String) : String {\n    return a.foldRight(\"\", { a, b -> a + b})\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun test1(): String {\n    return doSmth(\"O\", \"K\")\n}\n\nfun box(): String {\n    val result = test1()\n    if (result != \"OK\") return \"fail1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// FILE: flow.kt\n// COMMON_COROUTINES_TEST\n// FULL_JDK\n// WITH_RUNTIME\n// WITH_COROUTINES\n\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\npublic inline fun <T> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) = collector.block()\n}\n\nsuspend inline fun <T> Flow<T>.collect(crossinline action: suspend (T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n\npublic inline fun <T, R> Flow<T>.transform(crossinline transformer: suspend FlowCollector<R>.(value: T) -> Unit): Flow<R> {\n    return flow {\n        collect { value ->\n            transformer(value)\n        }\n    }\n}\n\npublic inline fun <T, R> Flow<T>.map(crossinline transformer: suspend (value: T) -> R): Flow<R> = transform { value -> emit(transformer(value)) }\n\ninline fun decorate() = suspend {\n    flow<Int> {\n        emit(1)\n    }.map { it + 1 }\n        .collect {\n        }\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport flow.*\n\nfun box() : String {\n    decorate()\n    val enclosingMethod = try {\n        Class.forName(\"flow.FlowKt\\$decorate\\$1\\$invokeSuspend\\$\\$inlined\\$map\\$1\\$1\").enclosingMethod\n    } catch (ignore: ClassNotFoundException) {\n        Class.forName(\"flow.FlowKt\\$decorate\\$1\\$doResume\\$\\$inlined\\$map\\$1\\$1\").enclosingMethod\n    }\n    if (\"$enclosingMethod\".contains(\"\\$\\$forInline\")) return \"$enclosingMethod\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninline suspend fun suspendThere(v: String): String = suspendCoroutineUninterceptedOrReturn { x ->\n    x.resume(v)\n    COROUTINE_SUSPENDED\n}\n\nsuspend inline fun complexSuspend(crossinline c: suspend () -> String): String {\n    return run {\n        c()\n    }\n}\n\n// FILE: inleneSite.kt\n// COMMON_COROUTINES_TEST\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun suspendHere(): String = suspendThere(\"O\")\n\nfun box(): String {\n    var result = \"\"\n\n    builder {\n        result = suspendHere() + complexSuspend { suspendThere(\"K\") }\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nsuspend inline fun inlineMe(c: suspend () -> Unit) {\n    c()\n    c()\n    c()\n    c()\n    c()\n}\nsuspend inline fun noinlineMe(noinline c: suspend () -> Unit) {\n    c()\n    c()\n    c()\n    c()\n    c()\n}\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    c()\n    c()\n    c()\n    c()\n    c()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nvar i = 0;\nvar j = 0;\nvar k = 0;\n\nsuspend fun calculateI() {\n    i++\n}\n\nsuspend fun calculateJ() {\n    j++\n}\n\nsuspend fun calculateK() {\n    k++\n}\n\nsuspend fun inlineSite() {\n    inlineMe {\n        calculateI()\n        calculateI()\n    }\n    noinlineMe {\n        calculateJ()\n        calculateJ()\n    }\n    crossinlineMe {\n        calculateK()\n        calculateK()\n    }\n}\n\nfun box(): String {\n    builder {\n        inlineSite()\n    }\n    if (i != 10) return \"FAIL I\"\n    if (j != 10) return \"FAIL J\"\n    if (k != 10) return \"FAIL K\"\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// suspend calls possible inside lambda matching to the parameter\n\nsuspend inline fun test(c: () -> Unit) {\n    c()\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\ninline fun transform(crossinline c: suspend () -> Unit) {\n    builder { c() }\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    var res = \"FAIL 1\"\n    builder {\n        test {\n            res = calculate()\n        }\n    }\n    if (res != \"OK\") return res\n    builder {\n        test {\n            transform {\n                test {\n                    res = calculate()\n                }\n            }\n        }\n    }\n    return res\n}\n"
        },
        {
            "code": "// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// suspend calls possible inside lambda matching to the parameter\n\nsuspend inline fun test(c: suspend () -> Unit) {\n    c()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    var res = \"FAIL 1\"\n    builder {\n        test {\n            res = calculate()\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 2\"\n    builder {\n        test {\n            test {\n                test {\n                    test {\n                        test {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nclass Controller {\n    var res = \"FAIL 1\"\n}\n\nval defaultController = Controller()\n\nsuspend inline fun test1(controller: Controller = defaultController, crossinline c: suspend Controller.() -> Unit) {\n    controller.c()\n}\n\nsuspend inline fun test2(controller: Controller = defaultController, crossinline c: suspend Controller.() -> Unit) {\n    val l : suspend () -> Unit = {\n        controller.c()\n    }\n    l()\n}\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun test3(controller: Controller = defaultController, crossinline c: suspend Controller.() -> Unit) {\n    val sr = object: SuspendRunnable {\n        override suspend fun run() {\n            controller.c()\n        }\n    }\n    sr.run()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    builder {\n        test1 {\n            res = calculate()\n        }\n    }\n    if (defaultController.res != \"OK\") return defaultController.res\n    defaultController.res = \"FAIL 2\"\n    builder {\n        test2 {\n            res = calculate()\n        }\n    }\n    if (defaultController.res != \"OK\") return defaultController.res\n    defaultController.res = \"FAIL 3\"\n    builder {\n        test3 {\n            res = calculate()\n        }\n    }\n    if (defaultController.res != \"OK\") return defaultController.res\n    val controller = Controller()\n    controller.res = \"FAIL 4\"\n    builder {\n        test1(controller) {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 5\"\n    builder {\n        test2(controller) {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 6\"\n    builder {\n        test3(controller) {\n            res = calculate()\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nclass Controller {\n    var res = \"FAIL 1\"\n}\n\nval defaultController = Controller()\n\nsuspend inline fun test(controller: Controller = defaultController, c: suspend Controller.() -> Unit) {\n    controller.c()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    builder {\n        test {\n            res = calculate()\n        }\n    }\n    if (defaultController.res != \"OK\") return defaultController.res\n    val controller = Controller()\n    controller.res = \"FAIL 2\"\n    builder {\n        test(controller) {\n            res = calculate()\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// WITH_RUNTIME\n// WITH_COROUTINES\n\n// FILE: flow.kt\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T : Any> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\npublic inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit): Flow<T> = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) = collector.block()\n}\n\ninline suspend fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n\ninline suspend fun inlineMe(crossinline block: suspend () -> Unit) = suspend {\n    block()\n}\n\n// FILE: Test.kt\n\nimport flow.*\nimport helpers.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var str = \"FAIL\"\n    builder {\n        flow<Unit> {\n            var continuation: Continuation<Unit>? = null\n            suspendCoroutineUninterceptedOrReturn<Unit> { continuation = it; Unit }\n            str = \"$continuation\"\n        }.collect {\n        }\n    }\n    if (\"(Test.kt:\" !in str) return str\n    builder {\n        inlineMe {\n            var continuation: Continuation<Unit>? = null\n            suspendCoroutineUninterceptedOrReturn<Unit> { continuation = it; Unit }\n            str = \"$continuation\"\n        }()\n    }\n    if (\"(Test.kt:\" !in str) return str\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// suspend calls possible inside lambda matching to the parameter\n\nsuspend inline fun test1(crossinline c: suspend () -> Unit) {\n    c()\n}\n\nsuspend inline fun test2(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = { c() }\n    l()\n}\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun test3(crossinline c: suspend () -> Unit) {\n    val sr = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n        }\n    }\n    sr.run()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    var res = \"FAIL 1\"\n    builder {\n        test1 {\n            res = calculate()\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 2\"\n    builder {\n        test2 {\n            res = calculate()\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 3\"\n    builder {\n        test3 {\n            res = calculate()\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 4\"\n    builder {\n        test1 {\n            test1 {\n                test1 {\n                    test1 {\n                        test1 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 5\"\n    builder {\n        test2 {\n            test2 {\n                test2 {\n                    test2 {\n                        test2 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 6\"\n    builder {\n        test3 {\n            test3 {\n                test3 {\n                    test3 {\n                        test3 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 7\"\n    builder {\n        test1 {\n            test2 {\n                test3 {\n                    test1 {\n                        test2 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n    l()\n    l()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    var res = \"OK\"\n    builder {\n        crossinlineMe {\n            res = \"FAIL 1\"\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 10)\n    return res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n    suspend fun run2()\n}\n\ninline fun inlineMe(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) =\n    object : SuspendRunnable {\n        override suspend fun run() {\n            c1() // TODO: Double this call, when suspend markers are generated for inline and crossinline lambdas\n        }\n\n        override suspend fun run2() {\n            c2()\n        }\n    }\n\n\ninline fun inlineMe2(crossinline c1: suspend () -> Unit) =\n    inlineMe(c1) {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    val r = inlineMe2 {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n\n    builder {\n        r.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 2)\n    StateMachineChecker.reset()\n    builder {\n        r.run2()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 2)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val o = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n            c()\n        }\n    }\n    o.run()\n    o.run()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 8)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\ninterface SuspendRunnable {\n    suspend fun run1()\n    suspend fun run2()\n}\n\nsuspend inline fun crossinlineMe(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) {\n    val o = object : SuspendRunnable {\n        override suspend fun run1() {\n            c1()\n            c1()\n        }\n        override suspend fun run2() {\n            c2()\n            c2()\n        }\n    }\n    o.run1()\n    o.run2()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nvar j = 0\n\nsuspend fun incrementJ() {\n    j++\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe({ StateMachineChecker.suspendHere() }) { incrementJ() }\n    }\n    if (j != 0) return \"FAIL j != 0 $j\"\n    StateMachineChecker.check(numberOfSuspensions = 2)\n    if (j != 2) return \"FAIL j != 2 $j\"\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = {\n        c()\n        c()\n    }\n    l()\n    l()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            val sr = object: SuspendRunnable {\n                override suspend fun run() {\n                    val l : suspend () -> Unit = {\n                        val sr = object: SuspendRunnable {\n                            override suspend fun run() {\n                                val l : suspend () -> Unit = {\n                                    val sr = object: SuspendRunnable {\n                                        override suspend fun run() {\n                                            StateMachineChecker.suspendHere()\n                                            StateMachineChecker.suspendHere()\n                                        }\n                                    }\n                                    sr.run()\n                                    sr.run()\n                                }\n                                l()\n                                l()\n                            }\n                        }\n                        sr.run()\n                        sr.run()\n                    }\n                    l()\n                    l()\n                }\n            }\n            sr.run()\n            sr.run()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 256)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = {\n        val l1 : suspend () -> Unit = {\n            c()\n            c()\n        }\n        l1()\n        l1()\n    }\n    l()\n    l()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 16)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\ninline fun inlineMe(crossinline c: suspend () -> Unit) = {\n    {\n        val sr: SuspendRunnable = object : SuspendRunnable {\n            override suspend fun run() {\n                c()\n                c()\n            }\n        }\n        sr\n    }()\n}()\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// In this test the following transformation are occuring:\n//   flow$1 -> flowWith$$inlined$flow$1\n//   flow$1 -> check$$inlined$flow$1\n//   flow$1 -> flowWith$$inlined$flow$2\n//   flowWith$$inlined$flow$2 -> check$$inlined$flowWith$1\n\n// All thansformations, except the third, shall generate state-machine.\n// The third shall not generate state-machine, since it is retransformed.\n\n// FILE: inline.kt\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T : Any> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\npublic inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) {\n        collector.block()\n        collector.block()\n    }\n}\n\nsuspend inline fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit) {\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) {\n            action(value)\n            action(value)\n        }\n    })\n}\n\ninline fun <T : Any, R : Any> Flow<T>.flowWith(crossinline builderBlock: suspend Flow<T>.() -> Flow<R>): Flow<T> =\n    flow {\n        builderBlock()\n        builderBlock()\n    }\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport flow.*\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nsuspend fun check() {\n    val f: Unit = flow<Int> {\n        emit(1)\n    }.flowWith {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n        this\n    }.collect {\n        // In this test collect is just terminating operation, which just runs the lazy computations\n    }\n}\n\nfun box(): String {\n    builder {\n        check()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 8)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n    suspend fun ownIndependentInline()\n}\n\ninline fun inlineMe(crossinline c1: suspend () -> Unit) =\n    object : SuspendRunnable {\n        override suspend fun run() {\n            c1()\n            c1()\n        }\n\n        override suspend fun ownIndependentInline() {\n            inlineMe2 {\n                StateMachineChecker.suspendHere()\n                StateMachineChecker.suspendHere()\n            }.ownIndependentInline()\n        }\n    }\n\n\ninline fun inlineMe2(crossinline c2: suspend () -> Unit): SuspendRunnable =\n    object : SuspendRunnable {\n        override suspend fun run() {\n        }\n\n        override suspend fun ownIndependentInline() {\n            c2()\n            c2()\n        }\n    }\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    val r = inlineMe {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n\n    builder {\n        r.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        r.ownIndependentInline()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = {\n        val sr = object: SuspendRunnable {\n            override suspend fun run() {\n                val l : suspend () -> Unit = {\n                    val sr = object: SuspendRunnable {\n                        override suspend fun run() {\n                            val l : suspend () -> Unit = {\n                                val sr = object: SuspendRunnable {\n                                    override suspend fun run() {\n                                        c()\n                                        c()\n                                    }\n                                }\n                                sr.run()\n                                sr.run()\n                            }\n                            l()\n                            l()\n                        }\n                    }\n                    sr.run()\n                    sr.run()\n                }\n                l()\n                l()\n            }\n        }\n        sr.run()\n        sr.run()\n    }\n    l()\n    l()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 256)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nclass R : SuspendRunnable {\n    override suspend fun run() {\n        val sr: SuspendRunnable = inlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n        sr.run()\n    }\n\n    inline fun inlineMe2(crossinline c: suspend () -> Unit) = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n            c()\n        }\n    }\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        R().run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: inline.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// FULL_JDK\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nimport helpers.*\nimport COROUTINES_PACKAGE.intrinsics.*\n\nfun check() = true\n\ninline suspend fun inlineMe(): Unit {\n    suspendCoroutineUninterceptedOrReturn<Nothing> {\n        if (check()) error(\"O\") else error(\"Not this one\")\n    }\n}\n\n// FILE: box.kt\n// WITH_COROUTINES\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nsuspend fun withoutTryCatch(): String {\n    StateMachineChecker.suspendHere()\n    inlineMe()\n    return \"\" // To prevent tail-call optimization\n}\n\nfun box(): String {\n    var result = \"FAIL 0\"\n    builder {\n        result = try {\n            StateMachineChecker.suspendHere()\n            inlineMe()\n            \"FAIL 1\"\n        } catch (e: IllegalStateException) {\n            e.message!!\n        }\n        try {\n            withoutTryCatch()\n            result += \"FAIL 2\"\n        } catch (e: IllegalStateException) {\n            result += \"K\"\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 2)\n    return result\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\ninterface SuspendRunnable {\n    suspend fun run()\n    suspend fun run2()\n}\n\ninline fun inlineMe(crossinline c: suspend () -> Unit, crossinline c2: suspend () -> Unit) =\n    object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n            c()\n        }\n\n        override suspend fun run2() {\n            c2()\n            c2()\n        }\n    }\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    val r = inlineMe(\n        {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    ) {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n    builder {\n        r.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        r.run2()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val o = object : SuspendRunnable {\n        override suspend fun run() {\n            val o1 = object: SuspendRunnable {\n                override suspend fun run() {\n                    c()\n                    c()\n                }\n            }\n            o1.run()\n            o1.run()\n        }\n    }\n    o.run()\n    o.run()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 16)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = {\n        c()\n        c()\n    }\n    l()\n    l()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 8)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val o = object : SuspendRunnable {\n        override suspend fun run() {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    o.run()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    var res = \"OK\"\n    builder {\n        crossinlineMe {\n            res = \"FAIL 1\"\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 5)\n    return res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nfun runSuspend(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\ninline suspend fun inlineMe(crossinline c1: suspend () -> Unit) {\n    object : SuspendRunnable {\n        override suspend fun run() {\n            c1()\n        }\n    }.run()\n\n    StateMachineChecker.check(2)\n    StateMachineChecker.reset()\n\n    runSuspend {\n        object : SuspendRunnable {\n            override suspend fun run() {\n                StateMachineChecker.suspendHere()\n                StateMachineChecker.suspendHere()\n            }\n        }.run()\n\n        StateMachineChecker.check(2)\n    }\n}\n\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        inlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = { c() }\n    l()\n}\n\nsuspend inline fun crossinlineMe2(crossinline c: suspend () -> Unit) {\n    crossinlineMe { c(); c() }\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe2 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 10)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nimport helpers.*\n\ninline fun inlineMe(crossinline c: suspend () -> Unit) = suspend { c(); c() }\n\ninline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    val r = inlineMe2 {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n\n    builder {\n        r()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 8)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\ninline fun inlineMe1(crossinline c: suspend () -> Unit) =\n    object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n            c()\n        }\n    }\n\ninline fun inlineMe2(crossinline c: suspend () -> Unit) = suspend {\n    c()\n    c()\n}\n\ninline suspend fun inlineMe3(crossinline c: suspend () -> Unit) {\n    c()\n    c()\n}\n\ninline suspend fun inlineMe4(c: suspend () -> Unit) {\n    c()\n    c()\n}\n\ninline fun inlineMe5(noinline c: suspend () -> Unit) =\n    object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n            c()\n        }\n    }\n\ninline fun inlineMe6(noinline c: suspend () -> Unit) = suspend {\n    c()\n    c()\n}\n\ninline suspend fun inlineMe7(noinline c: suspend () -> Unit) {\n    c()\n    c()\n}\n\ninline fun inlineMe11(crossinline c: suspend () -> Unit) = inlineMe1(c)\ninline fun inlineMe12(crossinline c: suspend () -> Unit) = inlineMe2(c)\ninline suspend fun inlineMe13(crossinline c: suspend () -> Unit) = inlineMe3(c)\ninline suspend fun inlineMe14(crossinline c: suspend () -> Unit) = inlineMe4(c)\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    val lambda = suspend {\n        StateMachineChecker.suspendHere()\n        StateMachineChecker.suspendHere()\n    }\n\n    builder {\n        val r = inlineMe1(lambda)\n        r.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe2(lambda)()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe3(lambda)\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe4(lambda)\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        val r = inlineMe5(lambda)\n        r.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe6(lambda)()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe7(lambda)\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n\n    StateMachineChecker.reset()\n    builder {\n        val r = inlineMe11 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n        r.run()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe12 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }()\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe13 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n    StateMachineChecker.reset()\n    builder {\n        inlineMe14 {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 4)\n\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// CHECK_STATE_MACHINE\n\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    c()\n    c()\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(CheckStateMachineContinuation)\n}\n\nfun box(): String {\n    builder {\n        crossinlineMe {\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n            StateMachineChecker.suspendHere()\n        }\n    }\n    StateMachineChecker.check(numberOfSuspensions = 10)\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines\n// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// NO_CHECK_LAMBDA_INLINING\n// FILE: test.kt\n\ninline suspend fun foo(x: suspend () -> String) = x()\n\n// FILE: box.kt\n// WITH_RUNTIME\n// WITH_COROUTINES\n\nimport helpers.ContinuationAdapter\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object: ContinuationAdapter<Unit>() {\n        override fun resume(value: Unit) {\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            throw exception\n        }\n    })\n}\n\nsuspend fun String.id() = this\n\nfun box(): String {\n    var res = \"\"\n    builder {\n        res = foo(\"OK\"::id)\n    }\n    return res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nsuspend inline fun test1(c: suspend () -> Unit) {\n    c()\n}\n\nsuspend inline fun test2(crossinline c: suspend () -> Unit) {\n    val l: suspend () -> Unit = { c() }\n    l()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = suspendCoroutineUninterceptedOrReturn<String> {\n    it.resume(\"OK\")\n    COROUTINE_SUSPENDED\n}\n\nfun box() : String {\n    var res = \"FAIL 1\"\n    builder {\n        val a = 1\n        test2 {\n            val b = 2\n            test1 {\n                val c = a + b // 3\n                run {\n                    val a = c + 1 // 4\n                    test1 {\n                        val b = c + c // 6\n                        test2 {\n                            val c = b - a // 2\n                            res = \"${calculate()} $a$b$c\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK 462\") return res\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// suspend calls possible inside lambda matching to the parameter\n\nclass Controller {\n    var res = \"FAIL 1\"\n\n    suspend inline fun test(c: Controller.() -> Unit) {\n        c()\n    }\n\n    inline fun transform(crossinline c: suspend Controller.() -> Unit) {\n        builder(this) { c() }\n    }\n}\n\nfun builder(controller: Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, EmptyContinuation)\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    val controller = Controller()\n    builder(controller) {\n        test {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    builder(controller) {\n        test {\n            transform {\n                test {\n                    res = calculate()\n                }\n            }\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// suspend calls possible inside lambda matching to the parameter\n\nclass Controller {\n    var res = \"FAIL 1\"\n\n    suspend inline fun test(c: suspend Controller.() -> Unit) {\n        c()\n    }\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(controller: Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    val controller = Controller()\n    builder(controller) {\n        test {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 2\"\n    builder(controller) {\n        test {\n            test {\n                test {\n                    test {\n                        test {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// SKIP_SOURCEMAP_REMAPPING\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// suspend calls possible inside lambda matching to the parameter\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nclass Controller {\n    var res = \"FAIL 1\"\n\n    suspend inline fun test1(crossinline c: suspend Controller.() -> Unit) {\n        c()\n    }\n\n    suspend inline fun test2(crossinline c: suspend Controller.() -> Unit) {\n        val l: suspend Controller.() -> Unit = { c() }\n        l()\n    }\n\n    suspend inline fun test3(crossinline c: suspend Controller.() -> Unit) {\n        val sr = object : SuspendRunnable {\n            override suspend fun run() {\n                c()\n            }\n        }\n        sr.run()\n    }\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(controller: Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() : String {\n    val controller = Controller()\n    builder(controller) {\n        test1 {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 2\"\n    builder(controller) {\n        test2 {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 3\"\n    builder(controller) {\n        test3 {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 4\"\n    builder(controller) {\n        test1 {\n            test1 {\n                test1 {\n                    test1 {\n                        test1 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 5\"\n    builder(controller) {\n        test2 {\n            test2 {\n                test2 {\n                    test2 {\n                        test2 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 6\"\n    builder(controller) {\n        test3 {\n            test3 {\n                test3 {\n                    test3 {\n                        test3 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 7\"\n    builder(controller) {\n        test1 {\n            test2 {\n                test3 {\n                    test1 {\n                        test2 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// SKIP_SOURCEMAP_REMAPPING\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// Are suspend calls possible inside lambda matching to the parameter\n// Start coroutine call is possible\n// Block is allowed to be called directly inside inline function\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\n\nclass Controller {\n    var res = \"FAIL 1\"\n\n    suspend inline fun test1(noinline c: suspend Controller.() -> Unit)  {\n        val l : suspend Controller.() -> Unit = { c() }\n        l()\n    }\n\n    suspend inline fun test2(noinline c: suspend Controller.() -> Unit) {\n        c.startCoroutine(this, EmptyContinuation)\n    }\n\n    suspend inline fun test3(noinline c: suspend Controller.() -> Unit) {\n        c()\n    }\n\n    suspend inline fun test4(noinline c: suspend Controller.() -> Unit) {\n        val sr = object: SuspendRunnable {\n            override suspend fun run() {\n                c()\n            }\n        }\n        sr.run()\n    }\n}\n\nfun builder(controller: Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, EmptyContinuation)\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nsuspend fun calculate() = \"OK\"\n\nfun box(): String {\n    val controller = Controller()\n    builder(controller) {\n        test1 {\n            res = calculate()\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 2\"\n    builder(controller) {\n        test2 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 3\"\n    builder(controller) {\n        test3 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 4\"\n    builder(controller) {\n        test4 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 5\"\n    builder(controller) {\n        test1 {\n            test1 {\n                test1 {\n                    test1 {\n                        test1 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 6\"\n    builder(controller) {\n        test2 {\n            test2 {\n                test2 {\n                    test2 {\n                        test2 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 7\"\n    builder(controller) {\n        test3 {\n            test3 {\n                test3 {\n                    test3 {\n                        test3 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 8\"\n    builder(controller) {\n        test4 {\n            test4 {\n                test4 {\n                    test4 {\n                        test4 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n    controller.res = \"FAIL 9\"\n    builder(controller) {\n        test1 {\n            test2 {\n                test3 {\n                    test4 {\n                        test1 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// IGNORE_BACKEND: JS\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n\n// Needed for JS compatibility\ninterface Runnable {\n    fun run(): Unit\n}\n\nclass Controller {\n    var res = \"FAIL 1\"\n\n    suspend inline fun test1(crossinline c: Controller.() -> Unit) {\n        c()\n    }\n\n    suspend inline fun test2(crossinline c: Controller.() -> Unit) {\n        val l = { c() }\n        l()\n    }\n\n    suspend inline fun test3(crossinline c: Controller.() -> Unit) {\n        val r = object: Runnable {\n            override fun run() {\n                c()\n            }\n        }\n        r.run()\n    }\n\n    inline fun transform(crossinline c: suspend Controller.() -> Unit) {\n        builder(this) { c() }\n    }\n}\n\nfun builder(controller : Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, EmptyContinuation)\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun box() : String {\n    val controller = Controller()\n    builder(controller) {\n        test1 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 2\"\n    builder(controller) {\n        test2 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 3\"\n    builder(controller) {\n        test3 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 4\"\n    builder(controller) {\n        test1 {\n            transform {\n                test1 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 5\"\n    builder(controller) {\n        test2 {\n            transform {\n                test2 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 6\"\n    builder(controller) {\n        test3 {\n            transform {\n                test3 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// IGNORE_BACKEND: JS\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n\n// Needed for JS compatibility\ninterface Runnable {\n    fun run(): Unit\n}\n\nclass Controller {\n    var res = \"FAIL 1\"\n\n    suspend inline fun test1(noinline c: Controller.() -> Unit) {\n        c()\n    }\n\n    suspend inline fun test2(noinline c: Controller.() -> Unit) {\n        val l = { c() }\n        l()\n    }\n\n    suspend inline fun test3(noinline c: Controller.() -> Unit) {\n        val r = object: Runnable {\n            override fun run() {\n                c()\n            }\n        }\n        r.run()\n    }\n\n    inline fun transform(crossinline c: suspend Controller.() -> Unit) {\n        builder(this) { c() }\n    }\n}\n\nfun builder(controller: Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, EmptyContinuation)\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun box() : String {\n    val controller = Controller()\n    builder(controller) {\n        test1 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 2\"\n    builder(controller) {\n        test2 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 3\"\n    builder(controller) {\n        test3 {\n            res = \"OK\"\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 4\"\n    builder(controller) {\n        test1 {\n            transform {\n                test1 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 5\"\n    builder(controller) {\n        test2 {\n            transform {\n                test2 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (controller.res != \"OK\") return controller.res\n\n    controller.res = \"FAIL 6\"\n    builder(controller) {\n        test3 {\n            transform {\n                test3 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    return controller.res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// WITH_RUNTIME\n// NO_CHECK_LAMBDA_INLINING\nimport kotlin.coroutines.*\n\nclass Controller(val s: String)\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit>{\n        override fun resumeWith(result: Result<Unit>) {\n            result.getOrThrow()\n        }\n\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n    })\n}\n\ninline fun execute(crossinline action: suspend () -> Unit) {\n    builder { action() }\n}\n\nfun builder(controller: Controller, c: suspend Controller.() -> Unit) {\n    c.startCoroutine(controller, object : Continuation<Unit>{\n        override fun resumeWith(result: Result<Unit>) {\n            result.getOrThrow()\n        }\n\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n    })\n}\n\ninline fun execute(controller: Controller, crossinline action: suspend Controller.() -> Unit) {\n    builder(controller) { action() }\n}\n\n// FILE: inlineSite.kt\nimport kotlin.coroutines.*\n\nsuspend fun withDefaultParameter(s: String, s1: String = \"\") = s + s1\n\nfun launch(s: String = \"\", block: suspend () -> String): String {\n    var res = s\n    builder { res += block() }\n    return res\n}\n\ninline fun launchCrossinline(s: String = \"\", crossinline block: suspend () -> String): String {\n    var res = s\n    builder { res += block() }\n    return res\n}\n\nsuspend fun Controller.withDefaultParameter(s: String, s1: String = \"\") = this.s + s + s1\n\nfun Controller.launch(s: String = \"\", block: suspend Controller.() -> String): String {\n    var res = s\n    builder(this) { res += block() }\n    return res\n}\n\ninline fun Controller.launchCrossinline(s: String = \"\", crossinline block: suspend Controller.() -> String): String {\n    var res = s\n    builder(this) { res += block() }\n    return res\n}\n\nfun box(): String {\n    var res = \"\"\n    execute {\n        res = withDefaultParameter(\"OK\")\n    }\n    if (res != \"OK\") return \"FAIL 1: $res\"\n    execute {\n        res = withDefaultParameter(\"O\", \"K\")\n    }\n    if (res != \"OK\") return \"FAIL 2: $res\"\n    execute {\n        res = launch {\n            withDefaultParameter(\"OK\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 3: $res\"\n    execute {\n        res = launch {\n            withDefaultParameter(\"O\", \"K\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 4: $res\"\n    execute {\n        res = launch(\"O\") {\n            withDefaultParameter(\"K\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 5: $res\"\n    execute {\n        res = launch(\"O\") {\n            withDefaultParameter(\"\", \"K\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 6: $res\"\n    execute {\n        res = launchCrossinline {\n            withDefaultParameter(\"OK\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 7: $res\"\n    execute {\n        res = launchCrossinline {\n            withDefaultParameter(\"O\", \"K\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 8: $res\"\n    execute {\n        res = launchCrossinline (\"O\") {\n            withDefaultParameter(\"K\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 9: $res\"\n    execute {\n        res = launchCrossinline(\"O\") {\n            withDefaultParameter(\"\", \"K\")\n        }\n    }\n    if (res != \"OK\") return \"FAIL 10: $res\"\n\n    val controller = Controller(\"A\")\n    execute(controller) {\n        res = withDefaultParameter(\"OK\")\n    }\n    if (res != \"AOK\") return \"FAIL 11: $res\"\n    execute(controller) {\n        res = withDefaultParameter(\"O\", \"K\")\n    }\n    if (res != \"AOK\") return \"FAIL 12: $res\"\n    execute(controller) {\n        res = launch {\n            withDefaultParameter(\"OK\")\n        }\n    }\n    if (res != \"AOK\") return \"FAIL 13: $res\"\n    execute(controller) {\n        res = launch {\n            withDefaultParameter(\"O\", \"K\")\n        }\n    }\n    if (res != \"AOK\") return \"FAIL 14: $res\"\n    execute(controller) {\n        res = launch(\"O\") {\n            withDefaultParameter(\"K\")\n        }\n    }\n    if (res != \"OAK\") return \"FAIL 15: $res\"\n    execute(controller) {\n        res = launch(\"O\") {\n            withDefaultParameter(\"\", \"K\")\n        }\n    }\n    if (res != \"OAK\") return \"FAIL 16: $res\"\n    execute(controller) {\n        res = launchCrossinline {\n            withDefaultParameter(\"OK\")\n        }\n    }\n    if (res != \"AOK\") return \"FAIL 17: $res\"\n    execute(controller) {\n        res = launchCrossinline {\n            withDefaultParameter(\"O\", \"K\")\n        }\n    }\n    if (res != \"AOK\") return \"FAIL 18: $res\"\n    execute(controller) {\n        res = launchCrossinline (\"O\") {\n            withDefaultParameter(\"K\")\n        }\n    }\n    if (res != \"OAK\") return \"FAIL 19: $res\"\n    execute(controller) {\n        res = launchCrossinline(\"O\") {\n            withDefaultParameter(\"\", \"K\")\n        }\n    }\n    if (res != \"OAK\") return \"FAIL 20: $res\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// Are suspend calls possible inside lambda matching to the parameter\n// Start coroutine call is possible\n// Block is allowed to be called directly inside inline function\n\nsuspend inline fun test1(noinline c: suspend () -> Unit)  {\n    val l : suspend () -> Unit = { c() }\n    builder { l() }\n}\n\n\nsuspend inline fun test2(noinline c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend inline fun test3(noinline c: suspend () -> Unit) {\n    c()\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun test4(noinline c: suspend () -> Unit) {\n    val sr = object: SuspendRunnable {\n        override suspend fun run() {\n            c()\n        }\n    }\n    sr.run()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nsuspend fun calculate() = \"OK\"\n\nfun box(): String {\n    var res = \"FAIL 1\"\n    builder {\n        test1 {\n            res = calculate()\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 2\"\n    builder {\n        test2 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 3\"\n    builder {\n        test3 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 4\"\n    builder {\n        test4 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 5\"\n    builder {\n        test1 {\n            test1 {\n                test1 {\n                    test1 {\n                        test1 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 6\"\n    builder {\n        test2 {\n            test2 {\n                test2 {\n                    test2 {\n                        test2 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 7\"\n    builder {\n        test3 {\n            test3 {\n                test3 {\n                    test3 {\n                        test3 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 8\"\n    builder {\n        test4 {\n            test4 {\n                test4 {\n                    test4 {\n                        test4 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n    res = \"FAIL 9\"\n    builder {\n        test1 {\n            test2 {\n                test3 {\n                    test4 {\n                        test1 {\n                            res = calculate()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// CHECK_STATE_MACHINE\n\n// FILE: inline.kt\n\nclass MyDeferred<T>(val t: suspend () -> T) {\n    suspend fun await() = t()\n}\n\nfun <T> async(block: suspend () -> T) = MyDeferred(block)\n\ninline fun <T, R> map(source: MyDeferred<T>, crossinline mapper: (T) -> R) =\n    async {\n        mapper(source.await())\n    }\n\ninline fun <T, R1, R2> map2(source: MyDeferred<T>, crossinline mapper1: (T) -> R1, crossinline mapper2: (R1) -> R2) =\n    async {\n        val c = suspend {\n            mapper1(source.await())\n        }\n        mapper2(c())\n    }\n\ninline fun <T, R1, R2, R3> map3(source: MyDeferred<T>, crossinline mapper1: (T) -> R1, crossinline mapper2: (R1) -> R2, crossinline mapper3: (R2) -> R3) =\n    async {\n        val c = suspend {\n            val c = suspend {\n                mapper1(source.await())\n            }\n            mapper2(c())\n        }\n        mapper3(c())\n    }\n\n// FILE: box.kt\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    val source = MyDeferred { 1 }\n    var result = -1\n    builder {\n        result = map(source) { it + 2 }.await()\n    }\n    if (result != 3) return \"FAIL 1 $result\"\n    builder {\n        result = map2(source, { it + 2 }, { it + 3 }).await()\n    }\n    if (result != 6) return \"FAIL 2 $result\"\n    builder {\n        result = map3(source, { it + 2 }, { it + 3 }, { it + 4 }).await()\n    }\n    if (result != 10) return \"FAIL 3 $result\"\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\nobject Result {\n    var a: String = \"\"\n    var b: Int = 0\n}\n\n// Needed for JS compatibility\ninterface Runnable {\n    fun run(): Unit\n}\n\nsuspend inline fun inlineMe(c: suspend () -> Unit) {\n    var a = \"\"\n    var b = 0\n    val r = object: Runnable {\n        override fun run() {\n            b++\n            a += \"a\"\n        }\n    }\n    r.run()\n    c()\n    r.run()\n    Result.a = a\n    Result.b = b\n}\nsuspend inline fun noinlineMe(noinline c: suspend () -> Unit) {\n    var a = \"\"\n    var b = 0\n    val r = object: Runnable {\n        override fun run() {\n            b += 2\n            a += \"b\"\n        }\n    }\n    r.run()\n    c()\n    r.run()\n    Result.a += a\n    Result.b += b\n}\nsuspend inline fun crossinlineMe(crossinline c: suspend () -> Unit) {\n    var a = \"\"\n    var b = 0\n    val r = object: Runnable {\n        override fun run() {\n            b += 3\n            a += \"c\"\n        }\n    }\n    r.run()\n    c()\n    r.run()\n    Result.a += a\n    Result.b += b\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun dummy() {\n    val local0 = 0\n    val local1 = 0\n    val local2 = 0\n    val local3 = 0\n    val local4 = 0\n    val local5 = 0\n    val local6 = 0\n    val local7 = 0\n    val local8 = 0\n    val local9 = 0\n    val local10 = 0\n    val local11 = 0\n    val local12 = 0\n    val local13 = 0\n    val local14 = 0\n    val local15 = 0\n    val local16 = 0\n    val local17 = 0\n    val local18 = 0\n    val local19 = 0\n    val local20 = 0\n    val local21 = 0\n    val local22 = 0\n}\n\nsuspend fun inlineSite() {\n    inlineMe {\n        dummy()\n        dummy()\n    }\n    if (Result.a != \"aa\" || Result.b != 2) throw RuntimeException(\"FAIL 1\")\n    noinlineMe {\n        dummy()\n        dummy()\n    }\n    if (Result.a != \"aabb\" || Result.b != 6) throw RuntimeException(\"FAIL 2\")\n    crossinlineMe {\n        dummy()\n        dummy()\n    }\n    if (Result.a != \"aabbcc\" || Result.b != 12) throw RuntimeException(\"FAIL 3\")\n}\n\nfun box(): String {\n    builder {\n        inlineSite()\n    }\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: inlined.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n\nsuspend inline fun inlineMe(c: suspend (String) -> String, d: suspend () -> String): String {\n    return c(try { d() } catch (e: Exception) { \"Exception 1 ${e.message}\" })\n}\n\nsuspend inline fun noinlineMe(noinline c: suspend (String) -> String, noinline d: suspend () -> String): String {\n    return c(try { d() } catch (e: Exception) { \"Exception 1 ${e.message}\" })\n}\n\nsuspend inline fun crossinlineMe(crossinline c: suspend (String) -> String, crossinline d: suspend () -> String): String {\n    return c(try { d() } catch (e: Exception) { \"Exception 1 ${e.message}\" })\n}\n\n// FILE: inlineSite.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun yieldString(s: String) = s\n\nsuspend fun throwException(s: String): String {\n    throw RuntimeException(s)\n}\n\nsuspend fun inlineSite() {\n    var res = inlineMe({ it }) { yieldString(\"OK\") }\n    if (res != \"OK\") throw RuntimeException(\"FAIL 1: $res\")\n\n    res = inlineMe({ it }) { throwException(\"OK\") }\n    if (res != \"Exception 1 OK\") throw RuntimeException(\"FAIL 2: $res\")\n\n    res = noinlineMe({ it }) { yieldString(\"OK\") }\n    if (res != \"OK\") throw RuntimeException(\"FAIL 3: $res\")\n\n    res = noinlineMe({ it }) { throwException(\"OK\") }\n    if (res != \"Exception 1 OK\") throw RuntimeException(\"FAIL 4: $res\")\n\n    res = crossinlineMe({ it }) { yieldString(\"OK\") }\n    if (res != \"OK\") throw RuntimeException(\"FAIL 5: $res\")\n\n    res = crossinlineMe({ it }) { throwException(\"OK\") }\n    if (res !=  \"Exception 1 OK\") throw RuntimeException(\"FAIL 6: $res\")\n\n    res = inlineMe({ try {yieldString(it) } catch (e: Exception) { yieldString(\"Exception 2 $it\") } }) { yieldString(\"OK\") }\n    if (res != \"OK\") throw RuntimeException(\"FAIL 7: $res\")\n\n    res = inlineMe({ try {throwException(it) } catch (e: Exception) { yieldString(\"Exception 2 $it\") } }) { yieldString(\"OK\") }\n    if (res != \"Exception 2 OK\") throw RuntimeException(\"FAIL 8: $res\")\n\n    res = noinlineMe({ try {yieldString(it) } catch (e: Exception) { yieldString(\"Exception 2 $it\") } }) { yieldString(\"OK\") }\n    if (res != \"OK\") throw RuntimeException(\"FAIL 9: $res\")\n\n    res = noinlineMe({ try {throwException(it) } catch (e: Exception) { yieldString(\"Exception 2 $it\") } }) { yieldString(\"OK\") }\n    if (res != \"Exception 2 OK\") throw RuntimeException(\"FAIL 10: $res\")\n\n    res = crossinlineMe({ try {yieldString(it) } catch (e: Exception) { yieldString(\"Exception 2 $it\") } }) { yieldString(\"OK\") }\n    if (res != \"OK\") throw RuntimeException(\"FAIL 11: $res\")\n\n    res = crossinlineMe({ try {throwException(it) } catch (e: Exception) { yieldString(\"Exception 2 $it\") } }) { yieldString(\"OK\") }\n    if (res !=  \"Exception 2 OK\") throw RuntimeException(\"FAIL 12: $res\")\n}\n\nfun box(): String {\n    builder {\n        inlineSite()\n    }\n    return \"OK\"\n}"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// TARGET_BACKEND: JVM\n\nsuspend inline fun test1(c: () -> Unit) {\n    c()\n}\n\nsuspend inline fun test2(c: suspend () -> Unit) {\n    c()\n}\n\nsuspend inline fun test3(crossinline c: suspend() -> Unit) {\n    c()\n}\n\nsuspend inline fun test4(crossinline c: suspend() -> Unit) {\n    val l : suspend () -> Unit = { c() }\n    l()\n}\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\nsuspend inline fun test5(crossinline c: suspend() -> Unit) {\n    val sr = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n        }\n    }\n    sr.run()\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\nimport COROUTINES_PACKAGE.jvm.internal.*\n\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nvar continuationChanged = true\nvar savedContinuation: Continuation<Unit>? = null\n\nsuspend inline fun saveContinuation() = suspendCoroutineUninterceptedOrReturn<Unit> { c ->\n    savedContinuation = c\n    Unit\n}\n\nsuspend inline fun checkContinuation(continuation: Continuation<Unit>) = suspendCoroutineUninterceptedOrReturn<Unit> { c ->\n    continuationChanged = (continuation !== c)\n    Unit\n}\n\nfun box() : String {\n    builder {\n        saveContinuation()\n        test1 {\n            checkContinuation(savedContinuation!!)\n        }\n    }\n    if (continuationChanged) return \"FAIL 1\"\n    continuationChanged = true\n    builder {\n        saveContinuation()\n        test2 {\n            checkContinuation(savedContinuation!!)\n        }\n    }\n    if (continuationChanged) return \"FAIL 2\"\n    continuationChanged = true\n    builder {\n        saveContinuation()\n        test3 {\n            checkContinuation(savedContinuation!!)\n        }\n    }\n    if (continuationChanged) return \"FAIL 3\"\n    continuationChanged = false\n    builder {\n        saveContinuation()\n        test4 {\n            checkContinuation(savedContinuation!!)\n        }\n    }\n    if (!continuationChanged) return \"FAIL 4\"\n    continuationChanged = false\n    builder {\n        saveContinuation()\n        test5 {\n            checkContinuation(savedContinuation!!)\n        }\n    }\n    if (continuationChanged) return \"FAIL 5\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n\n// Needed for JS compatibility\ninterface Runnable {\n    fun run(): Unit\n}\n\nsuspend inline fun test1(crossinline c: () -> Unit) {\n    c()\n}\n\nsuspend inline fun test2(crossinline c: () -> Unit) {\n    val l = { c() }\n    l()\n}\n\nsuspend inline fun test3(crossinline c: () -> Unit) {\n    val r = object: Runnable {\n        override fun run() {\n            c()\n        }\n    }\n    r.run()\n}\n\ninline fun transform(crossinline c: suspend () -> Unit) {\n    builder { c() }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun box() : String {\n    var res = \"FAIL 1\"\n    builder {\n        test1 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 2\"\n    builder {\n        test2 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 3\"\n    builder {\n        test3 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 4\"\n    builder {\n        test1 {\n            transform {\n                test1 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 5\"\n    builder {\n        test2 {\n            transform {\n                test2 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 6\"\n    builder {\n        test3 {\n            transform {\n                test3 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    return res\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// FILE: inlined.kt\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nvar result = \"FAIL\"\nvar i = 0\nvar finished = false\n\nvar proceed: () -> Unit = {}\n\nsuspend fun suspendHere() = suspendCoroutine<Unit> {\n    i++\n    proceed = { it.resume(Unit) }\n}\n\ninline suspend fun inlineMe() {\n    suspendHere()\n    suspendHere()\n    suspendHere()\n    suspendHere()\n    suspendHere()\n}\n\n// FILE: inlineSite.kt\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    val continuation = object: Continuation<Unit> {\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(r: Result<Unit>) {\n            r.getOrThrow()\n            proceed = {\n                result = \"OK\"\n                finished = true\n            }\n        }\n    }\n    c.startCoroutine(continuation)\n}\n\nsuspend fun inlineSite() {\n    inlineMe()\n    inlineMe()\n}\n\nfun box(): String {\n    builder {\n        inlineSite()\n    }\n    for (counter in 0 until 10) {\n        if (i != counter + 1) return \"Expected ${counter + 1}, got $i\"\n        proceed()\n    }\n    if (i != 10) return \"FAIL $i\"\n    if (finished) return \"resume on root continuation is called\"\n    proceed()\n    if (!finished) return \"resume on root continuation is not called\"\n    return result\n}\n"
        },
        {
            "code": "// WITH_RUNTIME\n// WITH_COROUTINES\n// NO_CHECK_LAMBDA_INLINING\n// FILE: inlined.kt\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nvar result = \"FAIL\"\nvar i = 0\nvar finished = false\n\nvar proceed: () -> Unit = {}\n\nsuspend fun suspendHere() = suspendCoroutine<Unit> {\n    i++\n    proceed = { it.resume(Unit) }\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.InlineOnly\ninline suspend fun inlineMe() {\n    suspendHere()\n    suspendHere()\n    suspendHere()\n    suspendHere()\n    suspendHere()\n}\n\n// FILE: inlineSite.kt\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nfun builder(c: suspend () -> Unit) {\n    val continuation = object: Continuation<Unit> {\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(r: Result<Unit>) {\n            r.getOrThrow()\n            proceed = {\n                result = \"OK\"\n                finished = true\n            }\n        }\n    }\n    c.startCoroutine(continuation)\n}\n\nsuspend fun inlineSite() {\n    inlineMe()\n    inlineMe()\n}\n\nfun box(): String {\n    builder {\n        inlineSite()\n    }\n    for (counter in 0 until 10) {\n        if (i != counter + 1) return \"Expected ${counter + 1}, got $i\"\n        proceed()\n    }\n    if (i != 10) return \"FAIL $i\"\n    if (finished) return \"resume on root continuation is called\"\n    proceed()\n    if (!finished) return \"resume on root continuation is not called\"\n    return result\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: test.kt\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n\n// Needed for JS compatibility\ninterface Runnable {\n    fun run(): Unit\n}\n\nsuspend inline fun test1(noinline c: () -> Unit) {\n    c()\n}\n\nsuspend inline fun test2(noinline c: () -> Unit) {\n    val l = { c() }\n    l()\n}\n\nsuspend inline fun test3(noinline c: () -> Unit) {\n    val r = object: Runnable {\n        override fun run() {\n            c()\n        }\n    }\n    r.run()\n}\n\ninline fun transform(crossinline c: suspend () -> Unit) {\n    builder { c() }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\n// FILE: box.kt\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.*\nimport helpers.*\n\nfun box() : String {\n    var res = \"FAIL 1\"\n    builder {\n        test1 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 2\"\n    builder {\n        test2 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 3\"\n    builder {\n        test3 {\n            res = \"OK\"\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 4\"\n    builder {\n        test1 {\n            transform {\n                test1 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 5\"\n    builder {\n        test2 {\n            transform {\n                test2 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    if (res != \"OK\") return res\n\n    res = \"FAIL 6\"\n    builder {\n        test3 {\n            transform {\n                test3 {\n                    res = \"OK\"\n                }\n            }\n        }\n    }\n    return res\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\npackage kotlin.internal\n\nfun apiVersionIsAtLeast(epic: Int, major: Int, minor: Int): Boolean {\n    return false\n}\n\nvar properFunctionWasClled = false\n\nfun doSomethingNew() {\n    properFunctionWasClled = true\n}\n\nfun doSomethingOld() {\n    throw AssertionError(\"Should not be called\")\n}\n\ninline fun versionDependentInlineFun() {\n    if (apiVersionIsAtLeast(1, 1, 0)) {\n        doSomethingNew()\n    }\n    else {\n        doSomethingOld()\n    }\n}\n\nfun test() {\n    versionDependentInlineFun()\n}\n\n\n// FILE: 2.kt\nimport kotlin.internal.*\n\nfun box(): String {\n    test()\n    if (!properFunctionWasClled) return \"Fail 1\"\n\n    return \"OK\"\n}"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\npublic class Data(val value: Int)\n\npublic class Input(val d: Data)  {\n    public fun data() : Int = 100\n}\n\npublic inline fun <R> use(block: ()-> R) : R {\n    return block()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun test1(d: Data): Int {\n    val input = Input(d)\n    var result = 10\n    with(input) {\n        fun localFun() {\n            result = input.d.value\n        }\n        localFun()\n    }\n    return result\n}\n\n\nfun box(): String {\n    val result = test1(Data(11))\n    if (result != 11) return \"test1: ${result}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\npublic inline fun myRun(block: () -> Unit) {\n    return block()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    var res = \"\"\n    myRun {\n        fun f1() {\n            res = \"OK\"\n        }\n        fun f2() {\n            f1()\n        }\n        f2()\n    }\n\n    return res\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\npublic inline fun myRun(block: () -> Unit) {\n    return block()\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    var res = \"\"\n    myRun {\n        fun f1() {\n            res = \"OK\"\n        }\n        val x: () -> Unit = {\n            f1()\n        }\n\n        x()\n    }\n\n    return res\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninterface InlineTrait {\n\n    private inline fun privateInline(s: () -> String): String {\n        return s()\n    }\n\n    fun testPrivateInline(): String {\n        return privateInline { \"private\" }\n    }\n\n    fun testPrivateInline2(): String {\n        return privateInline { \"private2\" }\n    }\n\n    companion object {\n        inline final fun finalInline(s: () -> String): String {\n            return s()\n        }\n    }\n}\n\nclass Z : InlineTrait {\n\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun testClassObject(): String {\n    return InlineTrait.finalInline({ \"classobject\" })\n}\n\nfun box(): String {\n    if (Z().testPrivateInline() != \"private\") return \"test1: ${Z().testPrivateInline()}\"\n    if (Z().testPrivateInline2() != \"private2\") return \"test2: ${Z().testPrivateInline2()}\"\n    if (testClassObject() != \"classobject\") return \"test3: ${testClassObject()}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\npackage builders\n\nimport java.util.ArrayList\nimport java.util.HashMap\n\nabstract class Element {\n    abstract fun render(builder: StringBuilder, indent: String)\n\n    override fun toString(): String {\n        val builder = StringBuilder()\n        render(builder, \"\")\n        return builder.toString()\n    }\n}\n\nclass TextElement(val text: String) : Element() {\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent$text\\n\")\n    }\n}\n\nabstract class Tag(val name: String) : Element() {\n    val children = ArrayList<Element>()\n    val attributes = HashMap<String, String>()\n\n    inline protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n        for (c in children) {\n            c.render(builder, indent + \"  \")\n        }\n        builder.append(\"$indent</$name>\\n\")\n    }\n\n    private fun renderAttributes(): String? {\n        val builder = StringBuilder()\n        for (a in attributes.keys) {\n            builder.append(\" $a=\\\"${attributes[a]}\\\"\")\n        }\n        return builder.toString()\n    }\n}\n\nabstract class TagWithText(name: String) : Tag(name) {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass HTML() : TagWithText(\"html\") {\n    inline fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\n    inline fun body(init: Body.() -> Unit) = initTag(Body(), init)\n\n    fun bodyNoInline(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head() : TagWithText(\"head\") {\n    inline fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title() : TagWithText(\"title\")\n\nabstract class BodyTag(name: String) : TagWithText(name) {\n    inline fun b(init: B.() -> Unit) = initTag(B(), init)\n    inline fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun pNoInline(init: P.() -> Unit) = initTag(P(), init)\n    inline fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    inline fun ul(init: UL.() -> Unit) = initTag(UL(), init)\n    inline fun a(href: String, init: A.() -> Unit) {\n        val a = initTag(A(), init)\n        a.href = href\n    }\n}\n\nclass Body() : BodyTag(\"body\")\nclass UL() : BodyTag(\"ul\") {\n    inline fun li(init: LI.() -> Unit) = initTag(LI(), init)\n}\n\nclass B() : BodyTag(\"b\")\nclass LI() : BodyTag(\"li\")\nclass P() : BodyTag(\"p\")\nclass H1() : BodyTag(\"h1\")\nclass A() : BodyTag(\"a\") {\n    public var href: String\n        get() = attributes[\"href\"]!!\n        set(value) {\n            attributes[\"href\"] = value\n        }\n}\n\ninline fun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\nfun htmlNoInline(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport builders.*\n\ninline fun testAllInline(f: () -> String) : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            html {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                body {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\"; +\"${f()}\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\ninline fun testHtmlNoInline(crossinline f: () -> String) : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            htmlNoInline() {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                body {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\"; +\"${f()}\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\ninline fun testBodyNoInline(crossinline f: () -> String) : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            html {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                bodyNoInline {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\"; +\"${f()}\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\ninline fun testBodyHtmlNoInline(crossinline f: () -> String) : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            htmlNoInline {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                bodyNoInline {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\"; +\"${f()}\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\nfun box(): String {\n    var expected = testAllInline({\"x\"});\n    print(expected + \" \" + testHtmlNoInline({\"x\"}))\n\n    if (expected != testHtmlNoInline({\"x\"})) return \"fail 1: ${testHtmlNoInline({\"x\"})}\\nbut expected\\n${expected} \"\n    if (expected != testBodyNoInline({\"x\"})) return \"fail 2: ${testBodyNoInline({\"x\"})}\\nbut expected\\n${expected} \"\n    if (expected != testBodyHtmlNoInline({\"x\"})) return \"fail 3: ${testBodyHtmlNoInline({\"x\"})}\\nbut expected\\n${expected} \"\n\n    var captured = \"x\"\n    if (expected != testHtmlNoInline({captured})) return \"fail 4: ${testHtmlNoInline({captured})}\\nbut expected\\n${expected} \"\n    if (expected != testBodyNoInline({captured})) return \"fail 5: ${testBodyNoInline({captured})}\\nbut expected\\n${expected} \"\n    if (expected != testBodyHtmlNoInline({captured})) return \"fail 6: ${testBodyHtmlNoInline({captured})}\\nbut expected\\n${expected} \"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_RUNTIME\npackage builders\n\nimport java.util.ArrayList\nimport java.util.HashMap\n\nabstract class Element {\n    abstract fun render(builder: StringBuilder, indent: String)\n\n    override fun toString(): String {\n        val builder = StringBuilder()\n        render(builder, \"\")\n        return builder.toString()\n    }\n}\n\nclass TextElement(val text: String) : Element() {\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent$text\\n\")\n    }\n}\n\nabstract class Tag(val name: String) : Element() {\n    val children = ArrayList<Element>()\n    val attributes = HashMap<String, String>()\n\n    inline protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n        for (c in children) {\n            c.render(builder, indent + \"  \")\n        }\n        builder.append(\"$indent</$name>\\n\")\n    }\n\n    private fun renderAttributes(): String? {\n        val builder = StringBuilder()\n        for (a in attributes.keys) {\n            builder.append(\" $a=\\\"${attributes[a]}\\\"\")\n        }\n        return builder.toString()\n    }\n}\n\nabstract class TagWithText(name: String) : Tag(name) {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass HTML() : TagWithText(\"html\") {\n    inline fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\n    inline fun body(init: Body.() -> Unit) = initTag(Body(), init)\n\n    fun bodyNoInline(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head() : TagWithText(\"head\") {\n    inline fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title() : TagWithText(\"title\")\n\nabstract class BodyTag(name: String) : TagWithText(name) {\n    inline fun b(init: B.() -> Unit) = initTag(B(), init)\n    inline fun p(init: P.() -> Unit) = initTag(P(), init)\n    inline fun pNoInline(init: P.() -> Unit) = initTag(P(), init)\n    inline fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    inline fun ul(init: UL.() -> Unit) = initTag(UL(), init)\n    inline fun a(href: String, init: A.() -> Unit) {\n        val a = initTag(A(), init)\n        a.href = href\n    }\n}\n\nclass Body() : BodyTag(\"body\")\nclass UL() : BodyTag(\"ul\") {\n    inline fun li(init: LI.() -> Unit) = initTag(LI(), init)\n}\n\nclass B() : BodyTag(\"b\")\nclass LI() : BodyTag(\"li\")\nclass P() : BodyTag(\"p\")\nclass H1() : BodyTag(\"h1\")\nclass A() : BodyTag(\"a\") {\n    public var href: String\n        get() = attributes[\"href\"]!!\n        set(value) {\n            attributes[\"href\"] = value\n        }\n}\n\ninline fun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\nfun htmlNoInline(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport builders.*\n\nfun testAllInline() : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            html {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                body {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\nfun testHtmlNoInline() : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            htmlNoInline() {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                body {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\nfun testBodyNoInline() : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            html {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                bodyNoInline {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\nfun testBodyHtmlNoInline() : String {\n    val args = arrayOf(\"1\", \"2\", \"3\")\n    val result =\n            htmlNoInline {\n                val htmlVal = 0\n                head {\n                    title { +\"XML encoding with Kotlin\" }\n                }\n                bodyNoInline {\n                    var bodyVar = 1\n                    h1 { +\"XML encoding with Kotlin\" }\n                    p { +\"this format can be used as an alternative markup to XML\" }\n\n                    // an element with attributes and text content\n                    a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n\n                    // mixed content\n                    p {\n                        +\"This is some\"\n                        b { +\"mixed\" }\n                        +\"text. For more see the\"\n                        a(href = \"https://jetbrains.com/kotlin\") { +\"Kotlin\" }\n                        +\"project\"\n                    }\n                    p { +\"some text\" }\n\n                    // content generated from command-line arguments\n                    p {\n                        +\"Command line arguments were:\"\n                        ul {\n                            for (arg in args)\n                                li { +arg; +\"$htmlVal\"; +\"$bodyVar\" }\n                        }\n                    }\n                }\n            }\n\n    return result.toString()!!\n}\n\nfun box(): String {\n    var expected = testAllInline();\n\n    if (expected != testHtmlNoInline()) return \"fail 1: ${testHtmlNoInline()}\\nbut expected\\n${expected} \"\n\n    if (expected != testBodyNoInline()) return \"fail 2: ${testBodyNoInline()}\\nbut expected\\n${expected} \"\n\n    if (expected != testBodyHtmlNoInline()) return \"fail 3: ${testBodyHtmlNoInline()}\\nbut expected\\n${expected} \"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface Z {\n    fun a(): String\n}\n\ninline fun test(crossinline z: () -> String) =\n        object : Z {\n            override fun a() = z()\n        }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val res = test {\n        \"OK\"\n    }\n\n    val enclosingMethod = res.javaClass.enclosingMethod\n    if (enclosingMethod?.name != \"box\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    val enclosingClass = res.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\") return \"fail 2: ${enclosingClass?.name}\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninline fun <R> call(crossinline s: () -> R) = { s() }()\n\ninline fun test(crossinline z: () -> String) = { z() }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val res = call {\n        test { \"OK\" }\n    }\n\n    var enclosingMethod = res.javaClass.enclosingMethod\n    if (enclosingMethod?.name != \"invoke\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    var enclosingClass = res.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\\$box$\\$inlined\\$call$1\") return \"fail 2: ${enclosingClass?.name}\"\n\n    val res2 = call {\n        call {\n            test { \"OK\" }\n        }\n    }\n\n    enclosingMethod = res2.javaClass.enclosingMethod\n    if (enclosingMethod?.name != \"invoke\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    enclosingClass = res2.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\\$box$\\$inlined\\$call$2\\$lambda$1\") return \"fail 2: ${enclosingClass?.name}\"\n\n    return res2()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// NO_CHECK_LAMBDA_INLINING\n// WITH_REFLECT\n// FILE: 1.kt\npackage test\n\ninline fun <R> call(s: () -> R) = s()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val res = call {\n        { \"OK\" }\n    }\n\n    var enclosingMethod = res.javaClass.enclosingMethod\n    if (enclosingMethod?.name != \"box\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    var enclosingClass = res.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\") return \"fail 2: ${enclosingClass?.name}\"\n\n    return res()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface Z {\n    fun a() : String\n}\n\ninline fun test(crossinline z: () -> String) =\n        object : Z {\n\n            val p = z()\n\n            override fun a() = p\n        }\n\n\ninline fun<T> call(crossinline z: () -> T) = z()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    /*This captured parameter would be added to object constructor*/\n    val captured = \"OK\";\n    var z: Any = \"fail\"\n    val res = test {\n\n        call {\n            z = {\n                captured\n            }\n        }\n\n        (z as Function0<String>)()\n    }\n\n\n    val enclosingConstructor = z.javaClass.enclosingConstructor\n    if (enclosingConstructor?.name != \"_2Kt\\$box$\\$inlined\\$test$1\") return \"fail 1: ${enclosingConstructor?.name}\"\n\n    val enclosingClass = z.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\\$box$\\$inlined\\$test$1\") return \"fail 2: ${enclosingClass?.name}\"\n\n    return res.a()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninline fun <R> call(s: () -> R) = s()\n\ninline fun test(crossinline z: () -> String) = { z() }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val res = call {\n        test { \"OK\" }\n    }\n\n    var enclosingMethod = res.javaClass.enclosingMethod\n    if (enclosingMethod?.name != \"box\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    var enclosingClass = res.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\") return \"fail 2: ${enclosingClass?.name}\"\n\n    val res2 = call {\n        call {\n            test { \"OK\" }\n        }\n    }\n\n    enclosingMethod = res2.javaClass.enclosingMethod\n    if (enclosingMethod?.name != \"box\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    enclosingClass = res2.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\") return \"fail 2: ${enclosingClass?.name}\"\n\n    return res2()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface Z<T> {\n    fun a() : T\n}\n\ninline fun test(crossinline z: () -> String) =\n        object : Z<Z<String>> {\n\n            val p: Z<String> = object : Z<String> {\n\n                val p2 = z()\n\n                override fun a() = p2\n            }\n\n            override fun a() = p\n        }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    var z = \"OK\"\n    val res = test {\n        z\n    }\n\n\n    val javaClass1 = res.javaClass\n    val enclosingMethod = javaClass1.enclosingMethod\n    if (enclosingMethod?.name != \"box\") return \"fail 1: ${enclosingMethod?.name}\"\n\n    val enclosingClass = javaClass1.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\") return \"fail 2: ${enclosingClass?.name}\"\n\n\n    val res2 = res.a()\n    val enclosingConstructor = res2.javaClass.enclosingConstructor\n    if (enclosingConstructor?.name != javaClass1.name) return \"fail 3: ${enclosingConstructor?.name} != ${javaClass1.name}\"\n\n    val enclosingClass2 = res2.javaClass.enclosingClass\n    if (enclosingClass2?.name != javaClass1.name) return \"fail 4: ${enclosingClass2?.name} != ${javaClass1.name}\"\n\n\n\n    return res2.a()\n}\n"
        },
        {
            "code": "// IGNORE_BACKEND: JVM_IR\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface Z {\n    fun a() : String\n}\n\ninline fun test(crossinline z: () -> String) =\n        object : Z {\n\n            val p = z()\n\n            override fun a() = p\n        }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    /*This captured parameter would be added to object constructor*/\n    val captured = \"OK\";\n    var z: Any = \"fail\"\n    val res = test {\n\n        z = {\n            captured\n        }\n        (z as Function0<String>)()\n    }\n\n\n    val enclosingConstructor = z.javaClass.enclosingConstructor\n    if (enclosingConstructor?.name != \"_2Kt\\$box$\\$inlined\\$test$1\") return \"fail 1: ${enclosingConstructor?.name}\"\n\n    val enclosingClass = z.javaClass.enclosingClass\n    if (enclosingClass?.name != \"_2Kt\\$box$\\$inlined\\$test$1\") return \"fail 2: ${enclosingClass?.name}\"\n\n    return res.a()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\n// FILE: 1.kt\n\npackage test\n\ninline class A(val x: Int) {\n    inline fun inc(): A = A(this.x + 1)\n\n    inline fun result(other: A): String = if (other.x == x) \"OK\" else \"fail\"\n}\n\ninline fun stub() {}\n\n// FILE: 2.kt\n// NO_CHECK_LAMBDA_INLINING\n// ^ TODO\n\nimport test.*\n\nfun box() : String {\n    val a = A(0)\n    val b = a.inc().inc()\n    val result = b.result(A(2))\n\n    return result\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n// WITH_REFLECT\n// TARGET_BACKEND: JVM\npackage test\n\nimport kotlin.properties.Delegates\nimport kotlin.properties.ReadWriteProperty\nimport kotlin.properties.ObservableProperty\nimport kotlin.reflect.KProperty\n\nvar result = \"fail\"\n\npublic inline fun <reified T> myObservable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit):\n        ReadWriteProperty<Any?, T> = object : ObservableProperty<T>(initialValue) {\n    override fun afterChange(property: KProperty<*>, oldValue: T, newValue: T) = onChange(property, oldValue, newValue)\n}\n\n\n//samely named reified parameter (T) as in myObservable\ninline fun <reified T : Any> crashMe(): ReadWriteProperty<Any?, Unit> {\n    return myObservable(Unit, { a, b, c -> result = T::class.java.simpleName })\n}\n\n\n// FILE: 2.kt\nimport test.*\n\n\nclass OK {\n    var value by crashMe<OK>()\n}\n\nfun box(): String {\n    OK().value = Unit\n    return result\n}"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <reified R> foo() = bar<R>() {\"OK\"}\ninline fun <reified E> bar(crossinline y: () -> String) = {\n    null is E\n    run(y)\n}\n\npublic inline fun <T> call(f: () -> T): T = f()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nval x: () -> String = foo<String>()\n\nfun box(): String {\n    return x()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\npublic abstract class A<T>\n\ninline fun <reified T> foo1(): A<T> {\n    return object : A<T>() {\n\n    }\n}\n\nfun<T> bar(x: T, block: (T) -> Boolean): Boolean = block(x)\n\ninline fun <reified T> foo2(x: Any): Boolean {\n    return bar(x) { it is T }\n}\n\ninline fun <reified T> foo3(x: Any, y: Any): Boolean {\n    return bar(x) { it is T && y is T }\n}\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nfun box(): String {\n    val x = foo1<Int>().javaClass.getGenericSuperclass()?.toString()\n    if (x != \"test.A<java.lang.Integer>\") return \"fail 1: \" + x\n\n    if (!foo2<String>(\"abc\")) return \"fail 2\"\n    if (foo2<Int>(\"abc\")) return \"fail 3\"\n\n    if (!foo3<String>(\"abc\", \"cde\")) return \"fail 4\"\n    if (foo3<String>(\"abc\", 1)) return \"fail 5\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun <reified T> f(x : () -> T): Array<T> = Array(1) { x() }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String = f { \"OK\" }[0]\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\nopen class TypeRef<T> {\n    val type = target()\n\n    private fun target(): String {\n        val thisClass = this.javaClass\n        val superClass = thisClass.genericSuperclass\n\n        return superClass.toString()\n    }\n}\n\n\n\ninline fun <reified T> typeWithMessage(message: String = \"Hello\"): String {\n    val type = object : TypeRef<T>() {}\n    val target = type.type\n\n    return message + \" \" + target\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun specifyOptionalArgument() = typeWithMessage<List<Int>>(\"Hello\")\n\nfun useDefault() = typeWithMessage<List<Int>>()\n\nfun box(): String {\n    val specifyOptionalArgument = specifyOptionalArgument()\n    val useDefault = useDefault()\n\n    if (useDefault != specifyOptionalArgument) return \"fail: $useDefault != $specifyOptionalArgument\"\n\n    val type = typeWithMessage<List<Int>>(\"\")\n    if (type != \" test.TypeRef<java.util.List<? extends java.lang.Integer>>\") return \"fail 2: $type\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_REFLECT\n\npackage foo\n\nimport kotlin.reflect.full.primaryConstructor\n\ninline fun <reified T : Any> f(): String {\n    var result = \"\"\n    for (p in T::class.primaryConstructor!!.parameters.sortedBy { it.index }) {\n        result += p.name\n    }\n    return result\n}\n\n// FILE: 2.kt\nimport foo.*\n\nclass A(val O: Int, val K: Int)\n\nfun box(): String {\n    return f<A>()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo() = this is T\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (null.foo<Any>() != false) return \"fail 1\"\n    if (null.foo<Any?>() != true) return \"fail 2\"\n\n    if (null.foo<A>() != false) return \"fail 3\"\n    if (null.foo<A?>() != true) return \"fail 4\"\n\n    val a = A()\n\n    if (a.foo<Any>() != true) return \"fail 5\"\n    if (a.foo<Any?>() != true) return \"fail 6\"\n\n    if (a.foo<A>() != true) return \"fail 7\"\n    if (a.foo<A?>() != true) return \"fail 8\"\n\n    val b = B()\n\n    if (b.foo<A>() != false) return \"fail 9\"\n    if (b.foo<A?>() != false) return \"fail 10\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo() = this is T\n\ninline fun <reified Y> Any?.foo2() = foo<Y?>()\n\ninline fun <reified Z> Any?.foo3() = foo2<Z>()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (null.foo3<Any>() != true) return \"fail 1\"\n    if (null.foo3<Any?>() != true) return \"fail 2\"\n\n    if (null.foo3<A>() != true) return \"fail 3\"\n    if (null.foo3<A?>() != true) return \"fail 4\"\n\n    val a = A()\n\n    if (a.foo3<Any>() != true) return \"fail 5\"\n    if (a.foo3<Any?>() != true) return \"fail 6\"\n\n    if (a.foo3<A>() != true) return \"fail 7\"\n    if (a.foo3<A?>() != true) return \"fail 8\"\n\n    val b = B()\n\n    if (b.foo3<A>() != false) return \"fail 9\"\n    if (b.foo3<A?>() != false) return \"fail 10\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo() = this is T?\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (null.foo<Any>() != true) return \"fail 1\"\n    if (null.foo<Any?>() != true) return \"fail 2\"\n\n    if (null.foo<A>() != true) return \"fail 3\"\n    if (null.foo<A?>() != true) return \"fail 4\"\n\n    val a = A()\n\n    if (a.foo<Any>() != true) return \"fail 5\"\n    if (a.foo<Any?>() != true) return \"fail 6\"\n\n    if (a.foo<A>() != true) return \"fail 7\"\n    if (a.foo<A?>() != true) return \"fail 8\"\n\n    val b = B()\n\n    if (b.foo<A>() != false) return \"fail 9\"\n    if (b.foo<A?>() != false) return \"fail 10\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// FULL_JDK\n// WITH_REFLECT\n// TARGET_BACKEND: JVM\npackage test\n\nimport kotlin.properties.Delegates\nimport kotlin.properties.ReadWriteProperty\n\nvar result = \"fail\"\n\ninline fun <reified T : Any> crashMe(): ReadWriteProperty<Any?, Unit> {\n    return Delegates.observable(Unit, { a, b, c -> result = T::class.java.simpleName })\n}\n\n\n// FILE: 2.kt\nimport test.*\n\n\nclass OK {\n    var value by crashMe<OK>()\n}\n\nfun box(): String {\n    OK().value = Unit\n    return result\n}"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\npublic inline fun <reified T : Any> inlineMeIfYouCan(): String? =\n        {\n            f {\n                T::class.java.getName()\n            }\n        }()\n\ninline fun f(x: () -> String) = x()\n\n// FILE: 2.kt\n\nimport test.*\n\nclass OK\n\nfun box(): String {\n    return inlineMeIfYouCan<OK>()!!\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass AbstractTreeNode<T>(val value: T, val parent: AbstractTreeNode<T>?)\n\ninternal inline fun <reified T : Any> AbstractTreeNode<*>.findNotNullValueOfType(strict: Boolean = false): T {\n    return findValueOfType(strict)!!\n}\n\ninternal inline fun <reified T : Any> AbstractTreeNode<*>.findValueOfType(strict: Boolean = true): T? {\n    var current: AbstractTreeNode<*>? = if (strict) this.parent else this\n    while (current != null) {\n        val value = current.value\n        if (value is T) return value\n        current = current.parent\n    }\n    return null\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return AbstractTreeNode(\"OK\", null).findNotNullValueOfType<String>()!!\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\nimport java.util.*\nimport kotlin.reflect.KClass\n\nval valuesInjectFnc = HashMap<KClass<out Any>, Any>()\n\ninline fun <reified T : Any> injectFnc(): Lazy<Function0<T>> = lazy(LazyThreadSafetyMode.NONE) {\n    (valuesInjectFnc[T::class] ?: throw Exception(\"no inject ${T::class.simpleName}\")) as Function0<T>\n}\n\ninline fun <reified T : Any> registerFnc(noinline value: Function0<T>) {\n    valuesInjectFnc[T::class] = value\n}\n\npublic class Box\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass Boxer {\n    val box: () -> Box by injectFnc()\n}\n\nfun box(): String {\n    val box = Box()\n    registerFnc { box }\n    val prop = Boxer().box\n    if (prop() != box) return \"fail 1\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T> inlineFun(crossinline lambda: () -> String = { { T::class.java.simpleName } () }): String {\n    return {\n        lambda()\n    } ()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass OK\n\nfun box(): String {\n    return inlineFun<OK>()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T> inlineFun(lambda: () -> String = { { T::class.java.simpleName } () }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass OK\n\nfun box(): String {\n    return inlineFun<OK>()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\nclass K\n\ninline fun <reified T> inlineFun(p: String, lambda: () -> String = { p + T::class.java.simpleName }): String {\n    return lambda()\n}\n\ninline fun <reified X> inlineFun2(p: String): String {\n    return inlineFun<X>(p)\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun2<K>(\"O\")\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\nclass OK\nclass FAIL\n\ninline fun <reified T> inlineFun(lambda: () -> String = { T::class.java.simpleName }): String {\n    return lambda()\n}\n\ninline fun <reified X> inlineFun2(): String {\n    return inlineFun<X>()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun2<OK>()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T> inlineFun(p: String, crossinline lambda: () -> String = { { p + T::class.java.simpleName } () }): String {\n    return {\n        lambda()\n    } ()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass K\n\nfun box(): String {\n    return inlineFun<K>(\"O\")\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T> inlineFun(lambda: () -> String = { T::class.java.simpleName }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nclass OK\n\nfun box(): String {\n    return inlineFun<OK>()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T> inlineFun(p: String, lambda: () -> String = { { p + T::class.java.simpleName } () }): String {\n    return lambda()\n}\n\n// FILE: 2.kt\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\nclass K\n\nfun box(): String {\n    return inlineFun<K>(\"O\")\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// SKIP_INLINE_CHECK_IN: inlineFun$default\n// WITH_RUNTIME\npackage test\n\nclass OK\nclass FAIL\n\ninline fun <reified T> inlineFun(lambda: () -> String = { T::class.java.simpleName }): String {\n    return lambda()\n}\n\ninline fun <reified T> inlineFun2(): String {\n    return inlineFun<OK>()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return inlineFun2<FAIL>()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// FULL_JDK\n// WITH_REFLECT\n\npackage test\n\nimport java.lang.reflect.ParameterizedType\nimport java.lang.reflect.Type\n\nopen class TypeLiteral<T> {\n    val type: Type\n        get() = (javaClass.genericSuperclass as ParameterizedType).getActualTypeArguments()[0]\n}\n\n// normal inline function works fine\ninline fun <reified T> typeLiteral(): TypeLiteral<T> = object : TypeLiteral<T>() {}\n\n// nested lambda loses reification of T\ninline fun <reified T> brokenTypeLiteral(): TypeLiteral<T> = \"\".run { typeLiteral<T>() }\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val type1 = typeLiteral<List<String>>().type.toString()\n    if (type1 != \"java.util.List<? extends java.lang.String>\") return \"fail 1: $type1\"\n\n    val type2 = brokenTypeLiteral<List<String>>().type.toString()\n    if (type2 != \"java.util.List<? extends java.lang.String>\") return \"fail 2: $type2\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninline fun <reified R, T> bar(crossinline tasksFactory: () -> T) = {\n    null is R\n    run(tasksFactory)\n}\n\npublic inline fun <T> call(f: () -> T): T = f()\n\n// FILE: 2.kt\n\n//NO_CHECK_LAMBDA_INLINING\nimport test.*\n\ninline fun <reified R> foo() = bar<R, String>() {\"OK\"}\n\nfun box(): String {\n    return foo<String>()()\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\ninterface Call<T> {\n    fun call(): T\n}\n\npublic inline fun <reified T: Any> Any.inlineMeIfYouCan() : () -> Call<T> = {\n    object : Call<T> {\n        override fun call() = T::class.java.newInstance()\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\npublic class A()\n\nfun box(): String {\n    val s = \"yo\".inlineMeIfYouCan<A>()().call()\n    if (s !is A) return \"fail\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo(): T = this as T\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    failTypeCast { null.foo<Any>(); return \"failTypeCast 1\" }\n    if (null.foo<Any?>() != null) return \"failTypeCast 2\"\n\n    failTypeCast { null.foo<A>(); return \"failTypeCast 3\" }\n    if  (null.foo<A?>() != null) return \"failTypeCast 4\"\n\n    val a = A()\n\n    if (a.foo<Any>() != a) return \"failTypeCast 5\"\n    if (a.foo<Any?>() != a) return \"failTypeCast 6\"\n\n    if (a.foo<A>() != a) return \"failTypeCast 7\"\n    if (a.foo<A?>() != a) return \"failTypeCast 8\"\n\n    val b = B()\n\n    failClassCast { b.foo<A>(); return \"failTypeCast 9\" }\n    failClassCast { b.foo<A?>(); return \"failTypeCast 10\" }\n\n    return \"OK\"\n}\n\ninline fun failTypeCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n\n    }\n}\n\ninline fun failClassCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n        throw e\n    }\n    catch (e: ClassCastException) {\n\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\ninline fun <reified T, reified R>T.castTo(): R = this as R\n\n// FILE: 2.kt\n\nimport test.*\n\nfun case1(): Int =\n        null.castTo<Int?, Int>()\n\nfun box(): String {\n    failTypeCast { case1(); return \"failTypeCast 9\" }\n    return \"OK\"\n}\n\ninline fun failTypeCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo(): T = this as T\n\ninline fun <reified Y> Any?.foo2(): Y? = foo<Y?>()\n\ninline fun <reified Z> Any?.foo3(): Z? = foo2<Z>()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (null.foo3<Any>() != null) return \"fail 1\"\n    if (null.foo3<Any?>() != null) return \"fail 2\"\n\n    if (null.foo3<A>() != null) return \"fail 3\"\n    if (null.foo3<A?>() != null) return \"fail 4\"\n\n    val a = A()\n\n    if (a.foo3<Any>() != a) return \"fail 5\"\n    if (a.foo3<Any?>() != a) return \"fail 6\"\n\n    if (a.foo3<A>() != a) return \"fail 7\"\n    if (a.foo3<A?>() != a) return \"fail 8\"\n\n    val b = B()\n\n    failClassCast { b.foo3<A>(); return \"failTypeCast 9\" }\n    failClassCast { b.foo3<A?>(); return \"failTypeCast 10\" }\n\n    return \"OK\"\n}\n\ninline fun failClassCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n        throw e\n    }\n    catch (e: ClassCastException) {\n\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nclass A\n\nfun call(a: String, b: String, c: String, d: String, e: String, f: Any) {\n\n}\n\ninline fun <reified T: Any> Any?.foo(): T {\n    call(\"1\", \"2\", \"3\", \"4\", \"5\", this as T)\n    return this as T\n}\n\n// FILE: 2.kt\n\nimport test.*\n\n\n\nfun box(): String {\n    val a = A()\n    if (a.foo<Any>() != a) return \"failTypeCast 5\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo(): T? = this as T?\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (null.foo<Any>() != null) return \"failTypeCast 1\"\n    if (null.foo<Any?>() != null) return \"failTypeCast 2\"\n\n    if  (null.foo<A>() != null) return \"failTypeCast 3\"\n    if  (null.foo<A?>() != null) return \"failTypeCast 4\"\n\n    val a = A()\n\n    if (a.foo<Any>() != a) return \"failTypeCast 5\"\n    if (a.foo<Any?>() != a) return \"failTypeCast 6\"\n\n    if (a.foo<A>() != a) return \"failTypeCast 7\"\n    if (a.foo<A?>() != a) return \"failTypeCast 8\"\n\n    val b = B()\n\n    failClassCast { b.foo<A>(); return \"failTypeCast 9\" }\n    failClassCast { b.foo<A?>(); return \"failTypeCast 10\" }\n\n    return \"OK\"\n}\n\ninline fun failTypeCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n\n    }\n}\n\ninline fun failClassCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n        throw e\n    }\n    catch (e: ClassCastException) {\n\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// WITH_RUNTIME\npackage test\n\nclass A\nclass B\n\ninline fun <reified T> Any?.foo(): T? = this as? T\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (null.foo<Any>() != null) return \"failTypeCast 1\"\n    if (null.foo<Any?>() != null) return \"failTypeCast 2\"\n\n    if  (null.foo<A>() != null) return \"failTypeCast 3\"\n    if  (null.foo<A?>() != null) return \"failTypeCast 4\"\n\n    val a = A()\n\n    if (a.foo<Any>() != a) return \"failTypeCast 5\"\n    if (a.foo<Any?>() != a) return \"failTypeCast 6\"\n\n    if (a.foo<A>() != a) return \"failTypeCast 7\"\n    if (a.foo<A?>() != a) return \"failTypeCast 8\"\n\n    val b = B()\n\n    if (b.foo<A>() != null) return \"fail 9\"\n    if (b.foo<A?>() != null) return \"fail 10\"\n\n    return \"OK\"\n}\n\ninline fun failTypeCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n\n    }\n}\n\ninline fun failClassCast(s: () -> Unit) {\n    try {\n        s()\n    }\n    catch (e: TypeCastException) {\n        throw e\n    }\n    catch (e: ClassCastException) {\n\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage test\n\ninline fun <reified T> f(): Array<T> = arrayOf()\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    f<String>()\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <reified T> f(x : () -> Unit) {\n    object { init { arrayOf<T>() } }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    f<String>() {}\n    return \"OK\"\n}\n"
        },
        {
            "code": "// TARGET_BACKEND: JVM\n// FILE: 1.kt\n// WITH_REFLECT\npackage test\n\n\npublic inline fun <reified T: Any> Any.inlineMeIfYouCan() : () -> Runnable = {\n    object : Runnable {\n        override fun run() {\n            T::class.java.newInstance()\n        }\n    }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    \"yo\".inlineMeIfYouCan<StringBuilder>()().run()\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\nimport kotlin.reflect.KClass\n\ninline fun <reified T : Any> injectFnc(): KClass<T> = {\n    T::class\n} ()\n\npublic class Box\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    val boxClass = injectFnc<Box>()\n    if (boxClass != Box::class) return \"fail 1\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <reified T> f(x : () -> Unit) {\n    object { init { \"OK\" is T } }\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    f<String>() {}\n    return \"OK\"\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage test\n\ninline fun <reified T> test(x: Any): Boolean {\n    val x = object {\n        val y = x is T\n    }\n\n    return x.y\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    if (!test<String>(\"OK\")) return \"fail 1\"\n\n    if (test<Int>(\"OK\")) return \"fail 2\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !API_VERSION: LATEST\n// FILE: 1.kt\n\npackage test\n\npublic inline fun <R> doRun(block: () -> R): R {\n    return block()\n}\n\n// FILE: 2.kt\n\nimport test.*\n\nfun box(): String {\n    return doRun { \"OK\" }\n}\n"
        },
        {
            "code": "// FILE: test/JavaClass.java\npackage test;\n\npublic abstract class JavaClass<T> implements A<T> {\n\n}\n\n// FILE: main.kt\npackage test\n\ninterface A<T> : Collection<T>\n\n// There must be toArray methods in B\nabstract class B<E> : JavaClass<E>()\n"
        },
        {
            "code": "// WITH_RUNTIME\n\n// FILE: test/B.java\npackage test;\n\npublic abstract class B<E> extends A<E> implements L<E> {\n\n}\n\n// FILE: main.kt\npackage test\nopen class A<T> : Collection<T> {\n    override val size: Int\n        get() = TODO(\"not implemented\") //To change initializer of created properties use File | Settings | File Templates.\n\n    override fun contains(element: T): Boolean {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun containsAll(elements: Collection<T>): Boolean {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun isEmpty(): Boolean {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun iterator(): Iterator<T> {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n}\n\ninterface L<Q> : List<Q>\n\n// 'remove(Int)' method must be present in C though it has supeclass that is subclass of List\nclass C<F> : B<F>() {\n    override fun get(index: Int): F {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun indexOf(element: F): Int {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun lastIndexOf(element: F): Int {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun listIterator(): ListIterator<F> {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun listIterator(index: Int): ListIterator<F> {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<F> {\n        TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n}\n"
        },
        {
            "code": "interface Pa<X, Y>\n\nfun foo(<!UNUSED_PARAMETER(IGNORE)!>u<!> : Unit) : Int = 1\nfun bas(<!UNUSED_PARAMETER!>u<!> : Pa<Int, String>) = 3\n\nfun test() : Int {\n    foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH(IGNORE; Unit)!>1<!>)\n    val <!UNUSED_VARIABLE!>a<!> : () -> Unit = {\n    foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH(integer; IGNORE)!>1<!>)\n    bas(<!CONSTANT_EXPECTED_TYPE_MISMATCH(integer; Pa<Int, String>)!>1<!>)\n}\nreturn 1 <!NONE_APPLICABLE!>-<!> \"1\"\n}\n\nclass A() {\n    val x : Int = <!TYPE_MISMATCH!>foo1(<!UNRESOLVED_REFERENCE, TOO_MANY_ARGUMENTS!>xx<!>)<!>\n}\n\nfun foo1() {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\nimport kotlin.reflect.*\n\nclass Foo(val prop: Any) {\n    fun func() {}\n}\n\nfun testSomeValidCases(p0: KProperty0<Int>, pm0: KMutableProperty0<String>, f: KFunction<String>, p1: KProperty1<String, Int>, p2: KProperty2<String, String, Int>) {\n    Foo::prop\n    Foo::func\n    Foo::class\n    p0.get()\n    p0.name\n    pm0.set(\"\")\n    f.name\n    p1.get(\"\")\n    p2.get(\"\", \"\")\n    (Foo::func).invoke(Foo(\"\"))\n    (Foo::func)(Foo(\"\"))\n\n    p0 == pm0\n    p1.equals(p2)\n    p0.hashCode()\n    f.toString()\n}\n\nfun <T : Any> kclass(k: KClass<*>, kt: KClass<T>) {\n    k.simpleName\n    k.<!UNSUPPORTED!>qualifiedName<!>\n    k.<!UNSUPPORTED!>members<!>\n    k.<!UNSUPPORTED!>constructors<!>\n    k.<!UNSUPPORTED!>nestedClasses<!>\n    k.<!UNSUPPORTED!>objectInstance<!>\n    k.<!UNSUPPORTED!>typeParameters<!>\n    k.<!UNSUPPORTED!>supertypes<!>\n    k.<!UNSUPPORTED!>visibility<!>\n    k.<!UNSUPPORTED!>isFinal<!>\n    k.<!UNSUPPORTED!>isOpen<!>\n    k.<!UNSUPPORTED!>isAbstract<!>\n    k.<!UNSUPPORTED!>isSealed<!>\n    k.<!UNSUPPORTED!>isData<!>\n    k.<!UNSUPPORTED!>isInner<!>\n    k.<!UNSUPPORTED!>isCompanion<!>\n\n    k.<!UNSUPPORTED!>annotations<!>\n\n    k == kt\n    k.hashCode()\n    k.toString()\n}\n"
        },
        {
            "code": "import kotlin.<!UNRESOLVED_REFERENCE!>Cloneable<!>\n\nfun cloneable(): <!UNRESOLVED_REFERENCE!>Cloneable<!> = intArrayOf(42)\n"
        },
        {
            "code": "// FILE: a.kt\n@file:JsQualifier(<!WRONG_JS_QUALIFIER!>\"\"<!>)\n\n// FILE: b.kt\n@file:JsQualifier(<!WRONG_JS_QUALIFIER!>\"a..b\"<!>)\n\n// FILE: c.kt\n@file:JsQualifier(<!WRONG_JS_QUALIFIER!>\"a.\"<!>)\n\n// FILE: d.kt\n@file:JsQualifier(<!WRONG_JS_QUALIFIER!>\".a\"<!>)\n\n// FILE: e.kt\n@file:JsQualifier(<!WRONG_JS_QUALIFIER!>\"%^&\"<!>)\n\n// FILE: f.kt\n@file:JsQualifier(\"a.bc.d23._$\")"
        },
        {
            "code": "@file:JsQualifier(\"a.b\")\n\nclass <!NON_EXTERNAL_DECLARATION_IN_INAPPROPRIATE_FILE!>A<!> {\n    class B\n\n    fun bar() {}\n}\n\n<!NON_EXTERNAL_DECLARATION_IN_INAPPROPRIATE_FILE!>fun foo()<!> = \"OK\""
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class A {\n    fun get(index: Int): Char = '*'\n}\n\nabstract class <!WRONG_MULTIPLE_INHERITANCE!>B<!> : A(), CharSequence\n\ninterface I {\n    fun nextChar(): Char\n}\n\nabstract class <!WRONG_MULTIPLE_INHERITANCE!>C<!> : CharIterator(), I {\n    override fun nextChar(): Char = '*'\n}\n\nclass <!WRONG_MULTIPLE_INHERITANCE!>CC(val s: CharSequence)<!> : CharSequence by s, MyCharSequence {}\n\ninterface MyCharSequence {\n    val length: Int\n\n    operator fun get(index: Int): Char\n\n    fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n}"
        },
        {
            "code": "// MODULE: lib\n// FILE: lib.kt\n\ninterface I {\n    fun foo(): String\n}\n\nabstract class A {\n    abstract fun bar(): String\n}\n\nabstract class G<T> {\n    abstract fun baz(): T\n}\n\nclass C {\n    private val propA = object : A() {\n        override fun bar() = \"propA.bar\"\n\n        fun x() = \"OK\"\n    }\n\n    private val propI = object : I {\n        override fun foo() = \"propI.foo\"\n\n        fun x() = \"OK\"\n    }\n\n    private val propAI = object : A(), I {\n        override fun foo() = \"propAI.foo\"\n\n        override fun bar() = \"propAI.bar\"\n\n        fun x() = \"OK\"\n    }\n\n    private val propG = object : G<String>() {\n        override fun baz() = \"propG.baz\"\n\n        fun x() = \"OK\"\n    }\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\nfun test() {\n    println(C().<!INVISIBLE_MEMBER!>propA<!>.x())\n    println(C().<!INVISIBLE_MEMBER!>propI<!>.x())\n    println(C().<!INVISIBLE_MEMBER!>propAI<!>.x())\n    println(C().<!INVISIBLE_MEMBER!>propG<!>.x())\n}"
        },
        {
            "code": "@Retention(AnnotationRetention.BINARY)\nannotation class X\n\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Y\n\n@X\nexternal class A {\n    @X\n    fun f()\n\n    @X\n    val p: Int\n\n    @get:X\n    val r: Int\n}\n\n<!RUNTIME_ANNOTATION_ON_EXTERNAL_DECLARATION!>@Y<!>\nexternal class B {\n    <!RUNTIME_ANNOTATION_ON_EXTERNAL_DECLARATION!>@Y<!>\n    fun f()\n\n    <!RUNTIME_ANNOTATION_ON_EXTERNAL_DECLARATION!>@Y<!>\n    val p: Int\n\n    <!RUNTIME_ANNOTATION_ON_EXTERNAL_DECLARATION!>@get:Y<!>\n    val r: Int\n}\n\n@X\nclass C {\n    @X\n    fun f() {}\n\n    @X\n    val p: Int = 0\n\n    val q: Int\n        @X get() = 0\n\n    @get:X\n    val r: Int = 0\n}\n\n<!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@Y<!>\nclass D {\n    <!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@Y<!>\n    fun f() {}\n\n    <!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@Y<!>\n    val p: Int = 0\n\n    val q: Int\n      <!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@Y<!> get() = 0\n\n    <!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@get:Y<!>\n    val r: Int = 0\n}"
        },
        {
            "code": "class A {\n    @property:JsName(\"x_\") <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@get:JsName(\"getX_\")<!> val x: Int = 0\n\n    <!JS_NAME_IS_NOT_ON_ALL_ACCESSORS!>@get:JsName(\"getY_\") var y: Int<!> = 0\n}"
        },
        {
            "code": "package foo\n\nclass A\n\n<!JS_NAME_PROHIBITED_FOR_EXTENSION_PROPERTY!>@JsName(\"xx\")<!> val A.x: Int\n    get() = 23\n\n<!JS_NAME_PROHIBITED_FOR_EXTENSION_PROPERTY!>@property:JsName(\"yy\")<!> val A.y: Int\n    get() = 42"
        },
        {
            "code": "interface I {\n    @JsName(\"bar\")\n    fun foo()\n\n    @JsName(\"foo\")\n    fun bar()\n}\n\ninterface J {\n    fun foo()\n\n    fun bar()\n}\n\nclass A : I, J {\n    // Duplicate diagnostics are expected here, since `bar()` function gets both `foo` and `bar` names and clashes with both\n    // names of `foo()` function.\n    <!JS_NAME_CLASH, JS_NAME_CLASH!>override fun bar()<!> {}\n\n    <!JS_NAME_CLASH, JS_NAME_CLASH!>override fun foo()<!> {}\n}\n"
        },
        {
            "code": "package foo\n\n<!JS_NAME_CLASH!>@JsName(\"x\") fun foo(x: Int)<!> = x\n\n<!JS_NAME_CLASH!>@JsName(\"x\") fun bar()<!> = 42"
        },
        {
            "code": "interface I {\n    fun foo()\n}\n\ninterface J {\n    @JsName(\"bar\")\n    fun foo()\n}\n\ninterface K : I, J {\n    override fun foo()\n}\n\ninterface L : K {\n    <!JS_NAME_CLASH!>override fun foo()<!>\n\n    <!JS_NAME_CLASH!>fun bar()<!>\n}"
        },
        {
            "code": "package foo\n\nclass <!JS_NAME_CLASH!>A(val x: Int)<!>\n\n<!JS_NAME_CLASH!>fun A()<!> {}"
        },
        {
            "code": "package foo\n\nclass A <!JS_NAME_ON_PRIMARY_CONSTRUCTOR_PROHIBITED!>@JsName(\"B\")<!> constructor()"
        },
        {
            "code": "package foo\n\nclass A {\n    var x: Int\n        <!JS_NAME_CLASH!>@JsName(\"xx\") get()<!> = 0\n        <!JS_NAME_CLASH!>@JsName(\"xx\") set(<!UNUSED_PARAMETER!>value<!>)<!> {}\n}"
        },
        {
            "code": "class C {\n    class <!JS_BUILTIN_NAME_CLASH!>prototype<!>\n\n    class <!JS_BUILTIN_NAME_CLASH!>length<!>\n\n    class <!JS_BUILTIN_NAME_CLASH!>`$metadata$`<!>\n\n    <!JS_BUILTIN_NAME_CLASH!>fun constructor()<!> {}\n}\n\nclass D {\n    private class <!JS_BUILTIN_NAME_CLASH!>prototype<!>\n\n    private class <!JS_BUILTIN_NAME_CLASH!>length<!>\n\n    private class <!JS_BUILTIN_NAME_CLASH!>`$metadata$`<!>\n\n    private fun constructor() {}\n}\n\nclass E {\n    @JsName(\"prototype\")\n    class <!JS_BUILTIN_NAME_CLASH!>D<!>\n\n    <!JS_BUILTIN_NAME_CLASH!>@JsName(\"constructor\")\n    fun f()<!> {}\n}\n\nclass F {\n    @JsName(\"A\")\n    class prototype\n\n    @JsName(\"B\")\n    class length\n\n    @JsName(\"f\")\n    fun constructor() {}\n}\n\nclass prototype\n\nclass length\n\nfun constructor() {\n}\n\nfun f() {\n    class prototype\n    class length\n\n    fun constructor() {}\n}\n\nexternal interface Object {\n    val constructor: Any?\n}"
        },
        {
            "code": "package foo\n\nopen class A {\n    @JsName(\"foo_\") open fun foo() = 23\n\n    @JsName(\"bar_\") open val bar = 123\n\n    open val baz: Int\n        @JsName(\"getBaz_\") get() = 55\n}\n\nclass B : A() {\n    <!JS_NAME_PROHIBITED_FOR_OVERRIDE!>@JsName(\"foo__\")<!> override fun foo() = 42\n\n    <!JS_NAME_PROHIBITED_FOR_OVERRIDE!>@JsName(\"bar__\")<!> override val bar = 142\n\n    override val baz: Int\n        <!JS_NAME_PROHIBITED_FOR_OVERRIDE!>@JsName(\"getBaz__\")<!> get() = 155\n}"
        },
        {
            "code": "interface A {\n    @JsName(\"foo\") fun f()\n}\n\ninterface B {\n    @JsName(\"foo\") fun g()\n}\n\nclass C : A, B {\n    <!JS_NAME_CLASH!>override fun f()<!> {}\n\n    <!JS_NAME_CLASH!>override fun g()<!> {}\n}\n\nabstract class <!JS_FAKE_NAME_CLASH!>D<!> : A, B\n\nopen class E {\n    open fun f() {}\n\n    open fun g() {}\n}\n\nclass <!JS_FAKE_NAME_CLASH!>F<!> : E(), A, B\n"
        },
        {
            "code": "package <!INVALID_CHARACTERS!>`//`<!>\n\nclass A"
        },
        {
            "code": "package foo\n\nclass A(val x: String) {\n    @JsName(\"aa\") <!JS_NAME_CLASH!>constructor(x: Int)<!> : this(\"int $x\")\n}\n\n<!JS_NAME_CLASH!>fun aa()<!> {}"
        },
        {
            "code": "package foo\n\n<!JS_NAME_CLASH!>@JsName(\"bar\") private fun foo(x: Int)<!> = x\n\n<!JS_NAME_CLASH!>fun bar()<!> = 42"
        },
        {
            "code": "package foo\n\nopen class Super {\n    <!JS_NAME_CLASH!>val foo<!> = 23\n}\n\nclass Sub : Super() {\n    <!JS_NAME_CLASH!>fun foo()<!> = 42\n}"
        },
        {
            "code": "// FILE: first.kt\npackage foo\n\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!>\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>C<!>\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>C<!>\n\n<!CONFLICTING_OVERLOADS!>fun f(): Int<!> = 23\n<!CONFLICTING_OVERLOADS!>fun f(): Int<!> = 99\n\n<!CONFLICTING_OVERLOADS!>fun g(): String<!> = \"23\"\n<!CONFLICTING_OVERLOADS!>fun g(): Int<!> = 23\n\nval <!REDECLARATION!>x<!>: Int = 42\nval <!REDECLARATION!>x<!>: Int = 99\n\nval <!REDECLARATION!>y<!>: String = \"42\"\nval <!REDECLARATION!>y<!>: Int = 42\n\nclass B {\n    <!CONFLICTING_OVERLOADS!>fun f(): Int<!> = 23\n    <!CONFLICTING_OVERLOADS!>fun f(): Int<!> = 99\n\n    <!CONFLICTING_OVERLOADS!>fun g(): String<!> = \"23\"\n    <!CONFLICTING_OVERLOADS!>fun g(): Int<!> = 23\n\n    val <!REDECLARATION!>x<!>: Int = 42\n    val <!REDECLARATION!>x<!>: Int = 99\n\n    val <!REDECLARATION!>y<!>: String = \"42\"\n    val <!REDECLARATION!>y<!>: Int = 42\n}\n\n// FILE: second.kt\npackage foo\n\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!>\n"
        },
        {
            "code": "package foo\n\nopen class Super {\n    <!JS_NAME_CLASH!>fun foo()<!> = 23\n}\n\nclass Sub : Super() {\n    <!JS_NAME_CLASH!>@JsName(\"foo\") fun bar()<!> = 42\n}"
        },
        {
            "code": "external open class A {\n    open fun f(x: Int): Unit\n\n    <!JS_NAME_CLASH!>open fun f(x: String): Unit<!>\n}\n\nclass InheritClass : A() {\n    <!JS_NAME_CLASH!>override fun f(x: Int): Unit<!> { }\n}"
        },
        {
            "code": "package foo\n\nclass A {\n    <!JS_NAME_CLASH!>fun bar()<!> = 23\n\n    <!JS_NAME_CLASH!>val bar<!> = 23\n}"
        },
        {
            "code": "// FILE: foo.kt\n\npackage foo\n\n<!JS_NAME_CLASH!>fun bar()<!> = 23\n\n// FILE: foobar.kt\n\npackage foo.bar\n\nval x = 42\n"
        },
        {
            "code": "package foo\n\ninterface I {\n    <!JS_NAME_CLASH!>fun foo()<!> = 23\n}\n\nclass Sub : I {\n    <!JS_NAME_CLASH!>var foo<!> = 42\n}"
        },
        {
            "code": "package foo\n\n<!JS_NAME_CLASH!>fun bar()<!> = 23\n\n<!JS_NAME_CLASH!>val bar<!> = 32"
        },
        {
            "code": "package foo\n\nclass A {\n    @JsName(\"x_\") val x: Int\n        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(\"get_x\")<!> get() = 23\n\n    @JsName(\"y_\") val y = 0\n\n    @JsName(\"m_\") var m: Int\n        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(\"get_m\")<!> get() = 23\n        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(\"set_m\")<!> set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\n@JsName(\"xx_\") val xx: Int\n    <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(\"get_xx\")<!> get() = 23\n\n@JsName(\"yy_\") val yy = 0\n\n@JsName(\"mm_\") var mm: Int\n    <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(\"get_mm\")<!> get() = 23\n    <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(\"set_mm\")<!> set(<!UNUSED_PARAMETER!>value<!>) {}\n"
        },
        {
            "code": "package foo\n\nclass A\n\n<!JS_NAME_CLASH!>fun A.get_bar()<!> = 23\n\nval A.bar: Int\n  <!JS_NAME_CLASH!>get()<!> = 42"
        },
        {
            "code": "package foo\n\n<!JS_NAME_CLASH!>@JsName(\"bar\") fun foo(x: Int)<!> = x\n\n<!JS_NAME_CLASH!>fun bar()<!> = 42"
        },
        {
            "code": "private fun ` .private `(): String = TODO(\"\")\n\n<!NAME_CONTAINS_ILLEGAL_CHARS!>fun ` .public `(): String<!> = TODO(\"\")\n\n<!NAME_CONTAINS_ILLEGAL_CHARS!>@JsName(\"  __  \")\nfun foo(): String<!> = TODO(\"\")\n\n<!NAME_CONTAINS_ILLEGAL_CHARS!>@JsName(\"  ___  \")\nprivate fun bar(): String<!> = TODO(\"\")\n\n@JsName(\"validName\")\nprivate fun ` .private with @JsName `(): String = TODO(\"\")\n\nprivate class <!NAME_CONTAINS_ILLEGAL_CHARS!>` .private class `<!> {\n    <!NAME_CONTAINS_ILLEGAL_CHARS!>val ` .field. `<!> = \"\"\n}\n\nval x: Int\n    <!NAME_CONTAINS_ILLEGAL_CHARS!>@JsName(\".\")\n    get()<!> = TODO(\"\")\n\nfun box(x: dynamic) {\n    x.<!NAME_CONTAINS_ILLEGAL_CHARS!>`foo-bar`<!>()\n    x.<!NAME_CONTAINS_ILLEGAL_CHARS!>`ba-z`<!>\n}"
        },
        {
            "code": "// FILE: foo.kt\n\npackage foo\n\n<!JS_NAME_CLASH!>val bar<!> = 23\n\n// FILE: foobar.kt\n\npackage foo.bar\n\nval x = 42\n"
        },
        {
            "code": "package foo\n\nclass A {\n    <!JS_NAME_IS_NOT_ON_ALL_ACCESSORS!>var x: Int<!>\n        @JsName(\"get_x\") get() = 23\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n\n    <!JS_NAME_IS_NOT_ON_ALL_ACCESSORS!>var y: Int<!>\n        get() = 23\n        @JsName(\"set_y\") set(<!UNUSED_PARAMETER!>value<!>) {}\n\n    var z: Int\n        @JsName(\"get_z\") get() = 23\n        @JsName(\"set_z\") set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\n<!JS_NAME_IS_NOT_ON_ALL_ACCESSORS!>var xx: Int<!>\n    @JsName(\"get_xx\") get() = 23\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\n<!JS_NAME_IS_NOT_ON_ALL_ACCESSORS!>var A.ext: Int<!>\n    @JsName(\"get_ext\") get() = 23\n    set(<!UNUSED_PARAMETER!>value<!>) {}"
        },
        {
            "code": "package foo\n\n<!JS_NAME_CLASH!>fun bar(x: Int)<!> = x\n\n<!JS_NAME_CLASH!>fun `bar_za3lpa$`()<!> = 42"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER -UNUSED_PARAMETER, -UNREACHABLE_CODE\n\nval prop: String = <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>\n\nval prop2: String\n    get() = <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>\n\nfun foo(x: Int, y: String = <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>) {\n    println(\"Hello\")\n    println(\"world\")\n\n    object {\n        fun bar(): Any = <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>\n    }\n\n    listOf<String>()\n            .map<String, String> { <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!> }\n            .filter(fun(x: String): Boolean { <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!> })\n\n    <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>\n}\n\nopen class A(val x: Int)\n\nopen class B() : A(<!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>) {\n    constructor(y: String) : this()\n\n    constructor(y: String, z: String) : this(y + z + <!CALL_TO_DEFINED_EXTERNALLY_FROM_NON_EXTERNAL_DECLARATION!>definedExternally<!>)\n}\n"
        },
        {
            "code": "val a01 = <!ARRAY_CLASS_LITERAL_REQUIRES_ARGUMENT!>Array::class<!>\nval a02 = Array<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Array<!>>::class\nval a03 = Array<Any?>::class\nval a04 = Array<Array<Any?>?>::class\nval a05 = Array<IntArray?>::class\nval a06 = <!ARRAY_CLASS_LITERAL_REQUIRES_ARGUMENT!>kotlin.Array::class<!>\nval a07 = kotlin.Array<IntArray?>::class\n"
        },
        {
            "code": "// !LANGUAGE: +BareArrayClassLiteral +ProhibitGenericArrayClassLiteral\n\nval a01 = Array::class\nval a02 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Array<!>>::class<!>\nval a03 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<Any?>::class<!>\nval a04 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<Array<Any?>?>::class<!>\nval a05 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<IntArray?>::class<!>\nval a06 = kotlin.Array::class\nval a07 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>kotlin.Array<IntArray?>::class<!>\n"
        },
        {
            "code": "abstract class <!IMPLEMENTING_FUNCTION_INTERFACE!>A<!> : () -> Unit\n\n<!IMPLEMENTING_FUNCTION_INTERFACE!>object B<!> : (String, Int) -> Long {\n    override fun invoke(a: String, B: Int) = 23L\n}\n\nabstract class <!IMPLEMENTING_FUNCTION_INTERFACE!>C<!> : kotlin.Function1<Any, Int>\n\nabstract class <!IMPLEMENTING_FUNCTION_INTERFACE!>D<!> : C()"
        },
        {
            "code": "fun test(d: dynamic) {\n    val a = arrayOf(1, 2, 3)\n\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>d)\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a)\n    d.foo(1, \"2\", <!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a)\n    d.foo(1, <!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a) { }\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a) { \"\" }\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a, <!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a)\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a, <!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a) { \"\" }\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a, 1, { \"\" }, <!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a)\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a, 1)\n    d.foo(<!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a, <!SPREAD_OPERATOR_IN_DYNAMIC_CALL!>*<!>a, { \"\" })\n\n    bar(d)\n    bar(d, d)\n    bar(<!WRONG_OPERATION_WITH_DYNAMIC!>*d<!>)\n    bar(<!WRONG_OPERATION_WITH_DYNAMIC!>*d<!>, <!WRONG_OPERATION_WITH_DYNAMIC!>*d<!>)\n    bar(<!WRONG_OPERATION_WITH_DYNAMIC!>*d<!>, 23, <!WRONG_OPERATION_WITH_DYNAMIC!>*d<!>)\n}\n\nfun bar(vararg x: Int): Unit = TODO(\"$x\")"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <T> foo(t1: T, t2: T): T = t1\n\ninterface Tr\nclass C: Tr\nfun <T: Tr> foo1(t1: T, t2: T): T = t1\n\nfun test(d: dynamic, b: Boolean, n: String?) {\n    foo(d, \"\").<!DEBUG_INFO_DYNAMIC!>foo<!>()\n    foo1(d, C()).<!DEBUG_INFO_DYNAMIC!>foo<!>()\n\n    val fromIf = if (b) d else \"\"\n    fromIf.<!DEBUG_INFO_DYNAMIC!>doo<!>()\n\n    val fromElvis = n ?: d\n    fromElvis.<!DEBUG_INFO_DYNAMIC!>doo<!>()\n}\n\nclass In<in T>(t: T)\nfun <T> contra(a: In<T>, b: In<T>): T = null!!\n\nfun testContra(d: dynamic) {\n    contra(In(d), In(\"\")).get(0) // not a dynamic call\n}\n"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\nfun withDynamicReceiver(<!UNUSED_PARAMETER!>d<!>: dynamic.() -> Unit) {}\n\nfun test() = withDynamicReceiver {\n    <!DEBUG_INFO_DYNAMIC!>foo<!>\n    <!DEBUG_INFO_DYNAMIC!>bar<!> = 1\n}\n\nfun test2() = withDynamicReceiver(fun dynamic.() {})\n\nval dynamicProperty: dynamic.() -> Unit = TODO()\n\nfun test(d: dynamic, <!UNUSED_PARAMETER!>dynamicParameter<!>: dynamic.() -> Unit) {\n    d.<!DEBUG_INFO_DYNAMIC!>dynamicProperty<!>()\n    d.<!DEBUG_INFO_DYNAMIC!>dynamicParameter<!>()\n}"
        },
        {
            "code": "typealias Dyn = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>dynamic<!>\ntypealias Dyn2 = Dyn\ntypealias Dyn3 = Dyn2\n\ntypealias Type<T> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>T<!>\ntypealias Dyn4 = Type<Dyn>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -REIFIED_TYPE_PARAMETER_NO_INLINE\n\nfun <reified T> foo(t: T) {}\nclass C<reified T>(t: T)\n\nfun test(d: dynamic) {\n    foo<<!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>dynamic<!>>(d)\n    <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>foo<!>(d)\n\n    C<<!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>dynamic<!>>(d)\n    <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>C<!>(d)\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\nfun foo(d: dynamic) {\n    if (d is Foo) {\n        d.bar() // resolved statically\n        d.<!DEBUG_INFO_DYNAMIC!>baz<!>()\n    }\n}\n\nclass Foo {\n    fun bar() {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo() {\n    val a: dynamic = Any()\n    val b: dynamic = Any()\n    val c = C()\n    println(a<!WRONG_OPERATION_WITH_DYNAMIC!>..<!>b)\n    println(c..a)\n    println(a.rangeTo(b))\n}\n\nclass C {\n    operator fun rangeTo(other: dynamic): ClosedRange<dynamic> = TODO(\"not implemented\")\n}"
        },
        {
            "code": "fun foo() {\n    val a: dynamic = Any()\n    println(a in setOf(1, 2))\n    println(1 <!WRONG_OPERATION_WITH_DYNAMIC!>in<!> a)\n    println(1 <!WRONG_OPERATION_WITH_DYNAMIC!>!in<!> a)\n    when (2) {\n        <!WRONG_OPERATION_WITH_DYNAMIC!>in<!> a -> println(\"ok\")\n    }\n    when (3) {\n        <!WRONG_OPERATION_WITH_DYNAMIC!>!in<!> a -> println(\"ok\")\n    }\n}"
        },
        {
            "code": "interface Tr : <!DYNAMIC_SUPERTYPE!>dynamic<!>\n\nfun <T: <!DYNAMIC_UPPER_BOUND!>dynamic<!>> foo() {}\n\nclass C<T> where T : <!DYNAMIC_UPPER_BOUND!>dynamic<!>"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\nfun foo(d: dynamic) {\n    Foo(d).p.<!DEBUG_INFO_DYNAMIC!>bar<!>()\n\n}\n\nclass Foo<T>(val p: T)"
        },
        {
            "code": "fun test(d: dynamic) {\n    d.foo(name = \"name\")\n\n    d.foo(1, name = \"name\")\n\n    d.foo(1, duplicate = \"\", <!ARGUMENT_PASSED_TWICE!>duplicate<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\n\nfun Any?.staticExtension() = 1\n\nval Any?.staticProperty get() = 2\n\nfun test(d: dynamic, <!UNUSED_PARAMETER!>staticParameter<!>: Any?.() -> Unit) {\n    d.<!DEBUG_INFO_DYNAMIC!>staticExtension<!>()\n    d.<!DEBUG_INFO_DYNAMIC!>staticProperty<!>\n    d.<!DEBUG_INFO_DYNAMIC!>staticParameter<!>\n}"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE)\nannotation class Ann1\n\n@Target(AnnotationTarget.TYPE)\nannotation class Ann2\n\ntypealias AnnGenList<T> = List<@Ann1 T>\ntypealias TestAnnGen1 = AnnGenList<dynamic>\ntypealias TestAnnGen2 = AnnGenList<@Ann2 dynamic>\ntypealias TestAnnGen3 = AnnGenList<<!REPEATED_ANNOTATION!>@Ann1<!> dynamic>\n\nfun useAnnGen1(x: TestAnnGen1) = x\nfun useAnnGen2(x: TestAnnGen2) = x\n\nfun testUseAnnGen1(x: List<dynamic>) = useAnnGen1(x)\nfun testUseAnnGen2(x: List<dynamic>) = useAnnGen2(x)"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.test() {\n    <!DEBUG_INFO_DYNAMIC!>foo<!>()\n    <!DEBUG_INFO_DYNAMIC!>ext<!>()\n\n    bar()\n    this.<!DEBUG_INFO_DYNAMIC!>bar<!>()\n\n    baz = 2\n    this.<!DEBUG_INFO_DYNAMIC!>baz<!> = 2\n\n    \"\".ext()\n    <!DEBUG_INFO_DYNAMIC!>ext<!>()\n\n    \"\".extValFun()\n    <!DEBUG_INFO_DYNAMIC!>extValFun<!>()\n\n    \"\".extVal\n    <!DEBUG_INFO_DYNAMIC!>extVal<!>\n\n    baz.extExtVal()\n    <!DEBUG_INFO_DYNAMIC!>extExtVal<!>()\n\n    \"\"()\n    <!DEBUG_INFO_DYNAMIC!>this<!>()\n\n    C() + C()\n    <!UNRESOLVED_REFERENCE!>+<!>C()\n\n    this <!DEBUG_INFO_DYNAMIC!>+<!> C()\n\n    0.<!UNRESOLVED_REFERENCE!>missing<!>()\n}\n\nfun bar() {}\nvar baz = 1\n\nfun Any.ext() {}\n\nval Any.extValFun: () -> Unit get() = null!!\nval Any.extVal: () -> Unit get() = null!!\n\nval Any.extExtVal: Any.() -> Unit get() = null!!\n\noperator fun Any.invoke() {}\n\noperator fun Any.plus(a: Any) {}\n\nclass C {\n\n    operator fun String.invoke() {}\n    val foo: String.() -> Unit = null!!\n\n    val s: String = \"\"\n\n    val withInvoke = WithInvoke()\n\n    fun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.test() {\n        s()\n        <!DEBUG_INFO_DYNAMIC!>this<!>()\n\n        s.foo()\n        this.<!DEBUG_INFO_DYNAMIC!>foo<!>()\n\n        withInvoke()\n        this@C.withInvoke()\n    }\n}\n\nclass WithInvoke {\n    operator fun invoke() {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER\n// !CHECK_TYPE\n\nfun test(d: dynamic) {\n    d.foo {}\n\n    d.foo { <!UNRESOLVED_REFERENCE!>it<!> }\n\n    d.foo { x -> }\n\n    d.foo { x: Int -> \"\" }\n\n    d.foo { x, y -> \"\" }\n\n    d.foo { x: String, y: Int -> \"\" }\n\n    d.foo { x, y: Int -> \"\" }\n\n    d.foo({})\n\n    d.foo({ x -> })\n\n    d.foo(checkSubtype<(Int) -> Unit>({ x -> }))\n\n    d.foo(label@ { x -> })\n\n    d.foo(label@ ({ x, y -> }))\n\n    d.foo((label@ ({ x, y: Int -> })))\n\n    d.foo(({ x -> }))\n\n    d.foo((({ x -> })))\n}\n"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\nfun test(d: dynamic) {\n    d.<!DEBUG_INFO_DYNAMIC!>onDynamic<!>()\n    d.<!DEBUG_INFO_DYNAMIC!>onNullableDynamic<!>()\n\n    d.<!DEBUG_INFO_DYNAMIC!>valOnDynamic<!>\n    d.<!DEBUG_INFO_DYNAMIC!>valOnDynamic<!> = 1\n\n    d.<!DEBUG_INFO_DYNAMIC!>varOnDynamic<!>\n    d.<!DEBUG_INFO_DYNAMIC!>varOnDynamic<!> = 1\n}\n\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.extTest() {\n    <!DEBUG_INFO_DYNAMIC!>onDynamic<!>()\n    <!DEBUG_INFO_DYNAMIC!>onNullableDynamic<!>()\n\n    <!DEBUG_INFO_DYNAMIC!>valOnDynamic<!>\n    <!DEBUG_INFO_DYNAMIC!>valOnDynamic<!> = 1\n\n    <!DEBUG_INFO_DYNAMIC!>varOnDynamic<!>\n    <!DEBUG_INFO_DYNAMIC!>varOnDynamic<!> = 1\n\n    this.<!DEBUG_INFO_DYNAMIC!>onDynamic<!>()\n    this.<!DEBUG_INFO_DYNAMIC!>onNullableDynamic<!>()\n\n    this.<!DEBUG_INFO_DYNAMIC!>valOnDynamic<!>\n    this.<!DEBUG_INFO_DYNAMIC!>valOnDynamic<!> = 1\n\n    this.<!DEBUG_INFO_DYNAMIC!>varOnDynamic<!>\n    this.<!DEBUG_INFO_DYNAMIC!>varOnDynamic<!> = 1\n\n}\n\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.onDynamic() {}\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!REDUNDANT_NULLABLE!>?<!><!>.onNullableDynamic() {}\n\nval <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.valOnDynamic: Int get() = 1\n\nvar <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.varOnDynamic: Int\n    get() = 1\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n\n\nclass ForMemberExtensions {\n    fun test(d: dynamic) {\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVar<!>\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVar<!> = 1\n\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVal<!>\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVal<!> = 1\n    }\n\n    val <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.memberExtensionVal: Int get() = 1\n    var <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.memberExtensionVar: Int\n        get() = 1\n        set(<!UNUSED_PARAMETER!>v<!>) {}\n}"
        },
        {
            "code": "val x: dynamic = 23\n\ninterface I {\n    fun foo(): String\n}\n\nclass C : I by <!DELEGATION_BY_DYNAMIC!>x<!>\n\nobject O : I by <!DELEGATION_BY_DYNAMIC!>x<!>\n\nfun box(): String {\n    return object : I by <!DELEGATION_BY_DYNAMIC!>x<!> {}.foo()\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.foo(s: String, a: Any) {}\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.foo(s: Any, a: String) {}\n\nfun test(d: dynamic) {\n    d.<!DEBUG_INFO_DYNAMIC!>foo<!>(1, \"\")\n    d.<!DEBUG_INFO_DYNAMIC!>foo<!>(\"\", \"\")\n    d.<!DEBUG_INFO_DYNAMIC!>foo<!>(1, 1)\n}"
        },
        {
            "code": "fun foo() {\n    val a: dynamic = Any()\n    println(a[0])\n    println(<!WRONG_OPERATION_WITH_DYNAMIC!>a[0, 1]<!>)\n\n    a[0] = 23\n    <!WRONG_OPERATION_WITH_DYNAMIC!>a[0, 1]<!> = 42\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n// !DIAGNOSTICS:-USELESS_CAST\n\nfun test(d: dynamic) {\n    d.<!DEBUG_INFO_DYNAMIC!>onAnyVar<!>\n    d.<!DEBUG_INFO_DYNAMIC!>onAnyVar<!> = 1\n\n    d?.<!DEBUG_INFO_DYNAMIC!>onAnyVar<!>\n    d?.<!DEBUG_INFO_DYNAMIC!>onAnyVar<!> = 1\n\n    run {\n        d!!.<!DEBUG_INFO_DYNAMIC!>onAnyVar<!>\n\n    }\n    run {\n        d!!.<!DEBUG_INFO_DYNAMIC!>onAnyVar<!> = 1\n    }\n\n    d.<!DEBUG_INFO_DYNAMIC!>onNullableAnyVar<!> = 1\n\n    d.<!DEBUG_INFO_DYNAMIC!>onStringVar<!> = 1\n\n    d.<!DEBUG_INFO_DYNAMIC!>onDynamicVar<!> = 1\n\n    d?.<!DEBUG_INFO_DYNAMIC!>onDynamicVar<!> = 1\n\n    (d as String).onStringVar\n    (d as Any).onAnyVar\n    (d as Any?).onNullableAnyVar\n    (d as Any).<!UNRESOLVED_REFERENCE!>onDynamicVar<!>\n\n    (d as String).onStringVar = 1\n    (d as Any).onAnyVar = 1\n    (d as Any?).onNullableAnyVar = 1\n    (d as Any).<!UNRESOLVED_REFERENCE!>onDynamicVar<!> = 1\n}\n\nvar Any.onAnyVar: Int\n    get() = 1\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n\nvar Any?.onNullableAnyVar: Int\n    get() = 1\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n\nvar String.onStringVar: Int\n    get() = 1\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n\nvar <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.onDynamicVar: Int\n    get() = 1\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n\nclass C {\n    fun test(d: dynamic) {\n        d.<!DEBUG_INFO_DYNAMIC!>memberVar<!>\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVar<!>\n\n        d.<!DEBUG_INFO_DYNAMIC!>memberVar<!> = 1\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVar<!> = 1\n    }\n\n    var memberVar = 1\n    var Any.memberExtensionVar: Int\n        get() = 1\n        set(<!UNUSED_PARAMETER!>v<!>) {}\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\nfun test() {\n    dynamic {\n        <!DEBUG_INFO_DYNAMIC!>foo<!>()\n        <!DEBUG_INFO_DYNAMIC!>bar<!>.<!DEBUG_INFO_DYNAMIC!>baz<!>(0)\n    }\n}\n\nfun <T> dynamic(<!UNUSED_PARAMETER!>body<!>: dynamic.() -> T): T {\n    val topLevel = null\n    return topLevel.<!UNRESOLVED_REFERENCE!>body<!>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS:-USELESS_CAST\n// !MARK_DYNAMIC_CALLS\n\nfun test(d: dynamic) {\n    d.<!DEBUG_INFO_DYNAMIC!>onAnyVal<!>\n    d.<!DEBUG_INFO_DYNAMIC!>onAnyVal<!> = 1\n\n    d?.<!DEBUG_INFO_DYNAMIC!>onAnyVal<!>\n    d?.<!DEBUG_INFO_DYNAMIC!>onAnyVal<!> = 1\n\n    run {\n        d!!.<!DEBUG_INFO_DYNAMIC!>onAnyVal<!>\n    }\n    run {\n        d!!.<!DEBUG_INFO_DYNAMIC!>onAnyVal<!> = 1\n    }\n\n    d.<!DEBUG_INFO_DYNAMIC!>onNullableAnyVal<!> = 1\n\n    d.<!DEBUG_INFO_DYNAMIC!>onStringVal<!> = 1\n\n    d.<!DEBUG_INFO_DYNAMIC!>onDynamicVal<!> = 1\n\n    (d as String).onStringVal\n    (d as Any).onAnyVal\n    (d as Any?).onNullableAnyVal\n    (d as Any).<!UNRESOLVED_REFERENCE!>onDynamicVal<!>\n}\n\nfun testReassignmentWithSafeCall(d: dynamic) {\n    d?.<!DEBUG_INFO_DYNAMIC!>onDynamicVal<!> = 1\n}\n\nfun testReassignmentWithStaticCalls(d: dynamic) {\n    <!VAL_REASSIGNMENT!>(d as String).onStringVal<!> = 1\n    <!VAL_REASSIGNMENT!>(d as Any).onAnyVal<!> = 1\n    <!VAL_REASSIGNMENT!>(d as Any?).onNullableAnyVal<!> = 1\n    (d as Any).<!UNRESOLVED_REFERENCE!>onDynamicVal<!> = 1\n}\n\nval Any.onAnyVal: Int get() = 1\nval Any?.onNullableAnyVal: Int get() = 1\nval String.onStringVal: Int get() = 1\nval <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.onDynamicVal: Int get() = 1\n\nclass C {\n    fun test(d: dynamic) {\n        d.<!DEBUG_INFO_DYNAMIC!>memberVal<!>\n        d.<!DEBUG_INFO_DYNAMIC!>memberVal<!> = 1\n\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVal<!>\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtensionVal<!> = 1\n    }\n\n    val memberVal = 1\n    val Any.memberExtensionVal: Int\n        get() = 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo() {\n    for (<!WRONG_OPERATION_WITH_DYNAMIC!>(x, y)<!> in A()) {\n        println(x + y)\n    }\n\n    bar { <!WRONG_OPERATION_WITH_DYNAMIC!>(x, y)<!> ->\n        println(x + y)\n    }\n\n    val x: dynamic = Any()\n\n    <!WRONG_OPERATION_WITH_DYNAMIC!>val (y, z) = x<!>\n    println(y + z)\n}\n\nclass A {\n    operator fun iterator(): Iterator<dynamic> = TODO(\"\")\n}\n\nfun bar(f: (dynamic) -> Unit): Unit = TODO(\"\")"
        },
        {
            "code": "// !DIAGNOSTICS: -NON_TOPLEVEL_CLASS_DECLARATION\n// !MARK_DYNAMIC_CALLS\n\nfun test(d: dynamic) {\n    <!DEBUG_INFO_DYNAMIC!>+<!>d\n    <!DEBUG_INFO_DYNAMIC!>-<!>d\n    <!DEBUG_INFO_DYNAMIC!>!<!> d\n\n\n    d <!DEBUG_INFO_DYNAMIC!>+<!> d\n    d <!DEBUG_INFO_DYNAMIC!>+<!> 1\n    \"\" + d\n\n    d <!DEBUG_INFO_DYNAMIC!>-<!> d\n    d <!DEBUG_INFO_DYNAMIC!>*<!> d\n    d <!DEBUG_INFO_DYNAMIC!>/<!> d\n    d <!DEBUG_INFO_DYNAMIC!>%<!> d\n\n    d <!DEBUG_INFO_DYNAMIC!>and<!> d\n\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!>\n\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!> = 2\n\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!><!DEBUG_INFO_DYNAMIC!>++<!>\n    <!DEBUG_INFO_DYNAMIC!>++<!><!DEBUG_INFO_DYNAMIC!>d[1]<!>\n\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!><!DEBUG_INFO_DYNAMIC!>--<!>\n    <!DEBUG_INFO_DYNAMIC!>--<!><!DEBUG_INFO_DYNAMIC!>d[1]<!>\n\n    <!DEBUG_INFO_DYNAMIC!>d()<!>\n    <!DEBUG_INFO_DYNAMIC!>d(1)<!>\n    <!DEBUG_INFO_DYNAMIC!>d(name = 1)<!>\n    <!DEBUG_INFO_DYNAMIC!>d {}<!>\n\n    class C {\n        val plus: dynamic = null\n    }\n\n    C() + 5 // todo should be marked as DEBUG_INFO_DYNAMIC\n    C().<!DEBUG_INFO_DYNAMIC!>plus(5)<!>\n\n    d == d\n    d != d\n\n    d === d\n    d !== d\n\n    d <!DEBUG_INFO_DYNAMIC!><<!> d\n    d <!DEBUG_INFO_DYNAMIC!><=<!> d\n    d <!DEBUG_INFO_DYNAMIC!>>=<!> d\n    d <!DEBUG_INFO_DYNAMIC!>><!> d\n\n    for (i in d) {\n        i.<!DEBUG_INFO_DYNAMIC!>foo<!>()\n    }\n\n    var dVar = d\n    dVar<!DEBUG_INFO_DYNAMIC!>++<!>\n    <!DEBUG_INFO_DYNAMIC!>++<!>dVar\n\n    dVar<!DEBUG_INFO_DYNAMIC!>--<!>\n    <!DEBUG_INFO_DYNAMIC!>--<!>dVar\n\n    dVar <!DEBUG_INFO_DYNAMIC!>+=<!> 1\n    dVar <!DEBUG_INFO_DYNAMIC!>-=<!> 1\n    dVar <!DEBUG_INFO_DYNAMIC!>*=<!> 1\n    dVar <!DEBUG_INFO_DYNAMIC!>/=<!> 1\n    dVar <!DEBUG_INFO_DYNAMIC!>%=<!> 1\n\n    d <!DEBUG_INFO_DYNAMIC!>+=<!> 1\n    d <!DEBUG_INFO_DYNAMIC!>-=<!> 1\n    d <!DEBUG_INFO_DYNAMIC!>*=<!> 1\n    d <!DEBUG_INFO_DYNAMIC!>/=<!> 1\n    d <!DEBUG_INFO_DYNAMIC!>%=<!> 1\n\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!> <!DEBUG_INFO_DYNAMIC!>+=<!> 1\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!> <!DEBUG_INFO_DYNAMIC!>-=<!> 1\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!> <!DEBUG_INFO_DYNAMIC!>*=<!> 1\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!> <!DEBUG_INFO_DYNAMIC!>/=<!> 1\n    <!DEBUG_INFO_DYNAMIC!>d[1]<!> <!DEBUG_INFO_DYNAMIC!>%=<!> 1\n}\n\n"
        },
        {
            "code": "fun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.test() {\n    val v1 = foo()\n    v1.isDynamic() // to check that anything is resolvable\n\n    val v2 = foo(1)\n    v2.isDynamic() // to check that anything is resolvable\n\n    val v3 = foo(1, \"\")\n    v3.isDynamic() // to check that anything is resolvable\n\n    val v4 = foo<String>()\n    v4.isDynamic() // to check that anything is resolvable\n\n    val v5 = foo\n    v5.isDynamic() // to check that anything is resolvable\n\n    foo = 1\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.DynamicExtension\nfun dynamic.onDynamicFun() = 1\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.DynamicExtension\nvar dynamic.onDynamicProperty\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\n\nfun test(d: dynamic, a: Any?) {\n    eatT<Int>(d.onDynamicFun())\n    eatT<String>(d.onDynamicProperty)\n    d.onDynamicProperty = \"\"\n    eatT<Iterator<*>>(d.iterator())\n\n    for (item in d) {\n        println(item)\n    }\n\n    a.<!UNRESOLVED_REFERENCE!>onDynamicFun<!>()\n    a.<!UNRESOLVED_REFERENCE!>onDynamicProperty<!>\n}\n\nfun <T> eatT(<!UNUSED_PARAMETER!>t<!>: T) {}"
        },
        {
            "code": "object X1\nobject X2\n\nclass Inv<T>\n\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.foo() = X1\nfun <T> Inv<T>.foo() = X2\n\nfun test(): X2 = Inv<Any>().foo()\n"
        },
        {
            "code": "// !DIAGNOSTICS: -REDUNDANT_NULLABLE\n\nfun test(d: Any, dl: Collection<dynamic>) {\n    d as <!DYNAMIC_NOT_ALLOWED!>dynamic<!>\n    d as <!DYNAMIC_NOT_ALLOWED!>dynamic?<!>\n\n    d as? <!DYNAMIC_NOT_ALLOWED!>dynamic<!>\n    d as? <!DYNAMIC_NOT_ALLOWED!>dynamic?<!>\n\n    <!USELESS_IS_CHECK!>d is <!DYNAMIC_NOT_ALLOWED!>dynamic<!><!>\n    <!USELESS_IS_CHECK!>d is <!DYNAMIC_NOT_ALLOWED!>dynamic?<!><!>\n\n    <!USELESS_IS_CHECK!>d !is <!DYNAMIC_NOT_ALLOWED!>dynamic<!><!>\n    <!USELESS_IS_CHECK!>d !is <!DYNAMIC_NOT_ALLOWED!>dynamic?<!><!>\n\n    when (d) {\n        <!USELESS_IS_CHECK!>is <!DYNAMIC_NOT_ALLOWED!>dynamic<!><!> -> {}\n        <!USELESS_IS_CHECK!>is <!DUPLICATE_LABEL_IN_WHEN, DYNAMIC_NOT_ALLOWED!>dynamic?<!><!> -> {}\n        <!USELESS_IS_CHECK!>!is <!DYNAMIC_NOT_ALLOWED!>dynamic<!><!> -> {}\n        <!USELESS_IS_CHECK!>!is <!DUPLICATE_LABEL_IN_WHEN, DYNAMIC_NOT_ALLOWED!>dynamic?<!><!> -> {}\n    }\n\n    dl as List<dynamic>\n    <!USELESS_IS_CHECK!>dl is List<dynamic><!>\n\n    when (dl) {\n        <!USELESS_IS_CHECK!>is List<dynamic><!> -> {}\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo(dn: dynamic<!REDUNDANT_NULLABLE!>?<!>, d: dynamic, dnn: dynamic<!REDUNDANT_NULLABLE!>?<!><!REDUNDANT_NULLABLE!>?<!>) {\n    val a1 = dn.foo()\n    a1.isDynamic()\n\n    val a2 = dn?.foo()\n    a2.isDynamic()\n\n    val a3 = dn!!.foo()\n    a3.isDynamic()\n\n    d.foo()\n    d?.foo()\n    d!!.foo()\n}"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\nfun test() {\n    v()\n    v(1)\n    v(1, \"\")\n}\n\nfun v(vararg d: dynamic) {\n    for (dd in d) {\n        dd.<!DEBUG_INFO_DYNAMIC!>foo<!>()\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nexternal val x: dynamic\n\nvar y: Any? by <!PROPERTY_DELEGATION_BY_DYNAMIC!>x<!>\n\nfun foo() {\n    val a: Any by <!PROPERTY_DELEGATION_BY_DYNAMIC!>x<!>\n}\n\nclass C {\n    val a: dynamic by <!PROPERTY_DELEGATION_BY_DYNAMIC!>x<!>\n}\n\nclass A {\n    operator fun provideDelegate(host: Any?, p: Any): dynamic = TODO(\"\")\n}\n\nval z: Any? by <!PROPERTY_DELEGATION_BY_DYNAMIC!>A()<!>\n\nclass DynamicHandler {\n    operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): dynamic = 23\n}\n\nclass B {\n    val x: dynamic by DynamicHandler()\n}"
        },
        {
            "code": "// !DIAGNOSTICS:-USELESS_CAST\n// !MARK_DYNAMIC_CALLS\n\nfun test(d: dynamic) {\n    d.<!DEBUG_INFO_DYNAMIC!>onAny<!>()\n    d?.<!DEBUG_INFO_DYNAMIC!>onAny<!>()\n    run {\n        d!!.<!DEBUG_INFO_DYNAMIC!>onAny<!>()\n    }\n\n    d.<!DEBUG_INFO_DYNAMIC!>onAny<!>(1)\n\n    d.<!DEBUG_INFO_DYNAMIC!>onNullableAny<!>()\n    d.<!DEBUG_INFO_DYNAMIC!>onString<!>()\n\n    d.<!DEBUG_INFO_DYNAMIC!>onDynamic<!>()\n    d?.<!DEBUG_INFO_DYNAMIC!>onDynamic<!>()\n\n    (d as String).onString()\n    (d as Any).onAny()\n    (d as Any?).onNullableAny()\n    (d as Any).<!UNRESOLVED_REFERENCE!>onDynamic<!>()\n}\n\nfun Any.onAny() {}\nfun Any?.onNullableAny() {}\nfun String.onString() {}\nfun <!DYNAMIC_RECEIVER_NOT_ALLOWED!>dynamic<!>.onDynamic() {}\n\nclass C {\n    fun test(d: dynamic) {\n        d.<!DEBUG_INFO_DYNAMIC!>member<!>()\n        d.<!DEBUG_INFO_DYNAMIC!>memberExtension<!>()\n    }\n\n    fun member() {}\n    fun Any.memberExtension() {}\n}"
        },
        {
            "code": "@file:JsModule(\"foo\")\npackage foo\n\n@JsModule(\"A\")\nexternal class <!NESTED_JS_MODULE_PROHIBITED!>A<!> {\n    class Nested\n}\n\n@JsModule(\"B\")\nexternal <!NESTED_JS_MODULE_PROHIBITED!>object B<!>\n\n<!NESTED_JS_MODULE_PROHIBITED!>@JsModule(\"foo\")\nexternal fun foo(): Int<!>\n\n<!NESTED_JS_MODULE_PROHIBITED!>@JsModule(\"bar\")\nexternal val bar: Int<!>\n\n<!NESTED_JS_MODULE_PROHIBITED!>@JsNonModule\nexternal val baz: Int<!>"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage foo\n\nimport kotlin.js.*\n\n@JsModule(\"A\")\nexternal object A {\n    fun f(): Int\n\n    val g: Int\n}\n\n@JsNonModule\nexternal open class B {\n    fun foo(): Int\n}\n\n// MODULE: m2(m1)\n// MODULE_KIND: UMD\n// FILE: c.kt\npackage bar\n\nimport foo.*\n\nfun box() {\n    A.<!CALL_FROM_UMD_MUST_BE_JS_MODULE_AND_JS_NON_MODULE!>f<!>()+A.<!CALL_FROM_UMD_MUST_BE_JS_MODULE_AND_JS_NON_MODULE!>g<!>\n    <!CALL_FROM_UMD_MUST_BE_JS_MODULE_AND_JS_NON_MODULE!>B<!>()\n}"
        },
        {
            "code": "package foo\n\n<!JS_MODULE_PROHIBITED_ON_VAR!>@JsModule(\"bar\")\nexternal var bar: Int<!> = definedExternally\n\n<!JS_MODULE_PROHIBITED_ON_VAR!>@JsNonModule\nexternal var baz: Int<!> = definedExternally"
        },
        {
            "code": "package foo\n\n@JsModule(\"A\")\nclass <!JS_MODULE_PROHIBITED_ON_NON_NATIVE!>A<!>\n\n@JsModule(\"B\")\n<!JS_MODULE_PROHIBITED_ON_NON_NATIVE!>object B<!>\n\n<!JS_MODULE_PROHIBITED_ON_NON_NATIVE!>@JsModule(\"foo\")\nfun foo()<!> = 23\n\n<!JS_MODULE_PROHIBITED_ON_NON_NATIVE!>@JsModule(\"bar\")\nval bar<!> = 42\n\n<!JS_MODULE_PROHIBITED_ON_NON_NATIVE!>@JsNonModule\nval baz<!> = 99"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage foo\n\nimport kotlin.js.*\n\n@JsModule(\"A\")\nexternal object A {\n    fun f(): Int\n\n    val g: Int\n}\n\n@JsModule(\"B\")\nexternal open class B {\n    fun foo(): Int\n\n    class Nested\n}\n\n@JsModule(\"bar\")\nexternal fun bar(): Unit\n\n// MODULE: m2(m1)\n// FILE: b.kt\n// TODO: it's hard to test @JsNonModule on file from an external module\n@file:JsModule(\"foo\")\npackage foo\n\nexternal fun baz(): Unit\n\n// FILE: c.kt\npackage bar\n\nimport foo.*\n\nfun box() {\n    A.<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>f<!>()+A.<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>g<!>\n    <!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>B<!>()\n    <!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>bar<!>()\n    <!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>baz<!>()\n\n    println(::<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>bar<!>.name)\n    println(::<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>baz<!>.name)\n    println(<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>A<!>::f.name)\n\n    B.<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>Nested<!>()\n\n    boo<<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>B?<!>>(null)\n    <!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>boo<!>(null as B?)\n    boo<<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>B.Nested?<!>>(null)\n\n    println(<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>B::class<!>)\n    println(<!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>B.Nested::class<!>)\n}\n\nexternal class DerivedB : <!CALL_TO_JS_MODULE_WITHOUT_MODULE_SYSTEM!>B<!>\n\ninline fun <reified T> boo(x: T) {\n    println(\"${T::class.simpleName}: $x\")\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage foo\n\nimport kotlin.js.*\n\n@JsNonModule\nexternal object A {\n    fun f(): Int\n\n    val g: Int\n}\n\n@JsNonModule\nexternal open class B {\n    fun foo(): Int\n\n    class Nested\n}\n\n@JsNonModule\nexternal fun bar(): Unit\n\n// MODULE: m2(m1)\n// MODULE_KIND: AMD\n// TODO: it's hard to test @JsNonModule on file from an external module\n// FILE: c.kt\npackage bar\n\nimport foo.*\n\nfun box() {\n    A.<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>f<!>()+A.<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>g<!>\n    <!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>B<!>()\n    <!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>bar<!>()\n    B.<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>Nested<!>()\n\n    println(::<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>bar<!>.name)\n    println(<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>A<!>::f.name)\n\n    boo<<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>B?<!>>(null)\n    <!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>boo<!>(null as B?)\n    boo<<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>B.Nested?<!>>(null)\n\n    println(<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>B::class<!>)\n    println(<!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>B.Nested::class<!>)\n}\n\nexternal class DerivedB : <!CALL_TO_JS_NON_MODULE_WITH_MODULE_SYSTEM!>B<!>\n\ninline fun <reified T> boo(x: T) {\n    println(\"${T::class.simpleName}: $x\")\n}"
        },
        {
            "code": "inline fun <T, reified K> bar() {}\n\nfun foo() {\n    bar<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>()\n}"
        },
        {
            "code": "import kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nsuspend fun dummy(): String = <!DEPRECATION_ERROR!>suspendCoroutine<!> {\n    it.resume(\"OK\")\n}"
        },
        {
            "code": "@file:JsModule(\"lib\")\n\nclass <!NON_EXTERNAL_DECLARATION_IN_INAPPROPRIATE_FILE!>A<!> {\n    class B\n\n    fun bar() {}\n}\n\n<!NON_EXTERNAL_DECLARATION_IN_INAPPROPRIATE_FILE!>fun foo()<!> = \"OK\""
        },
        {
            "code": "val a = \"1\"\n\nfun nonConst(): String = \"1\"\n\nfun test() {\n    val b = \"b\"\n\n    js(a)\n    js((b))\n    js((\"c\"))\n    js(<!CONSTANT_EXPECTED_TYPE_MISMATCH, JSCODE_ARGUMENT_SHOULD_BE_CONSTANT!>3<!>)\n    js(<!JSCODE_ARGUMENT_SHOULD_BE_CONSTANT, TYPE_MISMATCH!>3 + 2<!>)\n    js(<!CONSTANT_EXPECTED_TYPE_MISMATCH, JSCODE_ARGUMENT_SHOULD_BE_CONSTANT!>1.0f<!>)\n    js(<!CONSTANT_EXPECTED_TYPE_MISMATCH, JSCODE_ARGUMENT_SHOULD_BE_CONSTANT!>true<!>)\n    js(\"$a\")\n    js(\"${1}\")\n    js(\"$b;\")\n    js(\"${b}bb\")\n    js(a + a)\n    js(\"a\" + \"a\")\n    js(\"ccc\")\n\n    js(<!JSCODE_ARGUMENT_SHOULD_BE_CONSTANT!>nonConst()<!>)\n}"
        },
        {
            "code": "fun main(): Unit {\n    js(\"var a =<!JSCODE_WARNING!> 08<!>;\")\n\n    js(\"\"\"var a =<!JSCODE_WARNING!>\n\n        08<!>;\"\"\")\n\n    val code = \"var a = 08;\"\n    js(<!JSCODE_WARNING!>code<!>)\n}"
        },
        {
            "code": "fun test() {\n    js(<!JSCODE_NO_JAVASCRIPT_PRODUCED!>\"\"<!>)\n    js(<!JSCODE_NO_JAVASCRIPT_PRODUCED!>\" \"<!>)\n    js(<!JSCODE_NO_JAVASCRIPT_PRODUCED!>\"\"\"\n               \"\"\"<!>)\n\n    val empty = \"\"\n    js(<!JSCODE_NO_JAVASCRIPT_PRODUCED!>empty<!>)\n\n    val whitespace = \"  \"\n    js(<!JSCODE_NO_JAVASCRIPT_PRODUCED!>whitespace<!>)\n\n    val multiline = \"\"\"\n    \"\"\"\n    js(<!JSCODE_NO_JAVASCRIPT_PRODUCED!>multiline<!>)\n}"
        },
        {
            "code": "val code = \"\"\"\n    var s = \"hello\"\n    + );\n\"\"\"\n\nfun main(): Unit {\n    js(\"var<!JSCODE_ERROR!> =<!> 10;\")\n\n    js(\"\"\"var<!JSCODE_ERROR!> =<!> 10;\"\"\")\n\n    js(\"\"\"var<!JSCODE_ERROR!>\n      =<!> 777;\n    \"\"\")\n\n    js(\"\"\"\n    var<!JSCODE_ERROR!> =<!> 777;\n    \"\"\")\n\n    js(<!JSCODE_ERROR!>\"var \" + \" = \" + \"10;\"<!>)\n\n    val n = 10\n    js(<!JSCODE_ERROR!>\"var = $n;\"<!>)\n\n    js(<!JSCODE_ERROR!>code<!>)\n}\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\nexternal inline class <!WRONG_EXTERNAL_DECLARATION!>C(<!EXTERNAL_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER!>val a: Int<!>)<!> {\n    fun foo()\n}\n\n<!WRONG_MODIFIER_TARGET!>inline<!> external enum class <!WRONG_EXTERNAL_DECLARATION!>E<!> {\n    A\n}\n"
        },
        {
            "code": "external annotation class <!WRONG_EXTERNAL_DECLARATION!>A(val x: Int)<!>\n\nval x: Int\n    <!WRONG_EXTERNAL_DECLARATION!>external get()<!> = definedExternally\n\nclass B\n\n<!WRONG_EXTERNAL_DECLARATION!>val B.x: Int<!>\n    <!WRONG_EXTERNAL_DECLARATION!>external get()<!> = definedExternally\n\nclass C {\n    val a: Int\n        <!WRONG_EXTERNAL_DECLARATION!>external get()<!> = definedExternally\n}\n\nexternal class D {\n    val a: Int\n        <!WRONG_EXTERNAL_DECLARATION!>external get()<!> = definedExternally\n}\n\nexternal data class <!WRONG_EXTERNAL_DECLARATION!>E(val x: Int)<!>"
        },
        {
            "code": "external interface I\n\nexternal object O : I\n\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: Any): String = \"\"\n\n    operator fun setValue(thisRef: Any?, property: Any, value: String) {}\n}\n\nexternal class A : <!EXTERNAL_DELEGATION!>I by O<!> {\n    val prop <!EXTERNAL_DELEGATION!>by Delegate()<!>\n\n    var mutableProp <!EXTERNAL_DELEGATION!>by Delegate()<!>\n}\n\nexternal val topLevelProp <!EXTERNAL_DELEGATION!>by Delegate()<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -DEBUG_INFO_MISSING_UNRESOLVED\n\nexternal open class Base(x: Int) {\n    constructor(x: String) : <!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>this<!>(23)\n\n    constructor(x: String, y: String) : <!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>this<!>(\"\")\n}\n\nexternal open class Derived1() : Base<!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>(23)<!> {\n    constructor(x: Byte) : <!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>super<!>(23)\n\n    constructor(x: String) : <!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>super<!>(\"\")\n\n    constructor(x: String, y: String) : <!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>super<!>(\"\")\n}\n\nexternal open class Derived2() : Base<!EXTERNAL_DELEGATED_CONSTRUCTOR_CALL!>(\"\")<!>\n\n"
        },
        {
            "code": "external interface I {\n    <!NON_ABSTRACT_MEMBER_OF_EXTERNAL_INTERFACE!>fun foo(): Unit<!> = definedExternally\n\n    val a: Int?\n        get() = definedExternally\n\n    var b: String?\n        get() = definedExternally\n        set(value) = definedExternally\n\n    <!NON_ABSTRACT_MEMBER_OF_EXTERNAL_INTERFACE!>val c: Int<!>\n        get() = definedExternally\n\n    <!NON_ABSTRACT_MEMBER_OF_EXTERNAL_INTERFACE!>var d: String<!>\n        get() = definedExternally\n        set(value) = definedExternally\n\n    var e: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}"
        },
        {
            "code": "external class C {\n    inner class <!WRONG_EXTERNAL_DECLARATION!>Inner<!>\n}\n\nexternal enum class E {\n    X;\n\n    inner class <!WRONG_EXTERNAL_DECLARATION!>Inner<!>\n}\n"
        },
        {
            "code": "open class A\n\ninterface I\n\nexternal open class B\n\nexternal class <!EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE!>C<!> : A\n\nexternal class <!EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE!>D<!> : B, I\n\nexternal interface <!EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE!>K<!> : I\n\nexternal enum class E {\n    X\n}\n\nexternal enum class <!EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE!>F<!> : I {\n    X\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\n// FILE: uint.kt\n\npackage kotlin\n\ninline class UInt(private val i: Int)\n\n// FILE: test.kt\n\ninline class SomeIC(val a: Int)\n\nexternal val l: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\nexternal val ll\n    get(): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!> = definedExternally\n\nexternal var r: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\nexternal var rr: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    get() = definedExternally\n    set(<!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>v: SomeIC<!>) { definedExternally }\n\nexternal fun foo(): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\nexternal fun foo(<!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\nexternal fun foo(a: Int, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\nexternal fun foo(a: Int, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!><!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> args: SomeIC<!>)\nexternal fun foo(a: Int, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>ui: UInt<!>, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>vararg args: UInt<!>)\n\nexternal class CC(\n    <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>a: SomeIC<!>,\n    <!EXTERNAL_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER, INLINE_CLASS_IN_EXTERNAL_DECLARATION!>val b: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!><!>,\n    <!EXTERNAL_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER, INLINE_CLASS_IN_EXTERNAL_DECLARATION!>var c: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!><!>\n) {\n    val l: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    var r: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\n    fun foo(): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    fun foo(<!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    fun foo(a: Int, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\n    class N(\n        <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>a: SomeIC<!>,\n        <!EXTERNAL_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER, INLINE_CLASS_IN_EXTERNAL_DECLARATION!>val b: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!><!>,\n        <!EXTERNAL_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER, INLINE_CLASS_IN_EXTERNAL_DECLARATION!>var c: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!><!>\n    ) {\n        val l: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n        var r: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\n        fun foo(): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n        fun foo(<!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n        fun foo(a: Int, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    }\n}\n\nexternal interface EI {\n    val l: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    var r: <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n\n    fun foo(): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    fun foo(<!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n    fun foo(a: Int, <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>c: SomeIC<!>): <!INLINE_CLASS_IN_EXTERNAL_DECLARATION!>SomeIC<!>\n}"
        },
        {
            "code": "external fun foo(<!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>f: Int.() -> Int<!>)\n\nexternal fun bar(<!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>vararg f: Int.() -> Int<!>)\n\nexternal fun baz(): <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!>\n\nexternal val prop: <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!>\n\nexternal var prop2: <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!>\n\nexternal val propGet\n    get(): <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!> = definedExternally\n\nexternal var propSet\n    get(): <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!> = definedExternally\n    set(<!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>v: Int.() -> Int<!>) = definedExternally\n\nexternal class A(<!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>f: Int.() -> Int<!>)\n\nexternal data class <!WRONG_EXTERNAL_DECLARATION!>B(\n        <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>val a: <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!><!>,\n        <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>var b: <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!><!>\n)<!> {\n    val c: <!EXTENSION_FUNCTION_IN_EXTERNAL_DECLARATION!>Int.() -> Int<!>\n}"
        },
        {
            "code": "external interface I\n\nexternal interface J\n\nfun box(a: Any) = when (a) {\n    <!CANNOT_CHECK_FOR_EXTERNAL_INTERFACE!>is I<!> -> 0\n    <!CANNOT_CHECK_FOR_EXTERNAL_INTERFACE!>!is J<!> -> 1\n    else -> 2\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline fun <reified T> foo(x: T) {\n    println(x)\n}\n\nexternal interface I\n\nexternal class C : I\n\noperator inline fun <reified T> C.plus(other: T) = this\n\nfun bar() {\n    foo(C())\n\n    val c: I = C()\n    <!EXTERNAL_INTERFACE_AS_REIFIED_TYPE_ARGUMENT!>foo(c)<!>\n    foo<<!EXTERNAL_INTERFACE_AS_REIFIED_TYPE_ARGUMENT!>I<!>>(C())\n\n    <!EXTERNAL_INTERFACE_AS_REIFIED_TYPE_ARGUMENT!>C() + c<!>\n}"
        },
        {
            "code": "external interface I\n\nfun box() {\n    println(<!EXTERNAL_INTERFACE_AS_CLASS_LITERAL!>I::class<!>)\n}"
        },
        {
            "code": "external interface I\n\nfun box(a: Any, b: Any): Pair<I, I?> {\n    return Pair(<!UNCHECKED_CAST_TO_EXTERNAL_INTERFACE!>a as I<!>, <!UNCHECKED_CAST_TO_EXTERNAL_INTERFACE!>b as? I<!>)\n}"
        },
        {
            "code": "external interface I\n\nfun box(a: Any, b: Any): Boolean {\n    return <!CANNOT_CHECK_FOR_EXTERNAL_INTERFACE!>a is I<!> && <!CANNOT_CHECK_FOR_EXTERNAL_INTERFACE!>b !is I<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nclass A {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun get(a: String): Any?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun take(a: Number): String?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun foo(a: Double): String?<!> = null\n\n    companion object {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun get(a: String): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun take(a: Number): String?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun foo(a: Double): String?<!> = null\n    }\n}\n\nclass B {\n    <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n    val foo = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n    object Obj1 {}\n\n    companion object {\n        <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n        val foo = 0\n\n        <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n        object Obj2 {}\n    }\n}\n\nclass C {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun Int.get(a: String): Int?<!> = 1\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun Int.get2(a: Number): String?<!> = \"OK\"\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun Int.get3(a: Int): String?<!> = \"OK\"\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n    fun get(): Any?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int)<!> {}\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!><!> = 0\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n    fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = \"foo\"<!>): Int?<!> = 0\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nfun foo() {\n    @nativeGetter\n    fun Int.get(a: String): Int? = 1\n\n    @nativeGetter\n    fun Int.get2(a: Number): String? = \"OK\"\n\n    @nativeGetter\n    fun Int.get3(a: Int): String? = \"OK\"\n\n    @nativeGetter\n    fun Int.get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>): Int? = 1\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n    fun Int.get2(): String?<!> = \"OK\"\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n    fun Int.get3(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>, b: Int, c: Any?): String?<!> = \"OK\"\n\n    @nativeGetter\n    fun Any.foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Int = 1<!>): Any? = \"OK\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nexternal class A {\n    @nativeGetter\n    fun get(a: String): Any? = definedExternally\n\n    @nativeGetter\n    fun take(a: Number): String? = definedExternally\n\n    @nativeGetter\n    fun foo(a: Double): String? = definedExternally\n\n    companion object {\n        @nativeGetter\n        fun get(a: String): Any? = definedExternally\n\n        @nativeGetter\n        fun take(a: Number): String? = definedExternally\n\n        @nativeGetter\n        fun foo(a: Double): String? = definedExternally\n    }\n}\n\nexternal class B {\n    <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n    val foo: Int = definedExternally\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n    object Obj1 {}\n\n    companion object {\n        <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n        val foo: Int = definedExternally\n\n        <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n        object Obj2 {}\n    }\n}\n\nexternal class C {\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n    fun get(): Any?<!> = definedExternally\n\n    @nativeGetter\n    fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any? = definedExternally\n\n    @nativeGetter\n    fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int) { definedExternally }\n\n    @nativeGetter\n    fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!> = definedExternally\n\n    @nativeGetter\n    fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = definedExternally<!>): Int? = definedExternally\n\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\n<!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\nfun toplevelFun(): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Any<!><!> = 0\n\n<!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\nval toplevelVal = 0\n\n<!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\nclass Foo {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nfun foo() {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n    fun toplevelFun(): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Any<!><!> = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n    val toplevelVal = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n    class Foo {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nfun foo() {\n    class A {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun get(a: String): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun take(a: Number): String?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun foo(a: Double): String?<!> = null\n    }\n\n    class B {\n        <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n        val foo = 0\n    }\n\n    class C {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun Int.get(a: String): Int?<!> = 1\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun Int.get2(a: Number): String?<!> = \"OK\"\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun Int.get3(a: Int): String?<!> = \"OK\"\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n        fun get(): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int)<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!><!> = 0\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n        fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Int = 0<!>): Int?<!> = 0\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nexternal class A {\n    class B {\n        class A {\n            @nativeGetter\n            fun get(a: String): Any? = definedExternally\n\n            @nativeGetter\n            fun take(a: Number): String? = definedExternally\n\n            @nativeGetter\n            fun foo(a: Double): String? = definedExternally\n\n            companion object {\n                @nativeGetter\n                fun get(a: String): Any? = definedExternally\n\n                @nativeGetter\n                fun take(a: Number): String? = definedExternally\n\n                @nativeGetter\n                fun foo(a: Double): String? = definedExternally\n            }\n        }\n\n        class B {\n            <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n            val foo: Int = definedExternally\n\n            <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n            object Obj1 {}\n\n            companion object {\n                <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n                val foo: Int = definedExternally\n\n                <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n                object Obj2 {}\n            }\n        }\n\n        class C {\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n            fun get(): Any?<!> = definedExternally\n\n            @nativeGetter\n            fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any? = definedExternally\n\n            @nativeGetter\n            fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int) { definedExternally }\n\n            @nativeGetter\n            fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!> = definedExternally\n\n            @nativeGetter\n            fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Number = definedExternally<!>): Int? = definedExternally\n        }\n\n        object obj {\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n            fun get(): Any?<!> = definedExternally\n\n            @nativeGetter\n            fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any? = definedExternally\n\n            @nativeGetter\n            fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int) { definedExternally }\n\n            @nativeGetter\n            fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!> = definedExternally\n\n            @nativeGetter\n            fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = definedExternally<!>): Int? = definedExternally\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nclass A {\n    class B {\n        class A {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun get(a: String): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun take(a: Number): String?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun foo(a: Double): String?<!> = null\n\n            companion object {\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n                fun get(a: String): Any?<!> = null\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n                fun take(a: Number): String?<!> = null\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n                fun foo(a: Double): String?<!> = null\n            }\n        }\n\n        class B {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun Int.get(a: String): Int?<!> = 1\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun Int.get2(a: Number): String?<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun Int.get3(a: Int): String?<!> = \"OK\"\n\n            <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n            val foo = 0\n\n            <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n            object Obj1 {}\n\n            companion object {\n                <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n                val foo = 0\n\n                <!WRONG_ANNOTATION_TARGET!>@nativeGetter<!>\n                object Obj2 {}\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n                fun Int.get(a: String): Int?<!> = 1\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n                fun Int.get2(a: Number): String?<!> = \"OK\"\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n                fun Int.get3(a: Int): String?<!> = \"OK\"\n            }\n        }\n\n        class C {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n            fun get(): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!><!> = 0\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = \"foo\"<!>): Int?<!> = 0\n        }\n\n        object obj {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n            fun get(): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!><!> = 0\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Double = 0.0<!>): Int?<!> = 0\n        }\n\n        val anonymous = object {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\n            fun get(): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>foo<!>(a: Int)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun bar(a: String): <!NATIVE_GETTER_RETURN_TYPE_SHOULD_BE_NULLABLE!>Int<!><!> = 0\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeGetter\n            fun baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = \"foo\"<!>): Int?<!> = 0\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\n@nativeGetter\nfun Int.get(a: String): Int? = 1\n\n@nativeGetter\nfun Int.get2(a: Number): String? = \"OK\"\n\n@nativeGetter\nfun Int.get3(a: Int): String? = \"OK\"\n\n@nativeGetter\nfun Int.baz(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Int = 0<!>): String? = \"OK\"\n\n@nativeGetter\nfun Int.get(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>): Int? = 1\n\n<!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\nfun Int.get2(): String?<!> = \"OK\"\n\n<!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeGetter\nfun Int.get3(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>, b: Int, c: Any?): String?<!> = \"OK\"\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n// TODO: should we disable NOTHING_TO_INLINE in JS backend?\n// TODO: uncomment declarations in case we decide to implement KT-14031\n\nexternal class C {\n    <!WRONG_EXTERNAL_DECLARATION!>private fun a(): Int<!>\n\n    <!WRONG_EXTERNAL_DECLARATION!>private val b: String<!>\n\n    <!WRONG_EXTERNAL_DECLARATION!>private var c: Float<!>\n\n    <!WRONG_EXTERNAL_DECLARATION!>private var d: Float<!>\n        get\n        set\n\n    var e: Float\n        get\n        <!WRONG_EXTERNAL_DECLARATION!>private set<!>\n\n    /*\n    private inline fun inline_a(): Int = 23\n\n    private inline val inline_prop: Int\n        get() = 42\n    */\n}\n\nexternal object O {\n    <!WRONG_EXTERNAL_DECLARATION!>private fun a(): Int<!>\n\n    <!WRONG_EXTERNAL_DECLARATION!>private val b: String<!>\n\n    <!WRONG_EXTERNAL_DECLARATION!>private var c: Float<!>\n\n    <!WRONG_EXTERNAL_DECLARATION!>private var d: Float<!>\n        get\n        set\n\n    /*\n    private inline fun inline_a(): Int = 23\n\n    private inline val inline_prop: Int\n        get() = 42\n    */\n}\n\nexternal class Outer {\n    class Inner {\n        <!WRONG_EXTERNAL_DECLARATION!>private fun a(): Int<!>\n\n        <!WRONG_EXTERNAL_DECLARATION!>private val b: String<!>\n\n        <!WRONG_EXTERNAL_DECLARATION!>private var c: Float<!>\n\n        <!WRONG_EXTERNAL_DECLARATION!>private var d: Float<!>\n            get\n            set\n\n        /*\n        private inline fun inline_a(): Int = 23\n\n        private inline val inline_prop: Int\n            get() = 42\n        */\n    }\n\n    private class <!WRONG_EXTERNAL_DECLARATION!>PrivateInner<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n\n<!INLINE_EXTERNAL_DECLARATION!>inline external fun foo(): Unit<!>\n\ninline external val bar: Int\n    <!INLINE_EXTERNAL_DECLARATION!>get()<!> = definedExternally\n\nexternal val baz: Int\n    <!INLINE_EXTERNAL_DECLARATION!>inline get()<!> = definedExternally\n\nexternal class A {\n    <!INLINE_EXTERNAL_DECLARATION!>inline fun foo(): Unit<!>\n\n    inline val bar: Int\n        <!INLINE_EXTERNAL_DECLARATION!>get()<!> = definedExternally\n\n    val baz: Int\n        <!INLINE_EXTERNAL_DECLARATION!>inline get()<!> = definedExternally\n}"
        },
        {
            "code": "class A\n\n<!WRONG_EXTERNAL_DECLARATION!>external fun A.foo(): Unit<!> = definedExternally\n\n<!WRONG_EXTERNAL_DECLARATION!>external var A.bar: String<!>\n    get() = definedExternally\n    set(value) = definedExternally\n\n<!WRONG_EXTERNAL_DECLARATION!>external val A.baz: String<!>\n    get() = definedExternally"
        },
        {
            "code": "external class A {\n    <!EXTERNAL_ANONYMOUS_INITIALIZER!>init {\n        definedExternally\n    }<!>\n}"
        },
        {
            "code": "object O\n\nclass TopLevel {\n    external class <!NESTED_EXTERNAL_DECLARATION!>A<!>\n\n    class B\n\n    fun foo() = 23\n\n    <!NESTED_EXTERNAL_DECLARATION!>external fun bar(): Int<!>\n\n    val x = \"a\"\n\n    <!NESTED_EXTERNAL_DECLARATION!>external val y: String<!>\n\n    val O.u: String get() = \"O.u\"\n}\n\nexternal class TopLevelNative {\n    external class <!NESTED_EXTERNAL_DECLARATION!>A<!>\n\n    class B\n\n    fun foo(): Int = definedExternally\n\n    <!NESTED_EXTERNAL_DECLARATION!>external fun bar(): Int<!>\n\n    val x: String = definedExternally\n\n    <!NESTED_EXTERNAL_DECLARATION!>external val y: String<!>\n}\n\nfun topLevelFun() {\n    external class <!NESTED_EXTERNAL_DECLARATION!>A<!>\n\n    class B\n\n    fun foo() = 23\n\n    <!NESTED_EXTERNAL_DECLARATION!>external fun bar(): Int<!>\n}\n\n"
        },
        {
            "code": "open external class A {\n    open fun f(x: Int = definedExternally)\n}\n\nclass B : A() {\n    <!OVERRIDING_EXTERNAL_FUN_WITH_OPTIONAL_PARAMS!>override fun f(x: Int)<!> {}\n}\n\nclass BB : A()\n\nexternal class C : A {\n    override fun f(x: Int)\n}\n\n\nexternal interface I {\n    fun f(x: Int = definedExternally)\n}\n\ninterface J {\n    fun f(x: Int = 23)\n}\n\ninterface II {\n    fun f(x: Int)\n}\n\ninterface IIJ : II, J\n\nopen external class D {\n    open fun f(x: Int)\n}\n\nclass E : D() {\n    override fun f(x: Int) { }\n}\n\nclass F : D(), I {\n    <!OVERRIDING_EXTERNAL_FUN_WITH_OPTIONAL_PARAMS!>override fun f(x: Int)<!> {}\n}\n\nexternal class G : D, I {\n    override fun f(x: Int)\n}\n\nopen class X {\n    fun f(<!UNUSED_PARAMETER!>x<!>: Int) {}\n}\n\nopen external class XE {\n    fun f(x: Int)\n}\n\nclass <!OVERRIDING_EXTERNAL_FUN_WITH_OPTIONAL_PARAMS_WITH_FAKE!>Y<!> : X(), I\n\nclass <!OVERRIDING_EXTERNAL_FUN_WITH_OPTIONAL_PARAMS_WITH_FAKE!>YY<!> : A(), II\n\nexternal class YE: XE, I\n\nclass Z : X(), J"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nclass A {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun set(a: String, v: Any?): Any?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun put(a: Number, v: String)<!> {}\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun foo(a: Int, v: String)<!> {}\n\n    companion object {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun set(a: String, v: Any?): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun put(a: Number, v: String)<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun foo(a: Int, v: String)<!> {}\n    }\n}\n\nclass B {\n    <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n    val foo = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n    object Obj1 {}\n\n    companion object {\n        <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n        val foo = 0\n\n        <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n        object Obj2 {}\n    }\n}\n\nclass C {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun Int.set(a: String, v: Int)<!> {}\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set2<!>(a: Number, v: String?)<!> = \"OK\"\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set3<!>(a: Double, v: String?)<!> = \"OK\"\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun set(): Any?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun set(a: String, v: Any, v2: Any)<!> {}\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?)<!> {}\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n    fun foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = \"0.0\"<!>, v: String)<!> = \"OK\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nfun foo() {\n    @nativeSetter\n    fun Int.set(a: String, v: Int) {}\n\n    @nativeSetter\n    fun Int.set2(a: Number, v: String?): Any? = null\n\n    @nativeSetter\n    fun Int.set3(a: Double, v: String) = \"OK\"\n\n    @nativeSetter\n    fun Int.set4(a: Double, v: String): Any = 1\n\n    @nativeSetter\n    fun Int.set5(a: Double, v: String): CharSequence = \"OK\"\n\n    @nativeSetter\n    fun Int.set6(a: Double, v: String): <!NATIVE_SETTER_WRONG_RETURN_TYPE!>Number<!> = 1\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun Int.set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>): Int?<!> = 1\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun Int.set2(): String?<!> = \"OK\"\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun Int.set3(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>, b: Int, c: Any?)<!> {}\n\n    @nativeSetter\n    fun Any.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>foo<!>(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Double = 0.0<!>, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String? = null<!>) = \"OK\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nexternal class A {\n    @nativeSetter\n    fun set(a: String, v: Any?): Any? = definedExternally\n\n    @nativeSetter\n    fun put(a: Number, v: String) { definedExternally }\n\n    @nativeSetter\n    fun foo(a: Int, v: String) { definedExternally }\n\n    @nativeSetter\n    fun set4(a: Double, v: String): Any = definedExternally\n\n    @nativeSetter\n    fun set5(a: Double, v: String): CharSequence = definedExternally\n\n    companion object {\n        @nativeSetter\n        fun set(a: String, v: Any?): Any? = definedExternally\n\n        @nativeSetter\n        fun put(a: Number, v: String) { definedExternally }\n\n        @nativeSetter\n        fun foo(a: Int, v: String) { definedExternally }\n\n        @nativeSetter\n        fun set4(a: Double, v: String): Any = definedExternally\n\n        @nativeSetter\n        fun set5(a: Double, v: String): CharSequence = definedExternally\n    }\n}\n\nexternal class B {\n    <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n    val foo: Int = definedExternally\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n    object Obj1 {}\n\n    companion object {\n        <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n        val foo: Int = definedExternally\n\n        <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n        object Obj2 {}\n    }\n}\n\nexternal class C {\n    @nativeSetter\n    fun set6(a: Double, v: String): <!NATIVE_SETTER_WRONG_RETURN_TYPE!>Number<!> = definedExternally\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun set(): Any?<!> = definedExternally\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = definedExternally\n\n    <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun set(a: String, v: Any, v2: Any)<!> { definedExternally }\n\n    @nativeSetter\n    fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?) { definedExternally }\n\n    @nativeSetter\n    fun foo(a: Number, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String = definedExternally<!>): String = definedExternally\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\n<!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\nfun toplevelFun(): Any<!> = 0\n\n<!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\nval toplevelVal = 0\n\n<!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\nclass Foo {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nfun foo() {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n    fun toplevelFun(): Any<!> = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n    val toplevelVal = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n    class Foo {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nfun foo() {\n    class A {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun set(a: String, v: Any?): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun put(a: Number, v: String)<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun foo(a: Int, v: String)<!> {}\n    }\n\n    class B {\n        <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n        var foo = 0\n    }\n\n    class C {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun Int.set(a: String, v: Int)<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set2<!>(a: Number, v: String?)<!> = \"OK\"\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set3<!>(a: Double, v: String?)<!> = \"OK\"\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n        fun set(): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n        fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n        fun set(a: String, v: Any, v2: Any)<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?)<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n        fun foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Int = 0<!>, v: String)<!> = \"OK\"\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nexternal class A {\n    class B {\n        class A {\n            @nativeSetter\n            fun set(a: String, v: Any?): Any? = definedExternally\n\n            @nativeSetter\n            fun put(a: Number, v: String) { definedExternally }\n\n            @nativeSetter\n            fun foo(a: Int, v: String) { definedExternally }\n\n            @nativeSetter\n            fun set4(a: Double, v: String): Any = definedExternally\n\n            @nativeSetter\n            fun set5(a: Double, v: String): CharSequence = definedExternally\n\n            companion object {\n                @nativeSetter\n                fun set(a: String, v: Any?): Any? = definedExternally\n\n                @nativeSetter\n                fun put(a: Number, v: String) { definedExternally }\n\n                @nativeSetter\n                fun foo(a: Int, v: String) { definedExternally }\n\n                @nativeSetter\n                fun set4(a: Double, v: String): Any = definedExternally\n\n                @nativeSetter\n                fun set5(a: Double, v: String): CharSequence = definedExternally\n            }\n        }\n\n        class B {\n            <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n            val foo: Int = definedExternally\n\n            <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n            object Obj1 {}\n\n            companion object {\n                <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n                val foo: Int = definedExternally\n\n                <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n                object Obj2 {}\n            }\n        }\n\n        class C {\n            @nativeSetter\n            fun set6(a: Double, v: String): <!NATIVE_SETTER_WRONG_RETURN_TYPE!>Number<!> = definedExternally\n\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(): Any?<!> = definedExternally\n\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = definedExternally\n\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(a: String, v: Any, v2: Any)<!> { definedExternally }\n\n            @nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?) { definedExternally }\n\n            @nativeSetter\n            fun foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Double = definedExternally<!>, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String = definedExternally<!>): String = definedExternally\n        }\n\n        object obj {\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(): Any?<!> = definedExternally\n\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = definedExternally\n\n            <!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(a: String, v: Any, v2: Any)<!> { definedExternally }\n\n            @nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?) { definedExternally }\n\n            @nativeSetter\n            fun foo(a: Int, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String = definedExternally<!>): String = definedExternally\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nclass A {\n    class B {\n        class A {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun set(a: String, v: Any?): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun put(a: Number, v: String)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun foo(a: Int, v: String)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun set4(a: Double, v: String): Any<!> = 1\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun set5(a: Double, v: String): CharSequence<!> = \"OK\"\n\n            companion object {\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n                fun set(a: String, v: Any?): Any?<!> = null\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n                fun put(a: Number, v: String)<!> {}\n\n                <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n                fun foo(a: Int, v: String)<!> {}\n            }\n        }\n\n        class B {\n            <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n            val foo = 0\n\n            <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n            object Obj1 {}\n\n            companion object {\n                <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n                val foo = 0\n\n                <!WRONG_ANNOTATION_TARGET!>@nativeSetter<!>\n                object Obj2 {}\n            }\n        }\n\n        class C {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.set(a: String, v: Int)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set2<!>(a: Number, v: String?)<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set3<!>(a: Double, v: String?)<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.set6(a: Double, v: String): <!NATIVE_SETTER_WRONG_RETURN_TYPE!>Number<!><!> = 1\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(a: String, v: Any, v2: Any)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Double = 0.0<!>, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String = \"str\"<!>)<!> = \"OK\"\n        }\n\n        object obj {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.set(a: String, v: Int)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set2<!>(a: Number, v: String?)<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set3<!>(a: Double, v: String?)<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(a: String, v: Any, v2: Any)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun foo(a: Int, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String = \"str\"<!>)<!> = \"OK\"\n        }\n\n        val anonymous = object {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.set(a: String, v: Int)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set2<!>(a: Number, v: String?)<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun Int.<!NATIVE_SETTER_WRONG_RETURN_TYPE!>set3<!>(a: Double, v: String?)<!> = \"OK\"\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>): Any?<!> = null\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN, NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\n            fun set(a: String, v: Any, v2: Any)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun set(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: A<!>, v: Any?)<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeSetter\n            fun foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: Number = 0.0<!>, v: String)<!> = \"OK\"\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\n@nativeSetter\nfun Int.set(a: String, v: Int) {}\n\n@nativeSetter\nfun Int.set2(a: Number, v: String?): Any? = null\n\n@nativeSetter\nfun Int.set3(a: Double, v: String) = \"OK\"\n\n@nativeSetter\nfun Int.set4(a: Double, v: String): Any = 1\n\n@nativeSetter\nfun Int.set5(a: Double, v: String): CharSequence = \"OK\"\n\n@nativeSetter\nfun Int.set6(a: Double, v: String): <!NATIVE_SETTER_WRONG_RETURN_TYPE!>Number<!> = 1\n\n@nativeSetter\nfun Any.foo(<!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>a: String = \"0.0\"<!>, <!NATIVE_INDEXER_CAN_NOT_HAVE_DEFAULT_ARGUMENTS!>v: String = \"str\"<!>) = \"OK\"\n\n<!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\nfun Int.set(a: <!UNRESOLVED_REFERENCE!>A<!>): Int?<!> = 1\n\n<!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\nfun Int.set2(): String?<!> = \"OK\"\n\n<!NATIVE_INDEXER_WRONG_PARAMETER_COUNT!>@nativeSetter\nfun Int.set3(<!NATIVE_INDEXER_KEY_SHOULD_BE_STRING_OR_NUMBER!>a: Any<!>, b: Int, c: Any?)<!> {}\n"
        },
        {
            "code": "external fun foo(): Int = definedExternally\n\nexternal fun bar(): Unit {\n    definedExternally\n}\n\nexternal fun baz(): Int = <!WRONG_BODY_OF_EXTERNAL_DECLARATION!>23<!>\n\nexternal fun f(x: Int, y: String = definedExternally): Unit\n\nexternal fun g(x: Int, y: String = <!WRONG_DEFAULT_VALUE_FOR_EXTERNAL_FUN_PARAMETER!>\"\"<!>): Unit\n\nexternal var a: Int\n    get() = definedExternally\n    set(value) {\n        definedExternally\n    }\n\nexternal val b: Int\n    get() = <!WRONG_BODY_OF_EXTERNAL_DECLARATION!>23<!>\n\nexternal val c: Int = definedExternally\n\nexternal val d: Int = <!WRONG_INITIALIZER_OF_EXTERNAL_DECLARATION!>23<!>\n\nexternal class C {\n    fun foo(): Int = definedExternally\n\n    fun bar(): Int = <!WRONG_BODY_OF_EXTERNAL_DECLARATION!>23<!>\n}\n"
        },
        {
            "code": "external interface I {\n    interface J\n\n    class <!NESTED_CLASS_IN_EXTERNAL_INTERFACE!>C<!>\n\n    <!NESTED_CLASS_IN_EXTERNAL_INTERFACE!>object O<!>\n\n    enum class <!NESTED_CLASS_IN_EXTERNAL_INTERFACE!>E<!>\n\n    companion <!NESTED_CLASS_IN_EXTERNAL_INTERFACE!>object<!>\n}"
        },
        {
            "code": "external enum class E {\n    X,\n    Y <!EXTERNAL_ENUM_ENTRY_WITH_BODY!>{\n        fun foo()\n    }<!>,\n    Z <!EXTERNAL_ENUM_ENTRY_WITH_BODY!>{}<!>\n}"
        },
        {
            "code": "external class C(x: Int, <!EXTERNAL_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER!>val y: String<!>)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nclass A {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n    fun foo()<!> {}\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n    fun invoke(a: String): Int<!> = 0\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n    fun Int.ext()<!> = 1\n\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n    fun Int.invoke(a: String, b: Int)<!> = \"OK\"\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n    val baz = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n    object Obj {}\n\n    companion object {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun foo()<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun invoke(a: String): Int<!> = 0\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun Int.ext()<!> = 1\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun Int.invoke(a: String, b: Int)<!> = \"OK\"\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\nexternal class A {\n    @nativeInvoke\n    fun foo() {definedExternally}\n\n    @nativeInvoke\n    fun invoke(a: String): Int = definedExternally\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n    val foo: Int = definedExternally\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n    object Obj1 {}\n\n    companion object {\n        @nativeInvoke\n        fun foo() { definedExternally }\n\n        @nativeInvoke\n        fun invoke(a: String): Int = definedExternally\n\n        <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n        val foo: Int = definedExternally\n\n        <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n        object Obj2 {}\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -DEPRECATION\n\n<!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\nfun toplevelFun()<!> {}\n\n<!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\nval toplevelVal = 0\n\n<!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\nclass Foo {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nfun foo() {\n    <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n    fun toplevelFun()<!> {}\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n    val toplevelVal = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@nativeInvoke<!>\n    class Foo {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nfun foo() {\n    class A {\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun foo()<!> {}\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun invoke(a: String): Int<!> = 0\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun Int.ext()<!> = 1\n\n        <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n        fun Int.invoke(a: String, b: Int)<!> = \"OK\"\n\n        val anonymous = object {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun foo()<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun invoke(a: String): Int<!> = 0\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NON_TOPLEVEL_CLASS_DECLARATION, -DEPRECATION\n\nclass A {\n    class B {\n        class C {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun foo()<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun invoke(a: String): Int<!> = 0\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun Int.ext()<!> = 1\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun Int.invoke(a: String, b: Int)<!> = \"OK\"\n        }\n\n        object obj {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun foo()<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun invoke(a: String): Int<!> = 0\n        }\n\n        companion object {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun foo()<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun invoke(a: String): Int<!> = 0\n        }\n\n        val anonymous = object {\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun foo()<!> {}\n\n            <!NATIVE_ANNOTATIONS_ALLOWED_ONLY_ON_MEMBER_OR_EXTENSION_FUN!>@nativeInvoke\n            fun invoke(a: String): Int<!> = 0\n        }\n    }\n}\n"
        },
        {
            "code": "class C<<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T>\n\nval <<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T> T.v: T\n    get() = throw UnsupportedOperationException()\n\nfun <<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T> bar() {}"
        },
        {
            "code": "fun test(m: Map<String, Int>, mm: MutableMap<Int, String>) {\n    m.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>getOrDefault<!>(\"2\", 1)\n    mm.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>getOrDefault<!>(1, \"2\")\n    mm.remove(1, <!TOO_MANY_ARGUMENTS!>\"2\"<!>)\n}\n"
        },
        {
            "code": "val foo = <!INVISIBLE_MEMBER!>UInt<!>(<!NO_VALUE_FOR_PARAMETER!>)<!>"
        },
        {
            "code": "\nval a0: Any = 1u\n\nval n0: Number = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1u<!>\n\nval c0: Comparable<*> = 1u\nval c1: Comparable<UInt> = 1u\n\nval u0: UInt = 1u\nval u1: UInt? = 1u\nval u2: UInt? = u0\nval u3: UInt? = u1\n\nval i0: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1u<!>\n\nval m0 = <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>-<!>1u\nval m1: UInt = <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>-<!>1u\n\nval h1 = 0xFFu\nval h2: UShort = 0xFFu\n\nval b1 = 0b11u\nval b2: UByte = 0b11u"
        },
        {
            "code": "// !API_VERSION: 1.2\n\nval a = <!UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH!>0u<!>\nval b = <!UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH!>1uL<!>\n\nfun foo(<!UNUSED_PARAMETER!>u<!>: <!UNRESOLVED_REFERENCE!>UInt<!>) {}"
        },
        {
            "code": "val a1 = 1u<!WRONG_LONG_SUFFIX!>l<!>\nval a2 = 0x1u<!WRONG_LONG_SUFFIX!>l<!>\nval a3 = 0B1u<!WRONG_LONG_SUFFIX!>l<!>\nval a4 = 1U<!WRONG_LONG_SUFFIX!>l<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nconst val u1: UByte = 0xFFu\nconst val u2: UShort = 0xFFFFu\nconst val u3: UInt = 0xFFFF_FFFFu\nconst val u4: ULong = 0xFFFF_FFFF_FFFF_FFFFu\nconst val u5: ULong = 18446744073709551615u\n\nconst val u6 = 0xFFFF_FFFF_FFFF_FFFFu\nconst val u7 = 18446744073709551615u\n\nval u8: Comparable<*> = 0xFFFF_FFFF_FFFF_FFFFu\n\nconst val u9 = 0xFFFF_FFFF_FFFF_FFFFUL\n\nfun takeUByte(ubyte: UByte) {}\n\nfun test() {\n    takeUByte(200u)\n    takeUByte(255u)\n    takeUByte(0xFFu)\n}\n\nval s1: UByte = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>256u<!>\nval s2 = <!INT_LITERAL_OUT_OF_RANGE!>18446744073709551616u<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nval a0: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1uL<!>\nval a1: UInt = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1uL<!>\nval a3: ULong = 1uL\nval a4 = 1UL + 2UL\nval a5 = <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>-<!>1UL\n\nfun takeULong(u: ULong) {}\n\nfun test() {\n    takeULong(3UL)\n    takeULong(1UL + 3uL)\n    takeULong(1u + 0uL)\n    takeULong(1uL + 4u)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var a: UInt\n\nfun foo() {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var b: UByte\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var c: UShort\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var d: ULong\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun ubyte(vararg a: UByte) {}\nfun ushort(vararg a: UShort) {}\nfun uint(vararg a: UInt) {}\nfun ulong(vararg a: ULong) {}\n\nclass ValueParam(vararg val a: ULong)\n\nannotation class Ann(vararg val a: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>UInt<!>)\n\nfun array(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> a: UIntArray) {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\n// FILE: annotation.kt\n\npackage kotlin.internal\n\nannotation class ImplicitIntegerCoercion\n\n// FILE: test.kt\n\nimport kotlin.internal.ImplicitIntegerCoercion\n\n@ImplicitIntegerCoercion\nconst val IMPLICIT_INT = 255\n\n@ImplicitIntegerCoercion\nconst val EXPLICIT_INT: Int = 255\n\n@ImplicitIntegerCoercion\nconst val LONG_CONST = 255L\n\n@ImplicitIntegerCoercion\nval NON_CONST = 255\n\n@ImplicitIntegerCoercion\nconst val BIGGER_THAN_UBYTE = 256\n\n@ImplicitIntegerCoercion\nconst val UINT_CONST = 42u\n\nfun takeUByte(@ImplicitIntegerCoercion u: UByte) {}\nfun takeUShort(@ImplicitIntegerCoercion u: UShort) {}\nfun takeUInt(@ImplicitIntegerCoercion u: UInt) {}\nfun takeULong(@ImplicitIntegerCoercion u: ULong) {}\n\nfun takeUBytes(@ImplicitIntegerCoercion vararg u: UByte) {}\n\nfun takeLong(@ImplicitIntegerCoercion l: Long) {}\n\nfun takeUIntWithoutAnnotaion(u: UInt) {}\n\nfun takeIntWithoutAnnotation(i: Int) {}\n\nfun test() {\n    takeUByte(IMPLICIT_INT)\n    takeUByte(EXPLICIT_INT)\n\n    takeUShort(IMPLICIT_INT)\n    takeUShort(BIGGER_THAN_UBYTE)\n\n    takeUInt(IMPLICIT_INT)\n\n    takeULong(IMPLICIT_INT)\n\n    takeUBytes(IMPLICIT_INT, EXPLICIT_INT, 42u)\n\n    takeLong(<!NI;TYPE_MISMATCH!>IMPLICIT_INT<!>)\n\n    takeIntWithoutAnnotation(IMPLICIT_INT)\n\n    takeUIntWithoutAnnotaion(UINT_CONST)\n\n    takeUByte(<!TYPE_MISMATCH!>LONG_CONST<!>)\n    takeUByte(<!TYPE_MISMATCH!>NON_CONST<!>)\n    takeUByte(<!NI;TYPE_MISMATCH, TYPE_MISMATCH!>BIGGER_THAN_UBYTE<!>)\n    takeUByte(<!TYPE_MISMATCH!>UINT_CONST<!>)\n    takeUIntWithoutAnnotaion(<!TYPE_MISMATCH!>IMPLICIT_INT<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n\nfun foo(x: Int): Int = 0\n\nfun foo(x: UInt): String = \"\"\nfun foo(x: UByte): String = \"\"\nfun foo(x: UShort): String = \"\"\nfun foo(x: ULong): String = \"\"\n\nfun fooByte(x: Byte): Int = 0\nfun fooByte(x: UByte): String = \"\"\n\nfun fooShort(x: Short): Int = 0\nfun fooShort(x: UShort): String = \"\"\n\nfun fooLong(x: Long): Int = 0\nfun fooLong(x: ULong): String = \"\"\n\nfun test() {\n    foo(1) checkType { _<Int>() }\n    foo(1u) checkType { _<String>() }\n\n    foo(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>2147483648<!>) checkType { _<String>() }\n    foo(<!INTEGER_OVERFLOW!>2147483647 + 1<!>) checkType { _<Int>() }\n\n    fooByte(1) checkType { _<Int>() }\n    fooByte(1u) checkType { _<String>() }\n\n    fooShort(1) checkType { _<Int>() }\n    fooShort(1u) checkType { _<String>() }\n\n    fooLong(1) checkType { _<Int>() }\n    fooLong(1u) checkType { _<String>() }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun takeUByte(u: UByte) {}\nfun takeUShort(u: UShort) {}\nfun takeUInt(u: UInt) {}\nfun takeULong(u: ULong) {}\n\nfun takeUBytes(vararg u: UByte) {}\n\nfun takeNullableUInt(u: UInt?) {}\n\nfun test() {\n    takeUInt(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1 + 2<!>)\n    takeUInt(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1.plus(2)<!>)\n    takeNullableUInt(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>4<!>)\n\n    takeUInt(<!TYPE_MISMATCH!>Int.MAX_VALUE * 2L<!>)\n    takeUInt(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED, TYPE_MISMATCH!>-1<!>)\n    takeUInt(<!TYPE_MISMATCH!>Int.MAX_VALUE * 2L + 2<!>)\n\n    takeUByte(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1<!>)\n    takeUByte(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>255<!>)\n    takeUByte(<!TYPE_MISMATCH!>1.toByte()<!>)\n\n    takeUShort(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1<!>)\n    takeUInt(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1<!>)\n    takeULong(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1<!>)\n\n    takeULong(<!INT_LITERAL_OUT_OF_RANGE!>18446744073709551615<!>)\n    takeULong(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1844674407370955161<!>)\n    takeULong(18446744073709551615u)\n\n    takeUInt(<!INTEGER_OVERFLOW, TYPE_MISMATCH!>Int.MAX_VALUE * 2<!>)\n    takeUInt(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>4294967294<!>)\n\n    takeUBytes(<!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1<!>, <!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>2<!>, <!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>255<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH, SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>256<!>, <!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>0<!>, <!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED, TYPE_MISMATCH!>-1<!>, <!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>40 + 2<!>)\n\n    takeUInt(<!TYPE_MISMATCH!>1.myPlus(2)<!>)\n\n    val localVariable = 42\n    takeUInt(<!TYPE_MISMATCH!>localVariable<!>)\n\n    var localMutableVariable = 42\n    takeUInt(<!TYPE_MISMATCH!>localMutableVariable<!>)\n\n    val localNegativeVariable = -1\n    takeUInt(<!TYPE_MISMATCH!>localNegativeVariable<!>)\n\n    takeUInt(<!TYPE_MISMATCH!>globalVariable<!>)\n\n    takeUInt(<!TYPE_MISMATCH!>constVal<!>)\n\n    takeUInt(<!TYPE_MISMATCH!>globalVariableWithGetter<!>)\n}\n\nval globalVariable = 10\n\nconst val constVal = 10\n\nval globalVariableWithGetter: Int get() = 0\n\nval prop: UByte = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>255<!>\n\nfun Int.myPlus(other: Int): Int = this + other\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n// !CHECK_TYPE\n\n// Here we mostly trying to fix behaviour in order to track changes in inference rules for unsigned types later\n\nfun <T> id(x: T): T = x\nfun <K> select(x: K, y: K): K = TODO()\n\nfun takeUByte(u: UByte) {}\n\nfun foo() {\n    select(1, 1u) checkType { _<Comparable<*>>() }\n    takeUByte(<!TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>id(1)<!>)\n\n    1 <!NONE_APPLICABLE!>+<!> 1u\n    (1u + <!SIGNED_CONSTANT_CONVERTED_TO_UNSIGNED!>1<!>) checkType { _<UInt>() }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun test(\n    ub1: UByte, ub2: UByte,\n    us1: UShort, us2: UShort,\n    ui1: UInt, ui2: UInt,\n    ul1: ULong, ul2: ULong\n) {\n    val ub = <!FORBIDDEN_IDENTITY_EQUALS!>ub1 === ub2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>ub1 !== ub2<!>\n    val us = <!FORBIDDEN_IDENTITY_EQUALS!>us1 === us2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>us1 !== us2<!>\n    val ui = <!FORBIDDEN_IDENTITY_EQUALS!>ui1 === ui2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>ui1 !== ui2<!>\n    val ul = <!FORBIDDEN_IDENTITY_EQUALS!>ul1 === ul2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>ul1 !== ul2<!>\n\n    val u = <!EQUALITY_NOT_APPLICABLE!>ub1 === ul1<!>\n\n    val a1 = <!FORBIDDEN_IDENTITY_EQUALS!>1u === 2u<!> || <!FORBIDDEN_IDENTITY_EQUALS!>1u !== 2u<!>\n    val a2 = <!FORBIDDEN_IDENTITY_EQUALS!>0xFFFF_FFFF_FFFF_FFFFu === 0xFFFF_FFFF_FFFF_FFFFu<!>\n\n    val bu1 = 1u\n    val bu2 = 1u\n\n    val c1 = <!FORBIDDEN_IDENTITY_EQUALS!>bu1 === bu2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>bu1 !== bu2<!>\n}"
        },
        {
            "code": "\nfun ubyte(vararg a: UByte): UByteArray = a\nfun ushort(vararg a: UShort): UShortArray = a\nfun uint(vararg a: UInt): UIntArray = a\nfun ulong(vararg a: ULong): ULongArray = a\n\nfun rawUInt(vararg a: UInt): IntArray = <!TYPE_MISMATCH!>a<!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//If this test hangs, it means something is broken.\npackage a\n\nobject A {\n    val iii = 42\n}\n\n//inappropriate but participating in resolve functions\nfun foo(s: String, a: Any) = s + a\nfun foo(a: Any, s: String) = s + a\nfun foo(i: Int, j: Int) = i + j\nfun foo(a: Any, i: Int) = \"$a$i\"\nfun foo(f: (Int) -> Int, i: Int) = f(i)\nfun foo(f: (String) -> Int, s: String) = f(s)\nfun foo(f: (Any) -> Int, a: Any) = f(a)\nfun foo(s: String, f: (String) -> Int) = f(s)\nfun foo(a: Any, f: (Any) -> Int) = f(a)\n//appropriate function\nfun foo(i: Int, f: (Int) -> Int) = f(i)\n\nfun <T> id(t: T) = t\n\nfun test() {\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(1, id(fun(x1: Int) =\n          <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(2, id(fun(x2: Int) =\n                <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(3, id(fun(x3: Int) =\n                      <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(4, id(fun(x4: Int) =\n                            <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(5, id(fun(x5: Int) =\n                                  x1 + x2 + x3 + x4 + x5 + A.iii\n                            ))\n                      ))\n                ))\n          ))\n    ))\n}\n"
        },
        {
            "code": "class Class1<T : Class2<Class1<<!UNRESOLVED_REFERENCE!>X<!>>>>\n\nclass Class2<T : Class1<Class2<<!UNRESOLVED_REFERENCE!>X<!>>>>"
        },
        {
            "code": "fun foo(): Any {\n    <!LOCAL_OBJECT_NOT_ALLOWED!>object Bar<!>\n    return Bar\n}"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nclass A(val b: String) {\n    companion object {\n        val c: String = \"\"\n    }\n\n    fun mtd() = c.length\n}\n\n// FILE: b.kt\npackage b\n\n// FILE: c.kt\npackage c\n\n// FILE: test.kt\npackage test\n\nimport a.A\n\nfun <T, R> T.with(f: T.() -> R) = f()\n\nfun A.extFun1() = b.length\n\n// fun A.extFun2() = c.length // TODO fix KT-9953\n\nval x1 = A(\"\").with { b.length }\n\n// val x2 = A(\"\").with { c.length } // TODO fix KT-9953\n\nval x3 = A.with { c.length }"
        },
        {
            "code": "//If this test hangs, it means something is broken.\npackage c\n\nclass A {\n    val testVal : A = A()\n}\n\n//inappropriate but participating in resolve functions\nfun foo(a: A, <!UNUSED_PARAMETER!>b<!>: A, <!UNUSED_PARAMETER!>i<!>: Int) = a\nfun foo(a: Any) = a\nfun foo(a: A, <!UNUSED_PARAMETER!>b<!>: Any) = a\nfun foo(a: A, <!UNUSED_PARAMETER!>b<!>: A, <!UNUSED_PARAMETER!>s<!>: String) = a\n//appropriate function\nfun foo(a: A, <!UNUSED_PARAMETER!>b<!>: A) = a\n\nfun test(a: A) {\n    //the problem occurs if there are nested function invocations to resolve (resolve for them is repeated now)\n    //to copy this invocation many times (and to comment/uncomment inappropriate functions) to see the difference\n    foo(foo(a, foo(a, foo(a, a.testVal))), a)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage some\n\nclass A()\n\nval Int.some: Int get() = 4\nval Int.foo: Int get() = 4\n\nfun Int.extFun() = 4\n\nfun String.test() {\n    <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>some<!>\n    some.A()\n    \"\".<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>some<!>\n\n    <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>\n    \"\".<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>\n\n    <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>extFun<!>()\n    \"\".<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>extFun<!>()\n}"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nclass A\n\n// FILE: b.kt\npackage b\n\nimport a.A\n\nval A.d: Int get() = 1\n\n// FILE: c.kt\npackage c\n\nimport a.A\n\nval A.d: Int get() = 2\n\n// FILE: d.kt\n\npackage d\n\nimport a.A\nimport b.d\nimport c.d\n\nfun A.test() {\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>d<!>\n}\n"
        },
        {
            "code": "package test\n\n// imports should be resolved\nimport test.topLevelFun\nimport test.topLevelProperty\n\n@Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\nfun topLevelFun(){}\n\n@Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\nvar topLevelProperty = 1\n\n@Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\nfun String.topLevelExtensionFun(){}\n\n@Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\nval String.topLevelExtensionProperty: Int get() = 1\n\nopen class A {\n    constructor(<!UNUSED_PARAMETER!>p<!>: Int) : this(<!TYPE_MISMATCH!>\"\"<!>) {}\n\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    constructor(<!UNUSED_PARAMETER!>s<!>: String){}\n\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    open fun memberFun(){}\n\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    val memberProperty = 1\n\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    fun String.memberExtensionFun(){}\n\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    val String.memberExtensionProperty: Int get() = 1\n\n    fun foo() {\n        <!UNRESOLVED_REFERENCE!>topLevelFun<!>()\n        <!UNRESOLVED_REFERENCE, VARIABLE_EXPECTED!>topLevelProperty<!><!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>++<!>\n        \"\".<!UNRESOLVED_REFERENCE!>topLevelExtensionFun<!>()\n        \"\".<!UNRESOLVED_REFERENCE!>topLevelExtensionProperty<!>\n\n        <!UNRESOLVED_REFERENCE!>memberFun<!>()\n        <!UNRESOLVED_REFERENCE!>memberProperty<!>\n        \"\".<!UNRESOLVED_REFERENCE!>memberExtensionFun<!>()\n        \"\".<!UNRESOLVED_REFERENCE!>memberExtensionProperty<!>\n\n        A(<!TYPE_MISMATCH!>\"\"<!>)\n    }\n}\n\ninterface I {\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    fun foo1()\n\n    @Deprecated(\"hidden\", level = DeprecationLevel.HIDDEN)\n    fun foo2()\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class X<!> : I {\n    override fun foo1() {\n    }\n}\n\nclass B : A(<!TYPE_MISMATCH!>\"\"<!>) {\n    // still can override it\n    override fun memberFun() {\n        super.<!UNRESOLVED_REFERENCE!>memberFun<!>() // but cannot call super :)\n    }\n}\n\nclass C : A {\n    constructor() : super(<!TYPE_MISMATCH!>\"\"<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo() {\n    fun bar(x: String, y: String = x) {}\n    fun baz(x: Int = <!UNINITIALIZED_PARAMETER!>y<!>, y: Int) {}\n}"
        },
        {
            "code": "class A private constructor()\n\nclass B {\n    private companion object\n}\n\nclass C(val x: Int)\n\nclass D private constructor() {\n    companion object\n}\n\nclass E private constructor() {\n    companion object {\n        operator fun invoke(x: Int) = x\n    }\n}\n\nval a = <!NO_COMPANION_OBJECT!>A<!>\nval <!EXPOSED_PROPERTY_TYPE!>b<!> = <!INVISIBLE_MEMBER!>B<!>\nval c = <!NO_COMPANION_OBJECT!>C<!>\nval d = D\nval e = E(42)"
        },
        {
            "code": "class B\n\nclass A {\n    operator fun B.invoke() {}\n}\n\nval B.a: () -> Int  get() = { 5 }\n\nfun test(a: A, b: B) {\n    val <!UNUSED_VARIABLE!>x<!>: Int = b.a()\n\n    b.<!FUNCTION_EXPECTED!>(a)<!>()\n\n    with(b) {\n        val <!UNUSED_VARIABLE!>y<!>: Int = a()\n        <!FUNCTION_EXPECTED!>(a)<!>()\n    }\n}\n"
        },
        {
            "code": "//KT-4204 ConstraintSystem erased after resolution completion\npackage c\n\npublic abstract class TestBug1() {\n\n    public fun m3(<!UNUSED_PARAMETER!>position<!>: Int) {\n        position(m1().second<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    }\n\n    public fun m4(position: (Int)->Int) {\n        position(m1().second)\n    }\n\n    <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>abstract<!> fun m1(): Pair<Int, Int>\n\n    private fun position(<!UNUSED_PARAMETER!>p<!>: Int) {}\n\n}\n\n//from library\npublic class Pair<out A, out B> (\n        public val first: A,\n        public val second: B\n)\n"
        },
        {
            "code": "interface A\ninterface Foo {\n    operator fun A.invoke()\n}\n\nfun test(a: A, <!UNUSED_PARAMETER!>foo<!>: Foo) {\n    a.<!UNRESOLVED_REFERENCE!>foo<!>()\n}\n\nfun test(a: Int, foo: Int.()->Unit) {\n    a.foo()\n}"
        },
        {
            "code": "class A {\n    val foo: B.() -> Unit get() = null!!\n}\n\nclass B\n\nfun test(a: A, b: B) {\n    with(b) {\n        a.foo(<!NO_VALUE_FOR_PARAMETER!>)<!> // here must be error, because a is not extension receiver\n\n        a.foo(this)\n\n        (a.foo)()\n\n        (a.foo)(this)\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass My {\n    private operator fun Int.invoke(s: String) {}\n}\n\nfun My.foo(i: Int) {\n    <!INVISIBLE_MEMBER!>i<!>(\"\")\n    <!INVISIBLE_MEMBER!>1<!>(\"\")\n}\n"
        },
        {
            "code": "fun test1(f: String.() -> Unit) {\n    (f)(<!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    f(<!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n\nfun test2(f: (Int) -> Int) {\n    1.<!UNRESOLVED_REFERENCE!>f<!>(2)\n\n    2.<!NO_RECEIVER_ALLOWED!>(f)<!>(2)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun String.invoke(i: Int) {}\n\nfun foo(i: Int) {\n    <!NI;DEBUG_INFO_MISSING_UNRESOLVED!><!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>i<!>(1)<!>\n\n    <!FUNCTION_EXPECTED!>1<!>(1)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun test1() {\n    <!OI;TYPE_MISMATCH!>1<!>. <!NI;FUNCTION_EXPECTED!>(fun String.(i: Int) = i )<!>(1)\n    <!OI;TYPE_MISMATCH!>1<!>.<!NI;FUNCTION_EXPECTED!>(label@ fun String.(i: Int) = i )<!>(1)\n}\n\nfun test2(f: String.(Int) -> Unit) {\n    <!OI;TYPE_MISMATCH!>11<!>.<!NI;FUNCTION_EXPECTED!>(f)<!>(1)\n    <!OI;TYPE_MISMATCH!>11<!>.<!NI;FUNCTION_EXPECTED!>(f)<!>(<!OI;NO_VALUE_FOR_PARAMETER!>)<!>\n}\n\nfun test3() {\n    fun foo(): String.(Int) -> Unit = {}\n\n    <!OI;TYPE_MISMATCH!>1<!>.<!NI;FUNCTION_EXPECTED!>(foo())<!>(1)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n        \nfun Int.invoke(i: Int, a: Any) {}\nfun Int.invoke(a: Any, i: Int) {}\n\nfun foo(i: Int) {\n    <!NI;NONE_APPLICABLE, OI;OVERLOAD_RESOLUTION_AMBIGUITY!>i<!>(1, 1)\n\n    <!NI;NONE_APPLICABLE, OI;OVERLOAD_RESOLUTION_AMBIGUITY!>5<!>(1, 2)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\nfun foo(i: Int) {\n    <!FUNCTION_EXPECTED!>i<!>()\n    <!FUNCTION_EXPECTED!>1<!>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T>\n\noperator fun <T> T.invoke(a: A<T>) {}\n\nfun foo(s: String, ai: A<Int>) {\n    1(ai)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>s<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>ai<!>)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>\"\"<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>ai<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\noperator fun String.invoke(i: Int) {}\n\nfun foo(s: String?) {\n    <!UNSAFE_CALL!>s<!>(1)\n\n    <!NI;UNSAFE_IMPLICIT_INVOKE_CALL, OI;UNSAFE_CALL!>(s <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>)<!>(1)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun Int.invoke() {}\n\nclass SomeClass\n\nfun test(identifier: SomeClass, fn: String.() -> Unit) {\n    <!NI;DEBUG_INFO_MISSING_UNRESOLVED!><!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;DEBUG_INFO_MISSING_UNRESOLVED, OI;FUNCTION_EXPECTED!>identifier<!>()<!>\n    <!NI;DEBUG_INFO_MISSING_UNRESOLVED!><!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>identifier<!>(123)<!>\n    <!NI;DEBUG_INFO_MISSING_UNRESOLVED!><!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>identifier<!>(1, 2)<!>\n    1.<!NI;DEBUG_INFO_MISSING_UNRESOLVED!><!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>fn<!>()<!>\n}"
        },
        {
            "code": "//KT-3772 Invoke and overload resolution ambiguity\npackage bar\n\nopen class A {\n    public operator fun invoke(<!UNUSED_PARAMETER!>f<!>: A.() -> Unit) {}\n}\n\nclass B {\n    public operator fun invoke(<!UNUSED_PARAMETER!>f<!>: B.() -> Unit) {}\n}\n\nopen class C\nval C.attr: A\n    get() = A()\n\nopen class D: C()\nval D.attr: B\n    get() = B()\n\n\nfun main() {\n    val b =  D()\n    b.attr {} // overload resolution ambiguity\n\n    val d = b.attr\n    d {}      // no error\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\nclass A\n\nfun test(foo: A.() -> Int, a: A) {\n    val b: Int = foo(a)\n    val c: Int = (foo)(a)\n}\n\nclass B {\n    val foo: A.() -> Int = null!!\n\n    init {\n        val b: Int = foo(A())\n    }\n}\n\nfun foo(): A.() -> Int {\n    val b: Int = foo()(A())\n    val c: Int = (foo())(A())\n\n    <!OI;UNREACHABLE_CODE!>return<!> null!!\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: 1.kt\npackage fooIsExtension\n\nclass A\nclass B\n\nval A.foo: B.() -> Unit get() = {}\n\nfun test(a: A, b: B) {\n    b.(a.foo)()\n    (a.foo)(b)\n    a.foo(b)\n\n    with(a) {\n        b.foo()\n\n        b.(foo)()\n\n        (b.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>)()\n\n        foo(b)\n        (foo)(b)\n    }\n\n    with(b) {\n        a.foo(<!NO_VALUE_FOR_PARAMETER!>)<!>\n        a.<!FUNCTION_EXPECTED!>(<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>)<!>()\n\n        (a.foo)()\n\n        (a.foo)(this)\n        a.foo(this)\n    }\n\n    with(a) {\n        with(b) {\n            foo()\n            (foo)()\n        }\n    }\n}\n\n// FILE: 1.kt\npackage fooIsMember\n\nclass A {\n    val foo: B.() -> Unit get() = {}\n}\nclass B\n\nfun test(a: A, b: B) {\n    b.(a.foo)()\n    (a.foo)(b)\n    a.foo(b)\n\n    with(a) {\n        b.foo()\n\n        b.(foo)()\n\n        <!FUNCTION_EXPECTED!>(b.<!FUNCTION_CALL_EXPECTED!>foo<!>)<!>()\n\n        foo(b)\n        (foo)(b)\n    }\n\n    with(b) {\n        a.foo(<!NO_VALUE_FOR_PARAMETER!>)<!>\n        a.<!FUNCTION_EXPECTED!>(<!UNRESOLVED_REFERENCE!>foo<!>)<!>()\n\n        (a.foo)()\n\n        (a.foo)(this)\n        a.foo(this)\n    }\n\n    with(a) {\n        with(b) {\n            foo()\n            (foo)()\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A(val x: (String.() -> Unit)?)\n\nfun test(a: A) {\n    if (a.x != null) {\n        \"\".<!DEBUG_INFO_SMARTCAST!>(a.x)<!>()\n        a.<!UNSAFE_IMPLICIT_INVOKE_CALL!>x<!>(\"\") // todo\n        <!DEBUG_INFO_SMARTCAST!>(a.x)<!>(\"\")\n    }\n    \"\".<!UNSAFE_IMPLICIT_INVOKE_CALL!>(a.x)<!>()\n    a.<!UNSAFE_IMPLICIT_INVOKE_CALL!>x<!>(\"\")\n    <!UNSAFE_IMPLICIT_INVOKE_CALL!>(a.x)<!>(\"\")\n\n    with(\"\") {\n        a.<!UNSAFE_IMPLICIT_INVOKE_CALL!>x<!>(<!NO_VALUE_FOR_PARAMETER!>)<!>\n        <!UNSAFE_IMPLICIT_INVOKE_CALL!>(a.x)<!>()\n        if (a.x != null) {\n            a.<!UNSAFE_IMPLICIT_INVOKE_CALL!>x<!>(<!NO_VALUE_FOR_PARAMETER!>)<!> // todo\n            <!DEBUG_INFO_SMARTCAST!>(a.x)<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n//KT-4372 Invalid error position and failing to resolve invoke with receiver from other module\n\nclass Foo<TInner, TOuter> {\n    fun invoke(content: TInner.() -> Unit) {\n    }\n}\n\n// comment this function to fix the error below\nfun <TInner, TOuter> Foo<TInner, TOuter>.invoke(name: String, content: TInner.() -> Unit) {}\n\nenum class EnumClass(val x: String) {}\nobject Y {\n    val x = javaClass<EnumClass>() // javaClass unresolved in any file in this module\n}\n\n//declarations from library\nval <T> T.javaClass : Class<T>\n    get() = throw Exception()\n\nfun <<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T> javaClass() : Class<T> = throw Exception()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun Int.invoke(a: Int) {}\nfun Int.invoke(a: Int, b: Int) {}\n\nclass SomeClass\n\nfun test(identifier: SomeClass, fn: String.() -> Unit) {\n    <!NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;DEBUG_INFO_MISSING_UNRESOLVED, OI;FUNCTION_EXPECTED!>identifier<!>()\n    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>identifier<!>(123)\n    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>identifier<!>(1, 2)\n    1.<!NI;DEBUG_INFO_MISSING_UNRESOLVED!><!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>fn<!>()<!>\n}"
        },
        {
            "code": "\n//KT-9517 Wrong resolve for invoke convention after smart cast\nopen class A {\n    open val foo: () -> Number = null!!\n}\n\nclass B: A() {\n    override val foo: () -> Int\n        get() = null!!\n}\n\nfun test(a: A) {\n    if (a is B) {\n        val <!UNUSED_VARIABLE!>foo<!>: Int = <!DEBUG_INFO_SMARTCAST!>a<!>.foo() // B::foo + invoke()\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\nclass A\n\nvar A.timeInMillis: String\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n\nfun a(c: Calendar) {\n    A().apply {\n        c.apply {\n            timeInMillis = 5 // synthesized variable for get|setTimeInMillis\n            timeInMillis = <!TYPE_MISMATCH!>\"\"<!>\n        }\n        timeInMillis = \"\"\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ndata class A(val foo: Int)\n\noperator fun A.<!EXTENSION_SHADOWED_BY_MEMBER!>component1<!>(): String = \"\"\n\nfun test(a: A) {\n    val (b) = a\n    b checkType { _<Int>() }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nclass A {\n    fun foo() = this\n}\n\n\nfun test(a: A) {\n    fun A.<!EXTENSION_SHADOWED_BY_MEMBER!>foo<!>() = 4\n\n    a.foo() checkType { _<A>() }\n\n    with(a) {\n        foo() checkType { _<A>() }\n        this.foo() checkType { _<A>() }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n//KT-5971 Missing error when fun argument is safe call\n\nfun foo(i: Int) {}\n\nfun test(s: String?) {\n    foo(<!TYPE_MISMATCH!>s?.length<!>)\n}\n"
        },
        {
            "code": "package c\n\nfun zzz(i: Int, f: (Int) -> Int) { throw Exception(\"$i $f\")}\n\nfun test() {\n    fun foo(): Int = 42\n\n    fun bar(i: Int) = i\n\n    bar(foo(<!NAMED_PARAMETER_NOT_FOUND!>xx<!> = zzz(11) { j: Int -> j + 7 }))\n\n    bar(<!NAMED_PARAMETER_NOT_FOUND!>zz<!> = foo(\n      <!NAMED_PARAMETER_NOT_FOUND!>xx<!> = zzz(12) { i: Int -> i + i })<!NO_VALUE_FOR_PARAMETER!>)<!>\n}"
        },
        {
            "code": "interface Foo<T>\n\nclass Bar {\n    operator fun <T> invoke(): Foo<T> = throw Exception()\n}\n\nclass A {\n    val bar = Bar()\n}\n\nfun fooInt(l: Foo<Int>) = l\n\nfun test(bar: Bar, a: A) {\n    // no elements with error types\n    fooInt((bar()))\n    fooInt(if (true) bar() else bar())\n    fooInt(<!REDUNDANT_LABEL_WARNING!>label@<!> bar())\n    fooInt(a.bar())\n    fooInt(((<!REDUNDANT_LABEL_WARNING!>label@<!> if (true) (a.bar()) else bar())))\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A\nclass B\nclass C\nclass D\n\nfun A.bar(x: Int = 0) = \"\"\nfun A.bar(x: Int = 0, y: D.() -> Unit) = \"\"\n\nfun B.bar(x: Int = 0) = \"\"\nfun B.bar(x: Int = 0, y: D.() -> Unit) = \"\"\n\nfun C.bar(x: Int = 0) = \"\"\nfun C.bar(x: Int = 0, y: D.() -> Unit) = \"\"\n\nclass E {\n    fun foo() {\n        // `bar` calls are inapplicable since both E nor D aren't proper receivers\n        // But prior to this change, every lambda was analyzed repeatedly for every candidate\n        // Thus, the resulting time was exponential\n        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n                                                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!> {\n\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass ResolutionCandidate<A>\n\nclass ResolutionTask<B, C : B>(val candidate: ResolutionCandidate<B>)\n\nfun <D, E : D> List<ResolutionTask<D, E>>.bar(t: ResolutionTask<D, E>) = t\n\npublic class ResolutionTaskHolder<F, G : F> {\n    fun test(candidate: ResolutionCandidate<F>, tasks: MutableList<ResolutionTask<F, G>>) {\n        tasks.bar(ResolutionTask<F, G>(candidate))\n        tasks.add(ResolutionTask<F, G>(candidate))\n\n        //todo the problem is the type of ResolutionTask is inferred as ResolutionTask<F, F> too early\n        tasks.<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>bar<!>(ResolutionTask(candidate))\n        tasks.add(ResolutionTask(candidate))\n    }\n}"
        },
        {
            "code": "package c\n\nfun test() {\n    with (1) l@ {\n        foo(1, <!NAMED_PARAMETER_NOT_FOUND!>zz<!> = { this@l } )\n    }\n}\n\nfun foo(x: Int) = x\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage h\n\nfun foo(i: Int) = i\nfun foo(s: String) = s\n\nfun test() {\n    <!NONE_APPLICABLE!>foo<!>(<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>())\n}\n\nfun <T> emptyList(): List<T> {throw Exception()}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass B<E>\n\nfun <T> B<T>.foo(f: (T) -> Unit) {}\nfun <T> B<T>.bar(f: (T, T) -> Unit, g: (T, T) -> Unit) {}\nfun <T> B<T>.baz(f: (B<T>) -> Unit) {}\n\nfun number(x: Number) {}\nfun Number.foobar() {}\n\nfun test(b: B<out Number>) {\n    b.foo {\n        it checkType { _<Number>() }\n        it.toInt()\n    }\n\n    b.foo { x ->\n        x checkType { _<Number>() }\n        x.toInt()\n    }\n\n    b.bar({ x, y ->\n        x checkType { _<Number>() }\n        y checkType { _<Number>() }\n        x.toInt()\n        y.toInt()\n    }) { u, w ->\n        u checkType { _<Number>() }\n        w checkType { _<Number>() }\n\n        u.toInt()\n        w.toInt()\n    }\n\n    b.foo(::number)\n    b.foo(Number::foobar)\n\n    b.baz {\n        <!NAME_SHADOWING!>b<!> -> b checkType { _<B<out Number>>() }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninterface A\n\nobject B\nclass C\n\nfun test() {\n    val interface_as_fun = <!RESOLUTION_TO_CLASSIFIER!>A<!>()\n    val interface_as_val = <!NO_COMPANION_OBJECT!>A<!>\n\n    val object_as_fun = <!FUNCTION_EXPECTED!>B<!>()\n    val class_as_val = <!NO_COMPANION_OBJECT!>C<!>\n}\n\nfun <T> bar() {\n    val typeParameter_as_val = <!TYPE_PARAMETER_IS_NOT_AN_EXPRESSION!>T<!>\n    val typeParameter_as_fun = <!RESOLUTION_TO_CLASSIFIER!>T<!>()\n}"
        },
        {
            "code": "interface MutableMatrix<T> {\n}\n\nfun <T> toMutableMatrix(): MutableMatrix<T> {\n    return <!RESOLUTION_TO_CLASSIFIER!>MutableMatrix<!><T>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nobject X {\n    interface A\n\n    object B\n    class C\n}\n\nfun testX() {\n    val interface_as_fun = X.<!RESOLUTION_TO_CLASSIFIER!>A<!>()\n    val interface_as_val = X.<!NO_COMPANION_OBJECT!>A<!>\n\n    val object_as_fun = X.<!FUNCTION_EXPECTED!>B<!>()\n    val class_as_val = X.<!NO_COMPANION_OBJECT!>C<!>\n}\n\nclass Y {\n    interface A\n\n    object B\n    class C\n}\n\nfun testY() {\n    val interface_as_fun = Y.<!RESOLUTION_TO_CLASSIFIER!>A<!>()\n    val interface_as_val = Y.<!NO_COMPANION_OBJECT!>A<!>\n\n    val object_as_fun = Y.<!FUNCTION_EXPECTED!>B<!>()\n    val class_as_val = Y.<!NO_COMPANION_OBJECT!>C<!>\n}\n\nfun test(x: X) {\n    val interface_as_fun = x.<!RESOLUTION_TO_CLASSIFIER!>A<!>()\n    val interface_as_val = x.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>A<!>\n\n    val object_as_fun = x.<!RESOLUTION_TO_CLASSIFIER!>B<!>()\n    val class_as_val = x.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>C<!>\n}"
        },
        {
            "code": "//If this test hangs, it means something is broken.\npackage c\n\nfun z(<!UNUSED_PARAMETER!>view<!>: () -> Unit) {}\n\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n<!CONFLICTING_OVERLOADS!>fun x()<!> = z { z { z { z { z { z { z { z { } } } } } } } }\n\nclass x<!CONFLICTING_OVERLOADS!>()<!> {}"
        },
        {
            "code": "//If this test hangs, it means something is broken.\npackage a\n\nclass A {\n    val testVal : A = A()\n}\n\n//inappropriate but participating in resolve functions\nfun <T> foo(a: T, <!UNUSED_PARAMETER!>b<!>: T, <!UNUSED_PARAMETER!>i<!>: Int) = a\nfun foo(a: Any) = a\nfun <T> foo(a: T, <!UNUSED_PARAMETER!>b<!>: String) = a\nfun <T> foo(a: T, <!UNUSED_PARAMETER!>b<!>: T, <!UNUSED_PARAMETER!>s<!>: String) = a\n//appropriate function\nfun <T> foo(a: T, <!UNUSED_PARAMETER!>b<!>: T) = a\n\nfun test(a: A) {\n    //the problem occurs if there are nested function invocations to resolve (resolve for them is repeated now)\n    //to copy this invocation many times (and to comment/uncomment inappropriate functions) to see the difference\n    foo(foo(a, foo(a, foo(a, a.testVal))), a)\n\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nobject X1\nobject X2\n\nclass A<T>\n\n<!CONFLICTING_OVERLOADS!>fun <T1> A<T1>.foo()<!> = X1\n<!CONFLICTING_OVERLOADS!>fun <T2> A<out T2>.foo()<!> = X2\n\nfun <T> A<out T>.test() = <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>foo<!>() // TODO fix constraint system"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CONSTRAINT_SYSTEM_FOR_OVERLOAD_RESOLUTION: CONSTRAINT_SYSTEM_FOR_NEW_INFERENCE\n\nopen class A<T>(val value: T)\nclass B<T>(value: T) : A<T>(value)\n\nfun <T> A<T>.foo(block: (T?) -> Unit) {\n    block(value)\n}\nfun <T> B<T>.foo(block: (T) -> Unit) {\n    block(value)\n}\n\nfun main() {\n    B(\"string\").<!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> {  }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitAssigningSingleElementsToVarargsInNamedForm\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject X1\nobject X2\n\nfun overloadedFun(arg: String, vararg args: String) = X1\nfun overloadedFun(arg: String, vararg args: String, flag: Boolean = true) = X2\n\nval test1a: X1 = overloadedFun(\"\", \"\")\nval test1b: X1 = overloadedFun(\"\", args = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>)\nval test1c: X2 = overloadedFun(\"\", \"\", \"\", flag = true)\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\ninterface A<T> {\n    fun foo(x: T)\n    fun foo(x: String)\n\n    fun <E> baz(x: E, y: String)\n    fun <E> baz(x: String, y: E)\n}\n\nfun <E> baz(x: E, y: String) {}\nfun <E> baz(x: String, y: E) {}\n\nfun bar(x: A<String>) {\n    x.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(\"\")\n\n    x.<!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>baz<!>(\"\", \"\")\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>baz<!>(\"\", \"\")\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CONSTRAINT_SYSTEM_FOR_OVERLOAD_RESOLUTION: CONSTRAINT_SYSTEM_FOR_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: a.kt\n\npackage a\n\nfun <T> foo(block: (T?) -> Unit) {}\n\n// FILE: b.kt\n\npackage b\n\nfun <K> foo(block: (K) -> Unit) {}\n\n// FILE: test.kt\n\nimport a.*\nimport b.*\n\nfun main() {\n    <!OI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!><String> {  }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -REDUNDANT_PROJECTION\n\nclass In<in T>() {\n    fun f(t : T) {}\n    fun f(t : Int) = t\n}\n\nfun test1(x: In<String>): Unit = x.f(\"1\")\nfun test2(x: In<in String>): Unit = x.f(\"1\")\nfun test3(x: In<<!CONFLICTING_PROJECTION!>out<!> String>): Unit = x.<!NONE_APPLICABLE!>f<!>(\"1\")\nfun test4(x: In<*>): Unit = x.<!NONE_APPLICABLE!>f<!>(\"1\")"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject Right\nobject Wrong\n\nfun overloadedFun1(c: Any = \"\", b: String = \"\", f: Any = \"\") = Right\nfun overloadedFun1(b: Any = \"\", c: Any = \"\", e: String = \"\") = Wrong\n\nval test1: Right = overloadedFun1(b = \"\")\nval test1a: Wrong = <!TYPE_MISMATCH!>overloadedFun1(b = \"\")<!>\n\nfun overloadedFun2(a: String, b: Any = \"\") = Right\nfun overloadedFun2(a: Any, b: String = \"\") = Wrong\n\nval test2: Right = overloadedFun2(\"\")\n\nfun overloadedFun2a(a: Any, b: String = \"\") = Wrong\nfun overloadedFun2a(a: String, b: Any = \"\") = Right\n\nval test2a: Right = overloadedFun2a(\"\")\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CONSTRAINT_SYSTEM_FOR_OVERLOAD_RESOLUTION: CONSTRAINT_SYSTEM_FOR_OLD_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: a.kt\n\npackage a\n\nfun <T> foo(block: (T?) -> Unit) {}\n\n// FILE: b.kt\n\npackage b\n\nfun <K> foo(block: (K) -> Unit) {}\n\n// FILE: test.kt\n\nimport a.*\nimport b.*\n\nfun main() {\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!><String> {  }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitAssigningSingleElementsToVarargsInNamedForm\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject X1\nobject X2\n\nfun overloadedFun5(vararg ss: String) = X1\nfun overloadedFun5(s: String, vararg ss: String) = X2\n\nval test1 = <!OVERLOAD_RESOLUTION_AMBIGUITY!>overloadedFun5<!>(\"\")\nval test2 = <!OVERLOAD_RESOLUTION_AMBIGUITY!>overloadedFun5<!>(\"\", \"\")\nval test3: X2 = overloadedFun5(s = \"\", ss = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>)\nval test4: X1 = overloadedFun5(ss = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CONSTRAINT_SYSTEM_FOR_OVERLOAD_RESOLUTION: CONSTRAINT_SYSTEM_FOR_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: a.kt\n\npackage a\n\nenum class A { A1 }\n\nfun <T : Enum<T>> foo(arg: T.() -> Unit) = 1\n\n// FILE: b.kt\n\npackage b\n\nfun <T : Any> foo(arg: T.() -> Unit) = 2\n\n// FILE: test.kt\n\nimport a.*\nimport b.*\n\nfun test() {\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!><A> { }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface AutoCloseable\ninterface Closeable : AutoCloseable\n\nfun <T1 : AutoCloseable, R1> T1.myUse(f: (T1) -> R1): R1 = f(this)\nfun <T2 : Closeable, R2> T2.myUse(f: (T2) -> R2): R2 = f(this)\n\nfun test1(x: Closeable) = x.myUse { 42 }\nfun test2(x: Closeable) = x.myUse<Closeable, Int> { 42 }\nfun test3(x: Closeable) = x.myUse<<!OI;UPPER_BOUND_VIOLATED!>AutoCloseable<!>, Int> { 42 } // TODO KT-10681"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject X1\nobject X2\n\nfun <T1> foo(x: T1, f: (T1) -> T1) = X1\nfun <T2> foo(xf: () -> T2, f: (T2) -> T2) = X2\n\nval test: X2 = <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>foo<!>({ 0 }, { <!OI;CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>it<!> <!NI;UNREACHABLE_CODE!><!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> 1<!> })"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CONSTRAINT_SYSTEM_FOR_OVERLOAD_RESOLUTION: CONSTRAINT_SYSTEM_FOR_OLD_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: a.kt\n\npackage a\n\nenum class A { A1 }\n\nfun <T : Enum<T>> foo(arg: T.() -> Unit) = 1\n\n// FILE: b.kt\n\npackage b\n\nfun <T : Any> foo(arg: T.() -> Unit) = 2\n\n// FILE: test.kt\n\nimport a.*\nimport b.*\n\nfun test() {\n    foo<A> { }\n}"
        },
        {
            "code": "fun foo() {\n    <!UNRESOLVED_REFERENCE!>x<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>yyy<!><<!UNRESOLVED_REFERENCE!>XXX<!>>()\n    <!UNRESOLVED_REFERENCE!>x<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>yyy<!><Int>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun noArgs() {}\nfun oneLambdaArg(fn: () -> Unit) {}\nfun twoLambdaArgs(f1: () -> Unit, f2: () -> Unit) {}\nfun varargFn(vararg args: Int) {}\n\nfun testNoArgs() {\n    noArgs()\n    noArgs <!TOO_MANY_ARGUMENTS!>{}<!>\n    noArgs() <!TOO_MANY_ARGUMENTS!>{}<!>\n    noArgs() // {}\n    noArgs() /* */ <!TOO_MANY_ARGUMENTS!>{}<!>\n    noArgs() /*\n        block comment, no new line\n    */ <!TOO_MANY_ARGUMENTS!>{}<!>\n    noArgs()\n    /*\n        block comment with new line\n    */\n    <!UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    noArgs() // comment\n    // comment\n    <!UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    noArgs() <!TOO_MANY_ARGUMENTS!>{}<!> <!MANY_LAMBDA_EXPRESSION_ARGUMENTS!>{}<!>\n    noArgs() <!TOO_MANY_ARGUMENTS!>{}<!>\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n}\n\nfun testLambdaArg() {\n    oneLambdaArg(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    oneLambdaArg {}\n    oneLambdaArg()\n    {}\n    oneLambdaArg()\n    {}\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    oneLambdaArg(\n        {},\n        <!TOO_MANY_ARGUMENTS!>{}<!>\n    )\n    oneLambdaArg() {}\n    oneLambdaArg(<!NO_VALUE_FOR_PARAMETER!>)<!> // {}\n    oneLambdaArg() /* */ {}\n    oneLambdaArg() /*\n        block\n        comment\n    */ {}\n    oneLambdaArg() // comment\n    // comment\n    {}\n    oneLambdaArg() {}/*\n        block comment, no new line\n    */ <!MANY_LAMBDA_EXPRESSION_ARGUMENTS!>{}<!>\n    oneLambdaArg() {}/*\n        block comment with new line\n    */\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    oneLambdaArg() {}// comment\n    // comment\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    oneLambdaArg() {} <!MANY_LAMBDA_EXPRESSION_ARGUMENTS!>{}<!>\n    oneLambdaArg() {}\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    oneLambdaArg() {} // comment\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n}\n\nfun testVararg() {\n    varargFn(1,2,3)\n    varargFn <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n    varargFn(1,2,3) <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n    varargFn(1,2,3) // {}\n    varargFn(1,2,3) /* */ <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n    varargFn(1,2,3) /*\n        block comment, no new line\n    */ <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n    varargFn(1,2,3)\n    /*\n        block comment with new line\n    */ <!UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    varargFn(1,2,3) // comment\n    // comment\n    <!UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n    varargFn(1,2,3) <!VARARG_OUTSIDE_PARENTHESES!>{}<!> <!MANY_LAMBDA_EXPRESSION_ARGUMENTS!>{}<!>\n    varargFn(1,2,3) <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n    <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n}\n\nfun testTwoLambdas() {\n    twoLambdaArgs(\n        f1 = {},\n        f2 =\n        {}\n    )\n\n    fun bar(): () -> Unit {\n        twoLambdaArgs(<!NO_VALUE_FOR_PARAMETER!>)<!>\n        {}\n        <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!>\n\n        return <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (true) {\n            <!OI;TYPE_MISMATCH!>twoLambdaArgs({})\n            {}\n            <!MANY_LAMBDA_EXPRESSION_ARGUMENTS, UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{}<!><!>\n        } else <!NI;TYPE_MISMATCH!>{\n            {}\n        }<!><!>\n    }\n}\n\nfun f1(): (() -> Unit) -> (() -> Unit) -> Unit {\n    return { l1 ->\n        <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>l1()\n        <!UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE!>{ <!OI;CANNOT_INFER_PARAMETER_TYPE!>l2<!> -> <!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!><!NI;FUNCTION_EXPECTED!>l2<!>()<!> }<!><!>\n    }\n}\n"
        },
        {
            "code": "package p\n\nclass X<V>(<!UNUSED_PARAMETER!>provider<!>: () -> V, <!UNUSED_PARAMETER!>trackValue<!>: Boolean) {\n}\n\nclass B {\n    val c = <!NO_VALUE_FOR_PARAMETER!>X<!><String> <!TYPE_MISMATCH!>{\n        \"e\"\n    }<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\ninterface A\n\nfun <T>id(t: T): T = t\nfun doList(l: List<Int>) = l\nfun doInt(i: Int) = i\n\nfun <T> strangeNullableList(<!UNUSED_PARAMETER!>f<!>: (T) -> Unit): List<T>? = throw Exception()\nfun <T: A> emptyNullableListOfA(): List<T>? = null\n\n//-------------------------------\n\nfun testExclExcl() {\n    doList(<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>emptyNullableListOfA<!>()!!) //should be an error here\n    val <!UNUSED_VARIABLE!>l<!>: List<Int> = id(<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>emptyNullableListOfA<!>()!!)\n\n    doList(strangeNullableList { doInt(it) }!!) //lambda should be analyzed (at completion phase)\n}\n\nfun testDataFlowInfoAfterExclExcl(a: Int?) {\n    doInt(a!!)\n    <!DEBUG_INFO_SMARTCAST!>a<!> + 1\n}\n\nfun testUnnecessaryExclExcl(a: Int) {\n    doInt(a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>) //should be warning\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\ninterface A\nfun doList(l: List<Int>) = l\nfun doInt(i: Int) = i\nfun getList(): List<Int>? = null\nfun <T> strangeList(f: (T) -> Unit): List<T> = throw Exception(\"$f\")\nfun <T: A> emptyListOfA(): List<T> = throw Exception()\n\n//-------------------------------\n\nfun testElvis(a: Int?, b: Int?) {\n    if (a != null) {\n        doInt(b ?: <!DEBUG_INFO_SMARTCAST!>a<!>)\n    }\n    doList(getList() ?: <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>emptyListOfA<!>()) //should be an error\n    doList(getList() ?: strangeList { doInt(it) }) //lambda was not analyzed\n}\n\n\nfun testDataFlowInfo1(a: Int?, b: Int?) {\n    val c: Int = a ?: b!!\n    doInt(c)\n    // b is nullable if a != null\n    b <!UNSAFE_OPERATOR_CALL!>+<!> 1\n}\n\nfun testDataFlowInfo2(a: Int?, b: Int?) {\n    doInt(a ?: b!!)\n    // b is nullable if a != null\n    b <!UNSAFE_OPERATOR_CALL!>+<!> 1\n}\n\nfun testTypeMismatch(a: String?, b: Any) {\n    doInt(<!NI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>a<!> ?: <!OI;TYPE_MISMATCH!>b<!><!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -USELESS_ELVIS\n\nfun test() {\n    bar(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (true) {\n        <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n    } else {\n        <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>\n    }<!>)\n\n    bar(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!><!CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> ?: <!CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!><!>)\n}\n\nfun bar(s: String) = s"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage b\n\nfun bar(i: Int) = i\n\nfun test(a: Int?, b: Int?) {\n    bar(<!NI;TYPE_MISMATCH!>if (a == null) return else <!OI;TYPE_MISMATCH!>b<!><!>)\n}\n\nfun test(a: Int?, b: Int?, c: Int?) {\n    bar(<!NI;TYPE_MISMATCH!>if (a == null) return else if (b == null) return else <!OI;TYPE_MISMATCH!>c<!><!>)\n}\n\nfun test(a: Any?, b: Any?, c: Int?) {\n    bar(<!NI;TYPE_MISMATCH!>if (a == null) if (b == null) <!OI;TYPE_MISMATCH!>c<!> else return else return<!>)\n}\n\nfun test(a: Int?, b: Any?, c: Int?) {\n    bar(<!NI;TYPE_MISMATCH!>if (a == null) {\n        return\n    } else {\n        if (b == null) {\n            return\n        } else {\n            <!OI;TYPE_MISMATCH!>c<!>\n        }\n    }<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninterface A\ninterface B\n\ninterface C: A, B\ninterface D: A, B\ninterface E: A, B\n\nfun foo(c: C?, d: D?, e: E?) {\n    val test1: A? = <!OI;TYPE_MISMATCH!>c ?: d<!> ?: e\n\n    val test2: B? = if (false) if (true) c else d else e\n\n    val test3: A? = when {\n        true -> c\n        else -> when {\n            true -> d\n            else -> e\n        }\n    }\n\n    val test4: B? = when (1) {\n        1 -> c\n        2 -> d\n        else -> e\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <T> foo(t: T) = t\n\nfun test1() {\n    foo<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int, String><!>(<!OI;TYPE_MISMATCH!>\"\"<!>)\n}\n\n\nfun <T, R> bar(t: T, r: R) {}\n\nfun test2() {\n    bar<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>(<!OI;TYPE_MISMATCH!>\"\"<!>, \"\")\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: +DslMarkerOnFunctionTypeReceiver\n// !WITH_NEW_INFERENCE\n\n@Target(AnnotationTarget.TYPE)\n@DslMarker\nannotation class MyDsl\n\ninterface A {\n    fun foo()\n}\n\ninterface B {\n    fun bar()\n}\n\nfun baz1(x: (@MyDsl A).() -> Unit) {}\nfun baz2(x: (@MyDsl B).() -> Unit) {}\nfun baz3(x: @MyDsl A.() -> Unit) {}\nfun baz4(x: @MyDsl B.() -> Unit) {}\n\nfun @MyDsl A.baz5() {\n    baz4 {\n        bar()\n        <!DSL_SCOPE_VIOLATION!>foo<!>()\n    }\n}\n\nfun main() {\n    baz1 {\n        baz2 {\n            bar()\n            <!DSL_SCOPE_VIOLATION!>foo<!>()\n        }\n    }\n\n    baz3 {\n        baz2 {\n            bar()\n            <!DSL_SCOPE_VIOLATION!>foo<!>()\n        }\n    }\n\n    baz1 {\n        baz4 {\n            bar()\n            <!DSL_SCOPE_VIOLATION!>foo<!>()\n        }\n    }\n\n    baz3 {\n        baz4 {\n            bar()\n            <!DSL_SCOPE_VIOLATION!>foo<!>()\n        }\n    }\n\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun foo(x: (@Ann A).() -> Unit) {}\nfun bar(x: (@Ann B).() -> Unit) {}\n\nfun test() {\n    foo {\n        a()\n        foo l1@{\n            a()\n            bar l2@{\n                <!DSL_SCOPE_VIOLATION!>a<!>()\n                this@l1.a()\n                b()\n\n                foo l3@{\n                    a()\n                    <!DSL_SCOPE_VIOLATION!>b<!>()\n                    this@l2.b()\n                    bar {\n                        <!DSL_SCOPE_VIOLATION!>a<!>()\n                        this@l3.a()\n                        b()\n                    }\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\nclass A {\n    fun a() = 1\n}\n\n@Ann\nclass B {\n    fun b() = 2\n}\n\nfun bar(x: B.() -> Unit) {}\n\nfun A.test() {\n    bar {\n        <!DSL_SCOPE_VIOLATION!>a<!>()\n        this@test.a()\n        b()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann1\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann2\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann3\n\nclass A {\n    val B.y: (C.() -> Unit) get() = null!!\n}\n\nclass B\n\nclass C {\n    val D.x: (A.() -> Unit) get() = null!!\n}\n\nclass D\n\nfun foo(x: (@Ann1 A).() -> Unit) {}\nfun bar(x: (@Ann2 B).() -> Unit) {}\nfun baz(x: (@Ann3 C).() -> Unit) {}\nfun foo1(x: (@Ann1 D).() -> Unit) {}\nfun foo2(x: (@Ann2 D).() -> Unit) {}\nfun foo3(x: (@Ann3 D).() -> Unit) {}\n\nfun test() {\n    foo {\n        bar {\n            baz {\n                y()\n\n                <!FUNCTION_EXPECTED, NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>x<!>()\n\n                with(D()) {\n                    x()\n                }\n\n                foo1 {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    <!DSL_SCOPE_VIOLATION!>y<!>()\n\n                    with(A()) {\n                        x()\n                        y()\n                    }\n\n                    with(D()) {\n                        <!DSL_SCOPE_VIOLATION!>x<!>()\n                    }\n                    A().x()\n                }\n\n                foo2 {\n                    x()\n                    <!DSL_SCOPE_VIOLATION!>y<!>()\n                }\n\n                foo3 {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    <!DSL_SCOPE_VIOLATION!>y<!>()\n                }\n            }\n        }\n    }\n\n    foo1 {\n        foo {\n            baz {\n                bar {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    y()\n                }\n            }\n        }\n    }\n\n    foo2 {\n        foo {\n            baz {\n                bar {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    y()\n                }\n            }\n        }\n    }\n\n    foo3 {\n        foo {\n            baz {\n                bar {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    y()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\n@Target(AnnotationTarget.TYPE)\n@DslMarker\nannotation class MyDsl\n\ninterface A {\n    fun foo()\n}\n\ninterface B {\n    fun bar()\n}\n\nfun baz1(x: (@MyDsl A).() -> Unit) {}\nfun baz2(x: (@MyDsl B).() -> Unit) {}\nfun baz3(x: @MyDsl A.() -> Unit) {}\nfun baz4(x: @MyDsl B.() -> Unit) {}\n\nfun @MyDsl A.baz5() {\n    baz4 {\n        bar()\n        <!DSL_SCOPE_VIOLATION_WARNING!>foo<!>()\n    }\n}\n\nfun main() {\n    baz1 {\n        baz2 {\n            bar()\n            <!DSL_SCOPE_VIOLATION!>foo<!>()\n        }\n    }\n\n    baz3 {\n        baz2 {\n            bar()\n            <!DSL_SCOPE_VIOLATION_WARNING!>foo<!>()\n        }\n    }\n\n    baz1 {\n        baz4 {\n            bar()\n            <!DSL_SCOPE_VIOLATION_WARNING!>foo<!>()\n        }\n    }\n\n    baz3 {\n        baz4 {\n            bar()\n            <!DSL_SCOPE_VIOLATION_WARNING!>foo<!>()\n        }\n    }\n\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class L1\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class L2\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun foo1(x: (@L1 A).() -> Unit) {}\nfun foo2(x: (@L2 A).() -> Unit) {}\nfun bar1(x: (@L1 B).() -> Unit) {}\nfun bar2(x: (@L2 B).() -> Unit) {}\n\nfun test() {\n    foo1 {\n        a()\n\n        foo2 {\n            a()\n\n            bar1 {\n                a()\n                b()\n                bar2 {\n                    <!DSL_SCOPE_VIOLATION!>a<!>()\n                    b()\n                }\n            }\n\n            bar2 {\n                <!DSL_SCOPE_VIOLATION!>a<!>()\n                b()\n            }\n        }\n\n        bar1 {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            b()\n            bar2 {\n                <!DSL_SCOPE_VIOLATION!>a<!>()\n                b()\n            }\n        }\n\n        bar2 {\n            a()\n            b()\n        }\n    }\n\n    foo2 {\n        a()\n\n        bar1 {\n            a()\n            b()\n            bar2 {\n                <!DSL_SCOPE_VIOLATION!>a<!>()\n                b()\n            }\n        }\n\n        bar2 {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            b()\n        }\n    }\n\n    bar1 {\n        b()\n        bar2 {\n            b()\n        }\n    }\n\n    bar2 {\n        b()\n    }\n\n    foo1 {\n        bar1 {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            b()\n            foo2 {\n                a()\n                b()\n\n                bar2 {\n                    <!DSL_SCOPE_VIOLATION!>a<!>()\n                    b()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun bar(x: (@Ann B).() -> Unit) {}\n\nfun @Ann A.test() {\n    bar {\n        <!DSL_SCOPE_VIOLATION!>a<!>()\n        this@test.a()\n        b()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann1\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann2\n\nclass A {\n    fun D.extA() {}\n}\n\nclass B {\n    fun D.extB() {}\n}\n\nclass D\n\nfun foo(x: (@Ann1 A).() -> Unit) {}\nfun bar(x: (@Ann2 B).() -> Unit) {}\nfun baz(x: (@Ann1 D).() -> Unit) {}\n\nfun test() {\n    foo {\n        bar {\n            baz {\n                <!DSL_SCOPE_VIOLATION!>extA<!>()\n                extB()\n\n                D().<!DSL_SCOPE_VIOLATION!>extA<!>()\n                D().extB()\n\n                with(D()) {\n                    <!DSL_SCOPE_VIOLATION!>extA<!>()\n                    extB()\n                }\n            }\n        }\n    }\n\n    foo {\n        baz {\n            <!DSL_SCOPE_VIOLATION!>extA<!>()\n            D().<!DSL_SCOPE_VIOLATION!>extA<!>()\n\n            bar {\n                <!DSL_SCOPE_VIOLATION!>extA<!>()\n                extB()\n\n                D().<!DSL_SCOPE_VIOLATION!>extA<!>()\n                D().extB()\n\n                with(D()) {\n                    <!DSL_SCOPE_VIOLATION!>extA<!>()\n                    extB()\n                }\n            }\n        }\n    }\n\n    baz {\n        foo {\n            <!DSL_SCOPE_VIOLATION!>extA<!>()\n            D().extA()\n\n            bar {\n                <!DSL_SCOPE_VIOLATION!>extA<!>()\n                <!DSL_SCOPE_VIOLATION!>extB<!>()\n\n                D().extA()\n                D().extB()\n\n                with(D()) {\n                    extA()\n                    extB()\n                }\n            }\n        }\n    }\n\n    baz {\n        bar {\n            extB()\n\n            D().extB()\n\n            foo {\n                <!DSL_SCOPE_VIOLATION!>extA<!>()\n                <!DSL_SCOPE_VIOLATION!>extB<!>()\n\n                D().extA()\n                D().extB()\n\n                with(D()) {\n                    extA()\n                    extB()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\nclass A {\n    var a = 1\n}\n\nvar A.a1: Int\n    get() = 1\n    set(value) {}\n\n@Ann\nclass B {\n    var b = 2\n}\n\nvar B.b1: Int\n    get() = 1\n    set(value) {}\n\nfun foo(x: A.() -> Unit) {}\nfun bar(x: B.() -> Unit) {}\n\nfun test() {\n    foo {\n        a + 1\n        a += a + 1\n        a++\n\n        a1 + 1\n        a1 += a1 + 1\n        a1++\n\n        bar {\n            <!DSL_SCOPE_VIOLATION!>a<!> + 1\n            <!DSL_SCOPE_VIOLATION, DSL_SCOPE_VIOLATION!>a<!> += <!DSL_SCOPE_VIOLATION!>a<!> + 1\n            <!DSL_SCOPE_VIOLATION, DSL_SCOPE_VIOLATION!>a<!>++\n\n            <!DSL_SCOPE_VIOLATION!>a1<!> + 1\n            <!DSL_SCOPE_VIOLATION!>a1<!> += <!DSL_SCOPE_VIOLATION!>a1<!> + 1\n            <!DSL_SCOPE_VIOLATION!>a1<!>++\n\n            this@foo.a + 1\n            this@foo.a += this@foo.a + 1\n            this@foo.a++\n\n            this@foo.a1 + 1\n            this@foo.a1 += this@foo.a1 + 1\n            this@foo.a1++\n\n            b + 1\n            b += b + 1\n            b++\n\n            b1 + 1\n            b1 += b1 + 1\n            b1++\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun foo(x: (@Ann A).() -> Unit) {}\nfun bar(x: (@Ann B).() -> Unit) {}\n\nfun test() {\n    foo {\n        a()\n        bar {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun foo(x: (@Ann A).() -> Unit) {}\nfun bar(x: (@Ann B).() -> Unit) {}\n\nfun test() {\n    foo {\n        with(this) l1@{\n            a()\n            bar {\n                with(this) {\n                    <!DSL_SCOPE_VIOLATION!>a<!>()\n                    this@l1.a()\n                    b()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\nclass A {\n    fun a() = 1\n}\n\n@Ann\nclass B {\n    fun b() = 2\n}\n\nfun <T> foo(x: T.() -> Unit) {}\nfun <E> bar(x: E.() -> Unit) {}\n\nfun test() {\n    foo<A> {\n        a()\n        bar<B> {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun <T> foo(x: (@Ann T).() -> Unit) {}\nfun <E> bar(x: (@Ann E).() -> Unit) {}\n\nfun test() {\n    foo<A> {\n        a()\n        bar<B> {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\ninterface Common\ninterface C : Common\ninterface D : C\n\nclass A : C {\n    fun a() = 1\n}\n\nclass B : D {\n    fun b() = 2\n}\n\nfun foo(x: A.() -> Unit) {}\nfun bar(x: B.() -> Unit) {}\n\nfun test() {\n    foo {\n        a()\n        bar {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class L1\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class L2\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun foo1(x: (@L1 A).() -> Unit) {}\nfun foo2(x: (@L2 A).() -> Unit) {}\n\nfun foo12(x: (@L1 @L2 A).() -> Unit) {}\n\nfun bar1(x: (@L1 B).() -> Unit) {}\nfun bar2(x: (@L2 B).() -> Unit) {}\n\nfun <T> bar1t(q: T, x: (@L1 T).() -> Unit) {}\n\nfun test() {\n    foo12 {\n        a()\n        bar1 {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            b()\n        }\n\n        bar2 {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            b()\n        }\n    }\n\n    bar1 {\n        b()\n        foo12 {\n            a()\n            <!DSL_SCOPE_VIOLATION!>b<!>()\n        }\n    }\n\n    bar2 {\n        b()\n        foo12 {\n            a()\n            <!DSL_SCOPE_VIOLATION!>b<!>()\n        }\n    }\n\n    foo2 {\n        bar1t(this) {\n            a()\n            bar1 {\n                <!DSL_SCOPE_VIOLATION!>a<!>()\n                b()\n            }\n\n            bar2 {\n                <!DSL_SCOPE_VIOLATION!>a<!>()\n                b()\n            }\n        }\n    }\n\n    bar1 {\n        b()\n        foo2 {\n            bar1t(this) {\n                a()\n                <!DSL_SCOPE_VIOLATION!>b<!>()\n            }\n        }\n    }\n\n    bar2 {\n        b()\n        foo2 {\n            bar1t(this) {\n                a()\n                <!DSL_SCOPE_VIOLATION!>b<!>()\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann1\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann2\n\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann3\n\nclass A {\n    operator fun B.invoke() {}\n\n    val B.y: D get() = D()\n}\n\nclass B\n\nclass C {\n    operator fun D.invoke() {}\n\n    val D.x: B get() = B()\n}\n\nclass D\n\nfun foo(x: (@Ann1 A).() -> Unit) {}\nfun bar(x: (@Ann2 B).() -> Unit) {}\nfun baz(x: (@Ann3 C).() -> Unit) {}\nfun foo1(x: (@Ann1 D).() -> Unit) {}\nfun foo2(x: (@Ann2 D).() -> Unit) {}\nfun foo3(x: (@Ann3 D).() -> Unit) {}\n\nfun test() {\n    foo {\n        bar {\n            baz {\n                y()\n\n                <!FUNCTION_EXPECTED, NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>x<!>()\n\n                with(D()) {\n                    x()\n                }\n                D().x()\n\n                foo1 {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    <!DSL_SCOPE_VIOLATION!>y<!>()\n\n                    with(A()) {\n                        x()\n                        y()\n                    }\n\n                    with(D()) {\n                        <!DSL_SCOPE_VIOLATION!>x<!>()\n                    }\n                    D().<!DSL_SCOPE_VIOLATION!>x<!>()\n                }\n\n                foo2 {\n                    x()\n                    <!DSL_SCOPE_VIOLATION!>y<!>()\n                }\n\n                foo3 {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    <!DSL_SCOPE_VIOLATION!>y<!>()\n                }\n            }\n        }\n    }\n\n    foo1 {\n        foo {\n            baz {\n                bar {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    y()\n                }\n            }\n        }\n    }\n\n    foo2 {\n        foo {\n            baz {\n                bar {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    y()\n                }\n            }\n        }\n    }\n\n    foo3 {\n        foo {\n            baz {\n                bar {\n                    <!DSL_SCOPE_VIOLATION!>x<!>()\n                    y()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\nclass A\n\nfun A.a() = 1\n\n@Ann\nclass B\n\nfun B.b() = 2\n\nfun foo(x: A.() -> Unit) {}\nfun bar(x: B.() -> Unit) {}\n\nfun test() {\n    foo {\n        a()\n        bar {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\n@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\nclass A {\n    fun a() = 1\n}\n\nclass B {\n    fun b() = 2\n}\n\nfun <T> foo(x: T.() -> Unit) {}\nfun <E> bar(x: E.() -> Unit) {}\n\nfun test() {\n    foo<@Ann A> {\n        a()\n        bar<@Ann B> {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "@DslMarker\n@Target(AnnotationTarget.CLASS, AnnotationTarget.TYPEALIAS)\nannotation class XMarker\n\n@XMarker\nclass Foo\n\nclass Bar\n\n@XMarker\ntypealias XBar = Bar\n\ntypealias XXBar = XBar\n\nfun Foo.foo(body: Foo.() -> Unit) = body()\nfun Foo.xbar(body: XBar.() -> Unit) = Bar().body()\nfun Foo.xxbar(body: XXBar.() -> Unit) = Bar().body()\n\nfun test() {\n    Foo().foo {\n        xbar {\n            <!DSL_SCOPE_VIOLATION!>foo<!> {}\n        }\n        xxbar {\n            <!DSL_SCOPE_VIOLATION!>foo<!> {}\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\nclass A {\n    fun a() = 1\n}\n\n@Ann\nclass B {\n    fun b() = 2\n}\n\nfun test(a: A, b: B) {\n    with(a) l1@{\n        a()\n        with(b) {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@l1.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@DslMarker\nannotation class Ann\n\n@Ann\nclass A {\n    fun a() = 1\n}\n\n@Ann\nclass B {\n    fun b() = 2\n}\n\nfun foo(x: A.() -> Unit) {}\nfun bar(x: B.() -> Unit) {}\n\nfun test() {\n    foo {\n        a()\n        bar {\n            <!DSL_SCOPE_VIOLATION!>a<!>()\n            this@foo.a()\n            b()\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n@DslMarker\n@Target(AnnotationTarget.CLASS, AnnotationTarget.TYPEALIAS)\nannotation class XMarker\n\n@XMarker\nclass Foo\n\nclass Bar\n\ntypealias YBar = <!RECURSIVE_TYPEALIAS_EXPANSION!>ZBar<!>\ntypealias ZBar = <!RECURSIVE_TYPEALIAS_EXPANSION!>YBar<!>\n\nfun Foo.foo(body: Foo.() -> Unit) = body()\nfun Foo.zbar(<!OI;UNUSED_PARAMETER!>body<!>: <!RECURSIVE_TYPEALIAS_EXPANSION!>ZBar<!>.() -> Unit) = Bar().<!OI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>body<!>()\n\nfun test() {\n    Foo().foo {\n        zbar {\n            <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!> {}\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo(a: Any, f: ()->Int) = f()\nfun foo(a: Any, f: (Any)->Int) = f(a)\nfun foo(i: Int, f: Int.()->Int) = i.f()\n\nfun test1() {\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(1) { ->\n        <!NO_THIS!>this<!>\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport java.util.*;\n\nclass NotRange1() {\n\n}\n\nabstract class NotRange2() {\n  abstract operator fun iterator() : Unit\n}\n\nabstract class ImproperIterator1 {\n  abstract operator fun hasNext() : Boolean\n}\n\nabstract class NotRange3() {\n  abstract operator fun iterator() : ImproperIterator1\n}\n\nabstract class ImproperIterator2 {\n  abstract operator fun next() : Boolean\n}\n\nabstract class NotRange4() {\n  abstract operator fun iterator() : ImproperIterator2\n}\n\nabstract class ImproperIterator3 {\n  abstract <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun hasNext() : Int\n  abstract operator fun next() : Int\n}\n\nabstract class NotRange5() {\n  abstract operator fun iterator() : ImproperIterator3\n}\n\nabstract class AmbiguousHasNextIterator {\n  abstract operator fun hasNext() : Boolean\n  val hasNext : Boolean get() = false\n  abstract operator fun next() : Int\n}\n\nabstract class NotRange6() {\n  abstract operator fun iterator() : AmbiguousHasNextIterator\n}\n\nabstract class ImproperIterator4 {\n  val hasNext : Int get() = 1\n  abstract operator fun next() : Int\n}\n\nabstract class NotRange7() {\n  abstract operator fun iterator() : ImproperIterator3\n}\n\nabstract class GoodIterator {\n  abstract operator fun hasNext() : Boolean\n  abstract operator fun next() : Int\n}\n\nabstract class Range0() {\n  abstract operator fun iterator() : GoodIterator\n}\n\nabstract class Range1() {\n  abstract operator fun iterator() : Iterator<Int>\n}\n\nabstract class ImproperIterator5 {\n    abstract val String.hasNext : Boolean\n    abstract operator fun next() : Int\n}\n\nabstract class NotRange8() {\n    abstract operator fun iterator() : ImproperIterator5\n}\n\n\nfun test(notRange1: NotRange1, notRange2: NotRange2, notRange3: NotRange3, notRange4: NotRange4, notRange5: NotRange5, notRange6: NotRange6, notRange7: NotRange7, notRange8: NotRange8, range0: Range0, range1: Range1) {\n  for (i in <!ITERATOR_MISSING!>notRange1<!>);\n  for (i in <!HAS_NEXT_MISSING, NEXT_MISSING!>notRange2<!>);\n  for (i in <!NEXT_MISSING!>notRange3<!>);\n  for (i in <!HAS_NEXT_MISSING!>notRange4<!>);\n  for (i in <!HAS_NEXT_FUNCTION_TYPE_MISMATCH!>notRange5<!>);\n  for (i in notRange6);\n  for (i in <!HAS_NEXT_FUNCTION_TYPE_MISMATCH!>notRange7<!>);\n  for (i in <!HAS_NEXT_MISSING!>notRange8<!>);\n  for (i in range0);\n  for (i in range1);\n\n  for (i in (checkSubtype<List<Int>>(ArrayList<Int>())));\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION -UNREACHABLE_CODE -UNUSED_VARIABLE\n\n// FILE: 1.kt\npackage p1.yield\n\nimport p1.yield.yield\nimport p1.yield.foo\n\nval yield = 5\nfun foo(){}\n\nfun bar(yield: Int = 4) {}\n\nfun yield(yield: Int) {\n    \"$<!YIELD_IS_RESERVED!>yield<!>\"\n    \"${<!YIELD_IS_RESERVED!>yield<!>}\"\n\n    <!YIELD_IS_RESERVED!>yield<!>\n    val foo = <!YIELD_IS_RESERVED!>yield<!> + <!YIELD_IS_RESERVED!>yield<!>\n    val foo2 = <!YIELD_IS_RESERVED!>yield<!>\n\n    bar(<!OI;YIELD_IS_RESERVED!>yield<!> = 5)\n\n    yield(4)\n    <!YIELD_IS_RESERVED!>yield<!> {}\n\n    class yield<T: <!YIELD_IS_RESERVED!>yield<!><T>>\n\n    return@<!YIELD_IS_RESERVED!>yield<!>\n    return@<!YIELD_IS_RESERVED!>yield<!> Unit\n\n    val foo5: <!YIELD_IS_RESERVED!>yield<!><*>\n}\n\nfun yield(i: (Int) -> Unit) {}\n\n// FILE: 2.kt\n\npackage p2.yield\n\nimport p2.yield.yield\nimport p2.yield.foo\n\nval yield = 5\nfun foo(){}\n\nfun bar(yield: Int = 4) {}\n\nfun yield(yield: Int) {\n    \"$`yield`\"\n    \"${`yield`}\"\n\n    `yield`\n    val foo = `yield` + `yield`\n    val foo2 = `yield`\n\n    bar(`yield` = 5)\n\n    `yield`(4)\n    `yield` {}\n\n    class `yield`<T: `yield`<T>>\n\n    return@`yield`\n    return@`yield` Unit\n\n    val foo5: `yield`<*>\n}\n\nfun yield(i: (Int) -> Unit) {}\n"
        },
        {
            "code": "//FILE:a.kt\n//KT-1580 Can't access nested class/interface from other package\npackage lib\ninterface WithInner {\n    interface Inner {\n    }\n}\n\n//FILE:b.kt\npackage user\n\nimport lib.WithInner\n\nfun main(<!UNUSED_PARAMETER!>a<!> : WithInner, <!UNUSED_PARAMETER!>b<!> : WithInner.Inner) {\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n//FILE:file1.kt\npackage a\n\nprivate open class A {\n    fun bar() {}\n}\n\nprivate var x: Int = 10\n\nprivate fun foo() {}\n\nprivate fun bar() {\n    val y = x\n    x = 20\n}\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>makeA<!>() = A()\n\nprivate object PO {}\n\n//FILE:file2.kt\npackage a\n\nfun test() {\n    val y = makeA()\n    y.<!INVISIBLE_MEMBER(\"A\", \"private\", \"file\")!>bar<!>()\n    <!INVISIBLE_MEMBER(\"foo\", \"private\", \"file\")!>foo<!>()\n\n    val u : <!INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!> = <!INVISIBLE_MEMBER(\"A\", \"private\", \"file\")!>A<!>()\n\n    val z = <!INVISIBLE_MEMBER(\"x\", \"private\", \"file\")!>x<!>\n    <!INVISIBLE_MEMBER(\"x\", \"private\", \"file\")!>x<!> = 30\n\n    val po = <!INVISIBLE_MEMBER(\"PO\", \"private\", \"file\")!>PO<!>\n}\n\nclass B : <!EXPOSED_SUPER_CLASS!><!INVISIBLE_MEMBER(\"A\", \"private\", \"file\"), INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!>()<!> {}\n\nclass Q {\n    class W {\n        fun foo() {\n            val y = makeA() //assure that 'makeA' is visible\n        }\n    }\n}\n"
        },
        {
            "code": "//KT-37 Typechecker doesn't complain about accessing non-public property\npackage kt37\n\nclass C() {\n    private var f: Int\n\n    init {\n        f = 610\n    }\n}\n\nfun box(): String {\n    val c = C()\n    if (c.<!INVISIBLE_MEMBER!>f<!> != 610) return \"fail\"\n    return \"OK\"\n}"
        },
        {
            "code": "// NI_EXPECTED_FILE\n\npackage i\n\nval <T> List<T>.length = <!EXTENSION_PROPERTY_WITH_BACKING_FIELD, UNRESOLVED_REFERENCE!>size<!>\n\nval <T> List<T>.length1 : Int get() = size\n\nval String.bd = <!EXTENSION_PROPERTY_WITH_BACKING_FIELD!><!NO_THIS!>this<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> \"!\"<!>\n\nval String.bd1 : String get() = this + \"!\"\n\n\nclass A {\n    val ii : Int = 1\n}\n\nval A.foo = <!EXTENSION_PROPERTY_WITH_BACKING_FIELD, UNRESOLVED_REFERENCE!>ii<!>\n\nval A.foo1 : Int get() = ii\n\n\nclass C {\n    inner class D {}\n}\n\nval C.foo : C.D = <!EXTENSION_PROPERTY_WITH_BACKING_FIELD!><!UNRESOLVED_REFERENCE!>D<!>()<!>\n\nval C.bar : C.D = <!EXTENSION_PROPERTY_WITH_BACKING_FIELD!>C().D()<!>\n\nval C.foo1 : C.D get() = D()\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n//FILE:a.kt\npackage test_visibility\n\n<!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> class ProtectedClass\n<!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> interface ProtectedTrait\n\n<!WRONG_MODIFIER_TARGET!>protected<!> val protected_val : Int = 4\n<!WRONG_MODIFIER_TARGET!>protected<!> fun protected_fun() {}\n\nprivate val private_val : Int = 4\nprivate fun private_fun() {}\n\nval internal_val : Int = 34\nfun internal_fun() {}\n\nfun test1() {\n    private_fun();\n}\n\nclass Y {\n    fun test2() {\n        private_fun();\n    }\n}\n\nclass A {\n    private val i = 23\n    private val v: B = B()\n    private fun f(i: Int): B = B()\n\n    fun test() {\n        doSmth(i)\n    }\n}\n\nclass B {\n    fun bMethod() {}\n}\n\nfun test3(a: A) {\n    a.<!INVISIBLE_MEMBER(\"v\", \"private\", \"'A'\")!>v<!> //todo .bMethod()\n    a.<!INVISIBLE_MEMBER(\"f\", \"private\", \"'A'\")!>f<!>(0, <!TOO_MANY_ARGUMENTS!>1<!>) //todo .bMethod()\n}\n\ninterface T\n\nopen class C : T {\n    protected var i : Int = 34\n    fun test5() {\n        doSmth(i)\n    }\n}\n\nfun test4(c: C) {\n    c.<!INVISIBLE_MEMBER(\"i\", \"protected\", \"'C'\")!>i<!>++\n}\n\nclass D : C() {\n    val j = i\n    fun test6() {\n        doSmth(i)\n    }\n}\n\nclass E : C() {\n    fun test7() {\n        doSmth(i)\n    }\n}\n\nclass F : C() {\n    fun test8(c: C) {\n        doSmth(c.<!INVISIBLE_MEMBER!>i<!>)\n    }\n}\n\nclass G : T {\n    fun test8(c: C) {\n        doSmth(c.<!INVISIBLE_MEMBER(\"i\", \"protected\", \"'C'\")!>i<!>)\n    }\n}\n\nfun doSmth(i: Int) = i\n\n//FILE:b.kt\npackage test_visibility2\n\nimport test_visibility.*\n\nfun test() {\n    internal_fun()\n    <!INVISIBLE_MEMBER(\"private_fun\", \"private\", \"file\")!>private_fun<!>()\n}\n"
        },
        {
            "code": "// FILE: root.kt\nfun testFun() = \"239\"\n\n// FILE: otherPackage.kt\npackage test\n\nfun testFun() = 12\n\n// FILE: using.kt\nimport test.*\n\nval t: String = testFun()\n"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nval v = 1\nfun f() = 1\n\n// FILE: b.kt\npackage b\n\nval v = 1\nfun f() = 1\n\n// FILE: main.kt\nimport a.*\nimport b.*\n\nval vv = <!OVERLOAD_RESOLUTION_AMBIGUITY!>v<!>\nval ff = <!OVERLOAD_RESOLUTION_AMBIGUITY!>f<!>()\n"
        },
        {
            "code": "package b\n\nopen class A {\n    internal open fun foo() {}\n}\n\nclass B : A() {\n    <!CANNOT_CHANGE_ACCESS_PRIVILEGE!>protected<!> override fun foo() {}\n}\n\nclass C : A() {\n    internal override fun foo() {}\n}\n\n//------------\nopen class D {\n    <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>open<!> fun self() : D = this\n}\n\nclass E : D() {\n    internal <!CANNOT_OVERRIDE_INVISIBLE_MEMBER!>override<!> fun self() = this\n\n    fun test() {\n        val <!UNUSED_VARIABLE!>s<!> : E = self()\n    }\n}\n\n//------------\nopen class F {\n    protected open fun protected_fun() {}\n}\n\nclass G : F() {\n    override fun protected_fun() {}\n}\n\nfun test_fun_stays_protected(g: G) {\n    g.<!INVISIBLE_MEMBER!>protected_fun<!>()\n}\n\n//------------\nopen class H {\n    protected open fun pi_fun() {}\n}\n\nclass I : H() {\n    protected override fun pi_fun() {}\n}\n\nclass J : H() {\n    <!CANNOT_CHANGE_ACCESS_PRIVILEGE!>internal<!> override fun pi_fun() {}\n}\n\nclass K : H() {\n    public override fun pi_fun() {}\n}\n\n//-------------\ninterface T {\n    public fun foo() {}\n}\n\nopen class L : T {\n    override fun foo() {}\n}\n\nclass M : L() {\n    <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>internal<!> override fun foo() {}\n}\n//---------------\ninterface R {\n    fun foo() {}\n}\n\ninterface P : R {\n    override fun foo() {}\n}\n\ninterface Q : R {\n    override fun foo() {}\n}\n\nclass S : P, Q {\n    <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>internal<!> override fun foo() {}\n}"
        },
        {
            "code": "open class A {\n    protected fun foo() {}\n}\n\nclass B: A()\n\nclass C: A() {\n    fun bar() {\n        A().<!INVISIBLE_MEMBER!>foo<!>()\n        B().<!INVISIBLE_MEMBER!>foo<!>()\n    }\n}\n\nclass D {\n    fun qux() { B().<!INVISIBLE_MEMBER!>foo<!>() }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: module1/AbstractModule.java\npackage module1;\n\npublic abstract class AbstractModule<S> {\n    protected <T> S bind(Class<T> clazz) { return null; }\n}\n\n// FILE: module2/main.kt\npackage module2\n\nimport module1.*\n\nfun <T> javaClass(): Class<T> = null!!\n\npublic class AppServiceModule : AbstractModule<String>() {\n    inline fun <reified T> AbstractModule<Int>.bind() {\n        val x = <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>bind<!>(javaClass<T>())\n\n        x checkType { _<String>() } // check that Class receiver is used instead of extension one\n    }\n}\n"
        },
        {
            "code": "open class Base {\n    open protected fun foo() {}\n    open protected fun bar() {}\n\n    open protected var x: Int = 1\n    open var y: Int = 1\n        protected set\n}\n\nclass Derived : Base() {\n    override fun bar() { }\n\n    protected fun baz(x: Base) {\n        x.<!INVISIBLE_MEMBER!>foo<!>()\n        x.<!INVISIBLE_MEMBER!>bar<!>()\n\n        x.<!INVISIBLE_MEMBER!>x<!> = x.<!INVISIBLE_MEMBER!>x<!> + 1\n        <!INVISIBLE_SETTER!>x.y<!> = x.y + 1\n\n        if (x is Derived) {\n            <!DEBUG_INFO_SMARTCAST!>x<!>.foo()\n            <!DEBUG_INFO_SMARTCAST!>x<!>.bar()\n            <!DEBUG_INFO_SMARTCAST!>x<!>.baz(x)\n\n            <!DEBUG_INFO_SMARTCAST!>x<!>.x = <!DEBUG_INFO_SMARTCAST!>x<!>.x + 1\n            // TODO: Should be smart cast\n            <!INVISIBLE_SETTER!>x.y<!> = x.y + 1\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class A protected constructor(x: Int) {\n    protected constructor() : this(1)\n    protected constructor(x: String) : this(2)\n    public constructor(x: Double) : this(3)\n}\n\nfun foo() {\n    <!INVISIBLE_MEMBER!>A<!>()\n    A(1.0)\n}\n\nclass B1 : A(1) {}\nclass B2 : A() {}\nclass B3 : A(\"\") {}\n\nclass B4 : A {\n    constructor() : super(1)\n    constructor(x: Int) : super()\n    constructor(x: Int, y: Int) : super(\"\")\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\nopen class BaseOuter {\n    protected fun foo() = 1\n    protected fun bar() { }\n}\n\nclass Foo(var base: BaseOuter)\n\nfun BaseOuter.foo(): String = \"\"\n\nclass Derived : BaseOuter() {\n    fun test(foo: Foo) {\n        if (foo.base is Derived) {\n            foo.base.foo() checkType { _<String>() } // Resolved to extension\n            <!OI;SMARTCAST_IMPOSSIBLE!>foo.base<!>.<!NI;INVISIBLE_MEMBER!>bar<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "abstract class A<T : Any> {\n    abstract protected fun T.foo()\n\n    fun bar(x: T?) {\n        if (x != null) {\n            <!DEBUG_INFO_SMARTCAST!>x<!>.foo()\n        }\n    }\n}\n"
        },
        {
            "code": "// FILE: abc/A.java\npackage abc;\npublic class A {\n    public int getAbc() {}\n    protected int getFoo() { return 1; }\n\n    public String getBar() { return \"\"; }\n    protected void setBar(String x) {  }\n}\n\n// FILE: main.kt\nimport abc.A\n\nclass Data(var x: A)\n\nclass B : A() {\n    fun baz(a: A, b: B, d: Data) {\n        foo\n        bar = bar + \"\"\n\n        b.foo\n        b.bar = b.bar + \"\"\n\n        a.<!INVISIBLE_MEMBER!>foo<!>\n        // TODO: should be INVISIBLE_SETTER\n        a.bar = a.bar + \"\"\n\n        if (a is B) {\n            <!DEBUG_INFO_SMARTCAST!>a<!>.foo\n            <!DEBUG_INFO_SMARTCAST!>a<!>.bar = <!DEBUG_INFO_SMARTCAST!>a<!>.bar + \"\"\n        }\n\n        if (d.x is B) {\n            d.x.abc // Ok\n            d.x.<!INVISIBLE_MEMBER!>foo<!>\n            // TODO: should be INVISIBLE_SETTER\n            d.x.bar = d.x.bar + \"\"\n        }\n    }\n}\n\nfun baz(a: A) {\n    a.<!INVISIBLE_MEMBER!>foo<!>\n    <!INVISIBLE_SETTER!>a.bar<!> = a.bar + \"\"\n}\n"
        },
        {
            "code": "open class A {\n    open protected fun foo() { }\n    open protected fun foobaz() { }\n\n    fun bar(x: B) {\n        x.foo() // OK, foo declared in A\n        x.<!INVISIBLE_MEMBER!>baz<!>() // Declared in B\n        x.<!INVISIBLE_MEMBER!>foobaz<!>() // Declared in B\n    }\n}\n\nclass B : A() {\n    protected fun baz() {}\n    override fun foobaz() {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class A protected constructor(x: Int) {\n    protected constructor() : this(1)\n    public constructor(x: Double) : this(3)\n}\n\nclass B4 : A(1) {\n    init {\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>()\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>(1)\n        A(5.0)\n    }\n\n    fun foo() {\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>()\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>(1)\n        A(5.0)\n\n        object : A() {}\n        object : A(1) {}\n        object : A(5.0) {}\n\n        class Local : A()\n    }\n}\n"
        },
        {
            "code": "// FILE: p1/BaseClass.java\n\npackage p1;\n\npublic class BaseClass {\n    protected class ProtSubClass {\n        public ProtSubClass() {}\n    }\n}\n\n// FILE: k1/main.kt\npackage k1\n\nimport p1.BaseClass\n\nclass Foo : BaseClass() {\n\n    fun foo() {\n        ProtSubClass()\n        super.ProtSubClass()\n    }\n\n    private val v1: BaseClass.ProtSubClass = ProtSubClass()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: abc/A.java\npackage abc;\npublic class A {\n    protected void foo(Runnable x) {}\n}\n\n// FILE: main.kt\nimport abc.A;\n\nclass Data(var x: A)\n\nclass B : A() {\n    fun baz(a: A, b: B, d: Data) {\n        a.<!INVISIBLE_MEMBER!>foo<!> { }\n\n        b.foo { }\n\n        if (a is B) {\n            <!DEBUG_INFO_SMARTCAST!>a<!>.foo {}\n        }\n\n        if (d.x is B) {\n            <!SMARTCAST_IMPOSSIBLE!>d.x<!>.<!NI;INVISIBLE_MEMBER!>foo<!> {}\n        }\n    }\n}\n\nfun baz(a: A) {\n    a.<!INVISIBLE_MEMBER!>foo<!> { }\n}\n"
        },
        {
            "code": "// FILE: bar/JavaClass.java\n\npackage bar;\n\npublic class JavaClass {\n    protected void foo() {}\n    protected static void bar1() {}\n    protected static void bar2() {}\n\n    protected String field = \"\";\n    protected static String CONST1 = \"\";\n    protected static String CONST2 = \"\";\n\n}\n\n// FILE: foo/JavaClassSamePackage.java\npackage foo;\n\npublic class JavaClassSamePackage extends bar.JavaClass {\n    protected static void bar2() {}\n    protected static String CONST2 = \"\";\n}\n\n// FILE: foo/main.kt\npackage foo\n\nimport bar.JavaClass\n\nclass KotlinClass : JavaClass() {\n    fun baz() {\n        foo() // OK\n    }\n}\n\nclass KotlinClass2 : JavaClass() {\n    override fun foo() {}\n\n    val field: String = \"abc\"\n}\n\nfun test(a: KotlinClass, b: KotlinClass2) {\n    a.<!INVISIBLE_MEMBER!>foo<!>() // Error, protected_and_package declared in different package\n    b.<!INVISIBLE_MEMBER!>foo<!>() // Error, protected visibility in same package (but could be protected_and_package)\n\n    a.<!INVISIBLE_MEMBER!>field<!>\n\n    JavaClass.<!INVISIBLE_MEMBER!>bar1<!>()\n    JavaClass.<!INVISIBLE_MEMBER!>CONST1<!>\n\n    KotlinClass.<!UNRESOLVED_REFERENCE!>bar1<!>() // Currently it's unresolved, but it should be prohibited even in case it would be resolved\n    KotlinClass.<!UNRESOLVED_REFERENCE!>CONST1<!>\n\n    JavaClassSamePackage.<!INVISIBLE_MEMBER!>bar1<!>()\n    JavaClassSamePackage.bar2()\n\n    JavaClassSamePackage.<!INVISIBLE_MEMBER!>CONST1<!>\n    JavaClassSamePackage.CONST2\n}\n"
        },
        {
            "code": "open class A {\n    protected fun foo() {}\n\n    init {\n        B.foo() // Ok, receiver (B.Companion) is subtype of A\n        (B.Companion).foo()\n    }\n}\n\nclass B {\n    companion object : A()\n}\n\nclass C: A() {\n    init {\n        B.<!INVISIBLE_MEMBER!>foo<!>() // Error: receiver is not suitable\n    }\n}\n"
        },
        {
            "code": "open class BaseClass() {\n    protected class Nested(val x: Int, protected val y: Int)\n\n    protected fun foo() = Nested(1, 2)\n}\n\nclass Foo : BaseClass() {\n    fun bar() {\n        val f = foo()\n        f.x\n        f.<!INVISIBLE_MEMBER!>y<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: abc/A.java\npackage abc;\npublic class A {\n    protected A() {}\n    protected A(int x) {}\n    public A(double x) {}\n}\n\n// FILE: main.kt\nimport abc.*\n\nclass B4 : A(1) {\n    init {\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>()\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>(1)\n        A(5.0)\n    }\n\n    fun foo() {\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>()\n        <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>A<!>(1)\n        A(5.0)\n\n        object : A() {}\n        object : A(1) {}\n        object : A(5.0) {}\n\n        class Local : A()\n    }\n}\n"
        },
        {
            "code": "package d\n\n//import from objects before properties resolve\n\nimport d.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>A<!>.*\nimport d.M.R\nimport d.M.R.bar\nimport d.M.T\nimport d.M.Y\n\nvar r: T = T()\nval y: T = Y\n\nfun f() {\n    bar()\n    R.bar()\n    <!UNRESOLVED_REFERENCE!>B<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n}\n\nobject M {\n    object R {\n        fun bar() {}\n    }\n    open class T() {}\n\n    object Y : T() {}\n}\n\nobject A {\n    object B {\n        fun foo() {}\n    }\n}"
        },
        {
            "code": "//FILE:a.kt\n//KT-1642 kotlin subpackages hide Java's toplevel packages\npackage a.java\n\n//FILE:b.kt\n//+JDK\npackage a\n\nimport java.util.ArrayList"
        },
        {
            "code": "//KT-1248 Control visibility of overrides needed\npackage kt1248\n\ninterface ParseResult<out T> {\n    public val success : Boolean\n    public val value : T\n}\n\nclass Success<T>(<!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>internal<!> override val value : T) : ParseResult<T> {\n    <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>internal<!> override val success : Boolean = true\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class S(\n        n: A.Nested,\n        n2: A.Nested,\n        inn: A.Inner,\n        c: Int,\n        cc: Int,\n        cn: Int,\n        ci: Int,\n        t1: Int,\n        t2: Int\n)\n\nclass A : S (\n    foo(),\n    Nested(),\n    <!RESOLUTION_TO_CLASSIFIER!>Inner<!>(),\n    CONST,\n    Companion.CONST,\n    Nested.CONST,\n    Interface.CONST,\n    <!UNRESOLVED_REFERENCE!>a<!>,\n    <!UNRESOLVED_REFERENCE!>b<!>()\n) {\n\n    class Nested {\n        companion object {\n            const val CONST = 2\n        }\n    }\n\n    inner class Inner\n\n    interface Interface {\n        companion object {\n            const val CONST = 3\n        }\n    }\n\n    val a = 1\n    fun b() = 2\n\n    companion object {\n        const val CONST = 1\n        fun foo(): Nested = null!!\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface I\n\nopen class S(\n        n: A.Nested,\n        n2: A.Nested,\n        inn: A.Inner,\n        c: Int,\n        cc: Int,\n        cn: Int,\n        ci: Int,\n        t1: Int,\n        t2: Int\n) : I\n\nclass A : I by S(\n        foo(),\n        Nested(),\n        <!RESOLUTION_TO_CLASSIFIER!>Inner<!>(),\n        CONST,\n        Companion.CONST,\n        Nested.CONST,\n        Interface.CONST,\n        <!UNRESOLVED_REFERENCE!>a<!>,\n        <!UNRESOLVED_REFERENCE!>b<!>()\n) {\n\n    class Nested {\n        companion object {\n            const val CONST = 2\n        }\n    }\n\n    inner class Inner\n\n    interface Interface {\n        companion object {\n            const val CONST = 3\n        }\n    }\n\n    val a = 1\n    fun b() = 2\n\n    companion object {\n        const val CONST = 1\n        fun foo(): Nested = null!!\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A(\n        n: Nested = foo(),\n        n2: Nested = Nested(),\n        inn: Inner = null!!,\n        inn2: Inner = <!RESOLUTION_TO_CLASSIFIER!>Inner<!>(),\n        i: Interface = null!!,\n        c: Int = CONST,\n        cc: Int = Companion.CONST,\n        cn: Int = Nested.CONST,\n        ci: Int = Interface.CONST,\n        t1: Int = <!UNRESOLVED_REFERENCE!>a<!>,\n        t2: Int = <!UNRESOLVED_REFERENCE!>b<!>()\n) {\n\n    constructor(\n            dummy: Int,\n            n: Nested = foo(),\n            n2: Nested = Nested(),\n            inn: Inner = null!!,\n            inn2: Inner = <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>Inner<!>(),\n            i: Interface = null!!,\n            c: Int = CONST,\n            cc: Int = Companion.CONST,\n            cn: Int = Nested.CONST,\n            ci: Int = Interface.CONST,\n            t1: Int = <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>a<!>,\n            t2: Int = <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>b<!>()\n    ) : this(\n        foo(),\n        Nested(),\n        inn,\n        <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>Inner<!>(),\n        i,\n        CONST,\n        Companion.CONST,\n        Nested.CONST,\n        Interface.CONST,\n        <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>a<!>,\n        <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>b<!>()\n    )\n\n    class Nested {\n        companion object {\n            const val CONST = 2\n        }\n    }\n\n    inner class Inner\n\n    interface Interface {\n        companion object {\n            const val CONST = 3\n        }\n    }\n\n    val a = 1\n    fun b() = 2\n\n    companion object {\n        const val CONST = 1\n        fun foo(): Nested = null!!\n    }\n}\n"
        },
        {
            "code": "open class S(val a: Any, val b: Any, val c: Any) {}\n\nobject A : S(<!UNRESOLVED_REFERENCE!>prop1<!>, <!UNRESOLVED_REFERENCE!>prop2<!>, <!UNRESOLVED_REFERENCE!>func<!>()) {\n    val prop1 = 1\n    val prop2: Int\n        get() = 1\n    fun func() {}\n}\n"
        },
        {
            "code": "interface I<F, G>\n\nval aImpl: A.Companion.Interface\n    get() = null!!\n\nval bImpl: B.Companion.Interface\n    get() = null!!\n\ninterface A {\n    companion object : <!UNRESOLVED_REFERENCE!>Nested<!>(), <!DELEGATION_NOT_TO_INTERFACE, UNRESOLVED_REFERENCE!>Interface<!> by aImpl, I<<!UNRESOLVED_REFERENCE!>Nested<!>, <!UNRESOLVED_REFERENCE!>Interface<!>> {\n\n        class Nested\n\n        interface Interface\n    }\n}\n\nclass B {\n    companion object : <!UNRESOLVED_REFERENCE!>Nested<!>(), <!DELEGATION_NOT_TO_INTERFACE, UNRESOLVED_REFERENCE!>Interface<!> by aImpl, I<<!UNRESOLVED_REFERENCE!>Nested<!>, <!UNRESOLVED_REFERENCE!>Interface<!>> {\n\n        class Nested\n\n        interface Interface\n    }\n}\n"
        },
        {
            "code": "open class S(val a: Any, val b: Any, val c: Any) {}\n\ninterface A {\n    companion object : S(<!UNRESOLVED_REFERENCE!>prop1<!>, <!UNRESOLVED_REFERENCE!>prop2<!>, <!UNRESOLVED_REFERENCE!>func<!>()) {\n        val prop1 = 1\n        val prop2: Int\n            get() = 1\n        fun func() {}\n    }\n}\n\nclass B {\n    companion object : S(<!UNRESOLVED_REFERENCE!>prop1<!>, <!UNRESOLVED_REFERENCE!>prop2<!>, <!UNRESOLVED_REFERENCE!>func<!>()) {\n        val prop1 = 1\n        val prop2: Int\n            get() = 1\n        fun func() {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.*\n\nannotation class Ann(\n        val kc1: KClass<*>,\n        val kc2: KClass<*>,\n        val kc3: KClass<*>,\n        val c: Int,\n        val cc: Int,\n        val cn: Int,\n        val ci: Int,\n        val t1: Int,\n        val t2: Int\n)\n\n@Ann(\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>Nested<!>::class<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>Inner<!>::class<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>Interface<!>::class<!>,\n        <!UNRESOLVED_REFERENCE!>CONST<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>Companion<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>CONST<!><!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>Nested<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>CONST<!><!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>Interface<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>CONST<!><!>,\n        <!UNRESOLVED_REFERENCE!>a<!>,\n        <!UNRESOLVED_REFERENCE!>b<!>()\n)\nclass A {\n\n    class Nested {\n        companion object {\n            const val CONST = 2\n        }\n    }\n\n    inner class Inner\n\n    interface Interface {\n        companion object {\n            const val CONST = 3\n        }\n    }\n\n    val a = 1\n    fun b() = 2\n\n    companion object {\n        const val CONST = 1\n        fun foo(): Nested = null!!\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.*\n\nannotation class Ann(\n        val kc1: KClass<*>,\n        val kc2: KClass<*>,\n        val kc3: KClass<*>,\n        val c: Int,\n        val cc: Int,\n        val cn: Int,\n        val ci: Int,\n        val t1: Int,\n        val t2: Int\n)\n\nclass A\n@Ann(\n        Nested::class,\n        Inner::class,\n        Interface::class,\n        CONST,\n        Companion.CONST,\n        Nested.CONST,\n        Interface.CONST,\n        <!UNRESOLVED_REFERENCE!>a<!>,\n        <!UNRESOLVED_REFERENCE!>b<!>()\n)\nconstructor() {\n\n    @Ann(\n            Nested::class,\n            Inner::class,\n            Interface::class,\n            CONST,\n            Companion.CONST,\n            Nested.CONST,\n            Interface.CONST,\n            <!UNRESOLVED_REFERENCE!>a<!>,\n            <!UNRESOLVED_REFERENCE!>b<!>()\n    )\n    constructor(dummy: Int) : this()\n\n    class Nested {\n        companion object {\n            const val CONST = 2\n        }\n    }\n\n    inner class Inner\n\n    interface Interface {\n        companion object {\n            const val CONST = 3\n        }\n    }\n\n    val a = 1\n    fun b() = 2\n\n    companion object {\n        const val CONST = 1\n        fun foo(): Nested = null!!\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface I<F, G, H>\n\nclass A(impl: Interface) : <!UNRESOLVED_REFERENCE!>Nested<!>(), <!DELEGATION_NOT_TO_INTERFACE, UNRESOLVED_REFERENCE!>Interface<!> by impl, <!UNRESOLVED_REFERENCE!>Inner<!>, I<<!UNRESOLVED_REFERENCE!>Nested<!>, <!UNRESOLVED_REFERENCE!>Interface<!>, <!UNRESOLVED_REFERENCE!>Inner<!>> {\n\n    class Nested\n\n    inner class Inner\n\n    interface Interface\n}\n"
        },
        {
            "code": "interface I<F, G>\n\nval aImpl: A.Interface\n    get() = null!!\n\nobject A : <!UNRESOLVED_REFERENCE!>Nested<!>(), <!DELEGATION_NOT_TO_INTERFACE, UNRESOLVED_REFERENCE!>Interface<!> by aImpl, I<<!UNRESOLVED_REFERENCE!>Nested<!>, <!UNRESOLVED_REFERENCE!>Interface<!>> {\n\n    class Nested\n\n    interface Interface\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class S(\n        n: A.Nested,\n        n2: A.Nested,\n        inn: A.Inner,\n        c: Int,\n        cc: Int,\n        cn: Int,\n        ci: Int,\n        t1: Int,\n        t2: Int\n)\n\nclass A : S {\n\n    constructor() : super(\n            foo(),\n            Nested(),\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>Inner<!>(),\n            CONST,\n            Companion.CONST,\n            Nested.CONST,\n            Interface.CONST,\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL, UNINITIALIZED_VARIABLE!>a<!>,\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>b<!>()\n    )\n\n    class Nested {\n        companion object {\n            const val CONST = 2\n        }\n    }\n\n    inner class Inner\n\n    interface Interface {\n        companion object {\n            const val CONST = 3\n        }\n    }\n\n    val a = 1\n    fun b() = 2\n\n    companion object {\n        const val CONST = 1\n        fun foo(): Nested = null!!\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T : <!UNRESOLVED_REFERENCE!>Nested<!>, F: <!UNRESOLVED_REFERENCE!>Inner<!>, G: <!UNRESOLVED_REFERENCE!>Interface<!>> {\n\n    class Nested\n\n    inner class Inner\n\n    interface Interface\n}\n\nclass B<T, F, G> where T : <!UNRESOLVED_REFERENCE!>Nested<!>, F: <!UNRESOLVED_REFERENCE!>Inner<!>, G: <!UNRESOLVED_REFERENCE!>Interface<!> {\n\n    class Nested\n\n    inner class Inner\n\n    interface Interface\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// JAVAC_EXPECTED_FILE\n//FILE:a.kt\npackage a\n\nprivate open class A {\n    fun bar() {}\n}\n\nprivate fun foo() {}\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>makeA<!>() = A()\n\nprivate object PO {}\n\n//FILE:b.kt\n//+JDK\npackage b\n\nimport a.<!INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!>\nimport a.<!INVISIBLE_REFERENCE(\"foo\", \"private\", \"file\")!>foo<!>\nimport a.makeA\nimport a.<!INVISIBLE_REFERENCE(\"PO\", \"private\", \"file\")!>PO<!>\n\nfun test() {\n    val y = makeA()\n    y.<!INVISIBLE_MEMBER(\"A\", \"private\", \"file\")!>bar<!>()\n    <!INVISIBLE_MEMBER(\"foo\", \"private\", \"file\")!>foo<!>()\n\n    val u : <!INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!> = <!INVISIBLE_MEMBER(\"A\", \"private\", \"file\")!>A<!>()\n    val a : java.util.Arrays.<!INVISIBLE_REFERENCE(\"ArrayList\", \"private\", \"'Arrays'\")!>ArrayList<!><Int>;\n\n    val po = <!INVISIBLE_MEMBER(\"PO\", \"private\", \"file\")!>PO<!>\n}\n\nclass B : <!EXPOSED_SUPER_CLASS!><!INVISIBLE_MEMBER(\"A\", \"private\", \"file\"), INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!>()<!> {}\n\nclass Q {\n    class W {\n        fun foo() {\n            val y = makeA() //assure that 'makeA' is visible\n        }\n    }\n}\n\n//check that 'toString' can be invoked without specifying return type\nclass NewClass : java.util.ArrayList<<!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Integer<!>>() {\n    public override fun toString() = \"a\"\n}\n"
        },
        {
            "code": "class A<T> {\n    public var x: Int = 0\n        private set\n}\n\nfun main() {\n    val a = A<Any>()\n    <!INVISIBLE_SETTER!>a.x<!> = 1\n}"
        },
        {
            "code": "//KT-1822 Error 'cannot infer visibility' required\npackage kt1822\n\nopen class C {\n    internal open fun foo() {}\n}\n\ninterface T {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> fun foo() {}\n}\n\nclass G : C(), T {\n    <!CANNOT_INFER_VISIBILITY!>override fun foo()<!> {} //should be an error \"cannot infer visibility\"; for now 'public' is inferred in such cases\n}\n\nopen class A {\n    internal open fun foo() {}\n}\n\ninterface B {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> fun foo() {}\n}\n\ninterface D {\n    public fun foo() {}\n}\n\nclass E : A(), B, D {\n    override fun foo() {}\n}"
        },
        {
            "code": "// FILE: root.kt\nfun testFun() = 12\n\n// FILE: otherPackage.kt\npackage test\n\nfun testFun() = 12\n\n// FILE: using.kt\npackage test\n\nval t = testFun()\n"
        },
        {
            "code": "//KT-151 Inherit visibility when overriding\npackage kt151\n\nopen class A {\n    protected open fun x() {}\n}\n\nclass B : A() {\n    override fun x() {} // No visibility modifier required\n}\n\nfun test(b: B) {\n    b.<!INVISIBLE_MEMBER!>x<!>()\n}\n\n\n//more tests\nopen class C {\n    internal open fun foo() {}\n}\n\ninterface T {\n    fun foo() {}\n}\n\nclass D : C(), T {\n    <!CANNOT_CHANGE_ACCESS_PRIVILEGE!>protected<!> override fun foo() {}\n}\n\nclass E : C(), T {\n    <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>internal<!> override fun foo() {}\n}\n\nclass F : C(), T {\n    <!CANNOT_WEAKEN_ACCESS_PRIVILEGE, INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>override<!> fun foo() {}\n}\n\nclass G : C(), T {\n    public override fun foo() {}\n}"
        },
        {
            "code": "//FILE:a.kt\n//KT-1080 Don't use previously imported packages while resolving import references\n\npackage kt1080\n\nimport <!UNRESOLVED_REFERENCE!>reflect<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Constructor<!>\n\nimport b.*\nimport <!UNRESOLVED_REFERENCE!>d<!>\nimport <!UNRESOLVED_REFERENCE!>d<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Test<!>\nimport b.<!PACKAGE_CANNOT_BE_IMPORTED!>d<!>\n\nclass Some: <!UNRESOLVED_REFERENCE!>Test<!>()\n\n//FILE:b.kt\n\npackage b.d\n\npublic open class Test"
        },
        {
            "code": "package c\n\ninterface B {\n    fun bar() {}\n}\n\nclass C() {\n    fun bar() {\n    }\n}\n\nfun test(a : Any?) {\n    if (a is B) {\n        if (a is C) {\n            <!DEBUG_INFO_SMARTCAST!>a<!>.bar();\n        }\n    }\n}\n\nfun Any?.bar() {}\n"
        },
        {
            "code": "//KT-323 Handle visibility interactions with overriding\npackage kt323\n\nopen class A {\n    open var a : Int = 0\n}\n\nclass B : A() {\n    override <!VAR_OVERRIDDEN_BY_VAL!>val<!> a = 34\n\n    var b : Int\n        <!REDUNDANT_MODIFIER_IN_GETTER!>public<!> get() = 23\n        set(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n    protected var c : Int\n        get() = 23\n        private set(<!UNUSED_PARAMETER!>i<!>: Int) {}\n}"
        },
        {
            "code": "fun devNull(<!UNUSED_PARAMETER!>obj<!>: Any?) {}\n\nopen class A {\n    companion object {\n        val internal_val = 1\n        public val public_val: Int = 2\n        private val private_val = 3\n        protected val protected_val: Int = 5\n    }\n\n    fun fromClass() {\n        devNull(internal_val)\n        devNull(public_val)\n        devNull(private_val)\n        devNull(protected_val)\n    }\n}\n\nfun fromOutside() {\n    devNull(A.internal_val)\n    devNull(A.public_val)\n    devNull(A.<!INVISIBLE_MEMBER!>private_val<!>)\n    devNull(A.<!INVISIBLE_MEMBER!>protected_val<!>)\n}\n\nclass B: A() {\n    fun fromSubclass() {\n        devNull(A.internal_val)\n        devNull(A.public_val)\n        devNull(A.<!INVISIBLE_MEMBER!>private_val<!>)\n        devNull(A.<!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>protected_val<!>)\n    }\n}"
        },
        {
            "code": "//FILE:a.kt\n//KT-900 Inaccessible class should be unresolved\n\npackage a\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>b<!> : <!UNRESOLVED_REFERENCE!>B<!> = <!UNRESOLVED_REFERENCE!>B<!>() //only B() is unresolved, but in \": B\" and \"B.foo()\" B should also be unresolved\n    <!UNRESOLVED_REFERENCE!>B<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n\n    <!UNRESOLVED_REFERENCE!>P<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n\n    <!UNRESOLVED_REFERENCE!>M<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n}\n\nclass A() {\n    companion object {\n        class B() {\n            companion object {\n                fun foo() {}\n            }\n        }\n\n        object P {\n            fun foo() {}\n        }\n    }\n}\n\nobject N {\n    object M {\n        fun bar() {}\n    }\n}\n\n//FILE:b.kt\npackage b\n\nimport b.N.M\nimport b.A.Companion.P\nimport b.A.Companion.B\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>b<!> : B = B()\n    B.foo()\n\n    P.foo()\n\n    M.bar()\n}\n\nclass A() {\n    companion object {\n        class B() {\n            companion object {\n                fun foo() {}\n            }\n        }\n\n        object P {\n            fun foo() {}\n        }\n    }\n}\n\nobject N {\n    object M {\n        fun bar() {}\n    }\n}"
        },
        {
            "code": "//KT-1738 Make it possible to define visibility for constructor parameters which become properties\n\npackage kt1738\n\nclass A(private var i: Int, var j: Int) {\n}\n\nfun test(a: A) {\n    a.<!INVISIBLE_MEMBER!>i<!>++\n    a.j++\n}"
        },
        {
            "code": "//FILE:a.kt\n//KT-1579 Can't import nested class/interface\npackage lib\ninterface WithInner {\n    interface Inner {\n    }\n}\n//FILE:b.kt\npackage user\nimport lib.WithInner.Inner"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\n// FILE: 1.kt\nopen class A {\n    class Y {\n        fun A_Y() {}\n    }\n\n    companion object {\n        class Z {\n            fun A_C_Z() {}\n        }\n    }\n}\n\n// FILE: 2.kt\nclass E: B() {\n    init {\n        Y().B_Y()\n        Y().<!UNRESOLVED_REFERENCE!>A_Y<!>()\n\n        Z().B_Z()\n        Z().<!UNRESOLVED_REFERENCE!>A_C_Z<!>()\n    }\n}\n\nclass Y: C() {\n    init {\n        Y().A_Y()\n\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Z()<!>.A_C_Z()\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\n\nfun foo() = \"\"\n\nclass C: B() {\n    init {\n        val <!UNUSED_VARIABLE!>a<!>: Int = foo()\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\nopen class B: A()\n\n// FILE: 2.kt\nclass D: C() {\n    init {\n        foo()\n        A.foo()\n        B.<!UNRESOLVED_REFERENCE!>foo<!>()\n        C.foo()\n        D.<!UNRESOLVED_REFERENCE!>foo<!>()\n\n        bar()\n        C.bar()\n        D.<!UNRESOLVED_REFERENCE!>bar<!>()\n    }\n}\n"
        },
        {
            "code": "// FILE: K.kt\n\nopen class K : C(), I\n\n// FILE: test.kt\n\nfun test() {\n    I.a\n\n    C.a\n    C.b\n    C.bar()\n\n    K.<!UNRESOLVED_REFERENCE!>a<!>\n    K.<!UNRESOLVED_REFERENCE!>b<!>\n    K.<!UNRESOLVED_REFERENCE!>bar<!>()\n\n    D.a\n    D.b\n    D.c\n    D.bar()\n    D.baz()\n\n    E.a\n    E.b\n    E.c\n    E.bar()\n    E.baz()\n}\n"
        },
        {
            "code": "// FILE: K.kt\n\nopen class K : C()\n\n// FILE: test.kt\n\nfun test() {\n    I.a\n\n    C.a\n    C.b\n    C.bar()\n\n    K.<!UNRESOLVED_REFERENCE!>a<!>\n    K.<!UNRESOLVED_REFERENCE!>b<!>\n    K.<!UNRESOLVED_REFERENCE!>bar<!>()\n\n    D.a\n    D.b\n    D.c\n    D.bar()\n    D.baz()\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun test() {\n    A.field\n    B.field\n\n    E.<!OVERLOAD_RESOLUTION_AMBIGUITY!>field<!>\n    O.field\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: 1.kt\n\nfun foo() = \"\"\n\nclass B: A() {\n    init {\n        val a: Int = foo()\n    }\n}\n\n// FILE: 2.kt\nfun test() {\n    fun foo() = \"\"\n\n    class B: A() {\n        init {\n            val a: Int = <!TYPE_MISMATCH!>foo()<!> // todo\n        }\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\nopen class X: A() {\n    init {\n        foo()\n        A.foo()\n    }\n}\n\nopen class Y: B() {\n    init {\n        foo()\n        A.foo()\n        B.foo()\n\n        bar()\n        B.bar()\n    }\n}\n\nclass XN: X() {\n    init {\n        foo()\n        A.foo()\n        X.<!UNRESOLVED_REFERENCE!>foo<!>()\n        XN.<!UNRESOLVED_REFERENCE!>foo<!>()\n    }\n}\n\nclass YN: Y() {\n    init {\n        foo()\n        A.foo()\n        Y.<!UNRESOLVED_REFERENCE!>foo<!>()\n        YN.<!UNRESOLVED_REFERENCE!>foo<!>()\n\n        bar()\n        B.bar()\n        Y.<!UNRESOLVED_REFERENCE!>bar<!>()\n        YN.<!UNRESOLVED_REFERENCE!>bar<!>()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\nopen class A {\n    companion object : J() {\n        fun bar() {}\n    }\n}\n\nclass B : J2() {\n    init {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n        boo()\n    }\n\n    fun test2() {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n        boo()\n    }\n\n    object O {\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            boo()\n        }\n    }\n\n    companion object {\n        init {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            boo()\n        }\n\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            boo()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// FILE: test.kt\nopen class A<T> : J() {\n    init {\n        foo()\n        bar()\n        val a: Int = <!TYPE_MISMATCH!><!DEBUG_INFO_LEAKING_THIS!>baz<!>()<!>\n        val b: T = <!DEBUG_INFO_LEAKING_THIS!>baz<!>()\n    }\n\n    fun test1() {\n        foo()\n        bar()\n        val a: Int = <!TYPE_MISMATCH!>baz()<!>\n        val b: T = baz()\n    }\n\n    fun baz(): T = null!!\n\n    object O {\n        fun test() {\n            foo()\n            bar()\n            val a: Int = baz()\n            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()\n        }\n    }\n\n    companion object : A<Int>() {\n        init {\n            foo()\n            bar()\n            val a: Int = baz()\n            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()\n        }\n\n        fun test() {\n            foo()\n            bar()\n            val a: Int = baz()\n            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\nopen class A {\n    companion object : J() {\n        fun bar() {}\n    }\n}\n\nclass B : A() {\n    init {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n    }\n\n    fun test2() {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n    }\n\n    object O {\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n        }\n    }\n\n    companion object {\n        init {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n        }\n\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n        }\n\n        fun bar() {}\n    }\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\nclass A {\n    init {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n    }\n\n    fun test1() {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n    }\n\n    object O {\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n        }\n    }\n\n    companion object : J() {\n        init {\n            foo()\n            bar()\n        }\n\n        fun test() {\n            foo()\n            bar()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\nopen class A {\n    companion object : J() {\n        fun bar() {}\n    }\n}\n\nclass B : A() {\n    init {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n    }\n\n    fun test2() {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n    }\n\n    object O {\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n        }\n    }\n\n    companion object {\n        init {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n        }\n\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n        }\n\n        fun bar() {}\n    }\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\n\nopen class B : J() {\n    fun baz() {}\n}\n\nclass A {\n    init {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n        baz()\n    }\n\n    fun test1() {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n        baz()\n    }\n\n    object O {\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n            baz()\n        }\n    }\n\n\n    companion object : B() {\n        init {\n            foo()\n            bar()\n            baz()\n        }\n\n        fun test() {\n            foo()\n            bar()\n            baz()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// FILE: test.kt\nopen class A<T> : J() {\n    init {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n        val a: Int = <!TYPE_MISMATCH!><!DEBUG_INFO_LEAKING_THIS!>baz<!>()<!>\n        val b: T = <!DEBUG_INFO_LEAKING_THIS!>baz<!>()\n    }\n\n    fun test1() {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n        val a: Int = <!TYPE_MISMATCH!>baz()<!>\n        val b: T = baz()\n    }\n\n    fun baz(): T = null!!\n\n    object O {\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            val a: Int = baz()\n            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()\n        }\n    }\n\n    companion object : A<Int>() {\n        init {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            val a: Int = baz()\n            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()\n        }\n\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            val a: Int = baz()\n            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\nopen class A {\n    companion object : J() {\n        fun bar() {}\n    }\n}\n\nclass B : J2() {\n    init {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n        boo()\n    }\n\n    fun test2() {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n        boo()\n    }\n\n    object O {\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n            boo()\n        }\n    }\n\n    companion object {\n        init {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n            boo()\n        }\n\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n            boo()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\n\nopen class B : J() {\n    fun baz() {}\n}\n\nclass A {\n    init {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n        baz()\n    }\n\n    fun test1() {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n        bar()\n        baz()\n    }\n\n    object O {\n        fun test() {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>\n            bar()\n            baz()\n        }\n    }\n\n\n    companion object : B() {\n        init {\n            foo()\n            bar()\n            baz()\n        }\n\n        fun test() {\n            foo()\n            bar()\n            baz()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// FILE: test.kt\nclass A {\n    init {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n    }\n\n    fun test1() {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        bar()\n    }\n\n    object O {\n        fun test() {\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n            bar()\n        }\n    }\n\n    companion object : J() {\n        init {\n            foo()\n            bar()\n        }\n\n        fun test() {\n            foo()\n            bar()\n        }\n\n        fun bar() {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: 1.kt\n\nclass B: A() {\n    companion object {\n        init {\n            val a: Int = foo()\n            val b: Int = bar\n        }\n    }\n\n    init {\n        val a: Int = foo()\n        val b: Int = bar\n    }\n}\n\nopen class C: A() {\n    val bar = \"\"\n    fun foo() = \"\"\n\n    init {\n        val a: String = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n        val b: String = bar\n    }\n}\n\nclass E: C() {\n    init {\n        val a: String = foo()\n        val b: String = bar\n    }\n}\n\nopen class F: A() {\n    companion object {\n        val bar = \"\"\n        fun foo() = \"\"\n\n        init {\n            val a: String = foo()\n            val b: String = bar\n        }\n    }\n    init {\n        val a: String = foo()\n        val b: String = bar\n    }\n}\n\nclass G: F() {\n    companion object {\n        init {\n            val a: String = foo()\n            val b: String = bar\n        }\n    }\n\n    init {\n        val a: String = foo()\n        val b: String = bar\n    }\n}"
        },
        {
            "code": "// FILE: K.kt\n\nopen class K {\n    companion object {\n        fun foo() {}\n    }\n}\n\n// FILE: K.kt\n\nclass K2 {\n    companion object {\n        fun baz() {}\n    }\n}\n\n// FILE: test.kt\n\nfun test() {\n    K.foo()\n\n    D.b\n    D.bar()\n    D.<!UNRESOLVED_REFERENCE!>foo<!>()\n\n    K2.<!UNRESOLVED_REFERENCE!>b<!>\n    K2.<!UNRESOLVED_REFERENCE!>bar<!>()\n    K2.<!UNRESOLVED_REFERENCE!>foo<!>()\n    K2.baz()\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun test() {\n    A.<!INVISIBLE_MEMBER!>a<!>\n    A.<!INVISIBLE_MEMBER!>foo<!>()\n    A.b\n    A.bar()\n    B.a\n    B.foo()\n    B.foo(1)\n    B.b\n    B.bar()\n    B.bar(1)\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun test() {\n    A.field\n    B.field\n\n    E.<!OVERLOAD_RESOLUTION_AMBIGUITY!>field<!>\n    O.field\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: 1.kt\nimport A.foo\nimport B.bar\n\nclass E: A() {\n    init {\n        foo()\n        bar()\n    }\n}\n\nclass F: B() {\n    init {\n        foo()\n        bar()\n    }\n}\n\n// FILE: 2.kt\nimport C.bar\n\nclass Z: A() {\n    init {\n        val a: Int = bar()\n    }\n}\n\n// FILE: 3.kt\nimport C.*\n\nclass Q: A() {\n    init {\n        val a: Int = bar()\n    }\n}"
        },
        {
            "code": "// FILE: test.kt\n\nfun test() {\n    A.field\n    B.field\n\n    C.field\n    D.field\n\n    E.<!OVERLOAD_RESOLUTION_AMBIGUITY!>field<!>\n    O.field\n\n    EE.<!OVERLOAD_RESOLUTION_AMBIGUITY!>field<!>\n    EO.field\n\n    OO.field\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: 1.kt\nimport A.foo\nimport B.bar\n\nclass E: A() {\n    init {\n        foo\n        bar\n    }\n}\n\nclass F: B() {\n    init {\n        foo\n        bar\n    }\n}\n\n// FILE: 2.kt\nimport C.bar\n\nclass Z: A() {\n    init {\n        val a: Int = bar\n    }\n}\n\n// FILE: 3.kt\nimport C.*\n\nclass Q: A() {\n    init {\n        val a: Int = bar\n    }\n}\n\n// FILE: 4.kt\nval bar = \"\"\n\nclass W: A() {\n    init {\n        val a: Int = bar\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: 1.kt\n\nfun foo() = \"\"\n\nopen class B: A() {\n    init {\n        val a: Int = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n    }\n}\n\nfun test() {\n    fun foo() = \"\"\n\n    class B: A() {\n        init {\n            val a: Int = <!TYPE_MISMATCH!>foo()<!> // todo\n        }\n    }\n}\n\nclass E: A() {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>foo<!>() = A()\n\n    init {\n        val a: A = foo() // todo: discuss\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\n\nclass X: A {\n    val a_s: <!UNRESOLVED_REFERENCE!>A_S<!> = null!!\n\n    init {\n        <!UNRESOLVED_REFERENCE!>A_S<!>()\n        A.A_S()\n        X.<!UNRESOLVED_REFERENCE!>A_S<!>()\n    }\n\n    object xD {\n        val a_: <!UNRESOLVED_REFERENCE!>A_S<!> = null!!\n\n        init {\n            <!UNRESOLVED_REFERENCE!>A_S<!>()\n        }\n    }\n}\n\nclass Y: B() {\n    val b_: B_ = null!!\n    val b_s: B_S = null!!\n\n    init {\n        B_()\n        B.<!RESOLUTION_TO_CLASSIFIER!>B_<!>()\n        Y.<!UNRESOLVED_REFERENCE!>B_<!>()\n\n        B_S()\n        B.B_S()\n        Y.<!UNRESOLVED_REFERENCE!>B_S<!>()\n    }\n\n    object X {\n        val b_: B_ = null!!\n        val b_s: B_S = null!!\n\n        init {\n            <!RESOLUTION_TO_CLASSIFIER!>B_<!>()\n            B_S()\n        }\n    }\n}\n\nclass Z: C() {\n    val a_s: <!UNRESOLVED_REFERENCE!>A_S<!> = null!!\n    val b_: B_ = null!!\n    val b_s: B_S = null!!\n\n    init {\n        <!UNRESOLVED_REFERENCE!>A_S<!>()\n        B_()\n        B_S()\n    }\n\n    object X {\n        val a_s: <!UNRESOLVED_REFERENCE!>A_S<!> = null!!\n        val b_: B_ = null!!\n        val b_s: B_S = null!!\n\n        init {\n            <!UNRESOLVED_REFERENCE!>A_S<!>()\n            <!RESOLUTION_TO_CLASSIFIER!>B_<!>()\n            B_S()\n        }\n    }\n}\n"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>init<!>: A.() -> Unit) { }\n\nclass A {\n    var x: Int = 0\n    companion object {\n        val f = foo() {\n            x = 1\n        }\n    }\n}\n\nclass B(val a: String) {\n    fun f() = 0\n    companion object   {\n        fun B.bar() = a + f()\n    }\n}\n\nopen class C {\n    fun bar() {}\n}\n\nclass E: C() {\n\n    class D {\n        init {\n            with(C()) {\n                bar()\n                this.bar()\n            }\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\nopen class A {\n    companion object {\n        class B\n    }\n}\n\nclass C: A() {\n    val b: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B<!> = null!!\n\n    init {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B()<!>\n    }\n\n    object O {\n        val b: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B<!> = null!!\n\n        init {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B()<!>\n        }\n    }\n\n    class K {\n        val b: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B<!> = null!!\n\n        init {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B()<!>\n        }\n    }\n\n    inner class I {\n        val b: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B<!> = null!!\n\n        init {\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B()<!>\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\nopen class A {\n    inner class B {\n        fun foo() {}\n    }\n\n    inner class D\n\n    companion object {\n        class B {\n            fun bar() {}\n        }\n\n        class C\n    }\n\n    init {\n        B().foo()\n        B().<!UNRESOLVED_REFERENCE!>bar<!>()\n\n        D()\n        C()\n    }\n}\n\nclass E: A() {\n    init {\n        B().foo()\n        B().<!UNRESOLVED_REFERENCE!>bar<!>()\n\n        D()\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>C()<!>\n    }\n\n    object Z {\n        init {\n            <!RESOLUTION_TO_CLASSIFIER!>B<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n            <!RESOLUTION_TO_CLASSIFIER!>B<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n\n            <!RESOLUTION_TO_CLASSIFIER!>D<!>()\n            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>C()<!>\n        }\n    }\n}\n\nclass F: A() {\n    class B {\n        fun fas() {}\n    }\n    inner class D {\n        fun f() {}\n    }\n\n    init {\n        B().fas()\n        D().f()\n    }\n\n    companion object {\n        init {\n            B().fas()\n            <!RESOLUTION_TO_CLASSIFIER!>D<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>f<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\ninterface B {\n    class B_\n}\n\nclass X: A {\n    val a: <!UNRESOLVED_REFERENCE!>A_<!> = <!UNRESOLVED_REFERENCE!>A_<!>()\n    val b: A.A_ = A.A_()\n\n    companion object {\n        val a: <!UNRESOLVED_REFERENCE!>A_<!> = <!UNRESOLVED_REFERENCE!>A_<!>()\n    }\n}\n\nclass Y: B {\n    val a: <!UNRESOLVED_REFERENCE!>B_<!> = <!UNRESOLVED_REFERENCE!>B_<!>()\n    val b: B.B_ = B.B_()\n\n    companion object {\n        val b: <!UNRESOLVED_REFERENCE!>B_<!> = <!UNRESOLVED_REFERENCE!>B_<!>()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\n// FILE: 1.kt\ninterface A {\n    companion object {\n        fun foo() {}\n\n        class A_\n    }\n}\n\nopen class B {\n    companion object {\n        fun bar() {}\n\n        class B_\n    }\n}\n\n// FILE: 2.kt\nclass D: C() {\n    init {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        A.foo()\n        A.Companion.foo()\n        C.<!UNRESOLVED_REFERENCE!>foo<!>()\n        D.<!UNRESOLVED_REFERENCE!>foo<!>()\n\n        <!UNRESOLVED_REFERENCE!>A_<!>()\n        A.<!UNRESOLVED_REFERENCE!>A_<!>()\n        A.Companion.A_()\n        C.<!UNRESOLVED_REFERENCE!>A_<!>()\n        D.<!UNRESOLVED_REFERENCE!>A_<!>()\n\n        bar()\n        B.bar()\n        B.Companion.bar()\n        C.<!UNRESOLVED_REFERENCE!>bar<!>()\n        D.<!UNRESOLVED_REFERENCE!>bar<!>()\n\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B_()<!>\n        B.<!UNRESOLVED_REFERENCE!>B_<!>()\n        B.Companion.B_()\n        C.<!UNRESOLVED_REFERENCE!>B_<!>()\n        D.<!UNRESOLVED_REFERENCE!>B_<!>()\n    }\n}"
        },
        {
            "code": "// FILE: 1.kt\ninterface E {\n    class E_S\n}\n\nopen class D: C(), E\n\n// FILE: 2.kt\nclass X: D() {\n    init {\n        B_()\n        B.<!RESOLUTION_TO_CLASSIFIER!>B_<!>()\n        C.<!UNRESOLVED_REFERENCE!>B_<!>()\n        D.<!UNRESOLVED_REFERENCE!>B_<!>()\n        X.<!UNRESOLVED_REFERENCE!>B_<!>()\n\n        <!UNRESOLVED_REFERENCE!>A_S<!>()\n        A.A_S()\n        C.<!UNRESOLVED_REFERENCE!>A_S<!>()\n        D.<!UNRESOLVED_REFERENCE!>A_S<!>()\n        X.<!UNRESOLVED_REFERENCE!>A_S<!>()\n\n        B_S()\n        B.B_S()\n        C.<!UNRESOLVED_REFERENCE!>B_S<!>()\n        D.<!UNRESOLVED_REFERENCE!>B_S<!>()\n        X.<!UNRESOLVED_REFERENCE!>B_S<!>()\n\n        <!UNRESOLVED_REFERENCE!>E_S<!>()\n        E.E_S()\n        D.<!UNRESOLVED_REFERENCE!>E_S<!>()\n        X.<!UNRESOLVED_REFERENCE!>E_S<!>()\n    }\n}\n\nclass Y: F() {\n    init {\n\n        B_()\n        F.<!UNRESOLVED_REFERENCE!>B_<!>()\n        Y.<!UNRESOLVED_REFERENCE!>B_<!>()\n\n        <!UNRESOLVED_REFERENCE!>A_S<!>()\n        F.<!UNRESOLVED_REFERENCE!>A_S<!>()\n        Y.<!UNRESOLVED_REFERENCE!>A_S<!>()\n\n        B_S()\n        F.<!UNRESOLVED_REFERENCE!>B_S<!>()\n        Y.<!UNRESOLVED_REFERENCE!>B_S<!>()\n\n        <!UNRESOLVED_REFERENCE!>E_S<!>()\n        F.<!UNRESOLVED_REFERENCE!>E_S<!>()\n        Y.<!UNRESOLVED_REFERENCE!>E_S<!>()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\nclass X {\n    fun T_X() {}\n}\n\nclass Y {\n    fun T_Y() {}\n}\n\nopen class A {\n    class X {\n        fun A_X() {}\n    }\n    companion object {\n        class Y {\n            fun A_C_Y() {}\n        }\n    }\n\n    init {\n        X().A_X()\n        X().<!UNRESOLVED_REFERENCE!>T_X<!>()\n\n        Y().A_C_Y()\n        Y().<!UNRESOLVED_REFERENCE!>T_Y<!>()\n    }\n}\n\nclass B: A() {\n    init {\n        X().A_X()\n        X().<!UNRESOLVED_REFERENCE!>T_X<!>()\n\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Y()<!>.A_C_Y()\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Y()<!>.<!UNRESOLVED_REFERENCE!>T_Y<!>()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\ninterface A {\n    companion object {\n        fun foo() {}\n\n        class A_\n    }\n}\n\nopen class B {\n    companion object {\n        fun bar() {}\n\n        class B_\n    }\n}\n\nclass C: B(), A {\n    init {\n        <!UNRESOLVED_REFERENCE!>foo<!>()\n        A.foo()\n        A.Companion.foo()\n        C.<!UNRESOLVED_REFERENCE!>foo<!>()\n\n        <!UNRESOLVED_REFERENCE!>A_<!>()\n        A.<!UNRESOLVED_REFERENCE!>A_<!>()\n        A.Companion.A_()\n        C.<!UNRESOLVED_REFERENCE!>A_<!>()\n\n        bar()\n        B.bar()\n        B.Companion.bar()\n        C.<!UNRESOLVED_REFERENCE!>bar<!>()\n\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>B_()<!>\n        B.<!UNRESOLVED_REFERENCE!>B_<!>()\n        B.Companion.B_()\n        C.<!UNRESOLVED_REFERENCE!>B_<!>()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\nopen class A {\n    class X {\n        fun A_X() {}\n    }\n\n    class Y {\n        fun A_Y() {}\n    }\n\n    companion object {\n        class X {\n            fun A_C_X() {}\n        }\n\n        class Z {\n            fun A_C_Z() {}\n        }\n    }\n\n    init {\n        X().A_X()\n        X().<!UNRESOLVED_REFERENCE!>A_C_X<!>()\n    }\n}\n\nclass Simple: A() {\n    init {\n        Y().A_Y()\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Z()<!>.A_C_Z()\n    }\n}\n\nclass B: A() {\n    class Y {\n        fun B_Y() {}\n    }\n\n    class Z {\n        fun B_Z() {}\n    }\n\n    init {\n        X().A_X()\n        X().<!UNRESOLVED_REFERENCE!>A_C_X<!>()\n\n        Y().B_Y()\n        Y().<!UNRESOLVED_REFERENCE!>A_Y<!>()\n\n        Z().B_Z()\n        Z().<!UNRESOLVED_REFERENCE!>A_C_Z<!>()\n    }\n\n    companion object {\n        init {\n            X().A_X()\n            X().<!UNRESOLVED_REFERENCE!>A_C_X<!>()\n\n            Y().B_Y()\n            Y().<!UNRESOLVED_REFERENCE!>A_Y<!>()\n\n            Z().B_Z()\n            Z().<!UNRESOLVED_REFERENCE!>A_C_Z<!>()\n        }\n    }\n}\n\nclass C: A() {\n    companion object {\n        class Y {\n            fun C_C_Y() {}\n        }\n\n        class Z {\n            fun C_C_Z() {}\n        }\n\n        init {\n            Y().C_C_Y()\n            Y().<!UNRESOLVED_REFERENCE!>A_Y<!>()\n\n            Z().C_C_Z()\n            Z().<!UNRESOLVED_REFERENCE!>A_C_Z<!>()\n        }\n    }\n\n    init {\n        Y().C_C_Y()\n        Y().<!UNRESOLVED_REFERENCE!>A_Y<!>()\n\n        Z().C_C_Z()\n        Z().<!UNRESOLVED_REFERENCE!>A_C_Z<!>()\n    }\n}"
        },
        {
            "code": "//KT-1244 Frontend allows access to private members of other classes\n\npackage kt1244\n\nclass A {\n    private var a = \"\"\n}\n\nclass B() {\n    init {\n        A().<!INVISIBLE_MEMBER!>a<!> = \"Hello\"\n    }\n}"
        },
        {
            "code": "//KT-1806 accessing private member in object class/anonymous object is not highlighted as error\npackage kt1806\n\nobject MyObject {\n    private var message: String = \"'Static'\"\n\n}\n\nfun test1() {\n\n    doSmth(MyObject.<!INVISIBLE_MEMBER!>message<!>)\n}\n\nclass Test {\n  private val MyObject1 = object {\n      private var message: String = \"'Static'\"\n  }\n\n  fun test2() {\n      doSmth(MyObject1.<!INVISIBLE_MEMBER!>message<!>)\n  }\n}\n\nfun doSmth(s: String) = s"
        },
        {
            "code": "class A(val foo: Int)\n\nfun A.test(foo: String) {\n    val <!UNUSED_VARIABLE!>a<!>: String = foo\n}"
        },
        {
            "code": "//FILE:a.kt\n//+JDK\npackage a\nimport kotlin.collections.Map.*\n\nfun foo(b : Entry<String, String>) = b\n\n//FILE:b.kt\n//+JDK\npackage b\n\nimport kotlin.collections.Map.Entry\nfun bar(b : Entry<String, String>) = b\n\n//FILE:c.kt\n//+JDK\npackage c\n\nfun fff(b: Map.Entry<String, String>) = b"
        },
        {
            "code": "//FILE:a/C.java\n//KT-1942 Package local members from Java are visible in subclasses\npackage a;\n\npublic class C {\n    int myValue;\n}\n\n//FILE:d.kt\n\npackage d\n\nimport a.C\n\nclass A : C() {\n    fun test() {\n        val <!UNUSED_VARIABLE!>v<!> = <!INVISIBLE_MEMBER!>myValue<!>\n    }\n}\n"
        },
        {
            "code": "package kt1805\n//KT-1805 Better diagnostic for access to private field of parent class\n\nopen class Some {\n    private val privateField = 12\n}\n\nclass SomeSubclass : Some() {\n    fun test() {\n        this.<!INVISIBLE_MEMBER!>privateField<!> // 1. Unresolved reference\n    }\n}\n\nfun test() {\n    val s2 = Some()\n    s2.<!INVISIBLE_MEMBER!>privateField<!> // 2. Can't access to 'privateField' in Some\n\n    val s1 = SomeSubclass()\n    s1.<!INVISIBLE_MEMBER!>privateField<!> // 3. Unresolved reference\n}"
        },
        {
            "code": "package kt_250_617_10\n\nimport java.util.ArrayList\nimport java.util.HashMap\n\n//KT-250 Incorrect variable resolve in constructor arguments of superclass\nopen class A(val x: Int)\nclass B(<!UNUSED_PARAMETER!>y<!>: Int) : A(<!UNRESOLVED_REFERENCE!>x<!>)  //x is resolved as a property in a, so no error is generated\n\n//KT-617 Prohibit dollars in call to superclass constructors\nopen class M(<!UNUSED_PARAMETER!>p<!>: Int)\nclass N(val p: Int) : A(<!SYNTAX!><!SYNTAX!><!>$p<!><!SYNTAX!>)<!>\n\n//KT-10 Don't allow to use properties in supertype initializers\nopen class Element()\nclass TextElement(<!UNUSED_PARAMETER!>name<!>: String) : Element()\n\nabstract class Tag(val name : String) {\n  val children = ArrayList<Element>()\n  val attributes = HashMap<String, String>()\n}\n\nabstract class TagWithText(name : String) : Tag(name) {\n  operator fun String.unaryPlus() {\n    children.add(TextElement(this))\n  }\n}\n\nopen class BodyTag(name : String) : TagWithText(name) {\n}\n\nclass Body() : BodyTag(<!UNRESOLVED_REFERENCE!>name<!>) { // Must be an error!\n}\nclass Body1() : BodyTag(<!NO_THIS!>this<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>name<!>) { // Must be an error!\n}\n\n//more tests\n\nopen class X(<!UNUSED_PARAMETER!>p<!>: Int, <!UNUSED_PARAMETER!>r<!>: Int) {\n    val s = \"s\"\n}\n\nclass Y(i: Int) : X(i, <!UNRESOLVED_REFERENCE!>rrr<!>) {\n    val rrr = 3\n}\n\nclass Z(val i: Int) : X(<!UNRESOLVED_REFERENCE!>s<!>, <!UNRESOLVED_REFERENCE!>x<!>) {\n    val x = 2\n}"
        },
        {
            "code": "// import all members from companion object\npackage c\n\nimport c.A.Companion.B\nimport c.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>M<!>.*\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>b<!>: B = B()\n    var <!UNUSED_VARIABLE!>r<!>: <!UNRESOLVED_REFERENCE!>R<!> = <!UNRESOLVED_REFERENCE!>R<!>()\n}\n\nclass A() {\n    companion object {\n        class B() {\n            companion object {\n            }\n        }\n    }\n}\n\nobject M {\n    fun foo() {}\n    class R() {}\n}"
        },
        {
            "code": "typealias A<T> = Array<T>\ntypealias AA<T> = A<A<T>>\n\ntypealias AN = <!TYPEALIAS_EXPANDED_TO_MALFORMED_TYPE!>A<Nothing><!>\n\ntypealias AAN = <!TYPEALIAS_EXPANDED_TO_MALFORMED_TYPE!>AA<Nothing><!>\n\ntypealias AAN2 = <!TYPEALIAS_EXPANDED_TO_MALFORMED_TYPE!>A<A<Nothing>><!>\n\ntypealias First<X, <!UNUSED_TYPEALIAS_PARAMETER!>Y<!>> = List<X>\ntypealias UnusedAN1 = First<Int, <!UNSUPPORTED!>Array<Nothing><!>>\ntypealias UnusedAN2 = First<Int, A<Nothing>> // TODO\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\ntypealias ToTypeParam1<T> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>T<!>\ntypealias ToTypeParam2<T> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>ToTypeParam1<T><!>\ntypealias ToTypeParam3<T1, <!UNUSED_TYPEALIAS_PARAMETER!>T2<!>> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>ToTypeParam2<T1><!>\ntypealias ToTypeParam4 = ToTypeParam1<Any>\n\ntypealias ToFun1 = () -> Unit\ntypealias ToFun2<T> = (T) -> Unit\n\nclass Outer {\n    typealias ToTypeParam1<T> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>T<!>\n    typealias ToTypeParam2<T> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>ToTypeParam1<T><!>\n    typealias ToTypeParam3<T1, <!UNUSED_TYPEALIAS_PARAMETER!>T2<!>> = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>ToTypeParam2<T1><!>\n    typealias ToTypeParam4 = ToTypeParam1<Any>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_JAVAC\n\n// FILE: test/jv/JavaSample.java\n\npackage test.jv;\n\npublic class JavaSample {\n    public static void member() {}\n}\n\n// FILE: foo.kt\n\npackage test.kot\n\ntypealias JavaAlias = test.jv.JavaSample\n\n// FILE: test.kt\n\nimport test.kot.JavaAlias\nimport test.kot.JavaAlias.member\n\nfun foo(\n    sample: <!UNRESOLVED_REFERENCE!>JavaSample<!>,\n    alias: JavaAlias\n) {\n    member()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\nclass TC<T, C : Collection<T>>\n\ntypealias TCAlias<T, C> = TC<T, C>\ntypealias TCAliasT<T> = TC<T, Any>\ntypealias TCAliasC<C> = TC<Any, C>\ntypealias TCAliasT1<T> = TCAlias<T, Any>\ntypealias TCAliasC1<C> = TCAlias<Any, C>\n\ntypealias Test1 = TC<Any, <!UPPER_BOUND_VIOLATED!>Any<!>>\ntypealias Test2 = TC<Any, Collection<Any>>\ntypealias Test3 = <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>TCAlias<Any, Any><!>\ntypealias Test4 = TCAlias<Any, Collection<Any>>\ntypealias Test5 = <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>TCAliasT<Any><!>\ntypealias Test6 = <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>TCAliasC<Any><!>\ntypealias Test7 = TCAliasC<Collection<Any>>\ntypealias Test8 = <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>TCAliasT1<Any><!>\ntypealias Test9 = <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>TCAliasC1<Any><!>\ntypealias Test10 = TCAliasC1<Collection<Any>>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Cons<T : Number>(val head: T, val tail: Cons<T>?)\ntypealias C<T> = Cons<T>\n\nval test1 = C(1, C(2, null))\nval test2 = C(1, <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>C<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>\"\"<!>, null)<!>)\n"
        },
        {
            "code": "class C(val x: String) {\n    constructor(): this(\"\")\n}\n\ntypealias TC = C\n\nval test1: C = TC(\"\")\nval test2: TC = TC(\"\")\nval test3: C = TC()\nval test4: TC = TC()\n\nval test5 = <!NONE_APPLICABLE!>TC<!>(\"\", \"\")\n\ninterface Interface\ntypealias TI = Interface\n\nobject AnObject\ntypealias TO = AnObject\n\nval test6 = <!RESOLUTION_TO_CLASSIFIER!>TI<!>()\nval test6a = <!RESOLUTION_TO_CLASSIFIER!>Interface<!>()\n\nval test7 = <!FUNCTION_EXPECTED!>TO<!>()\nval test7a = <!FUNCTION_EXPECTED!>AnObject<!>()\n"
        },
        {
            "code": "// WITH_RUNTIME\nimport kotlin.annotation.AnnotationTarget.*\n\nannotation class NoTarget\n\n@Target(CLASS)\nannotation class IrrelevantTarget\n\n@Target(TYPEALIAS)\nannotation class TypealiasTarget\n\n<!WRONG_ANNOTATION_TARGET!>@NoTarget<!>\n<!WRONG_ANNOTATION_TARGET!>@IrrelevantTarget<!>\n@TypealiasTarget\ntypealias Test = String"
        },
        {
            "code": "interface Inv<T>\ninterface Out<out T>\ninterface In<in T>\n\ntypealias InvStar = Inv<*>\ntypealias InvIn = Inv<in Int>\ntypealias InvOut = Inv<out Int>\ntypealias InvT<T> = Inv<T>\n\ntypealias OutStar = Out<*>\ntypealias OutOut = Out<<!REDUNDANT_PROJECTION!>out<!> Int>\ntypealias OutT<T> = Out<T>\n\ntypealias InStar = In<*>\ntypealias InIn = In<<!REDUNDANT_PROJECTION!>in<!> Int>\ntypealias InT<T> = In<T>\n\nclass Test1 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InvStar<!>\nclass Test2 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InvIn<!>\nclass Test3 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InvOut<!>\nclass Test4 : InvT<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>*<!>>\nclass Test5 : InvT<InvT<*>>\n\nclass Test6 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>OutStar<!>\nclass Test7 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>OutOut<!>\nclass Test8 : OutT<Int>\nclass Test9 : OutT<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>out<!> Int>\n\nclass Test10 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InStar<!>\nclass Test11 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InIn<!>\nclass Test12 : InT<Int>\nclass Test13 : InT<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>in<!> Int>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\nclass Num<T : Number>\nclass NumColl<T : Collection<Number>>\nclass TColl<T, C : Collection<T>>\n\ntypealias NA<T> = Num<T>\ntypealias NL<T> = NumColl<List<T>>\ntypealias TC<T1, T2> = TColl<T1, T2>\n\nfun test1(x: NA<Int>) {}\nfun test2(x: NA<<!UPPER_BOUND_VIOLATED!>Any<!>>) {}\nfun test3(x: NL<Int>) {}\nfun test4(x: <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>NL<Any><!>) {}\n\nval test5 = NA<Int>()\nval test6 = NA<<!UPPER_BOUND_VIOLATED!>Any<!>>()\nval test7 = NL<Int>()\nval test8 = <!OI;UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>NL<Any>()<!>\n\nfun test9(x: TC<Number, Collection<Number>>) {}\nfun test10(x: TC<Number, Collection<Int>>) {}\nfun test11(x: TC<Number, List<Int>>) {}\nfun test12(x: TC<Number, <!UPPER_BOUND_VIOLATED!>List<Any><!>>) {}\n\nval test13 = TC<Number, Collection<Number>>()\nval test14 = TC<Number, Collection<Int>>()\nval test15 = TC<Number, List<Int>>()\nval test16 = TC<Number, <!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>List<Any><!>>()\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\ntypealias L<T> = List<T>\n\nclass Outer {\n    private class Private\n    protected class Protected\n    internal class Internal\n\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate1<!> = Private\n    protected typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate2<!> = Private\n    internal typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate3<!> = Private\n    private typealias TestPrivate4 = Private\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate5<!> = L<Private>\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate6<!> = L<TestPrivate1>\n\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestProtected1<!> = Protected\n    protected typealias TestProtected2 = Protected\n    internal typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestProtected3<!> = Protected\n    private typealias TestProtected4 = Protected\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestProtected5<!> = L<Protected>\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestProtected6<!> = L<TestProtected1>\n\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal1<!> = Internal\n    protected typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal2<!> = Internal\n    internal typealias TestInternal3 = Internal\n    private typealias TestInternal4 = Internal\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal5<!> = L<Internal>\n    typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal6<!> = L<TestInternal1>\n}\n\nprivate class Private\ninternal class Internal\n\ntypealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate1<!> = Private\ninternal typealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate2<!> = Private\nprivate typealias TestPrivate3 = Private\ntypealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate4<!> = L<Private>\ntypealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestPrivate5<!> = L<TestPrivate1>\n\ntypealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal1<!> = Internal\ninternal typealias TestInternal2 = Internal\nprivate typealias TestInternal3 = Internal\ntypealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal4<!> = L<Internal>\ntypealias <!EXPOSED_TYPEALIAS_EXPANDED_TYPE!>TestInternal5<!> = L<TestInternal1>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ntypealias A<T> = Map<T, T>\ntypealias B = A<*>\n\nfun check(x: B) = x\n\nfun test1(x: Map<Int, Int>) = check(x)\n\nfun test2(x: Map<String, Int>) = check(x)\n\nfun test3(x: Map<Int, String>) = check(x).size\n\nfun test4(x: Map<Int, String>) = <!OI;MEMBER_PROJECTED_OUT!>check(x)[<!NI;TYPE_MISMATCH!>\"42\"<!>]<!>\n\nfun test5(x: Map<Int, String>) = <!OI;MEMBER_PROJECTED_OUT!>check(x)[<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>]<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nobject ObjectWithInvoke {\n    operator fun invoke() = this\n}\n\nclass ClassWithCompanionObjectWithInvoke {\n    companion object {\n        operator fun invoke(x: Any) = x\n    }\n}\n\ntypealias WI = ObjectWithInvoke\n\ntypealias CWI = ClassWithCompanionObjectWithInvoke\n\nval test1 = WI()\nval test2 = WI(<!TOO_MANY_ARGUMENTS!>null<!>)\n\nval test3 = CWI()\nval test4 = CWI(\"\")\nval test5 = CWI(<!NULL_FOR_NONNULL_TYPE!>null<!>)\nval test5a = ClassWithCompanionObjectWithInvoke(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nopen class Base {\n    typealias Nested = String\n}\n\nclass Derived : Base()\n\nfun test(x: Derived.<!UNRESOLVED_REFERENCE!>Nested<!>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\n\nfun Base.testWithImplicitReceiver(x: <!UNRESOLVED_REFERENCE!>Nested<!>) {\n    val y: <!UNRESOLVED_REFERENCE!>Nested<!> = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass Outer<T> {\n    class Nested\n    class GenericNested<TT>\n    inner class Inner\n    inner class GenericInner<TT>\n\n    typealias NestedAlias = Nested\n    typealias GenericNestedAlias<TT> = GenericNested<TT>\n    typealias InnerAlias = Inner\n    typealias GenericInnerAlias<TT> = GenericInner<TT>\n\n    fun test1(x: NestedAlias) = x\n    fun test2(x: GenericNestedAlias<Int>) = x\n    fun <T> test3(x: GenericNestedAlias<T>) = x\n    fun test4(x: InnerAlias) = x\n    fun test5(x: GenericInnerAlias<Int>) = x\n    fun <T> test6(x: GenericInnerAlias<T>) = x\n}\nfun test1(x: Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><Int><!>.NestedAlias) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun <T> test2(x: Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><T><!>.NestedAlias) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun test3(x: Outer.NestedAlias) = x\nfun test4(x: Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><Int><!>.GenericNestedAlias<Int>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun <T> test5(x: Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><T><!>.GenericNestedAlias<Int>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun <T> test6(x: Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><Int><!>.GenericNestedAlias<T>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun test7(x: Outer.GenericNestedAlias<Int>) = x\nfun <T> test8(x: Outer.GenericNestedAlias<T>) = x\nfun test9(x: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Outer<!>.InnerAlias) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun test10(x: Outer<Int>.InnerAlias) = x\nfun <T> test11(x: Outer<T>.InnerAlias) = x\nfun test12(x: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Outer<!>.GenericInnerAlias<Int>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\nfun test13(x: Outer<Int>.GenericInnerAlias<Int>) = x\nfun <T> test14(x: Outer<T>.GenericInnerAlias<Int>) = x\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\ntypealias Array2D<T> = Array<Array<T>>\n\nfun foo1(a: Array2D<out Number>) = a\n\nfun bar1(a: Array2D<Int>) =\n        foo1(<!TYPE_MISMATCH(\"Array2D<out Number> /* = Array<Array<out Number>> */\", \"Array2D<Int> /* = Array<Array<Int>> */\")!>a<!>)\n\n\ntypealias TMap<T> = Map<T, T>\n\nfun <T> foo2(m: TMap<T>) = m\n\nfun bar2(m: TMap<*>) =\n        <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>foo2<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>m<!>)\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: test.kt\nclass KTest {\n    class Nested\n    inner class Inner\n}\n\ninterface ITest {\n    class Nested\n}\n\ntypealias JT = JTest\ntypealias JD = JDerived\ntypealias KT = KTest\ntypealias IT = ITest\n\n// Referencing Java class static members via type alias should be ok\nval testFoo: String = JT.foo()\nval seeAlsoFoo: String = JTest.foo()\n// Referencing base Java class static members via type alias for derived Java class should be ok\nval testDerivedFoo: String = JD.foo()\nval seeAlsoDerivedFoo: String = JDerived.foo()\n\n// Referencing nested classes via type alias should be prohibited\n// (in type position and in expression position)\nval testNested1: JT.<!UNRESOLVED_REFERENCE!>Nested<!> = JT.<!UNRESOLVED_REFERENCE!>Nested<!>()\nval testNested2: KT.<!UNRESOLVED_REFERENCE!>Nested<!> = KT.<!UNRESOLVED_REFERENCE!>Nested<!>()\nval testNested3: IT.<!UNRESOLVED_REFERENCE!>Nested<!> = IT.<!UNRESOLVED_REFERENCE!>Nested<!>()\nval testInner1: JT.<!UNRESOLVED_REFERENCE!>Inner<!> = JT.<!UNRESOLVED_REFERENCE!>Inner<!>()\nval testInner2: KT.<!UNRESOLVED_REFERENCE!>Inner<!> = KT.<!UNRESOLVED_REFERENCE!>Inner<!>()\nfun testNestedAsTypeArgument1(x: List<JT.<!UNRESOLVED_REFERENCE!>Nested<!>>) {}\nfun testNestedAsTypeArgument2(x: List<KT.<!UNRESOLVED_REFERENCE!>Nested<!>>) {}\nfun testNestedAsTypeArgument3(x: List<IT.<!UNRESOLVED_REFERENCE!>Nested<!>>) {}\nfun testInnerAsTypeArgument1(x: List<JT.<!UNRESOLVED_REFERENCE!>Inner<!>>) {}\nfun testInnerAsTypeArgument2(x: List<KT.<!UNRESOLVED_REFERENCE!>Inner<!>>) {}\n\n"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE)\nannotation class A\n\ntypealias Gen<T> = List<@A T>\n\ntypealias Test1 = Gen<<!REPEATED_ANNOTATION!>@A<!> Int>\n"
        },
        {
            "code": "class C {\n    private companion object\n}\n\ntypealias CAlias = C\n\nval <!EXPOSED_PROPERTY_TYPE!>test1<!> = <!INVISIBLE_MEMBER!>CAlias<!>\nval <!EXPOSED_PROPERTY_TYPE!>test1a<!> = <!INVISIBLE_MEMBER!>C<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass OuterClass<T1> {\n    class NestedClass<T2>\n    typealias NestedType<T> = NestedClass<T>\n}\n\ntypealias ON1<T1, T2> = OuterClass<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><T1><!>.NestedClass<T2>\ntypealias ON2<T1, T2> = OuterClass<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><T1><!>.NestedType<T2>\ntypealias ON3<T2> = OuterClass.NestedType<T2>"
        },
        {
            "code": "typealias Test<T, <!UNUSED_TYPEALIAS_PARAMETER!>X<!>> = List<T>\ntypealias Test2<T, <!UNUSED_TYPEALIAS_PARAMETER!>X<!>> = Test<T, X>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n// NI_EXPECTED_FILE\n\nclass C {\n    typealias Self = C\n    class Nested {\n        class N2\n        typealias Root = C\n    }\n    companion object X {\n        val ok = \"OK\"\n        class InCompanion\n    }\n}\n\nval c = C.Self.<!UNRESOLVED_REFERENCE!>Self<!>()\nval n = C.Self.<!UNRESOLVED_REFERENCE!>Nested<!>()\nval x = C.Self.<!UNRESOLVED_REFERENCE!>X<!>\nval n2 = C.Nested.Root.<!UNRESOLVED_REFERENCE!>Nested<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>N2<!>()\nval ic = C.Self.<!UNRESOLVED_REFERENCE!>InCompanion<!>()\nval ok = C.Self.ok\n"
        },
        {
            "code": "// +JDK\n\ntypealias Exn = java.lang.Exception\n\nfun test() {\n    throw <!NO_COMPANION_OBJECT!>Exn<!>\n}"
        },
        {
            "code": "interface IFoo\n\ntypealias Test = IFoo\n\nval testAsFunction = <!RESOLUTION_TO_CLASSIFIER!>Test<!>()\nval testAsValue = <!NO_COMPANION_OBJECT!>Test<!>"
        },
        {
            "code": "interface Order<T>\n\ntypealias Ord<T> = Order<T>\n\nclass Test1<T1 : Ord<T1>>\n\ninterface Num<T : Number>\n\ntypealias N<T> = Num<T>\n\nclass Test2<T : N<<!UPPER_BOUND_VIOLATED!>String<!>>>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\n// FILE: foo.kt\n\npackage test\n\ntypealias ClassAlias = ClassSample\ntypealias ObjectAlias = ObjectSample\ntypealias EnumAlias = EnumSample\n\nclass ClassSample {\n    class Nested1\n}\n\nobject ObjectSample {\n    class Nested2\n}\n\nenum class EnumSample {\n    Entry;\n\n    class Nested3\n}\n\n// FILE: test.kt\n\nimport test.ClassAlias\nimport test.ClassAlias.Nested1\n\nimport test.ClassSample.Nested1.*\nimport test.ClassAlias.<!UNRESOLVED_REFERENCE!>Nested1<!>.*\n\nimport test.ObjectAlias\nimport test.ObjectAlias.Nested2\n\nimport test.ObjectSample.Nested2.*\nimport test.ObjectAlias.<!UNRESOLVED_REFERENCE!>Nested2<!>.*\n\nimport test.EnumAlias\nimport test.EnumAlias.Nested3\n\nimport test.EnumSample.Nested3.*\nimport test.EnumAlias.<!UNRESOLVED_REFERENCE!>Nested3<!>.*\n\nimport test.EnumAlias.Entry\n\nfun f() {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Num<Tn : Number>(val x: Tn)\ntypealias N<T> = Num<T>\n\nval test0 = N(1)\nval test1 = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>N<!>(<!NI;TYPE_MISMATCH!>\"1\"<!>)\n\n\nclass Cons<T>(val head: T, val tail: Cons<T>?)\ntypealias C<T> = Cons<T>\ntypealias CC<T> = C<C<T>>\n\nval test2 = <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>C<!>(1, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\nval test3 = <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>CC<!>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\nval test4 = CC(C(1, null), null)\n\n\nclass Pair<X, Y>(val x: X, val y: Y)\ntypealias PL<T> = Pair<T, List<T>>\ntypealias PN<T> = Pair<T, Num<T>>\n\nval test5 = <!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>PL<!>(1, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n\n\nclass Foo<T>(val p: Pair<T, T>)\ntypealias F<T> = Foo<T>\n\nfun testProjections1(x: Pair<in Int, out String>) = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>F<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>x<!>)\nfun testProjections2(x: Pair<in Int, out Number>) = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>F<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>x<!>)\nfun testProjections3(x: Pair<in Number, out Int>) = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>F<!>(<!NI;TYPE_MISMATCH!>x<!>)\nfun testProjections4(x: Pair<in Int, in Int>) = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>F<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>x<!>)"
        },
        {
            "code": "// !LANGUAGE: -TypeAliases\n\nclass C\n\n<!UNSUPPORTED_FEATURE!>typealias<!> S = String\n<!UNSUPPORTED_FEATURE!>typealias<!> L<T> = List<T>\n<!UNSUPPORTED_FEATURE!>typealias<!> CA = C\n<!UNSUPPORTED_FEATURE!>typealias<!> Unused = Any\n\nval test1: <!UNSUPPORTED_FEATURE!>S<!> = \"\"\n\nfun test2(x: <!UNSUPPORTED_FEATURE!>L<<!UNSUPPORTED_FEATURE!>S<!>><!>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\n\nclass Test3 : <!UNSUPPORTED_FEATURE!>CA<!>()"
        },
        {
            "code": "// FILE: file1.kt\nprivate class <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>C<!> {\n    companion object\n}\n\nprivate typealias <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>TA<!> = C\n\nprivate val test1: C = C()\nprivate val test1co: C.Companion = C\n\nprivate val test2: TA = TA()\nprivate val test2co = TA\n\n// FILE: file2.kt\nprivate val test1: <!INVISIBLE_REFERENCE!>C<!> = <!INVISIBLE_MEMBER!>C<!>()\nprivate val test1co: <!INVISIBLE_REFERENCE!>C<!>.<!INVISIBLE_REFERENCE!>Companion<!> = <!INVISIBLE_MEMBER!>C<!>\n\nprivate val test2: <!INVISIBLE_REFERENCE!>TA<!> = <!INVISIBLE_MEMBER!>TA<!>()\nprivate val test2co = <!INVISIBLE_MEMBER!>TA<!>\n\nprivate class <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>C<!>\nprivate typealias <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>TA<!> = Int"
        },
        {
            "code": "typealias N = Nothing\n\nfun <!ABBREVIATED_NOTHING_RETURN_TYPE!>testFun<!>(): N = null!!\nval <!ABBREVIATED_NOTHING_PROPERTY_TYPE!>testVal<!>: N = null!!\nval <!ABBREVIATED_NOTHING_PROPERTY_TYPE!>testValWithGetter<!>: N get() = null!!\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Foo<A : Number>\nclass Bar<B : CharSequence>\n\nclass Hr<A, B, C, D>(val a: A, val b: B)\n\ntypealias Test<A, B> = Hr<A, B, Foo<A>, Bar<B>>\n\nval test1 = Test(1, \"\")\nval test2 = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>Test<!>(1, 2)\n\n\ntypealias Bas<T> = Hr<T, T, Foo<T>, Bar<T>>\n\nval test3 = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>Bas<!>(1, 1)\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass Num<T: Number>(val x: T)\n\ntypealias N<T> = Num<T>\ntypealias N2<T> = N<T>\n\nval x1 = Num<<!UPPER_BOUND_VIOLATED!>String<!>>(\"\")\nval x2 = N<<!UPPER_BOUND_VIOLATED!>String<!>>(\"\")\nval x3 = N2<<!UPPER_BOUND_VIOLATED!>String<!>>(\"\")\n\nclass TColl<T, C : Collection<T>>\n\ntypealias TC<T, C> = TColl<T, C>\ntypealias TC2<T, C> = TC<T, C>\n\nval y1 = TColl<Any, <!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>Any<!>>()\nval y2 = TC<Any, <!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>Any<!>>()\nval y3 = TC2<Any, <!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>Any<!>>()\n"
        },
        {
            "code": "interface Out<out R>\ninterface Inv<E>\ntypealias A1<E> = Out<Out<E>>\ntypealias A2<E> = Out<Out<E>>\ntypealias A3<E> = Inv<Out<E>>\ntypealias A4<E> = Out<Inv<E>>\n\ninterface Q1<out S> : Out<A1<S>>\ninterface Q2<out S> : Out<A2<S>>\ninterface Q3<out S> : Out<<!TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE!>A3<S><!>>\ninterface Q4<out S> : Out<<!TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE!>A4<S><!>>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass Outer<TO> {\n    typealias LTO = List<TO>\n\n    class Nested<TN> {\n        typealias LTO = List<<!UNRESOLVED_REFERENCE!>TO<!>>\n        typealias LTN = List<TN>\n\n        inner class Inner<TI> {\n            typealias LTO = List<<!UNRESOLVED_REFERENCE!>TO<!>>\n            typealias LTN = List<TN>\n            typealias LTI = List<TI>\n        }\n    }\n}\n\nfun <TF> foo() {\n    class Local<TL> {\n        typealias LTF = List<TF>\n        typealias LTL = List<TL>\n    }\n\n    fun <TLF> localfun() =\n            object {\n                typealias LTF = List<TF>\n                typealias LTLF = List<TLF>\n            }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\nclass TColl<T, C : Collection<T>>\n\ntypealias TC<T1, T2> = TColl<T1, T2>\ntypealias TC2<T1, T2> = TC<T1, T2>\n\nfun test1(x: TC2<Number, Collection<Number>>) {}\nfun test2(x: TC2<Number, Collection<Int>>) {}\nfun test3(x: TC2<Number, List<Int>>) {}\nfun test4(x: <!UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION!>TC2<Number, List<Any>><!>) {}\n\nval test5 = TC2<Number, Collection<Number>>()\nval test6 = TC2<Number, Collection<Int>>()\nval test7 = TC2<Number, List<Int>>()\nval test8 = TC2<Number, <!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>List<Any><!>>()\n"
        },
        {
            "code": "class A : <!CYCLIC_INHERITANCE_HIERARCHY!>B<!>() {\n    open class Nested<T>\n}\n\ntypealias ANested<T> = A.Nested<T>\n\nopen class B : <!CYCLIC_INHERITANCE_HIERARCHY!>ANested<Int><!>()"
        },
        {
            "code": "object AnObject {\n    val ok = \"OK\"\n    fun foo() = \"OK\"\n}\n\ntypealias GenericTestObject<<!UNUSED_TYPEALIAS_PARAMETER!>T<!>> = AnObject\n\nval test11: AnObject = GenericTestObject\nval test12: GenericTestObject<*> = GenericTestObject\nval test13: String = GenericTestObject.ok\nval test14: String = GenericTestObject.foo()\n\nclass GenericClassWithCompanion<T> {\n    companion object {\n        val ok = \"OK\"\n        fun foo() = \"OK\"\n    }\n}\n\ntypealias TestGCWC<T> = GenericClassWithCompanion<T>\n\nval test25: GenericClassWithCompanion.Companion = TestGCWC\nval test26 = TestGCWC\nval test27: String = TestGCWC.ok\nval test28: String = TestGCWC.foo()\n"
        },
        {
            "code": "open class Ref<T>(var x: T)\n\ntypealias R<T> = Ref<T>\n\n// Type inference SHOULD NOT work for type alias constructor in supertypes list\nclass Test1 : <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>R<!>(0)\nclass Test2 : R<Int>(0)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !CHECK_TYPE\n// FILE: a.kt\npackage a\n\nclass B(x: String)\ntypealias A1 = B\nprivate typealias A2 = B\nprivate typealias A3 = B\n\nfun A3(x: Any) = \"OK\"\n\nfun bar() {\n    A3(\"\") checkType { _<B>() }\n}\n\n// FILE: main.kt\npackage usage\n\nimport a.B\n\nfun baz() {\n    a.A1(\"\") // resolved to B constructor, OK\n    a.<!INVISIBLE_MEMBER!>A2<!>(\"\") // resolved to B constructor, INVISIBLE_MEMBER because type alias is private, OK\n\n    a.A3(\"\") checkType { _<String>() }\n\n    val x: a.<!INVISIBLE_REFERENCE!>A2<!> = B(\"\") // A2 is unresolved because it's private in file, OK\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Bound<X, Y : X>(val x: X, val y: Y)\ntypealias B<X, Y> = Bound<X, Y>\ntypealias BOutIn<T> = Bound<out List<T>, in T>\ntypealias BInIn<T> = Bound<in List<T>, in T>\n\nfun <T> listOf(): List<T> = null!!\n\n// Unresolved reference is ok here:\n// we can't create a substituted signature for type alias constructor\n// since it has 'out' type projection in 'in' position.\nval test1 = <!UNRESOLVED_REFERENCE!>BOutIn<!>(<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>listOf<!>(), null!!)\n\nval test2 = <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>BInIn(listOf(), null!!)<!>"
        },
        {
            "code": "typealias<!SYNTAX!><!>\n\n<!SYNTAX!><!>typealias A1<!SYNTAX!><!>\n\n<!SYNTAX!><!>typealias A2 =\n<!SYNTAX!><!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Outer {\n    inner class Inner\n}\n\ntypealias OI = Outer.Inner\n\nfun test1(x: Outer) = x.OI()\n\n\nclass Generic<T> {\n    inner class Inner\n}\n\ntypealias GI<T> = Generic<T>.Inner\ntypealias GIntI = Generic<Int>.Inner\n\nfun test2(x: Generic<Int>) = x.GI()\nfun <T> test3(x: Generic<T>) = x.GI()\nfun <T> test4(x: Generic<List<T>>) = x.GI()\nfun <T> test5(x: Generic<T>) = <!OI;TYPE_MISMATCH!>x<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>GIntI<!>()\nfun Generic<Int>.test6() = GIntI()"
        },
        {
            "code": "class C<T1, T2> {\n    companion object {\n        val OK = \"OK\"\n    }\n}\n\ntypealias C2<T> = C<T, T>\n\nval test1: String = <!FUNCTION_CALL_EXPECTED!>C2<String><!>.<!UNRESOLVED_REFERENCE!>OK<!>\nval test2: String = C2.OK\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nfun outer() {\n    <!WRONG_MODIFIER_TARGET!>companion<!> typealias TestLocal = Any\n}"
        },
        {
            "code": "typealias TopLevel = Any\n\ninterface A {\n    <!TOPLEVEL_TYPEALIASES_ONLY!>typealias Nested = Any<!>\n}\n\nclass C {\n    <!TOPLEVEL_TYPEALIASES_ONLY!>typealias Nested = Any<!>\n    class D {\n        <!TOPLEVEL_TYPEALIASES_ONLY!>typealias Nested = Any<!>\n        fun foo() {\n            <!TOPLEVEL_TYPEALIASES_ONLY!>typealias LocalInMember = Any<!>\n        }\n    }\n}\n\nfun foo() {\n    <!TOPLEVEL_TYPEALIASES_ONLY!>typealias Local = Any<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\ninterface Ref<T> {\n    var x: T\n}\n\nclass LateInitNumRef<NN: Number>() : Ref<NN> {\n    constructor(x: NN) : this() { this.x = x }\n\n    private var xx: NN? = null\n\n    override var x: NN\n        get() = xx!!\n        set(value) {\n            xx = value\n        }\n}\n\ntypealias LateNR<Nt> = LateInitNumRef<Nt>\n\nfun <V, R : Ref<in V>> update(r: R, v: V): R {\n    r.x = v\n    return r\n}\n\nval r1 = update(LateInitNumRef(), 1)\nval r1a = update(LateNR(), 1)\nval r2 = update(LateInitNumRef(1), 1)\nval r2a = update(LateNR(1), 1)\nval r3 = LateInitNumRef(1)\nval r3a = LateNR(1)\n\nfun test() {\n    r1.x = <!OI;TYPE_MISMATCH!>r1.x<!>\n    r1a.x = <!OI;TYPE_MISMATCH!>r1a.x<!>\n    r2.x = r2.x\n    r2a.x = r2a.x\n    r3.x = r3.x\n    r3a.x = r3a.x\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage something\n\nobject N\n\nclass WC {\n    companion object\n}\n\ntypealias T = N\ntypealias TWC = WC\n\n// FILE: 2.kt\nimport something.T\nimport something.TWC\n\nval test1 = T.hashCode()\nval test2 = TWC.hashCode()"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE)\nannotation class A\n\ntypealias AInt = @A Int\ntypealias AI = AInt\n\ntypealias Test1 = <!REPEATED_ANNOTATION!>@A<!> AInt\ntypealias Test2 = <!REPEATED_ANNOTATION!>@A<!> AI\ntypealias Test3 = List<<!REPEATED_ANNOTATION!>@A<!> AInt>\ntypealias Test4 = List<<!REPEATED_ANNOTATION!>@A<!> AI>\n\nval testProperty1: <!REPEATED_ANNOTATION!>@A<!> AInt = 0\nval testProperty2: <!REPEATED_ANNOTATION!>@A<!> AI = 0\n\nfun testFunction1(x: <!REPEATED_ANNOTATION!>@A<!> AInt): <!REPEATED_ANNOTATION!>@A<!> AInt = x\nfun testFunction2(x: <!REPEATED_ANNOTATION!>@A<!> AI): <!REPEATED_ANNOTATION!>@A<!> AI = x"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass A {\n    public inner class B { }\n    public typealias BAlias = B\n}\n\nfun f() {\n    val a = A()\n    a.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>BAlias<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n// FILE: file1.kt\npackage package1\n\ntypealias S = String\n\n// FILE: file2.kt\npackage package2\n\ntypealias I = Int\n\nclass Outer {\n    typealias A = Any\n}\n\n// FILE: test.kt\npackage package3\n\nimport package1.*\nimport package2.I\nimport package2.Outer.A\n\nval testS: S = \"\"\nval testI: I = 42\nval testA: A = Any()\n"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE)\nannotation class A\n\ntypealias Test1 = @A <!REPEATED_ANNOTATION!>@A<!> Int\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nopen class Base {\n    open fun foo() {}\n}\n\nopen class GenericBase<T> {\n    open fun foo() {}\n}\n\nclass Unrelated {\n    fun foo() {}\n}\n\ntypealias B = Base\ntypealias U = Unrelated\ntypealias GB<T> = GenericBase<T>\n\nclass TestSuperForBase : B() {\n    typealias MyBase = B\n\n    override fun foo() {\n        super<Base>.foo()\n        super<B>.foo()\n        super<MyBase>.foo()\n        super<<!NOT_A_SUPERTYPE!>U<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n    }\n}\n\nclass TestSuperForGenericBase<T> : GB<T>() {\n    typealias MyBase = GB<T>\n    typealias MyBaseInt = GB<Int>\n\n    override fun foo() {\n        super<GenericBase>.foo()\n        super<GB>.foo()\n        super<MyBase>.foo()\n        super<MyBaseInt>.foo() // Type arguments don't matter here\n        super<<!NOT_A_SUPERTYPE!>U<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n    }\n}"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE)\nannotation class Ann\n\ntypealias TString = String\n\ntypealias TNString = TString?\n\ntypealias TNAString = @Ann TString?\n\nval test1: TNString = TODO()\nval test2: TNAString = TODO()\nval test3: List<TNString> = TODO()\nval test4: List<TNAString> = TODO()\nval test5: List<TNString<!REDUNDANT_NULLABLE!>?<!>> = TODO()\nval test6: () -> List<TNString> = TODO()\n\nfun test(x: TNString) {\n    x<!UNSAFE_CALL!>.<!>hashCode()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\ninterface In<in T>\ninterface Out<out T>\n\ntypealias InAlias<T> = In<T>\ntypealias OutAlias<T> = Out<T>\n\ntypealias TestOutForIn<T> = In<<!CONFLICTING_PROJECTION!>out<!> T>\ntypealias TestInForOut<T> = Out<<!CONFLICTING_PROJECTION!>in<!> T>\n\ntypealias TestOutForInWithinAlias<T> = <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>InAlias<out T><!>\ntypealias TestInForOutWithinAlias<T> = <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>OutAlias<in T><!>\n\nfun <T> testOutForInWithinResolvedType(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>InAlias<out T><!>) {}\nfun <T> testInForOutWithinResolvedType(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>OutAlias<in T><!>) {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage test\n\ntypealias OI = Outer.Inner\n\nclass Outer {\n    open inner class Inner\n\n    inner class Test : OI()\n}\n\n\ntypealias GI<T> = Generic<T>.Inner\ntypealias GIInt = Generic<Int>.Inner\ntypealias GIStar = Generic<*>.Inner\ntypealias GG<T1, T2> = Generic<T1>.Generic<T2>\ntypealias GIntG<T2> = Generic<Int>.Generic<T2>\ntypealias GGInt<T1> = Generic<T1>.Generic<Int>\n\nclass Generic<T1> {\n    open inner class Inner\n    open inner class Generic<T2>\n\n    inner class Test1 : GI<T1>()\n    inner class Test2 : <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>GIInt<!>()\n    inner class Test3 : GIStar()\n    inner class Test3a : test.Generic<*>.Inner()\n\n    inner class Test4<T2> : GG<T1, T2>()\n    inner class Test5 : GG<T1, Int>()\n    inner class Test6 : <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>GG<!><Int, T1>()\n    inner class Test7 : <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>GG<!><Int, Int>()\n    inner class Test8 : <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>GIntG<!><Int>()\n    inner class Test9 : <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>GGInt<!><Int>()\n    inner class Test10 : GGInt<T1>()\n\n    inner class Test11 : GG<T1, Int> {\n        constructor() : super()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nopen class C<T>\n\ntypealias CStar = C<*>\ntypealias CIn = C<in Int>\ntypealias COut = C<out Int>\ntypealias CT<T> = C<T>\n\nclass Test1 : <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>CStar()<!>\nclass Test2 : <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>CIn()<!>\nclass Test3 : <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>COut()<!>\n\nclass Test4 : CStar {\n    constructor() : <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>super<!>()\n}\n\nclass Test5 : CT<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>*<!>>()\n"
        },
        {
            "code": "open class MyBase protected constructor() {\n    protected constructor(<!UNUSED_PARAMETER!>x<!>: Nothing?): this()\n}\ntypealias MyAlias = MyBase\n\nclass MyDerived1 : MyAlias()\nclass MyDerived1a : MyBase()\n\nclass MyDerived2 : MyAlias(null)\nclass MyDerived2a : MyBase(null)\n\nclass MyDerived3 : MyAlias {\n    constructor(x: Nothing?) : super(<!DEBUG_INFO_CONSTANT!>x<!>)\n}"
        },
        {
            "code": "typealias R = <!RECURSIVE_TYPEALIAS_EXPANSION!>R<!>\n\ntypealias L = <!RECURSIVE_TYPEALIAS_EXPANSION!>List<L><!>\n\ntypealias A = <!RECURSIVE_TYPEALIAS_EXPANSION!>B<!>\ntypealias B = <!RECURSIVE_TYPEALIAS_EXPANSION!>A<!>\n\ntypealias F1 = <!RECURSIVE_TYPEALIAS_EXPANSION!>(Int) -> F2<!>\ntypealias F2 = <!RECURSIVE_TYPEALIAS_EXPANSION!>(F1) -> Int<!>\n\nval x: <!RECURSIVE_TYPEALIAS_EXPANSION!>A<!> = TODO()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_TYPEALIAS_PARAMETER\n\ntypealias WithVariance<<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>in<!> X, <!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>out<!> Y> = Int\ntypealias WithBounds1<T : <!BOUND_ON_TYPE_ALIAS_PARAMETER_NOT_ALLOWED!>T<!>> = Int\ntypealias WithBounds2<X : <!BOUND_ON_TYPE_ALIAS_PARAMETER_NOT_ALLOWED!>Y<!>, Y : <!BOUND_ON_TYPE_ALIAS_PARAMETER_NOT_ALLOWED!>X<!>> = Int\n\ntypealias WithBounds3<X> <!SYNTAX!>where <!DEBUG_INFO_MISSING_UNRESOLVED!>X<!> : <!DEBUG_INFO_MISSING_UNRESOLVED!>Any<!><!> = Int\n\nval x: WithVariance<Int, Int> = 0\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_TYPEALIAS_PARAMETER\n\ninterface I1<S>\ninterface Out<out T>\ninterface InvOut<T1, out T2>\n\ntypealias A1<S> = I1<S>\ntypealias A2<T, S> = I1<S>\ntypealias AOut<T> = Out<T>\ntypealias AInvOut<T1, T2> = InvOut<T1, T2>\ntypealias AInvOutTT<T> = AInvOut<T, T>\n\nclass Test1<out S> : <!TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE!>A1<S><!>\nclass Test2<out S> : <!TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE!>A2<Any, S><!>\nclass Test3<out S> : AOut<S>\nclass Test4<out S> : <!TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE!>AInvOut<S, S><!>\nclass Test5<out S> : <!TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE!>AInvOutTT<S><!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass C<T>\n\ntypealias CStar = C<*>\ntypealias CIn = C<in Int>\ntypealias COut = C<out Int>\ntypealias CT<T> = C<T>\n\nval test1 = <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>CStar()<!>\nval test2 = <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>CIn()<!>\nval test3 = <!OI;EXPANDED_TYPE_CANNOT_BE_CONSTRUCTED!>COut()<!>\nval test4 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>CT<!><<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>>()\nval test5 = CT<CT<*>>()"
        },
        {
            "code": "interface IBase\n\ntypealias B = IBase\n\nclass Test1 : B\nclass Test2 : IBase, <!SUPERTYPE_APPEARS_TWICE!>B<!>\n"
        },
        {
            "code": "class In<in T>(val x: Any)\n\ntypealias InAlias<T> = In<T>\n\nval test1 = In<<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>out<!> String>(\"\")\nval test2 = InAlias<<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>out<!> String>(\"\")\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Pair<T1, T2>(val x1: T1, val x2: T2)\n\ntypealias P<T1, T2> = Pair<T1, T2>\n\ntypealias P2<T> = Pair<T, T>\n\ntypealias PR<T1, T2> = Pair<T2, T1>\n\nval test0 = P(1, 2)\nval test1 = P<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>(1, 2)\nval test2 = P<Int, Int>(1, 2)\nval test3 = P<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int, Int, Int><!>(1, 2)\n\nval test0p2 = P2(1, 1)\nval test0p2a = P2(1, \"\")\nval test1p2 = P2<Int>(1, 1)\nval test2p2 = P2<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int, Int><!>(1, 1)\nval test3p2 = P2<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int, Int, Int><!>(1, 1)\n\nval test0pr = PR(1, \"\")\nval test1pr = PR<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>(1, <!OI;TYPE_MISMATCH!>\"\"<!>)\nval test2pr = PR<Int, String>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!TYPE_MISMATCH!>\"\"<!>)\nval test2pra = PR<String, Int>(1, \"\")\nval test3pr = P2<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><String, Int, Int><!>(<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, \"\")\n\nclass Num<T : Number>(val x: T)\ntypealias N<T> = Num<T>\n\nval testN0 = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>N<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\nval testN1 = N<Int>(1)\nval testN1a = N<<!UPPER_BOUND_VIOLATED!>String<!>>(\"\")\nval testN2 = N<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int, Int><!>(1)\n\nclass MyPair<T1 : CharSequence, T2 : Number>(val string: T1, val number: T2)\ntypealias MP<T1> = MyPair<String, T1>\n\nval testMP0 = MP<Int>(\"\", 1)\nval testMP1 = <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>MP<!>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!NI;TYPE_MISMATCH!>\"\"<!>)\nval testMP2 = MP<<!UPPER_BOUND_VIOLATED!>String<!>>(\"\", \"\")"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nfun outer() {\n    typealias Test1 = <!RECURSIVE_TYPEALIAS_EXPANSION!>Test1<!>\n    typealias Test2 = <!RECURSIVE_TYPEALIAS_EXPANSION!>List<Test2><!>\n    typealias Test3<T> = List<<!UNRESOLVED_REFERENCE!>Test3<!><T>>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\ntypealias L<T> = List<T>\ntypealias NL<T> = List<T>?\ntypealias LStar<<!UNUSED_TYPEALIAS_PARAMETER!>T<!>> = List<*>\ntypealias MyList<<!UNUSED_TYPEALIAS_PARAMETER!>T<!>, X> = List<X>\n\nfun testL1(x: Collection<Any>) = x is L\nfun testL2(x: Collection<Int>): List<Int> = x as L\nfun testL3(x: Collection<Int>?): List<Int>? = x as L?\nfun testL4(x: Collection<Int>?): List<Int>? = x as? L\n\nfun testNL1(x: Collection<Int>?): Boolean = x is NL\nfun testNL2(x: Collection<Int>?): List<Int>? = x as NL\nfun testNL3(x: Collection<Int>?): List<Int>? = x as NL<!REDUNDANT_NULLABLE!>?<!>\n\nfun testLStar(x: Collection<Int>): List<Int> = x as LStar\nfun testMyList(x: Collection<Int>): List<Int> = x as MyList\n\ntypealias MMTT<T> = MutableMap<T, T>\ntypealias Dictionary<T> = MutableMap<String, T>\ntypealias WriteableMap<K, V> = MutableMap<in K, V>\ntypealias ReadableList<T> = MutableList<out T>\n\nfun testWrong1(x: Map<Any, Any>) = x is <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>MMTT<!>\nfun testWrong2(x: Map<Any, Any>) = x is <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Dictionary<!>\nfun testWrong3(x: Map<Any, Any>) = x is <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>WriteableMap<!>\nfun testWrong4(x: List<Any>) = x is <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>ReadableList<!>\n\nfun <T> testLocal(x: Any) {\n    class C\n    typealias CA = C\n    if (x is <!CANNOT_CHECK_FOR_ERASED!>C<!>) {}\n    if (x is <!CANNOT_CHECK_FOR_ERASED!>CA<!>) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\n// FILE: foo.kt\n\npackage test\n\ntypealias ClassAlias = ClassSample\ntypealias ObjectAlias = ObjectSample\ntypealias EnumAlias = EnumSample\n\nclass ClassSample {\n    class Nested {\n        fun func() {}\n    }\n\n    fun func() {}\n}\n\nobject ObjectSample {\n    class Nested {\n        fun func() {}\n    }\n\n    fun func() {}\n}\n\nenum class EnumSample {\n    Entry;\n\n    class Nested {\n        fun func() {}\n    }\n\n    fun func() {}\n}\n\n// FILE: test.kt\n\nfun foo(\n    a0: test.ClassSample.Nested,\n    a1: test.ClassAlias.<!UNRESOLVED_REFERENCE!>Nested<!>,\n\n    b0: test.ObjectSample.Nested,\n    b1: test.ObjectAlias.<!UNRESOLVED_REFERENCE!>Nested<!>,\n\n    c0: test.EnumSample.Nested,\n    c1: test.EnumAlias.<!UNRESOLVED_REFERENCE!>Nested<!>\n) {\n    test.ClassSample::Nested\n    test.ClassAlias::<!UNRESOLVED_REFERENCE!>Nested<!>\n\n    test.ClassSample::func\n    test.ClassAlias::func\n\n    test.ClassSample.Nested::func\n    test.ClassAlias.<!UNRESOLVED_REFERENCE!>Nested<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>func<!>\n\n    test.ObjectSample::Nested\n    test.ObjectAlias::Nested\n\n    test.ObjectSample::func\n    test.ObjectAlias::func\n\n    test.ObjectSample.Nested::func\n    test.ObjectAlias.<!UNRESOLVED_REFERENCE!>Nested<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>func<!>\n\n    test.EnumSample::Nested\n    test.EnumAlias::<!UNRESOLVED_REFERENCE!>Nested<!>\n\n    test.EnumSample::func\n    test.EnumAlias::func\n\n    test.EnumSample.Nested::func\n    test.EnumAlias.<!UNRESOLVED_REFERENCE!>Nested<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>func<!>\n}"
        },
        {
            "code": "// NI_EXPECTED_FILE\n\nclass In<in T>\nclass Out<out T>\nclass Inv<T>\n\ntypealias In1<T> = In<T>\ntypealias In2<T> = In<<!REDUNDANT_PROJECTION!>in<!> T>\ntypealias In3<T> = In<<!CONFLICTING_PROJECTION!>out<!> T>\ntypealias In4<<!UNUSED_TYPEALIAS_PARAMETER!>T<!>> = In<*>\n\ntypealias Out1<T> = Out<T>\ntypealias Out2<T> = Out<<!CONFLICTING_PROJECTION!>in<!> T>\ntypealias Out3<T> = Out<<!REDUNDANT_PROJECTION!>out<!> T>\ntypealias Out4<<!UNUSED_TYPEALIAS_PARAMETER!>T<!>> = Out<*>\n\ntypealias Inv1<T> = Inv<T>\ntypealias Inv2<T> = Inv<in T>\ntypealias Inv3<T> = Inv<out T>\ntypealias Inv4<<!UNUSED_TYPEALIAS_PARAMETER!>T<!>> = Inv<*>\n\nval inv1: Inv1<Int> = Inv<Int>()\n\nfun inInv_Inv(x: In1<Int>) = x\nfun inInv_In(x: In1<in Int>) = x\nfun inInv_Out(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>In1<out Int><!>) = x\nfun inInv_Star(x: In1<*>) = x\n\nfun inIn_Inv(x: In2<Int>) = x\nfun inIn_In(x: In2<in Int>) = x\nfun inIn_Out(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION, CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>In2<out Int><!>) = x\nfun inIn_Star(x: In2<*>) = x\n\nfun inOut_Inv(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>In3<Int><!>) = x\nfun inOut_In(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>In3<in Int><!>) = x\nfun inOut_Out(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>In3<out Int><!>) = x\nfun inOut_Star(x: In3<*>) = x\n\nfun outInv_Inv(x: Out1<Int>) = x\nfun outInv_In(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Out1<in Int><!>) = x\nfun outInv_Out(x: Out1<out Int>) = x\nfun outInv_Star(x: Out1<*>) = x\n\nfun outIn_Inv(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Out2<Int><!>) = x\nfun outIn_In(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Out2<in Int><!>) = x\nfun outIn_Out(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Out2<out Int><!>) = x\nfun outIn_Star(x: Out2<*>) = x\n\nfun outOut_Inv(x: Out3<Int>) = x\nfun outOut_In(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION, CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Out3<in Int><!>) = x\nfun outOut_Out(x: Out3<out Int>) = x\nfun outOut_Star(x: Out3<*>) = x\n\nfun invInv_Inv(x: Inv1<Int>) = x\nfun invInv_In(x: Inv1<in Int>) = x\nfun invInv_Out(x: Inv1<out Int>) = x\nfun invInv_Star(x: Inv1<*>) = x\n\nfun invIn_Inv(x: Inv2<Int>) = x\nfun invIn_In(x: Inv2<in Int>) = x\nfun invIn_Out(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Inv2<out Int><!>) = x\nfun invIn_Star(x: Inv2<*>) = x\n\nfun invOut_Inv(x: Inv3<Int>) = x\nfun invOut_In(x: <!CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION!>Inv3<in Int><!>) = x\nfun invOut_Out(x: Inv3<out Int>) = x\nfun invOut_Star(x: Inv3<*>) = x\n"
        },
        {
            "code": "// FILE: foo.kt\n\n// FILE: foo.kt\n\npackage test\n\ntypealias ClassAlias = ClassSample\ntypealias ObjectAlias = ObjectSample\ntypealias EnumAlias = EnumSample\n\nclass ClassSample\n\nobject ObjectSample\n\nenum class EnumSample {\n    Entry;\n}\n\n// FILE: bar.kt\n\nimport test.ClassAlias.*\nimport test.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>ObjectAlias<!>.*\nimport test.EnumAlias.*\nimport test.EnumAlias\n\n\nfun bar() {\n    Entry\n    EnumAlias.Entry\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass Pair<X, Y>(val x: X, val y: Y)\n\nclass C<T> {\n    typealias P = Pair<T, T>\n    typealias P1<X> = Pair<X, T>\n    typealias P2<Y> = Pair<T, Y>\n}\n\n// C<...>.P[<...>]() syntax doesn't work due to the way qualified expressions are resolved now.\n// This restriction can be removed later.\nval test0 = <!FUNCTION_CALL_EXPECTED!>C<Int><!>.<!UNRESOLVED_REFERENCE!>P<!>(1, 1)\nval test1 = <!FUNCTION_CALL_EXPECTED!>C<Int><!>.<!UNRESOLVED_REFERENCE!>P1<!><String>(\"\", 1)\nval test2 = <!FUNCTION_CALL_EXPECTED!>C<Int><!>.<!UNRESOLVED_REFERENCE!>P2<!><String>(1, \"\")\nval test3 = <!FUNCTION_CALL_EXPECTED!>C<Int><!>.<!UNRESOLVED_REFERENCE!>P1<!>(\"\", 1)\nval test4 = <!FUNCTION_CALL_EXPECTED!>C<Int><!>.<!UNRESOLVED_REFERENCE!>P2<!>(1, \"\")\n\n// C.P() syntax could work if we add captured type parameters as type variables in a constraint system for corresponding call.\n// However, this should be consistent with inner classes capturing type parameters.\nval test5 = C.P(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\nval test6 = C.<!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>P1<!>(\"\", <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\nval test7 = C.<!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>P2<!>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, \"\")\n"
        },
        {
            "code": "// FILE: 1.kt\npackage bar\n\ntypealias HostAlias = Host\n\nobject Host {\n    fun foo() {}\n}\n\n// FILE: 2.kt\nimport bar.HostAlias.foo\n\nfun test() {\n    foo()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nopen class MyClass private constructor(val x: Int) {\n\n    protected constructor(x: String) : this(x.length)\n\n    constructor(x: Double) : this(x.toInt())\n}\n\ntypealias MyAlias = MyClass\n\nval test1 = <!INVISIBLE_MEMBER!>MyAlias<!>(1)\nval test1a = <!INVISIBLE_MEMBER!>MyClass<!>(1)\n\nval test2 = <!INVISIBLE_MEMBER!>MyAlias<!>(\"\")\nval test2a = <!INVISIBLE_MEMBER!>MyClass<!>(\"\")\n\nval test3 = MyAlias(1.0)\nval test3a = MyClass(1.0)\n\nclass MyDerived : MyClass(1.0) {\n    val test4 = <!INVISIBLE_MEMBER!>MyAlias<!>(1)\n    val test4a = <!INVISIBLE_MEMBER!>MyClass<!>(1)\n    val test5 = <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>MyAlias<!>(\"\")\n    val test5a = <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>MyClass<!>(\"\")\n    val test6 = MyAlias(1.0)\n    val test6a = MyClass(1.0)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n\nabstract class AbstractClass\ntypealias Test1 = AbstractClass\nval test1 = <!CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS!>Test1()<!>\nval test1a = <!CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS!>AbstractClass()<!>\n\nannotation class AnnotationClass\ntypealias Test2 = AnnotationClass\nval test2 = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Test2()<!>\nval test2a = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>AnnotationClass()<!>\n\nenum class EnumClass { VALUE1, VALUE2 }\ntypealias Test3 = EnumClass\nval test3 = <!ENUM_CLASS_CONSTRUCTOR_CALL!><!INVISIBLE_MEMBER!>Test3<!>()<!>\nval test3a = <!ENUM_CLASS_CONSTRUCTOR_CALL!><!INVISIBLE_MEMBER!>EnumClass<!>()<!>\n\nsealed class SealedClass\ntypealias Test4 = SealedClass\nval test4 = <!SEALED_CLASS_CONSTRUCTOR_CALL!><!INVISIBLE_MEMBER!>Test4<!>()<!>\nval test4a = <!SEALED_CLASS_CONSTRUCTOR_CALL!><!INVISIBLE_MEMBER!>SealedClass<!>()<!>\n\nclass Outer {\n    inner class Inner\n    typealias TestInner = Inner\n}\ntypealias Test5 = Outer.Inner\n\nval test5 = <!RESOLUTION_TO_CLASSIFIER!>Test5<!>()\nval test5a = Outer.<!RESOLUTION_TO_CLASSIFIER!>Inner<!>()\nval test5b = Outer.<!RESOLUTION_TO_CLASSIFIER!>TestInner<!>()\nval test5c = Outer().<!UNRESOLVED_REFERENCE!>TestInner<!>()\nval test5d = Outer().Inner()\nval test5e = Outer().Test5()\n"
        },
        {
            "code": "// FILE: b.kt\npackage MyPackage\n    //properties\n    <!MUST_BE_INITIALIZED!>val a: Int<!>\n    val a1: Int = 1\n    <!MUST_BE_INITIALIZED!><!WRONG_MODIFIER_TARGET!>abstract<!> val a2: Int<!>\n    <!WRONG_MODIFIER_TARGET!>abstract<!> val a3: Int = 1\n\n    <!MUST_BE_INITIALIZED!>var b: Int<!>                private set\n    var b1: Int = 0;                         private set\n    <!MUST_BE_INITIALIZED!><!WRONG_MODIFIER_TARGET!>abstract<!> var b2: Int<!>      private set\n    <!WRONG_MODIFIER_TARGET!>abstract<!> var b3: Int = 0; private set\n\n    <!MUST_BE_INITIALIZED!>var c: Int<!>                set(v: Int) { field = v }\n    var c1: Int = 0;                         set(v: Int) { field = v }\n    <!MUST_BE_INITIALIZED!><!WRONG_MODIFIER_TARGET!>abstract<!> var c2: Int<!>      set(v: Int) { field = v }\n    <!WRONG_MODIFIER_TARGET!>abstract<!> var c3: Int = 0; set(v: Int) { field = v }\n\n    val e: Int                               get() = a\n    val e1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;          get() = a\n    <!WRONG_MODIFIER_TARGET!>abstract<!> val e2: Int      get() = a\n    <!WRONG_MODIFIER_TARGET!>abstract<!> val e3: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>; get() = a\n\n    //methods\n    <!NON_MEMBER_FUNCTION_NO_BODY!>fun f()<!>\n    fun g() {}\n    <!WRONG_MODIFIER_TARGET!>abstract<!> fun h()\n    <!WRONG_MODIFIER_TARGET!>abstract<!> fun j() {}\n\n    //property accessors\n    var i: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var i1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var j: Int                       get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var j1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    <!MUST_BE_INITIALIZED!>var k: Int<!>        <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var k1: Int = 0;                 <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var l: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var l1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var n: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get <!WRONG_MODIFIER_TARGET!>abstract<!> set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n\n// FILE: c.kt\n//creating an instance\nabstract class B1(\n    val i: Int,\n    val s: String\n) {\n}\n\nclass B2() : B1(1, \"r\") {}\n\nabstract class B3(<!UNUSED_PARAMETER!>i<!>: Int) {\n}\n\nfun foo(<!UNUSED_PARAMETER!>c<!>: B3) {\n    val <!UNUSED_VARIABLE!>a<!> = <!CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS!>B3(1)<!>\n    val <!UNUSED_VARIABLE!>b<!> = <!CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS!>B1(2, \"s\")<!>\n}"
        },
        {
            "code": "import kotlin.reflect.*\n\nclass Foo(val prop: Any) {\n    fun func() {}\n}\n\nfun n01() = Foo::prop\nfun n02() = Foo::func\nfun n03() = Foo::class\nfun n04(p: KProperty0<Int>) = p.get()\nfun n05(p: KMutableProperty0<String>) = p.set(\"\")\nfun n07(p: KFunction<String>) = p.name\nfun n08(p: KProperty1<String, Int>) = p.get(\"\")\nfun n09(p: KProperty2<String, String, Int>) = p.get(\"\", \"\")\nfun n10() = (Foo::func).invoke(Foo(\"\"))\nfun n11() = (Foo::func)(Foo(\"\"))\n\nfun y01() = Foo::prop.<!NO_REFLECTION_IN_CLASS_PATH!>getter<!>\nfun y02() = Foo::class.<!NO_REFLECTION_IN_CLASS_PATH!>members<!>\nfun y03() = Foo::class.simpleName\nfun y04() = Foo::class.<!UNRESOLVED_REFERENCE!>properties<!>\n\nfun <T : Any> kclass(k: KClass<*>, kt: KClass<T>) {\n    k.simpleName\n    k.qualifiedName\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>members<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>constructors<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>nestedClasses<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>objectInstance<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>typeParameters<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>supertypes<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>visibility<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isFinal<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isOpen<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isAbstract<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isSealed<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isData<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isInner<!>\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>isCompanion<!>\n\n    k.<!NO_REFLECTION_IN_CLASS_PATH!>annotations<!>\n    k.isInstance(42)\n\n    k == kt\n    k.hashCode()\n    k.toString()\n}\n\nfun ktype(t: KType, t2: KType) {\n    t.classifier\n    t.arguments\n    t.isMarkedNullable\n    t.annotations\n\n    t == t2\n    t.hashCode()\n    t.toString()\n\n    KTypeProjection.Companion.covariant(t)\n    KTypeProjection.STAR\n    KTypeProjection(KVariance.IN, t)\n}\n"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>a<!>: (String) -> Unit) {\n    \"\".<!UNRESOLVED_REFERENCE!>a<!>()\n}\n\n\n\ninterface A : (String) -> Unit {}\n\nfun foo(<!UNUSED_PARAMETER!>a<!>: @ExtensionFunctionType A) {\n    // @Extension annotation on an unrelated type shouldn't have any effect on this diagnostic.\n    // Only kotlin.Function{n} type annotated with @Extension should\n    \"\".<!UNRESOLVED_REFERENCE!>a<!>()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +LateinitTopLevelProperties\n\nobject Delegate {\n    operator fun getValue(instance: Any?, property: Any) : String = \"\"\n    operator fun setValue(instance: Any?, property: Any, value: String) {}\n}\n\nlateinit var testOk: String\n\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val testErr0: Any\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var testErr1: Int\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var testErr2: Any?\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var testErr3: String = \"\"\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var testErr4 by Delegate\n"
        },
        {
            "code": "<!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>val String.test1: Int<!>\n<!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>var String.test2: Int<!>\n\n<!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>var String.test3: Int<!>; public set\n\nclass C {\n    <!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>val String.test1: Int<!>\n    <!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>var String.test2: Int<!>\n    <!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>var String.test3: Int<!>; public set\n}\n\ninterface I {\n    val String.test1: Int\n    var String.test2: Int\n    var String.test3: Int; public set\n}\n\nabstract class A {\n    <!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>val String.test1: Int<!>\n    <!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>var String.test2: Int<!>\n    <!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>var String.test3: Int<!>; public set\n\n    abstract val String.testA1: Int\n    abstract var String.testA2: Int\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nval x get() = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>()\nval y get() = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>()\n\nfun <E> foo(): E = null!!\nfun <E> bar(): List<E> = null!!\n"
        },
        {
            "code": "// !CHECK_TYPE\nclass A {\n    val x get() = 1\n    val y get() = id(1)\n    val y2 get() = id(id(2))\n    val z get() = l(\"\")\n    val z2 get() = l(id(l(\"\")))\n\n    val <T> T.u get() = id(this)\n}\nfun <E> id(x: E) = x\nfun <E> l(<!UNUSED_PARAMETER!>x<!>: E): List<E> = null!!\n\nfun foo(a: A) {\n    a.x checkType { _<Int>() }\n    a.y checkType { _<Int>() }\n    a.y2 checkType { _<Int>() }\n    a.z checkType { _<List<String>>() }\n    a.z2 checkType { _<List<List<String>>>() }\n\n    with(a) {\n        1.u checkType { _<Int>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: -ShortSyntaxForPropertyGetters\n// NI_EXPECTED_FILE\n\n// blockBodyGetter.kt\n<!UNSUPPORTED_FEATURE!>val x get() {\n    return 1\n}<!>\n\n// cantBeInferred.kt\n<!UNSUPPORTED_FEATURE!>val x1 get() = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>()<!>\n<!UNSUPPORTED_FEATURE!>val y1 get() = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>()<!>\n\nfun <E> foo(): E = null!!\nfun <E> bar(): List<E> = null!!\n\n// explicitGetterType.kt\n<!UNSUPPORTED_FEATURE!>val x2 get(): String = foo()<!>\n<!UNSUPPORTED_FEATURE!>val y2 get(): List<Int> = bar()<!>\n<!UNSUPPORTED_FEATURE!>val z2 get(): List<Int> {\n    return bar()\n}<!>\n\n<!MUST_BE_INITIALIZED!>val u<!> get(): String = field\n\n// members.kt\nclass A {\n    <!UNSUPPORTED_FEATURE!>val x get() = 1<!>\n    <!UNSUPPORTED_FEATURE!>val y get() = id(1)<!>\n    <!UNSUPPORTED_FEATURE!>val y2 get() = id(id(2))<!>\n    <!UNSUPPORTED_FEATURE!>val z get() = l(\"\")<!>\n    <!UNSUPPORTED_FEATURE!>val z2 get() = l(id(l(\"\")))<!>\n\n    <!UNSUPPORTED_FEATURE!>val <T> T.u get() = id(this)<!>\n}\nfun <E> id(x: E) = x\nfun <E> l(<!UNUSED_PARAMETER!>x<!>: E): List<E> = null!!\n\n// vars\n<!UNSUPPORTED_FEATURE!>var x3\n    get() = 1\n    set(<!UNUSED_PARAMETER!>q<!>) {\n    }<!>\n\n// recursive\n<!UNSUPPORTED_FEATURE!>val x4 get() = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>x4<!><!>\n\n// null as nothing\n<!UNSUPPORTED_FEATURE!>val x5 get() = null<!>\n<!UNSUPPORTED_FEATURE!>val <!IMPLICIT_NOTHING_PROPERTY_TYPE!>y5<!> get() = null!!<!>\n\n// objectExpression.kt\nobject Outer {\n    <!UNSUPPORTED_FEATURE!>private var x\n        get() = object : CharSequence {\n            override val length: Int\n                get() = 0\n\n            override fun get(index: Int): Char {\n                return ' '\n            }\n\n            override fun subSequence(startIndex: Int, endIndex: Int) = \"\"\n\n            fun bar() {\n            }\n        }\n        set(q) {\n            x = q\n        }<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\ninterface A {\n    val x: Int\n\n    val z: Comparable<*>\n}\n\nopen class B {\n    open var y = \"\"\n\n    open val z: CharSequence = \"\"\n}\n\nclass C : B(), A {\n    override val x\n        get() = 1\n\n    override var y\n        get() = super.y\n        set(value) {\n            value checkType { _<String>() }\n        }\n\n    override var z\n        get() = \"\"\n        set(value) {\n            value checkType { _<String>() }\n        }\n}\n\nfun foo(c: C) {\n    c.x checkType { _<Int>() }\n    c.y checkType { _<String>() }\n    c.z checkType { _<String>() }\n\n    c.y = \"\"\n    c.y = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n\n    c.z = \"\"\n    c.z = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\nobject Outer {\n    private var x\n        get() = object : CharSequence {\n            override val length: Int\n                get() = 0\n\n            override fun get(index: Int): Char {\n                checkSubtype<CharSequence>(<!NI;DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>x<!>)\n                return ' '\n            }\n\n            override fun subSequence(startIndex: Int, endIndex: Int) = \"\"\n\n            fun bar() {\n            }\n        }\n        set(q) {\n            checkSubtype<CharSequence>(x)\n            y = q\n            x = q\n        }\n\n    private var y = <!DEBUG_INFO_LEAKING_THIS!>x<!>\n\n    fun foo() {\n        x = y\n\n        checkSubtype<CharSequence>(x)\n        checkSubtype<CharSequence>(y)\n\n        x.bar()\n        y.bar()\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\nval x get(): String = foo()\nval y get(): List<Int> = bar()\nval z get(): List<Int> {\n    return bar()\n}\n\n<!MUST_BE_INITIALIZED!>val u<!> get(): String = field\n\nfun <E> foo(): E = null!!\nfun <E> bar(): List<E> = null!!\n\n\nfun baz() {\n    x checkType { _<String>() }\n    y checkType { _<List<Int>>() }\n    z checkType { _<List<Int>>() }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject Delegate {\n    operator fun getValue(x: Any?, y: Any?): String = \"\"\n}\n\nfun <T> delegateFactory(p: Any) = Delegate\n\nclass C(p: Any, val v: Any) {\n\n    val test1 get() = <!UNRESOLVED_REFERENCE!>p<!>\n\n    val test2 get() = v\n\n    // NB here we can use both 'T' (property type parameter) and 'p' (primary constructor parameter)\n    val <T> List<T>.test3 by delegateFactory<T>(p)\n\n    <!PROPERTY_WITH_NO_TYPE_NO_INITIALIZER!>val test4<!> get() { return <!UNRESOLVED_REFERENCE!>p<!> }\n\n    <!PROPERTY_WITH_NO_TYPE_NO_INITIALIZER!>var test5<!>\n        get() { return <!UNRESOLVED_REFERENCE!>p<!> }\n        set(nv) { <!UNRESOLVED_REFERENCE!>p<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>let<!> {} }\n}"
        },
        {
            "code": "// !CHECK_TYPE\nval x get() = 1\nval y get() = id(1)\nval y2 get() = id(id(2))\nval z get() = l(\"\")\nval z2 get() = l(id(l(\"\")))\n\nval <T> T.u get() = id(this)\n\nfun <E> id(x: E) = x\nfun <E> l(<!UNUSED_PARAMETER!>x<!>: E): List<E> = null!!\n\nfun foo() {\n    x checkType { _<Int>() }\n    y checkType { _<Int>() }\n    y2 checkType { _<Int>() }\n    z checkType { _<List<String>>() }\n    z2 checkType { _<List<List<String>>>() }\n\n    1.u checkType { _<Int>() }\n}\n"
        },
        {
            "code": "<!PROPERTY_WITH_NO_TYPE_NO_INITIALIZER!>val x<!> get() {\n    return 1\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\nval x get() = null\nval <!IMPLICIT_NOTHING_PROPERTY_TYPE!>y<!> get() = null!!\n\nfun foo() {\n    <!DEBUG_INFO_CONSTANT!>x<!> checkType { _<Nothing?>() }\n    y <!UNREACHABLE_CODE!>checkType { _<Nothing>() }<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// NI_EXPECTED_FILE\n\nval x get() = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>x<!>\n\nclass A {\n    val y get() = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>y<!>\n\n    val a get() = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b<!>\n    val b get() = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>a<!>\n\n    val z1 get() = id(<!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>z1<!>)\n    val z2 get() = l(<!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>z2<!>)\n\n    val u get() = <!UNRESOLVED_REFERENCE!>field<!>\n}\n\nfun <E> id(x: E) = x\nfun <E> l(<!UNUSED_PARAMETER!>x<!>: E): List<E> = null!!\n"
        },
        {
            "code": "// !CHECK_TYPE\nvar x\n    get() = 1\n    set(q) {\n        q checkType { _<Int>() }\n    }\n\n<!MUST_BE_INITIALIZED!>var noSetter<!>\n    get() = 1\n\n\nfun foo() {\n    x checkType { _<Int>() }\n    noSetter checkType { _<Int>() }\n\n    x = 1\n    x = <!TYPE_MISMATCH!>\"\"<!>\n\n    noSetter = 2\n    noSetter = <!TYPE_MISMATCH!>\"\"<!>\n}\n"
        },
        {
            "code": "// FILE: fileDependencyRecursion.kt\npackage test\n\nimport testOther.some\n\nval normal: Int = 1\nval fromImported: Int = some\n\n// FILE: fileDependencyRecursionOther.kt\npackage testOther\n\nimport test.normal\n\nval some: Int = 1\nval fromImported: Int = normal"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun text() {\n    \"direct:a\" to \"mock:a\"\n    \"direct:a\" on {it.body == \"<hello/>\"} to \"mock:a\"\n    \"direct:a\" on {it -> it.body == \"<hello/>\"} to \"mock:a\"\n    bar <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>{<!>1}\n    bar <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>{<!><!UNRESOLVED_REFERENCE!>it<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> 1}\n    bar {it, <!UNUSED_ANONYMOUS_PARAMETER!>it1<!> -> it}\n\n    bar1 {1}\n    bar1 {it + 1}\n\n    bar2 {<!TYPE_MISMATCH!><!>}\n    bar2 {1}\n    bar2 {<!UNRESOLVED_REFERENCE!>it<!>}\n    bar2 <!NI;TYPE_MISMATCH!>{<!CANNOT_INFER_PARAMETER_TYPE, EXPECTED_PARAMETERS_NUMBER_MISMATCH!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>it<!>}<!>\n}\n\nfun bar(<!UNUSED_PARAMETER!>f<!> :  (Int, Int) -> Int) {}\nfun bar1(<!UNUSED_PARAMETER!>f<!> :  (Int) -> Int) {}\nfun bar2(<!UNUSED_PARAMETER!>f<!> :  () -> Int) {}\n\ninfix fun String.to(<!UNUSED_PARAMETER!>dest<!> : String) {\n\n}\n\ninfix fun String.on(<!UNUSED_PARAMETER!>predicate<!> :  (s : URI) -> Boolean) : URI {\n    return URI(this)\n}\n\nclass URI(val body : Any) {\n    infix fun to(<!UNUSED_PARAMETER!>dest<!> : String) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C\n\noperator fun C.plus(a: Any): C = this\noperator fun C.plusAssign(a: Any) {}\n\nfun test() {\n    val c = C()\n    c += \"\"\n    var c1 = C()\n    c1 <!ASSIGN_OPERATOR_AMBIGUITY!>+=<!> \"\"\n}"
        },
        {
            "code": "//KT-1821 Write test for ITERATOR_AMBIGUITY diagnostic\n\ninterface MyCollectionInterface {\n}\n\ninterface MyAnotherCollectionInterface {\n}\n\nclass MyCollection : MyCollectionInterface, MyAnotherCollectionInterface {\n}\n\nfun MyCollectionInterface.iterator() = MyIterator()\n\nfun MyAnotherCollectionInterface.iterator() = MyIterator()\n\nclass MyIterator {\n    fun next() : MyElement = MyElement()\n    fun hasNext() = true\n}\n\nclass MyElement\n\nfun test1(collection: MyCollection) {\n    collection.<!OVERLOAD_RESOLUTION_AMBIGUITY!>iterator<!>()\n    for (element in <!ITERATOR_AMBIGUITY!>collection<!>) {\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-13330 AssertionError: Illegal resolved call to variable with invoke\n\nfun foo(exec: (String.() -> Unit)?) = \"\".<!NI;UNSAFE_IMPLICIT_INVOKE_CALL, NI;WRONG_NUMBER_OF_TYPE_ARGUMENTS, OI;UNSAFE_IMPLICIT_INVOKE_CALL!>exec<!><!OI;WRONG_NUMBER_OF_TYPE_ARGUMENTS!><<!UNRESOLVED_REFERENCE!>caret<!>><!>() // <caret> is test data tag here"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    operator fun get(i: Int): C = this\n}\n\noperator fun C.plus(a: Any): C = this\noperator fun C.plusAssign(a: Any) {}\n\nclass C1 {\n    operator fun get(i: Int): C = C()\n    operator fun set(i: Int, v: C) {}\n}\n\nfun test() {\n    val c = C()\n    c[0] += \"\"\n    var c1 = C1()\n    c1[0] <!ASSIGN_OPERATOR_AMBIGUITY!>+=<!> \"\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject Legal {\n    operator fun get(i: Int) = 0\n    operator fun set(i: Int, newValue: Int) {}\n    operator fun set(i: Int, newValue: String) {}\n}\n\nfun testLegal() {\n    ++Legal[0]\n    Legal[0]++\n    Legal[0] += 1\n}\n\nobject MismatchingTypes {\n    operator fun get(i: Int) = 0\n    operator fun set(i: Int, newValue: String) {}\n}\n\nfun testMismatchingTypes() {\n    ++MismatchingTypes<!NO_SET_METHOD!>[0]<!>\n    MismatchingTypes<!NO_SET_METHOD!>[0]<!>++\n    MismatchingTypes<!NO_SET_METHOD!>[0]<!> += 1\n}\n\nobject MismatchingArities1 {\n    operator fun get(i: Int) = 0\n    operator fun set(i: Int, j: Int, newValue: Int) {}\n}\n\nobject MismatchingArities2 {\n    operator fun get(i: Int, j: Int) = 0\n    operator fun set(i: Int, newValue: Int) {}\n}\n\nfun testMismatchingArities() {\n    ++MismatchingArities1<!NO_SET_METHOD!>[0]<!>\n    MismatchingArities1<!NO_SET_METHOD!>[0]<!>++\n    MismatchingArities1<!NO_SET_METHOD!>[0]<!> += 1\n\n    ++<!NO_VALUE_FOR_PARAMETER!>MismatchingArities2[0]<!>\n    <!NO_VALUE_FOR_PARAMETER!>MismatchingArities2[0]<!>++\n    <!NO_VALUE_FOR_PARAMETER!>MismatchingArities2[0]<!> += 1\n}\n\n"
        },
        {
            "code": "//KT-1028 Wrong type checking for plusAssign\npackage kt1028\n\nimport java.util.*\n\nclass event<T>()\n{\n    val callbacks = ArrayList< Function1<T, Unit> >() // Should be ArrayList<()->Unit>, bug posted\n\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plusAssign(f : (T) -> Unit) = callbacks.add(f)\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minusAssign(f : (T) -> Unit) = callbacks.remove(f)\n    fun call(value : T) { for(c in callbacks) c(value) }\n}\n\nclass MouseMovedEventArgs()\n{\n    public val X : Int = 0\n}\n\nclass Control()\n{\n    public val MouseMoved : event<MouseMovedEventArgs> = event<MouseMovedEventArgs>()\n\n    fun MoveMouse() = MouseMoved.call(MouseMovedEventArgs())\n}\n\nclass Test()\n{\n    fun test()\n    {\n        val control = Control()\n        control.MouseMoved <!ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT!>+=<!> { it.X } // here\n        control.MouseMoved.plusAssign( { it.X } ) // ok\n    }\n}"
        },
        {
            "code": "fun intBinEq() {\n    var x = 0\n    x <!NONE_APPLICABLE!>+=<!> 'a'\n    x += 1.toByte()\n    x += 1.toShort()\n    <!TYPE_MISMATCH!>x += 1L<!>\n    <!TYPE_MISMATCH!>x += 1f<!>\n    <!TYPE_MISMATCH!>x += 1.0<!>\n    x <!NONE_APPLICABLE!>*=<!> 'a'\n    x *= 1.toByte()\n    x *= 1.toShort()\n    <!TYPE_MISMATCH!>x *= 1L<!>\n    <!TYPE_MISMATCH!>x *= 1f<!>\n    <!TYPE_MISMATCH!>x *= 1.0<!>\n}\n\nfun shortBinEq() {\n    var x = 0.toShort()\n    x <!NONE_APPLICABLE!>+=<!> 'a'\n    <!TYPE_MISMATCH!>x += 1.toByte()<!>\n    <!TYPE_MISMATCH!>x += 1.toShort()<!>\n    <!TYPE_MISMATCH!>x += 1L<!>\n    <!TYPE_MISMATCH!>x += 1f<!>\n    <!TYPE_MISMATCH!>x += 1.0<!>\n\n    x <!NONE_APPLICABLE!>*=<!> 'a'\n    <!TYPE_MISMATCH!>x *= 1.toByte()<!>\n    <!TYPE_MISMATCH!>x *= 1.toShort()<!>\n    <!TYPE_MISMATCH!>x *= 1L<!>\n    <!TYPE_MISMATCH!>x *= 1f<!>\n    <!TYPE_MISMATCH!>x *= 1.0<!>\n}\n\nclass A {\n    operator fun plus(x : A) : A { return x }\n}\n\nclass B {\n    operator fun plus(x : A) : A { return x }\n}\n\nfun overloading() {\n    var x = A()\n    var y = A()\n    x += y\n    var z = B()\n    <!TYPE_MISMATCH!>z += x<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nclass A {\n    operator fun get(x: Int): Int = x\n    fun set(<!UNUSED_PARAMETER!>x<!>: Int, <!UNUSED_PARAMETER!>y<!>: Int) {} // no `operator` modifier\n}\n\nfun main() {\n    val a = A()\n    <!OPERATOR_MODIFIER_REQUIRED!>a<!NI;NO_SET_METHOD!>[1]<!><!>++\n    <!OPERATOR_MODIFIER_REQUIRED!>a<!NI;NO_SET_METHOD!>[1]<!><!> += 3\n    <!OPERATOR_MODIFIER_REQUIRED!>a[1]<!> = a[1] + 3\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    val c: C = C()\n}\n\noperator fun C.plus(a: Any): C = this\noperator fun C.plusAssign(a: Any) {}\n\nclass C1 {\n    var c: C = C()\n}\n\nfun test() {\n    val c = C()\n    c.c += \"\"\n    var c1 = C1()\n    c1.c <!ASSIGN_OPERATOR_AMBIGUITY!>+=<!> \"\"\n}"
        },
        {
            "code": "class A {\n  operator fun plusAssign(<!UNUSED_PARAMETER!>x<!>: Int) {}\n  operator fun minusAssign(<!UNUSED_PARAMETER!>x<!>: Int) {}\n  operator fun timesAssign(<!UNUSED_PARAMETER!>x<!>: Int) {}\n  operator fun divAssign(<!UNUSED_PARAMETER!>x<!>: Int) {}\n  operator fun remAssign(<!UNUSED_PARAMETER!>x<!>: Int) {}\n}\n\nfun testVal() {\n  val a = A()\n  a += 1\n  a -= 1\n  a *= 1\n  a /= 1\n  a %= 1\n}\n\nfun testExpr() {\n  A() += 1\n  A() -= 1\n  A() *= 1\n  A() /= 1\n  A() %= 1\n}\n\nclass B {\n  operator fun plus(<!UNUSED_PARAMETER!>x<!>: Int): B = B()\n  operator fun minus(<!UNUSED_PARAMETER!>x<!>: Int): B = B()\n  operator fun times(<!UNUSED_PARAMETER!>x<!>: Int): B = B()\n  operator fun div(<!UNUSED_PARAMETER!>x<!>: Int): B = B()\n  operator fun rem(<!UNUSED_PARAMETER!>x<!>: Int): B = B()\n}\n\nfun testWrong() {\n  <!VARIABLE_EXPECTED!>B()<!> += 1\n  <!VARIABLE_EXPECTED!>B()<!> -= 1\n  <!VARIABLE_EXPECTED!>B()<!> *= 1\n  <!VARIABLE_EXPECTED!>B()<!> /= 1\n  <!VARIABLE_EXPECTED!>B()<!> %= 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun compareTo(c: C): Int? = null\n}\n\nfun test(c: C) {\n    c <!COMPARE_TO_TYPE_MISMATCH!><<!> c\n    c <!COMPARE_TO_TYPE_MISMATCH!><=<!> c\n    c <!COMPARE_TO_TYPE_MISMATCH!>>=<!> c\n    c <!COMPARE_TO_TYPE_MISMATCH!>><!> c\n}"
        },
        {
            "code": "//KT-1820 Write test for ASSIGN_OPERATOR_AMBIGUITY\npackage kt1820\n\nclass MyInt(val i: Int) {\n    operator fun plus(m: MyInt) : MyInt = MyInt(m.i + i)\n}\n\noperator fun Any.plusAssign(<!UNUSED_PARAMETER!>a<!>: Any) {}\n\nfun test(m: MyInt) {\n    m += m\n\n    var i = 1\n    i <!ASSIGN_OPERATOR_AMBIGUITY!>+=<!> 34\n}\n\n\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n// A generic funciton is always less specific than a non-generic one\nfun <T> foo(<!UNUSED_PARAMETER!>t<!> : T) : Unit {}\nfun foo(<!UNUSED_PARAMETER!>i<!> : Int) : Int = 1\n\nfun test() {\n    checkSubtype<Int>(foo(1))\n    checkSubtype<Unit>(foo(\"s\"))\n}\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nclass C(a: Int, b: Int, c: Int, d: Int, <!UNUSED_PARAMETER!>e<!>: Int = d, val f: String) {\n    init {\n        a + a\n    }\n\n    val g = b\n\n    init {\n        c + c\n    }\n}\n\nfun f(a: Int, b: Int, <!UNUSED_PARAMETER!>c<!>: Int = b) {\n    a + a\n}\n\nfun Any.getValue(<!UNUSED_PARAMETER!>thisRef<!>: Any?, <!UNUSED_PARAMETER!>prop<!>: KProperty<*>): String = \":)\"\nfun Any.setValue(<!UNUSED_PARAMETER!>thisRef<!>: Any?, <!UNUSED_PARAMETER!>prop<!>: KProperty<*>, <!UNUSED_PARAMETER!>value<!>: String) {\n}\n\nfun Any.provideDelegate(<!UNUSED_PARAMETER!>thisRef<!>: Any?, <!UNUSED_PARAMETER!>prop<!>: KProperty<*>) {\n}\n\noperator fun Int.getValue(thisRef: Any?, prop: KProperty<*>): String = \":)\"\n\noperator fun Int.setValue(thisRef: Any?, prop: KProperty<*>, value: String) {\n}\n\noperator fun Int.provideDelegate(thisRef: Any?, prop: KProperty<*>) {\n}\n\n\nfun get(<!UNUSED_PARAMETER!>p<!>: Any) {\n}\n\nfun set(<!UNUSED_PARAMETER!>p<!>: Any) {\n}\n\nfun foo(s: String) {\n    s.<!UNRESOLVED_REFERENCE!>xxx<!> = 1\n}"
        },
        {
            "code": "fun foo1(): () -> String = <!RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY!>return<!> { \"some long expression \"}\nfun foo2(): () -> String = <!RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY!>return<!UNRESOLVED_REFERENCE!>@label<!><!> { \"some long expression \"}\nfun foo3(): () -> String = <!RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY!>return<!><!SYNTAX!>@<!> { \"some long expression \"}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(arg: Int?) {\n    run {\n        var x = arg\n        if (x == null) return@run\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n    }\n}"
        },
        {
            "code": "class Foo(var x: Int?) {\n    init {\n        if (x != null) {\n            val y = x\n            // Error: x is not stable, Type(y) = Int?\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n            y<!UNSAFE_CALL!>.<!>hashCode()\n            if (y == x) {\n                // Still error\n                y<!UNSAFE_CALL!>.<!>hashCode()\n            }\n            if (x == null && y != x) {\n                // Still error\n                y<!UNSAFE_CALL!>.<!>hashCode()\n            }\n        }\n    }\n}"
        },
        {
            "code": "fun baz(s: String?, u: String?): String {\n    val t = when(if (u == null) return \"\" else <!DEBUG_INFO_SMARTCAST!>u<!>) {\n        \"abc\" -> <!DEBUG_INFO_SMARTCAST!>u<!>\n        \"\" -> {\n            if (s == null) return \"\"\n            <!DEBUG_INFO_SMARTCAST!>s<!>\n        }\n        else -> <!DEBUG_INFO_SMARTCAST!>u<!>\n    }\n    return t\n}"
        },
        {
            "code": "// See KT-9134: smart cast is not provided inside lambda call\nfun bar(): Int = {\n    var i: Int?\n    i = 42\n    <!DEBUG_INFO_SMARTCAST!>i<!>\n}()"
        },
        {
            "code": "class My {\n    init {\n        var y: Int?\n        y = 42\n        <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n    }\n}"
        },
        {
            "code": "class C {\n    fun foo() {}\n}\n\nfun test(a: C?, nn: () -> Nothing?) {\n    a ?: nn()\n    a<!UNSAFE_CALL!>.<!>foo()\n\n    a ?: return\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +SoundSmartcastForEnumEntries\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// SKIP_TXT\n\nenum class Message(val text: String?) {\n    HELLO(\"hello\"),\n    WORLD(\"world\"),\n    NOTHING(null)\n}\n\nfun printMessages() {\n    Message.HELLO.text!!\n    <!DEBUG_INFO_SMARTCAST!>Message.HELLO.text<!>.length\n\n    Message.NOTHING.text<!UNSAFE_CALL!>.<!>length\n\n    Message.NOTHING.text!!\n    <!DEBUG_INFO_SMARTCAST!>Message.NOTHING.text<!>.length\n}\n"
        },
        {
            "code": "// Based on KT-8643\npublic class MyClass\n{\n    fun main() {\n        var str: String? = null\n\n        if (str != null)\n            callback {\n                // Nodoby writes str, smart cast is possible\n                method1(<!DEBUG_INFO_SMARTCAST!>str<!>)\n            }\n    }\n\n    inline fun callback(foo: () ->Unit) = foo()\n\n    fun method1(str: String) = str\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nclass Item(val link: String?)\n\nfun test(item: Item) {\n    if (item.link != null) {\n        val href: String = <!DEBUG_INFO_SMARTCAST!>item.link<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +SafeCastCheckBoundSmartCasts\ninterface SomeClass {\n    val data: Any?\n}\n\ninterface SomeSubClass : SomeClass {\n    val foo: Any?\n}\n\nobject Impl : SomeSubClass {\n    override val data = \"\"\n    override val foo = 42\n}\n\nfun g(a: SomeClass?) {\n    var b = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>(a as? SomeSubClass)?.foo<!>\n    b = \"Hello\"\n    if (<!SENSELESS_COMPARISON!>b != null<!>) {\n        // 'a' cannot be cast to SomeSubClass!\n        a<!UNSAFE_CALL!>.<!>hashCode()\n        a.<!UNRESOLVED_REFERENCE!>foo<!>\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (a as SomeSubClass).foo\n    }\n    var c = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>a as? SomeSubClass<!>\n    c = Impl\n    if (<!SENSELESS_COMPARISON!>c != null<!>) {\n        // 'a' cannot be cast to SomeSubClass\n        a<!UNSAFE_CALL!>.<!>hashCode()\n        a.<!UNRESOLVED_REFERENCE!>foo<!>\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        <!DEBUG_INFO_SMARTCAST!>c<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo\n    }\n}\n\nfun f(a: SomeClass?) {\n    var aa = a\n\n    if (aa as? SomeSubClass != null) {\n        aa = null\n        // 'aa' cannot be cast to SomeSubClass\n        <!OI;DEBUG_INFO_CONSTANT!>aa<!><!UNSAFE_CALL!>.<!>hashCode()\n        aa.<!UNRESOLVED_REFERENCE!>foo<!>\n        (<!DEBUG_INFO_CONSTANT!>aa<!> as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (<!ALWAYS_NULL!>aa<!> as SomeSubClass).foo\n    }\n    val b = (aa as? SomeSubClass)?.foo\n    aa = null\n    if (b != null) {\n        // 'aa' cannot be cast to SomeSubClass\n        <!OI;DEBUG_INFO_CONSTANT!>aa<!><!UNSAFE_CALL!>.<!>hashCode()\n        aa.<!UNRESOLVED_REFERENCE!>foo<!>\n        (<!DEBUG_INFO_CONSTANT!>aa<!> as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (<!ALWAYS_NULL!>aa<!> as SomeSubClass).foo\n    }\n    aa = a\n    val c = aa as? SomeSubClass\n    if (c != null) {\n        // 'c' can be cast to SomeSubClass\n        aa<!UNSAFE_CALL!>.<!>hashCode()\n        aa.<!UNRESOLVED_REFERENCE!>foo<!>\n        (aa as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        <!DEBUG_INFO_SMARTCAST!>c<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +SafeCastCheckBoundSmartCasts\n\ninterface SomeClass {\n    val data: Any?\n}\n\ninterface SomeSubClass : SomeClass {\n    val foo: Any?\n}\n\nfun g(a: SomeClass?) {\n    if (a as? SomeSubClass != null) {\n        // 'a' can be cast to SomeSubClass\n        <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (a <!USELESS_CAST!>as SomeSubClass<!>).foo\n    }\n    val b = (a as? SomeSubClass)?.foo\n    if (b != null) {\n        // 'a' can be cast to SomeSubClass\n        <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (a <!USELESS_CAST!>as SomeSubClass<!>).foo\n    }\n    val c = a as? SomeSubClass\n    if (c != null) {\n        // 'a' and 'c' can be cast to SomeSubClass\n        <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        <!DEBUG_INFO_SMARTCAST!>c<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +SafeCastCheckBoundSmartCasts\n// See KT-20752\n\nclass Unstable {\n    val first: String? get() = null\n}\n\nclass StringList {\n    fun remove(s: String) = s\n}\n\nfun StringList.remove(s: String?) = s ?: \"\"\n\nfun foo(list: StringList, arg: Unstable) {\n    list.remove(arg.first)\n    if (arg.first <!USELESS_CAST!>as? String<!> != null) {\n        // Should be still resolved to extension, without smart cast or smart cast impossible\n        list.remove(arg.first)\n    }\n    val s = arg.first <!USELESS_CAST!>as? String<!>\n    if (s != null) {\n        // Should be still resolved to extension, without smart cast or smart cast impossible\n        list.remove(arg.first)\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +SafeCastCheckBoundSmartCasts\n// See KT-19007\n\n// Stub\nfun String.indexOf(arg: String) = this.length - arg.length\n\n// Stub\nfun String.toLowerCase() = this\n\nfun foo(a: Any) {\n    // Should compile in 1.2\n    (a as? String)?.indexOf(<!DEBUG_INFO_SMARTCAST!>a<!>.toLowerCase())\n}"
        },
        {
            "code": "// !LANGUAGE: -SafeCastCheckBoundSmartCasts\n\ninterface SomeClass {\n    val data: Any?\n}\n\ninterface SomeSubClass : SomeClass {\n    val foo: Any?\n}\n\nfun g(a: SomeClass?) {\n    if (a as? SomeSubClass != null) {\n        // 'a' can be cast to SomeSubClass\n        a<!UNSAFE_CALL!>.<!>hashCode()\n        a.<!UNRESOLVED_REFERENCE!>foo<!>\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (a as SomeSubClass).foo\n    }\n    val b = (a as? SomeSubClass)?.foo\n    if (b != null) {\n        // 'a' can be cast to SomeSubClass\n        a<!UNSAFE_CALL!>.<!>hashCode()\n        a.<!UNRESOLVED_REFERENCE!>foo<!>\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        (a as SomeSubClass).foo\n    }\n    val c = a as? SomeSubClass\n    if (c != null) {\n        // 'a' and 'c' can be cast to SomeSubClass\n        a<!UNSAFE_CALL!>.<!>hashCode()\n        a.<!UNRESOLVED_REFERENCE!>foo<!>\n        (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n        <!DEBUG_INFO_SMARTCAST!>c<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo\n    }\n}"
        },
        {
            "code": "data class StringPair(val first: String, val second: String)\n\ninfix fun String.to(second: String) = StringPair(this, second)\n\nfun hashMapOf(<!UNUSED_PARAMETER!>pair<!>: StringPair): MutableMap<String, String> {\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun F() : MutableMap<String, String> {\n    val value: String? = \"xyz\"\n    if (value == null) throw Error()\n    // Smart cast should be here\n    return hashMapOf(\"sss\" to <!DEBUG_INFO_SMARTCAST!>value<!>)  \n}"
        },
        {
            "code": "public fun foo(xx: Any): Int {\n    var x = xx\n    do {\n        var y: Any\n        // After the check, smart cast should work\n        if (x is String) {\n            break\n        } else {\n            y = \"abc\"\n        }\n        // y!! in both branches\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    } while (true)\n    // We could have smart cast here but with break it's hard to detect\n    return x.<!UNRESOLVED_REFERENCE!>length<!>()\n}"
        },
        {
            "code": "public fun bar(s: String) {\n    System.out.println(\"Length of $s is ${s.length}\")\n}\n\npublic fun foo() {\n    var s: Any = \"not null\"\n    if (s is String) \n        bar(<!DEBUG_INFO_SMARTCAST!>s<!>)\n}\n"
        },
        {
            "code": "fun foo() {\n    var v: Any = \"xyz\"\n    // It is possible in principle to provide smart cast here\n    // but now we decide that v is Any\n    v.<!UNRESOLVED_REFERENCE!>length<!>()\n    v = 42\n    v.<!UNRESOLVED_REFERENCE!>length<!>()\n}"
        },
        {
            "code": "// See KT-774\nfun box() : Int {\n    var a : Any = 1\n    var d = 1\n\n    if (a is Int) {\n        return <!DEBUG_INFO_SMARTCAST!>a<!> + d\n    } else {\n        return 2\n    }\n} "
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: Any): Int {\n    var p = pp\n    do {\n        (p as String).length\n        if (p == \"abc\") break\n        p = 42\n    } while (!x())\n    // Smart cast is NOT possible here\n    return p.<!UNRESOLVED_REFERENCE!>length<!>()\n}"
        },
        {
            "code": "// FILE: test.kt\n\nclass Your {\n    val x = My() {\n        arg: String? ->\n        var y = arg\n        val z: String\n        if (y != null) z = <!DEBUG_INFO_SMARTCAST!>y<!>\n        else z = \"42\"\n        z\n    }\n}"
        },
        {
            "code": "public fun foo(xx: Any): Int {\n    var x = xx\n    do {\n        var y: Any\n        // After the check, smart cast should work\n        if (x is String) {\n            y = \"xyz\"\n        } else {\n            y = \"abc\"\n        }\n        // y!! in both branches\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    } while (!(x is String))\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}"
        },
        {
            "code": "// See KT-5737\nfun get(): Any {\n    return \"abc\"\n}\n\nfun foo(): Int {\n    var ss: Any = get()\n\n    return if (ss is String && <!DEBUG_INFO_SMARTCAST!>ss<!>.length > 0)\n        1\n    else\n        0\n}"
        },
        {
            "code": "fun get(): Any {\n    return \"\"\n}\n\nfun foo(): Int {\n    var c: Any = get()\n    (c as String).length\n    return <!DEBUG_INFO_SMARTCAST!>c<!>.length // Previous line should make as unnecessary here.\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See KT-13468, KT-13765\n\nfun basic(): String {\n    var current: String? = null\n    current = if (current == null) \"bar\" else <!NI;DEBUG_INFO_SMARTCAST!>current<!>\n    return <!DEBUG_INFO_SMARTCAST!>current<!>\n}\n\nfun foo(flag: Boolean) {\n    var x: String? = null\n\n    if (x == null) {\n        x = if (flag) \"34\" else \"12\"\n    }\n\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n}\n\nfun bar(flag: Boolean) {\n    var x: String? = null\n\n    if (x == null) {\n        x = when {\n            flag -> \"34\"\n            else -> \"12\"\n        }\n    }\n\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n}\n\nfun baz(flag: Boolean) {\n    var x: String? = null\n\n    if (x == null) {\n        x = if (flag) {\n            \"34\"\n        } else {\n            \"12\"\n        }\n    }\n\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n}\n\nfun gav(flag: Boolean, arg: String?) {\n    var x: String? = null\n\n    if (x == null) {\n        x = arg ?: if (flag) {\n            \"34\"\n        } else {\n            \"12\"\n        }\n    }\n\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n}\n\nfun gau(flag: Boolean, arg: String?) {\n    var x: String? = null\n\n    if (x == null) {\n        x = if (flag) {\n            arg ?: \"34\"\n        } else {\n            arg ?: \"12\"\n        }\n    }\n\n    <!NI;DEBUG_INFO_SMARTCAST!>x<!><!OI;UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "fun foo(x: String) = x\n\nfun test1() {\n    var c: Any? = \"XXX\"\n    if (c !is String) return\n\n    val newC: String? = \"YYY\"\n    if (newC != null) {\n        c = newC\n    }\n    foo(<!DEBUG_INFO_SMARTCAST!>c<!>)\n}\n\nfun test2() {\n    var c: Any? = \"XXX\"\n    if (c !is String) return\n\n    val newC: String? = \"YYY\"\n    if (newC is String) {\n        c = newC\n    }\n    foo(<!DEBUG_INFO_SMARTCAST!>c<!>)\n}\n\nfun test3() {\n    var c: Any? = \"XXX\"\n    if (c !is String) return\n\n    val newC: String? = \"YYY\"\n    if (newC == null) return\n    c = newC\n\n    foo(<!DEBUG_INFO_SMARTCAST!>c<!>)\n}\n\n"
        },
        {
            "code": "fun foo() {\n    var v: Any = 42\n    v.<!UNRESOLVED_REFERENCE!>length<!>()\n    v = \"abc\"\n    <!DEBUG_INFO_SMARTCAST!>v<!>.length\n    v = 42\n    v.<!UNRESOLVED_REFERENCE!>length<!>()\n    v = \"abc\"\n    <!DEBUG_INFO_SMARTCAST!>v<!>.length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass MyClass(var p: String?)\n\nfun bar(s: String): Int {\n    return s.length\n}\n\nfun foo(m: MyClass): Int {\n    m.p = \"xyz\"\n    return bar(<!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>m.p<!>)\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: Any): Int {\n    var p = pp\n    while(true) {\n        (p as String).length\n        if (x()) break\n        p = 42\n    }\n    // Smart cast is NOT possible here\n    // (we could provide it but p = 42 makes it difficult to understand)\n    return p.<!UNRESOLVED_REFERENCE!>length<!>()\n}"
        },
        {
            "code": "class My {\n\n    val y: Int \n        get() {\n            var x: Int?\n            x = 3\n            return <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        }\n\n    fun test() {\n        var x: Int?\n        x = 2\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        fun bb() {\n           var <!NAME_SHADOWING!>x<!>: Any?\n           x = 4\n           <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        }\n        x = 4\n        // Really smart cast is possible but name shadowing by bb() prevents it\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n    }\n}"
        },
        {
            "code": "public fun bar(s: String) {\n    System.out.println(\"Length of $s is ${s.length}\")\n}\n\npublic fun foo() {\n    var s: Any = \"not null\"\n    if (s is String) {\n        s = 42\n        bar(<!TYPE_MISMATCH!>s<!>)\n    }\n}\n"
        },
        {
            "code": "fun String.next(): String {\n    return \"abc\"\n}\n\nfun list(start: String) {\n    var e: Any? = start\n    if (e==null) return\n    while (e is String) {\n        // Smart cast due to the loop condition\n        if (<!DEBUG_INFO_SMARTCAST!>e<!>.length == 0)\n            break\n        // We still have smart cast here despite of a break\n        e = <!DEBUG_INFO_SMARTCAST!>e<!>.next()\n    }\n    // e can never be null but we do not know it\n    e<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo(x: Int, f: () -> Unit, y: Int) {}\n\nfun bar() {\n    var x: Int?\n    x = 4\n    foo(<!DEBUG_INFO_SMARTCAST!>x<!>, { x = null; x<!UNSAFE_CALL!>.<!>hashCode() }, <!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>x<!>)\n}"
        },
        {
            "code": "public fun foo() {\n    var i: Any = 1\n    if (i is Int) {\n        while (i != 10) {\n            <!UNUSED_CHANGED_VALUE!>i<!UNRESOLVED_REFERENCE!>++<!><!>      // Here smart cast should not be performed due to a successor\n            i = \"\"\n        }\n    }\n}"
        },
        {
            "code": "public fun foo() {\n    var i: Any = 1\n    if (i is Int) {\n        while (i != 10) {\n            <!DEBUG_INFO_SMARTCAST!>i<!>++\n        }\n    }\n}"
        },
        {
            "code": "// See KT-9134: smart cast is not provided inside lambda call\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class My\n\nfun bar(): Int = @My {\n    var i: Int?\n    i = 42\n    <!DEBUG_INFO_SMARTCAST!>i<!>\n}()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// SKIP_TXT\n\nsealed class A\nsealed class B : A()\nsealed class C : B()\nsealed class D : C()\nobject BB : B()\nobject CC : C()\nobject DD : D()\n\nfun foo1(a: A) {\n    if (a is B) {\n        if (a is D) {\n            if (<!USELESS_IS_CHECK!>a is C<!>) {\n                val t =\n                    when (<!DEBUG_INFO_SMARTCAST!>a<!>) {\n                        is DD -> \"DD\"\n                    }\n            }\n        }\n    }\n}\n\nfun foo2(a: A) {\n    if (a is B) {\n        if (a is D) {\n            if (<!USELESS_IS_CHECK!>a is C<!>) {\n                val t =\n                    when (<!DEBUG_INFO_SMARTCAST!>a<!>) {\n                        is DD -> \"DD\"\n                    }\n            }\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -SoundSmartcastForEnumEntries\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// SKIP_TXT\n\nenum class Message(val text: String?) {\n    HELLO(\"hello\"),\n    WORLD(\"world\"),\n    NOTHING(null)\n}\n\nfun printMessages() {\n    Message.HELLO.text!!\n    <!DEBUG_INFO_SMARTCAST!>Message.HELLO.text<!>.length\n\n    <!DEBUG_INFO_SMARTCAST!>Message.NOTHING.text<!>.length\n\n    Message.NOTHING.text<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    <!DEBUG_INFO_SMARTCAST!>Message.NOTHING.text<!>.length\n}\n"
        },
        {
            "code": "abstract class A {\n    abstract protected fun foo(): String\n    abstract protected val bar: String\n}\n\ninterface B {\n    fun foo(): String\n    val bar: String\n}\n\nfun test(x: A) {\n    if (x is B) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo()\n        <!DEBUG_INFO_SMARTCAST!>x<!>.bar\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    fun foo(): CharSequence?\n}\n\ninterface B : A {\n    override fun foo(): String\n}\n\nfun test(a: A) {\n    if (a is B) {\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo().checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    val foo: Any?\n}\n\ninterface C: A {\n    override val foo: String\n}\ninterface B: A {\n    override var foo: String?\n}\n\nfun test(a: A) {\n    if (a is B && a is C) {\n        a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> = \"\"\n        a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> = null\n        a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\ninterface A {\n    fun foo(): CharSequence?\n    fun baz(x: Any) {}\n}\n\ninterface B {\n    fun foo(): String\n    fun baz(x: Int): String =\"\"\n    fun baz(x: Int, y: Int) {}\n\n    fun foobar(): CharSequence?\n}\n\ninterface C {\n    fun foo(): String\n    fun baz(x: Int): String =\"\"\n    fun baz(x: Int, y: Int) {}\n\n    fun foobar(): String\n}\n\nvar x: A = null!!\n\nfun test() {\n    x.foo().checkType { _<CharSequence?>() }\n\n    if (x is B && x is C) {\n        x.foo().checkType { _<CharSequence?>() }\n        x.baz(\"\")\n        x.baz(1).checkType { _<Unit>() }\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.baz(1, 2)\n\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.foobar().checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "interface A {\n    fun <T, E> foo(): E\n}\n\ninterface B {\n    fun <Q, W> foo(): Q\n}\n\nfun test(c: Any) {\n    if (c is B && c is A) {\n        c.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!><String, Int>()\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    fun <T, E> foo(): E\n}\n\ninterface B {\n    fun <Q, W> foo(): W\n}\n\nfun test(c: Any) {\n    if (c is B && c is A) {\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo<String, Int>().checkType { _<Int>() }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    val foo: Any?\n}\n\ninterface C: A {\n    override val foo: String?\n}\ninterface B: A {\n    override var foo: String\n}\n\nfun test(a: A) {\n    if (a is B && a is C) {\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo = \"\"\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo = <!NULL_FOR_NONNULL_TYPE!>null<!>\n\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo.checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    fun foo(): CharSequence?\n}\n\ninterface B {\n    fun foo(): String\n}\n\nfun test(c: Any) {\n    if (c is B && c is A) {\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo().checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface Common {\n    fun foo(): CharSequence?\n}\n\ninterface A : Common {\n    override fun foo(): CharSequence\n}\n\ninterface B : Common {\n    override fun foo(): String\n}\n\nfun test(c: Common) {\n    if (c is B && c is A) {\n        <!DEBUG_INFO_SMARTCAST!>c<!>.foo().checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    fun foo(): CharSequence\n}\n\ninterface B {\n    fun foo(): String?\n}\n\nfun test(c: Any) {\n    if (c is B && c is A) {\n        c.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>()\n    }\n}\n"
        },
        {
            "code": "open class A {\n    open var value: Int = 4\n        protected set\n}\n\nclass MutableA : A() {\n    override var value: Int = 4\n        public set\n}\n\nfun test(myA: A) {\n    if (myA is MutableA) {\n        <!DEBUG_INFO_SMARTCAST!>myA<!>.value = 5\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// FILE: main.kt\n\ninterface B {\n    fun foo(): String?\n}\n\ninterface C {\n    fun foo(): String\n}\n\nfun foo(x: Any?) {\n    if (x is A && x is B) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String?>() }\n    }\n\n    if (x is B && x is A) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String?>() }\n    }\n\n    if (x is A && x is C) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n    }\n\n    if (x is C && x is A) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n    }\n\n    if (x is A && x is B && x is C) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n    }\n\n    if (x is B && x is A && x is C) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n    }\n\n    if (x is B && x is C && x is A) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { _<String>() }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo().checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n    }\n}\n"
        },
        {
            "code": "package aaa\n\nfun bar(<!UNUSED_PARAMETER!>a<!>: Int, <!UNUSED_PARAMETER!>b<!>: Int) {}\n\nfun foo(a: Int?) {\n    bar(a!!, <!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n"
        },
        {
            "code": "var x: Int = 0\n    get() {\n        var y: Int? = null\n        if (y != null) {\n            return <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n        }\n        return field\n    }\n    set(param) {\n        var y: Int? = null\n        if (y != null) {\n            field = <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n        }\n        else {\n            field = param\n        }\n    }"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(x: String?, y: String?, z: String?, w: String?) {\n    if (x != null && y != null && (x == z || y == z))\n        <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    else\n        z<!UNSAFE_CALL!>.<!>length\n    if (x != null || y != null || (<!DEBUG_INFO_CONSTANT!>x<!> != z && <!DEBUG_INFO_CONSTANT!>y<!> != z))\n        z<!UNSAFE_CALL!>.<!>length\n    else\n        <!OI;DEBUG_INFO_CONSTANT!>z<!><!UNSAFE_CALL!>.<!>length\n    if (x == null || y == null || (x != z && y != z))\n        z<!UNSAFE_CALL!>.<!>length\n    else\n        <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    if (x != null && y == x && z == y && w == z)\n        <!DEBUG_INFO_SMARTCAST!>w<!>.length\n    else\n        w<!UNSAFE_CALL!>.<!>length\n    if ((x != null && y == x) || (z != null && y == z))\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    else\n        y<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(): Int {\n    val x: Any? = null\n    val y = 2\n    if (x == y) {\n        return x <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>+<!> y\n    }\n    return y\n}"
        },
        {
            "code": "class Your {\n    init {\n        var y: String? = \"xyz\"\n        if (y != null) {\n            // Bug that should be fixed\n            // Problem: descriptorToDeclaration cannot get here init block by its descriptor\n            // See PreliminaryDeclarationVisitor.getVisitorByVariable\n            <!SMARTCAST_IMPOSSIBLE!>y<!>.hashCode()\n        }\n    }\n\n    constructor()\n}\n\nclass Normal {\n    init {\n        var y: String? = \"xyz\"\n        if (y != null) {\n            <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n        }\n    }\n}"
        },
        {
            "code": "//KT-5455 Need warning about redundant type cast\nfun foo(o: Any): Int {\n    if (o is String) {\n        return (o <!USELESS_CAST!>as String<!>).length\n    }\n    return -1\n}\n\nopen class A {\n    fun foo() {}\n}\nclass B: A()\n\nfun test(a: Any?) {\n    if (a is B) {\n        (a as A).foo()\n    }\n}\n\nfun test1(a: B) {\n    (a as A?)?.foo()\n}\n\nfun test2(b: B?) {\n    if (b != null) {\n        (b as A).foo()\n    }\n}\n"
        },
        {
            "code": "fun trans(n: Int, f: () -> Boolean) = if (f()) n else null\n\nfun foo() {\n    var i: Int? = 5    \n    if (i != null) {\n        // Write is AFTER this place\n        <!DEBUG_INFO_SMARTCAST!>i<!>.hashCode()\n        object {\n            fun bar() {\n                i = null\n            }\n        }.bar()\n        <!SMARTCAST_IMPOSSIBLE!>i<!>.hashCode()\n    }\n}\n"
        },
        {
            "code": "fun baz(s: String?): String {\n    val t = if (s == null) {\n        \"\"\n    }\n    else if (s == \"\") {\n        val u: String? = null\n        if (u == null) return \"\"\n        <!DEBUG_INFO_SMARTCAST!>u<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>s<!>\n    }\n    return t\n}\n"
        },
        {
            "code": "//KT-2746 Do.smartcasts in inference\n\nclass C<T>(<!UNUSED_PARAMETER!>t<!> :T)\n\nfun test1(a: Any) {\n    if (a is String) {\n        val <!UNUSED_VARIABLE!>c<!>: C<String> = C(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    }\n}\n\n\nfun <T> f(t :T): C<T> = C(t)\n\nfun test2(a: Any) {\n    if (a is String) {\n        val <!UNUSED_VARIABLE!>c1<!>: C<String> = f(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    }\n}\n"
        },
        {
            "code": "interface A\ninterface B\n\nclass Test {\n    fun test(a: A?, b: B, list: MutableList<Pair<A, B>>) {\n        if (a != null) {\n            list.add(<!DEBUG_INFO_SMARTCAST!>a<!> to b)\n        }\n    }\n}\n\nclass Pair<out A, out B>(val first: A, val second: B)\ninfix fun <A, B> A.to(that: B) = Pair(this, that)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage a\n\nfun <T> id(t: T): T = t\n\nfun <T> two(u: T, <!UNUSED_PARAMETER!>v<!>: T): T = u\n\nfun <T> three(<!UNUSED_PARAMETER!>a<!>: T, <!UNUSED_PARAMETER!>b<!>: T, c: T): T = c\n\ninterface A\ninterface B: A\ninterface C: A\n\nfun test(a: A, b: B, c: C) {\n    if (a is B && a is C) {\n        val d: C = id(<!OI;DEBUG_INFO_SMARTCAST!>a<!>)\n        val e: Any = id(a)\n        val f = id(a)\n        checkSubtype<A>(f)\n        val g = two(<!DEBUG_INFO_SMARTCAST!>a<!>, b)\n        checkSubtype<B>(g)\n        checkSubtype<A>(g)\n\n        // smart cast isn't needed, but is reported due to KT-4294\n        val h: Any = two(<!DEBUG_INFO_SMARTCAST!>a<!>, b)\n\n        val k = three(a, b, c)\n        checkSubtype<A>(k)\n        checkSubtype<B>(<!TYPE_MISMATCH!>k<!>)\n        val l: Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>three(a, b, c)<!>\n        \n        use(d, e, f, g, h, k, l)\n    }\n}\n\nfun <T> foo(t: T, <!UNUSED_PARAMETER!>l<!>: MutableList<T>): T = t\n\nfun testErrorMessages(a: A, ml: MutableList<String>) {\n    if (a is B && a is C) {\n        <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>foo<!>(a, <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>ml<!>)\n    }\n\n    if(a is C) {\n        <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>foo<!>(a, <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>ml<!>)\n    }\n}\n\nfun rr(s: String?) {\n    if (s != null) {\n        val l = arrayListOf(\"\", <!DEBUG_INFO_SMARTCAST!>s<!>)\n        checkSubtype<MutableList<String>>(l)\n        checkSubtype<MutableList<String?>>(<!TYPE_MISMATCH!>l<!>)\n    }\n}\n\n//from library\nfun <T> arrayListOf(vararg <!UNUSED_PARAMETER!>values<!>: T): MutableList<T> = throw Exception()\n\nfun use(vararg a: Any) = a"
        },
        {
            "code": "//KT-4415 Class Auto-Cast Bug\n\ninterface SelfJson\n\nobject A {\n    fun find(<!UNUSED_PARAMETER!>clz<!>:Class<*>){  }\n\n    fun toJson2(obj:Any){\n        if(obj is SelfJson){\n            // A.find( (obj as SelfJson).javaClass)  // OK\n            A.find( <!DEBUG_INFO_SMARTCAST!>obj<!>.javaClass )   // ERROR:  Type mismatch: inferred type is kotlin.Any but SelfJson was expected\n        }\n    }\n}\n\n//from library\nval <T> T.javaClass : Class<T> get() = throw Exception()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// ISSUE: KT-25432\n\nclass Data<T>(val s: T)\n\nfun test(d: Data<out Any>) {\n    if (d.s is String) {\n        <!DEBUG_INFO_SMARTCAST!>d.s<!>.length\n    }\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// ISSUE: KT-29767\n\nfun test(a: MutableList<out Int?>?) {\n    if (a != null) {\n        val b = <!OI;DEBUG_INFO_SMARTCAST!>a<!>[0] // no SMARTCAST diagnostic\n        if (b != null) {\n            <!DEBUG_INFO_SMARTCAST!>b<!>.inc()\n        }\n    }\n}"
        },
        {
            "code": "interface PsiElement {\n    fun getText(): String\n    fun getParent(): PsiElement\n}\n\ninterface JetExpression : PsiElement\n\nfun foo1(e: PsiElement) {\n    var current: PsiElement? = e\n    var first = true\n    while (current != null) {\n        if (current is JetExpression && first) {\n            // Smartcast is possible here\n            println(<!DEBUG_INFO_SMARTCAST!>current<!>.getText())\n        }\n\n        current = <!DEBUG_INFO_SMARTCAST!>current<!>.getParent()\n    }\n}\n\n//from library\nfun println(any: Any?): Nothing = throw Exception(\"$any\")"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(s : String?, b : Boolean) {\n    if (s == null) return\n\n    val s1 = if (b) \"\" else <!DEBUG_INFO_SMARTCAST!>s<!>\n    s1 checkType { _<String>() }\n\n    val s2 = s\n    <!DEBUG_INFO_SMARTCAST!>s2<!> checkType { _<String>() }\n}"
        },
        {
            "code": "//KT-2851 Type inference failed passing in not-null after smart-cast value in Pair\npackage a\n\nfun main() {\n    val value: String? = \"\"\n    if (value != null) {\n        foo(Pair(\"val\", <!DEBUG_INFO_SMARTCAST!>value<!>))\n        foo(Pair(\"val\", value<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>))\n        foo(Pair<String, String>(\"val\", <!DEBUG_INFO_SMARTCAST!>value<!>))\n    }\n}\n\nfun foo(<!UNUSED_PARAMETER!>map<!>: Pair<String, String>) {}\n\n\n//from library\npublic class Pair<out A, out B> (\n        public val first: A,\n        public val second: B\n)\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninline fun<T> foo(block: () -> T):T = block()\n\nfun baz() {\n    val x: String = foo {\n        val task: String? = null\n        if (task == null) {\n            return\n        } else <!DEBUG_INFO_SMARTCAST!>task<!>\n    }\n}"
        },
        {
            "code": "//KT-1355 Type inference fails with smartcast and generic function\n//tests for Map.set\npackage a\n\nimport java.util.HashMap\n\nfun foo(map: MutableMap<Int, String>, value: String?) {\n    if (value != null) {\n        map.put(1, <!DEBUG_INFO_SMARTCAST!>value<!>) //ok\n        map.set(1, <!DEBUG_INFO_SMARTCAST!>value<!>) //type inference failed\n        map[1] = <!DEBUG_INFO_SMARTCAST!>value<!>    //type inference failed\n    }\n}\n\n//---------------------------\n\npublic data class Tag(public var tagName: String) {\n    public val attributes: MutableMap<String, String> = HashMap<String, String>()\n    public val contents: MutableList<Tag> = arrayListOf()\n\n    public var id: String?\n        get() = attributes[\"id\"]\n        set(value) {\n            if(value == null) {\n                attributes.remove(\"id\")\n            }\n            else {\n                attributes[\"id\"] = value<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n                attributes[\"id\"] = <!DEBUG_INFO_SMARTCAST!>value<!>\n            }\n        }\n}\n\n\n//from library\noperator fun <K, V> MutableMap<K, V>.set(key : K, value : V) = this.put(key, value)\n\nfun <T> arrayListOf(vararg <!UNUSED_PARAMETER!>values<!>: T): MutableList<T> = throw Exception()\n\n\n"
        },
        {
            "code": "//KT-4403 Wrong \"type mismatch\" on smart cast with inference\n\ninterface A\ninterface B : A\n\nfun <T> T.f(): T = this\n\nfun test(a: A) {\n    if (a !is B) return\n    val <!UNUSED_VARIABLE!>c<!> = <!DEBUG_INFO_SMARTCAST!>a<!>.f() // type mismatch\n}"
        },
        {
            "code": "package a\n\nfun <T> foo(u: T, <!UNUSED_PARAMETER!>v<!>: T): T = u\n\nfun test(s: String?) {\n    val <!UNUSED_VARIABLE!>r<!>: String = foo(s!!, <!DEBUG_INFO_SMARTCAST!>s<!>)\n}"
        },
        {
            "code": "open class Base\nclass Derived: Base()\n\nfun bar(derived: Derived) = derived\n\nfun trans(n: Int, f: (Int) -> Boolean) = if (f(n)) n else null\n\nfun foo() {\n    val base: Base = Derived()\n    if (base is Derived) {\n        fun can(n: Int) = n > 0\n        trans(42, ::can)\n        bar(<!DEBUG_INFO_SMARTCAST!>base<!>)\n    }\n}\n"
        },
        {
            "code": "interface IA\ninterface IB\n\nobject A : IA {\n    fun B.foo() {  }\n}\n\nobject B : IB\n\nfun test(a: IA, b: IB) {\n    with(a) lambda1@{\n        with(b) lambda2@{\n            if (this@lambda1 is A && this@lambda2 is B) {\n                <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>foo<!>()\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(x : String?, y : String?) {\n    if (y != null && x == y) {\n        // Both not null\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    }\n    else {\n        x<!UNSAFE_CALL!>.<!>length\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    if (y != null || x == <!DEBUG_INFO_CONSTANT!>y<!>) {\n        x<!UNSAFE_CALL!>.<!>length\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        // y == null but x != y\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!OI;DEBUG_INFO_CONSTANT!>y<!><!UNSAFE_CALL!>.<!>length\n    }\n    if (y == null && x != <!DEBUG_INFO_CONSTANT!>y<!>) {\n        // y == null but x != y\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!OI;DEBUG_INFO_CONSTANT!>y<!><!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        x<!UNSAFE_CALL!>.<!>length\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    if (y == null || x != y) {\n        x<!UNSAFE_CALL!>.<!>length\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        // Both not null\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    }\n}"
        },
        {
            "code": "abstract class Base {\n    override fun equals(other: Any?) = other is Base\n}\n\nclass Derived1 : Base() {\n    fun foo() {}\n}\n\nclass Derived2 : Base()\n\nfun check(x1: Derived1, x: Base) {\n    if (x1 == x) {\n        // Smart cast here will provoke CCA\n        x.<!UNRESOLVED_REFERENCE!>foo<!>()\n    }\n    if (x1 === x) {\n        // OK\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo()\n    }\n    if (x1 !== x) {} else {\n        // OK\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo()\n    }\n}\n\nclass FinalClass { // <-- 'equals' on instances of this class is useful for smart casts\n    fun use() {}\n\n    fun equals(x: Int): Boolean = x > 42\n}\n\nfun foo(x: FinalClass?, y: Any) {\n    if (x == y) {\n        // OK\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        // OK\n        <!DEBUG_INFO_SMARTCAST!>y<!>.use()\n    }\n    when (x) {\n        // OK (equals from FinalClass)\n        y -> <!DEBUG_INFO_SMARTCAST!>y<!>.use()\n    }\n    when (y) {\n        // ERROR (equals from Any)\n        x -> y.<!UNRESOLVED_REFERENCE!>use<!>()\n    }\n}\n\nopen class OpenClass {\n    override fun equals(other: Any?) = other is OpenClass\n}\n\ninterface Dummy // should not influence anything\n\nclass FinalClass2 : Dummy, OpenClass() { // but here not\n    fun use() {}\n}\n\nfun bar(x: FinalClass2?, y: Any) {\n    if (x == y) {\n        // OK\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        // ERROR\n        y.<!UNRESOLVED_REFERENCE!>use<!>()\n    }\n}\n\nopen class OpenClass2 // and here too\n\nfun bar(x: OpenClass2?, y: Any) {\n    if (x == y) {\n        // OK\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        // ERROR\n        y.<!UNRESOLVED_REFERENCE!>use<!>()\n    }\n}\n\nsealed class Sealed {\n    override fun equals(other: Any?) = other is Sealed\n\n    class Sealed1 : Sealed() {\n        fun gav() {}\n    }\n\n    object Sealed2 : Sealed()\n\n    fun check(arg: Sealed1) {\n        if (arg == this) {\n            // Smart cast here will provoke CCA\n            this.<!UNRESOLVED_REFERENCE!>gav<!>()\n            <!UNRESOLVED_REFERENCE!>gav<!>()\n        }\n    }\n}"
        },
        {
            "code": "fun foo(s: String) = s.length\n\nfun baz(s: String?, r: String?): Int {\n    return foo(r ?: when {\n        s != null -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> \"\"\n    })\n}\n\nfun bar(s: String?, r: String?): Int {\n    return (r ?: when {\n        s != null -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> \"\"\n    }).length\n}"
        },
        {
            "code": "fun baz(s: String?): String {\n    val t = if (s == null) {\n        \"\"\n    }\n    else {\n        val u: String? = null\n        when (u) {\n            null -> \"\"\n            else -> <!DEBUG_INFO_SMARTCAST!>u<!>\n        }\n    }\n    return t\n}\n"
        },
        {
            "code": "val x: Int? = 0\n    get() {\n        if (field != null) return <!DEBUG_INFO_SMARTCAST!>field<!>.hashCode()\n        return null\n    }\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// Issue: KT-30826\n\ninterface I1\ninterface I2 {\n    fun foo() {}\n}\n\nclass A : I1, I2\n\nfun foo(x: I1?) {\n    var y = x\n    y as I2\n    val bar = {\n        <!SMARTCAST_IMPOSSIBLE!>y<!>.foo() // NPE in NI, smartcast impossible in OI\n    }\n    y = null\n    bar()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(arg: Int?) {\n    var x = arg\n    if (x == null) return\n    run {\n        // Not safe: x = null later in the owner\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n    }\n    x = null  \n}"
        },
        {
            "code": "// Based on KT-9100\nfun test(x: Any?, y: Any?): Any {\n    val z = x ?: y!!\n    y<!UNSAFE_CALL!>.<!>hashCode()\n    // !! / ?. is necessary here, because y!! above may not be executed\n    y?.hashCode()\n    y!!.hashCode()\n    return z\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// SKIP_TXT\n\nsealed class A\nsealed class B : A()\nsealed class C : B()\nobject BB : B()\nobject CC : C()\n\nfun foo(a: A) {\n    if (a is B) {\n        if (a is C) {\n            val t = when (<!DEBUG_INFO_SMARTCAST!>a<!>) {\n                is CC -> \"CC\"\n            }\n        }\n    }\n}\n\nfun foo2(a: A) {\n    if (a is C) {\n        if (<!USELESS_IS_CHECK!>a is B<!>) {\n            val t = when (<!DEBUG_INFO_SMARTCAST!>a<!>) {\n                is CC -> \"CC\"\n            }\n        }\n    }\n}"
        },
        {
            "code": "package foo\n\nclass C(val i: Int?) {}\n\nclass A(val c: C) {\n    fun test1() {\n        if (this@A.c.i != null) {\n            useInt(<!DEBUG_INFO_SMARTCAST!>this.c.i<!>)\n            useInt(<!DEBUG_INFO_SMARTCAST!>c.i<!>)\n        }\n    }\n\n    inner class B {\n        fun test2() {\n            if (c.i != null) {\n                useInt(<!DEBUG_INFO_SMARTCAST!>this@A.c.i<!>)\n            }\n        }\n    }\n}\n\nfun A.foo() {\n    if (this@foo.c.i != null) {\n        useInt(<!DEBUG_INFO_SMARTCAST!>this.c.i<!>)\n        useInt(<!DEBUG_INFO_SMARTCAST!>c.i<!>)\n    }\n}\n\nfun test3() {\n    useFunction {\n        if(c.i != null) {\n            useInt(<!DEBUG_INFO_SMARTCAST!>this.c.i<!>)\n        }\n    }\n}\n\nfun useInt(i: Int) = i\nfun useFunction(f: A.() -> Unit) = f\n\n"
        },
        {
            "code": "package bar\n\nclass Test {\n    val foo: Int? = null\n    fun foo(o: Test) = foo == null && o.foo == null // ERROR warning: o.test == null is always true\n\n    fun bar(a: Test, b: Test) {\n        if (a.foo != null) {\n            useInt(<!TYPE_MISMATCH!>b.foo<!>)\n        }\n        if (a.foo != null) {\n            useInt(<!TYPE_MISMATCH!>foo<!>)\n        }\n        if (this.foo != null) {\n            useInt(<!DEBUG_INFO_SMARTCAST!>foo<!>)\n        }\n        if (foo != null) {\n            useInt(<!DEBUG_INFO_SMARTCAST!>this.foo<!>)\n        }\n    }\n\n    fun useInt(i: Int) = i\n}"
        },
        {
            "code": "fun baz(s: String?): Int {\n    return if (s == null) {\n        \"\"\n    }\n    else {\n        val u: String? = null\n        if (u == null) return 0\n        <!DEBUG_INFO_SMARTCAST!>u<!>\n    }.length\n}\n"
        },
        {
            "code": "class IncDec {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun inc(): Unit {}\n}\n\nfun foo(): IncDec {\n    var x = IncDec()\n    x = <!UNUSED_CHANGED_VALUE!>x<!INC_DEC_SHOULD_NOT_RETURN_UNIT!>++<!><!>\n    x<!INC_DEC_SHOULD_NOT_RETURN_UNIT!>++<!>\n    return x\n}\n"
        },
        {
            "code": "class My {\n    val x: Int\n    init {\n        var y: Int? = null\n        if (y != null) {\n            x = <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n        }\n        else {\n            x = 0\n        }\n    }\n}"
        },
        {
            "code": "//FILE: bar.kt\npackage bar\n\nval i: Int? = 2\n\n//FILE: foo.kt\npackage foo\n\nval i: Int? = 1\n\nclass A(val i: Int?) {\n    fun testUseFromClass() {\n        if (foo.i != null) {\n            useInt(<!TYPE_MISMATCH!>i<!>)\n        }\n    }\n}\n\nfun testUseFromOtherPackage() {\n    if (bar.i != null) {\n        useInt(<!TYPE_MISMATCH!>i<!>)\n    }\n}\n\nfun useInt(i: Int) = i"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(arg: Int?) {\n    run {\n        var x = arg\n        while (x != null) {\n            x = <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n            if (x == 0) x = null\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(arg: Int?) = run {\n    var x = arg\n    if (x == null) return@run\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n}\n\nclass My {\n    fun foo(arg: Int?) = run {\n        var x = arg\n        if (x == null) return@run\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n    }\n\n    fun Int?.bar() = run {\n        var x = this\n        if (x == null) return@run\n        <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface Foo\ninterface Bar : Foo\n\nfun foo(): Foo? = null\nfun bar(): Bar? = null\n\nfun <T : Bar> run(f: () -> T): T = f()\n\nval foo: Foo = run {\n    val x = bar()\n    if (x == null) throw Exception()\n    <!DEBUG_INFO_SMARTCAST!>x<!>\n}\n\nval foofoo: Foo = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>run<!> {\n    val x = foo()\n    if (x == null) throw Exception()\n    <!DEBUG_INFO_SMARTCAST, NI;TYPE_MISMATCH!>x<!>\n}\n\nval bar: Bar = <!NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>run<!> {\n    val x = foo()\n    if (x == null) throw Exception()\n    <!NI;DEBUG_INFO_SMARTCAST, TYPE_MISMATCH!>x<!>\n}<!>\n"
        },
        {
            "code": "// See KT-5385: no smart cast in a literal without given type arguments\n\ninterface Foo\nfun foo(): Foo? = null\n\nval foo: Foo = run {\n    val x = foo()\n    if (x == null) throw Exception()\n    <!DEBUG_INFO_SMARTCAST!>x<!>\n}\n\n// Basic non-lambda case\n\nfun <T> repeat(arg: T): T = arg\n\nfun bar(): Foo {\n    val x = foo()\n    if (x == null) throw Exception()\n    return repeat(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass ExplicitAccessorForAnnotation {\n    val tt: String? = \"good\"\n        get\n\n    fun foo(): String {\n        if (tt is String) {\n            return <!SMARTCAST_IMPOSSIBLE!>tt<!>\n        }\n        return \"\"\n    }\n}"
        },
        {
            "code": "class User(val login : Boolean) {}\n\nfun currentAccess(user: User?): Int {\n    return when {\n        user == null -> 0\n        // We should get smartcast here\n        <!DEBUG_INFO_SMARTCAST!>user<!>.login -> 1 \n        else -> -1\n    }\n}"
        },
        {
            "code": "fun baz(s: String?, b: Boolean?): String {\n    val t = if (if (b == null) return \"\" else <!DEBUG_INFO_SMARTCAST!>b<!>) {\n        if (s == null) return \"\"\n        <!DEBUG_INFO_SMARTCAST!>s<!>\n    }\n    else {\n        if (s != null) return <!DEBUG_INFO_SMARTCAST!>s<!>\n        \"\"\n    }\n    return t\n}"
        },
        {
            "code": "class Your\n\nfun Your.foo() = Any()\n\nfun <T> T?.let(f: (T) -> Unit) {\n    if (this != null) f(<!DEBUG_INFO_SMARTCAST!>this<!>)\n}\n\nfun test(your: Your?) {\n    (your?.foo() <!USELESS_CAST!>as? Any<!>)?.let {}\n    // strange smart cast to 'Your' at this point\n    your<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "//  Type inference failed after smart cast\n\ninterface A<T>\ninterface B<T> : A<T>\n\nfun <T> foo(b: A<T>) = b\n\nfun <T> test(a: A<T>) {\n    if (<!USELESS_IS_CHECK!>a is Any<!>) {\n        // Error:(9, 9) Kotlin: Type inference failed: fun <T> foo(b: A<T>): kotlin.Unit\n        // cannot be applied to (A<T>)\n        foo(a)\n    }   \n    foo(a) // ok\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// See KT-27260\n\nclass A(val x: String?) {\n    fun foo(other: A) {\n        when {\n            x == null && other.x == null -> \"1\"\n            x<!UNSAFE_CALL!>.<!>length > 0 -> \"2\"\n        }\n    }\n}"
        },
        {
            "code": "fun baz(s: String?): String {\n    // If String type is given explicitly, problem disappears\n    val t = if (s == null) {\n        \"\"\n    }\n    else {\n        val u: String? = null\n        if (u == null) return \"\"\n        // !! is detected as unnecessary here\n        <!DEBUG_INFO_SMARTCAST!>u<!>\n    }\n    return t\n}\n\nfun foo(s: String?): String {\n    if (s == null) return \"\"\n    val t = if (s == \"abc\") <!DEBUG_INFO_SMARTCAST!>s<!> else \"xyz\"\n    return t\n}\n"
        },
        {
            "code": "// See KT-5737\nfun get(): String? {\n    return \"abc\"\n}\n\nfun foo(): Int {\n    var ss:String? = get()\n\n    return if (ss != null && <!DEBUG_INFO_SMARTCAST!>ss<!>.length > 0)\n        1\n    else\n        0\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(arg: Int?): Int {\n    var i = arg\n    if (i != null && <!DEBUG_INFO_SMARTCAST!>i<!>++ == 5) {\n        return <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>i<!>--<!> + <!DEBUG_INFO_SMARTCAST!>i<!>\n    }\n    return 0\n}\n\noperator fun Long?.inc() = this?.let { it + 1 }\n\nfun bar(arg: Long?): Long {\n    var i = arg\n    if (i++ == 5L) {\n        return i<!UNSAFE_CALL!>--<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> i\n    }\n    if (i++ == 7L) {\n        return i++ <!UNSAFE_OPERATOR_CALL!>+<!> <!TYPE_MISMATCH!>i<!>\n    }\n    return 0L\n}"
        },
        {
            "code": "public fun fooNotNull(s: String) {\n    System.out.println(\"Length of $s is ${s.length}\")\n}\n\npublic fun foo() {\n    var s: String? = \"not null\"\n    if (s == null) {\n        return\n    }\n    fooNotNull(<!DEBUG_INFO_SMARTCAST!>s<!>)\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: String?): Int {\n    var p = pp\n    while(true) {\n        p!!.length\n        if (x()) break\n        (p) = null\n    }\n    // Smart cast is NOT possible here\n    // (we could provide it but p = null makes it much harder)\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// See KT-969\nfun f() {\n  var s: String?\n  s = \"a\"\n  var s1 = \"\" // String  ?\n  if (<!SENSELESS_COMPARISON!>s != null<!>) {    // Redundant\n    s1.length\n    // We can do smartcast here and below\n    s1 = <!DEBUG_INFO_SMARTCAST!>s<!>.toString() // return String?\n    s1.length\n    s1 = <!DEBUG_INFO_SMARTCAST!>s<!>\n    s1.length\n    // It's just an assignment without smartcast\n    val s2 = s\n    // But smartcast can be done here\n    <!DEBUG_INFO_SMARTCAST!>s2<!>.length\n    // And also here\n    val s3 = <!DEBUG_INFO_SMARTCAST!>s<!>.toString()\n    s3.length\n  }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-15792 and related\n\nfun foo() {\n    var x: String? = \"\"\n    val y = x\n    x = null\n    if (y != null) {\n        <!OI;DEBUG_INFO_CONSTANT!>x<!><!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n\nfun foo2() {\n    var x: String? = \"\"\n    val y = x\n    if (y != null) {\n        x<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n\nfun bar(s: String?) {\n    var ss = s\n    val hashCode = ss?.hashCode()\n    ss = null\n    if (hashCode != null) {\n        <!OI;DEBUG_INFO_CONSTANT!>ss<!><!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n\nfun bar2(s: String?) {\n    var ss = s\n    val hashCode = ss?.hashCode()\n    if (hashCode != null) {\n        ss<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n\nclass Some(var s: String?)\n\nfun baz(arg: Some?) {\n    val ss = arg?.s\n    if (ss != null) {\n        <!DEBUG_INFO_SMARTCAST!>arg<!>.hashCode()\n        <!SMARTCAST_IMPOSSIBLE!><!DEBUG_INFO_SMARTCAST!>arg<!>.s<!>.hashCode()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo() {\n    var v: String? = \"xyz\"\n    // It is possible in principle to provide smart cast here\n    v<!UNSAFE_CALL!>.<!>length\n    v = null\n    <!OI;DEBUG_INFO_CONSTANT!>v<!><!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun create(): Map<String, String> = null!!\n\noperator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = null!!\n\noperator fun <K, V> Map.Entry<K, V>.component1() = key\n\noperator fun <K, V> Map.Entry<K, V>.component2() = value\n\nclass MyClass {\n    private var m: Map<String, String>? = null\n    fun foo(): Int {\n        var res = 0\n        m = create()\n        // See KT-7428\n        for ((k, v) in <!SMARTCAST_IMPOSSIBLE!>m<!>)\n            res <!NI;OVERLOAD_RESOLUTION_AMBIGUITY!>+=<!> (<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>k<!>.<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>length<!> <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v<!>.<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>length<!>)\n        return res\n    }\n}"
        },
        {
            "code": "public fun fooNotNull(s: String) {\n    System.out.println(\"Length of $s is ${s.length}\")\n}\n\npublic fun foo() {\n    var s: String? = \"not null\"\n    if (s == null) {\n        // Coming soon\n    } else {\n        fooNotNull(<!DEBUG_INFO_SMARTCAST!>s<!>)\n    }\n}\n"
        },
        {
            "code": "// See KT-774\nfun box() : Int {\n    var a : Int? = 1\n    var d = 1\n\n    if (a == null) {\n        return 2\n    } else {\n        return <!DEBUG_INFO_SMARTCAST!>a<!> + d\n    }\n} "
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: String?): Int {\n    var p = pp\n    do {\n        p!!.length\n        if (p == \"abc\") break\n        p = null\n    } while (!x())\n    // Smart cast is NOT possible here\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass MyClass\n\noperator fun MyClass.inc(): MyClass { <!OI;UNREACHABLE_CODE!>return<!> null!! }\n\npublic fun box() : MyClass? {\n    var i : MyClass?\n    i = MyClass()\n    // type of j can be inferred as MyClass()\n    var j = <!DEBUG_INFO_SMARTCAST!>i<!>++\n    <!DEBUG_INFO_SMARTCAST!>j<!>.hashCode()\n    return i\n}"
        },
        {
            "code": "data class SomeObject(val n: SomeObject?) {\n    fun doSomething(): Boolean = true\n    fun next(): SomeObject? = n    \n}\n\n\nfun list(start: SomeObject) {\n    var e: SomeObject?\n    e = start\n    // This comparison is senseless\n    while (e != null) {\n        // Smart cast because of the loop condition\n        if (!<!DEBUG_INFO_SMARTCAST!>e<!>.doSomething())\n            break\n        // We still have smart cast here despite of a break\n        e = <!DEBUG_INFO_SMARTCAST!>e<!>.next()\n    } \n    // e can be null because of next()\n    e<!UNSAFE_CALL!>.<!>doSomething()\n}"
        },
        {
            "code": "operator fun Int?.inc(): Int? { return this }\n\npublic fun box(arg: Int?) : Int? {\n    var i : Int? = arg\n    var j = i++\n    j<!UNSAFE_CALL!>.<!>toInt()\n    return i\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ndata class SomeObject(val n: SomeObject?) {\n    fun doSomething() {}\n    fun next(): SomeObject? = n    \n}\n\n\nfun list(start: SomeObject): SomeObject {\n    var e: SomeObject? = start\n    for (i in 0..42) {\n        // Unsafe calls because of nullable e at the beginning\n        e<!UNSAFE_CALL!>.<!>doSomething()\n        e = e<!UNSAFE_CALL!>.<!>next()\n    }\n    // Smart cast is not possible here due to next()\n    return <!TYPE_MISMATCH!>e<!>\n}"
        },
        {
            "code": "class MyClass\n\n// Correct at compile time but wrong at run-time\noperator fun MyClass?.inc(): MyClass? { return null }\n\npublic fun box() {\n    var i : MyClass? \n    i = MyClass()\n    // type of j should be MyClass?\n    var j = ++i\n    // j is null so call should be unsafe\n    j<!UNSAFE_CALL!>.<!>hashCode()\n}\n"
        },
        {
            "code": "public fun fooNotNull(s: String) {\n    System.out.println(\"Length of $s is ${s.length}\")\n}\n\npublic fun foo() {\n    var s: String? = \"not null\"\n    if (s != null)\n        fooNotNull(<!DEBUG_INFO_SMARTCAST!>s<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(): Int {\n    var s: String? = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>\"abc\"<!>\n    s = null\n    return <!OI;DEBUG_INFO_CONSTANT!>s<!><!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// JAVAC_EXPECTED_FILE\n// See also KT-10735\nfun test() {\n    var a: Int?\n    try {\n        a = 3\n    }\n    catch (e: Exception) {\n        return\n    }\n    <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode() // a is never null here\n}\nclass A: Exception()\nclass B: Exception()\nfun test2() {\n    var a: Int?\n    try {\n        a = 4\n    }\n    catch (e: A) {\n        return\n    }\n    catch (e: B) {\n        return\n    }\n    <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode() // a is never null here\n}\nfun test3() {\n    var a: Int? = null\n    try {\n        a = 5\n    }\n    catch (e: A) {\n        // do nothing\n    }\n    catch (e: B) {\n        return\n    }\n    a<!UNSAFE_CALL!>.<!>hashCode() // a is nullable here\n}\nfun test4() {\n    var a: Int? = null\n    try {\n        // do nothing\n    }\n    catch (e: A) {\n        return\n    }\n    catch (e: B) {\n        return\n    }\n    a<!UNSAFE_CALL!>.<!>hashCode() // a is nullable here\n}\nfun test5() {\n    var a: Int?// = null\n    try {\n        <!UNUSED_VALUE!>a =<!> 3\n    }\n    catch (e: Exception) {\n        return\n    }\n    finally {\n        a = 5\n    }\n    <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode() // a is never null here\n}\nfun test6() {\n    var a: Int?// = null\n    try {\n        <!UNUSED_VALUE!>a =<!> 3\n    }\n    catch (e: Exception) {\n        return\n    }\n    finally {\n        a = null\n    }\n    <!OI;DEBUG_INFO_CONSTANT!>a<!><!UNSAFE_CALL!>.<!>hashCode() // a is null here\n}\n"
        },
        {
            "code": "// !LANGUAGE: -SoundSmartCastsAfterTry\n\nfun foo() {\n    var s: String?\n    s = \"Test\"\n    try {\n        s = null\n    } catch (ex: Exception) {}\n    <!DEBUG_INFO_SMARTCAST!>s<!>.hashCode()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ndata class SomeObject(val n: SomeObject?) {\n    fun doSomething() {}\n    fun next(): SomeObject? = n    \n}\n\n\nfun list(start: SomeObject): SomeObject {\n    var e: SomeObject? = start\n    for (i in 0..42) {\n        if (e == null)\n            break\n        // Smart casts are possible because of the break before\n        <!DEBUG_INFO_SMARTCAST!>e<!>.doSomething()\n        e = <!DEBUG_INFO_SMARTCAST!>e<!>.next()\n    }\n    return <!TYPE_MISMATCH!>e<!>\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(qq: String?): Int {\n    var q = qq\n    while(true) {\n        q!!.length\n        var r = q\n        do {\n            var p = r\n            do {\n                // p = r, r = q and q is not null\n                <!DEBUG_INFO_SMARTCAST!>p<!>.length\n            } while (!x())\n        } while (<!SENSELESS_COMPARISON!>r == null<!>) // r = q and q is not null\n        if (!x()) break\n    }\n    // Smart cast is possible\n    return <!DEBUG_INFO_SMARTCAST!>q<!>.length\n}"
        },
        {
            "code": "// !LANGUAGE: +CapturedInClosureSmartCasts\n\nfun run(f: () -> Unit) = f()\n\nfun foo(s: String?) {\n    var x: String? = null\n    if (s != null) {\n        x = s\n    }\n    if (x != null) {\n        run {\n            <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        }\n    }\n}\n\nfun bar(s: String?) {\n    var x = s\n    if (x != null) {\n        run {\n            <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        }\n    }\n}\n\nfun baz(s: String?) {\n    var x = s\n    if (x != null) {\n        run {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        }\n        run {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n            x = null\n        }\n    }\n}\n\nfun gaz(s: String?) {\n    var x = s\n    if (x != null) {\n        run {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n            x = null\n        }\n        run {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        }\n    }\n}\n\nfun gav(s: String?) {\n    var x = s\n    if (x != null) {\n        run {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        }\n        x = null\n    }\n}"
        },
        {
            "code": "// FILE: test.kt\n\nfun bar() {\n    var v: String?\n    v = J.foo()\n    <!DEBUG_INFO_SMARTCAST!>v<!>.length\n    gav(<!DEBUG_INFO_SMARTCAST!>v<!>)\n}\n\nfun gav(v: String) = v"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo() {\n    var v: String? = null\n    v<!UNSAFE_CALL!>.<!>length\n    v = \"abc\"\n    <!DEBUG_INFO_SMARTCAST!>v<!>.length\n    v = null\n    <!OI;DEBUG_INFO_CONSTANT!>v<!><!UNSAFE_CALL!>.<!>length\n    v = \"abc\"\n    <!DEBUG_INFO_SMARTCAST!>v<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: String?): Int {\n    var p = pp\n    while(true) {\n        p!!.length\n        if (x()) break\n        p = null\n    }\n    // Smart cast is NOT possible here\n    // (we could provide it but p = null makes it much harder)\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "public fun foo() {\n    var s: String? = \"\"\n    fun closure(): Int {\n        if (s == null) {\n            return -1\n        } else {\n            return 0\n        }\n    }\n    if (s != null) {\n        System.out.println(closure())\n        // Smart cast is possible, nobody modifies s\n        System.out.println(<!DEBUG_INFO_SMARTCAST!>s<!>.length)\n    }\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: String?, rr: String?): Int {\n    var p = pp\n    var r = rr\n    do {\n        do {\n            p!!.length\n        } while (r == null)  \n    } while (!x())\n    // Auto cast possible\n    <!DEBUG_INFO_SMARTCAST!>r<!>.length\n    // Auto cast possible\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "class Bar {\n    fun next(): Bar? {\n        if (2 == 4)\n            return this\n        else\n            return null\n    }\n}\n\nfun foo(): Bar {\n    var x: Bar? = Bar()\n    var y: Bar?\n    y = Bar()\n    while (x != null) {\n        // Here call is unsafe because of inner loop\n        y<!UNSAFE_CALL!>.<!>next()\n        while (y != null) {\n            if (x == y)\n                // x is not null because of outer while\n                return <!DEBUG_INFO_SMARTCAST!>x<!>\n            // y is not null because of inner while\n            y = <!DEBUG_INFO_SMARTCAST!>y<!>.next()\n        }\n        // x is not null because of outer while\n        x = <!DEBUG_INFO_SMARTCAST!>x<!>.next()\n    }\n    return Bar()\n}"
        },
        {
            "code": "operator fun Int?.inc(): Int? { return this }\n\npublic fun box(arg: Int?) : Int? {\n    var i = arg\n    var j = ++i\n    j<!UNSAFE_CALL!>.<!>toInt()\n    return ++j\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(): Int {\n    var i: Int? = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>42<!>\n    i = null\n    return <!TYPE_MISMATCH!><!OI;DEBUG_INFO_CONSTANT!>i<!> + 1<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +SoundSmartCastsAfterTry\n\nfun foo() {\n    var s: String?\n    s = \"Test\"\n    try {\n        s = \"Other\"\n    } catch (ex: Exception) {}\n    // Problem: here we do not see that 's' is always not-null\n    s<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "// !LANGUAGE: +SoundSmartCastsAfterTry\n\nfun bar(arg: Any?) = arg\n\nfun foo() {\n    var s: String?\n    s = null\n    try {\n        s = \"Test\"\n    } catch (ex: Exception) {}\n    bar(s)\n    if (s != null) { }\n    s<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(pp: String?): Int {\n    var p = pp\n    while(true) {\n        p!!.length\n        if (x()) break\n        (((p))) = null\n    }\n    // Smart cast is NOT possible here\n    // (we could provide it but p = null makes it much harder)\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See also KT-7186\n\nfun IntArray.forEachIndexed( op: (i: Int, value: Int) -> Unit) {\n    for (i in 0..this.size)\n        op(i, this[i])\n}\n\nfun max(a: IntArray): Int? {\n    var maxI: Int? = null\n    a.forEachIndexed { i, value ->\n        if (maxI == null || value >= a[<!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>maxI<!>])\n            maxI = i\n    }\n    return maxI\n}"
        },
        {
            "code": "// !LANGUAGE: -CapturedInClosureSmartCasts\n\nfun run(f: () -> Unit) = f()\n\nfun foo(s: String?) {\n    var x: String? = null\n    if (s != null) {\n        x = s\n    }\n    if (x != null) {\n        run {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        }\n    }\n}\n"
        },
        {
            "code": "class MyClass\n\n// Correct at compile time but wrong at run-time\noperator fun MyClass?.inc(): MyClass? { return null }\n\npublic fun box() : MyClass? {\n    var i : MyClass? \n    i = MyClass()\n    var j = i++\n    <!DEBUG_INFO_SMARTCAST!>j<!>.hashCode()\n    return i\n}\n"
        },
        {
            "code": "data class SomeObject(val n: SomeObject?) {\n    fun doSomething() {}\n    fun next(): SomeObject? = n    \n}\n\n\nfun list(start: SomeObject) {\n    var e: SomeObject? = start\n    while (e != null) {\n        // While condition makes both smart casts possible\n        <!DEBUG_INFO_SMARTCAST!>e<!>.doSomething()\n        e = <!DEBUG_INFO_SMARTCAST!>e<!>.next()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +SoundSmartCastsAfterTry\n\nfun foo() {\n    var s: String?\n    s = \"Test\"\n    try {\n        s = null\n    } catch (ex: Exception) {}\n    s<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "class Bar {\n    fun next(): Bar? {\n        if (2 == 4)\n            return this\n        else\n            return null\n    }\n}\n\nfun foo(): Bar {\n    var x: Bar? = Bar()\n    var y: Bar? = Bar()\n    while (x != null) {\n        // Here call is unsafe because of initialization and also inner loop\n        y<!UNSAFE_CALL!>.<!>next()\n        while (y != null) {\n            if (x == y)\n                // x is not null because of outer while\n                return <!DEBUG_INFO_SMARTCAST!>x<!>\n            // y is not null because of inner while\n            y = <!DEBUG_INFO_SMARTCAST!>y<!>.next()\n        }\n        // x is not null because of outer while\n        x = <!DEBUG_INFO_SMARTCAST!>x<!>.next()\n    }\n    return Bar()\n}"
        },
        {
            "code": "public fun foo() {\n    var s: String? = \"\"\n    fun closure(): Int {\n        if (s == \"\") {\n            s = null\n            return -1\n        } else if (s == null) {\n            return -2\n        } else {\n            return <!SMARTCAST_IMPOSSIBLE!>s<!>.length // Here smartcast is possible, at least in principle\n        }\n    }\n    if (s != null) {\n        System.out.println(closure())\n        System.out.println(<!SMARTCAST_IMPOSSIBLE!>s<!>.length)   // Here smartcast is not possible due to a closure predecessor\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass MyClass\n\noperator fun MyClass.inc(): MyClass { <!OI;UNREACHABLE_CODE!>return<!> null!! }\n\npublic fun box() {\n    var i : MyClass?\n    i = MyClass()\n    // Type of j should be inferred as MyClass?\n    var j = ++<!DEBUG_INFO_SMARTCAST!>i<!>\n    // j is null so call is unsafe\n    j.hashCode()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ndata class SomeObject(val n: SomeObject?) {\n    fun doSomething() {}\n    fun next(): SomeObject? = n    \n}\n\n\nfun list(start: SomeObject): SomeObject {\n    var e: SomeObject? = start\n    for (i in 0..42) {\n        if (e == null)\n            continue\n        // Smart casts are possible because of the continue before\n        <!DEBUG_INFO_SMARTCAST!>e<!>.doSomething()\n        e = <!DEBUG_INFO_SMARTCAST!>e<!>.next()\n    }\n    return <!TYPE_MISMATCH!>e<!>\n}"
        },
        {
            "code": "fun foo(arg: Int?) {\n    val x = arg\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>arg<!>.hashCode()\n    }\n    val y: Any? = arg\n    if (y != null) {\n        <!DEBUG_INFO_SMARTCAST!>arg<!>.hashCode()\n    }\n    val yy: Any?\n    yy = arg\n    if (yy != null) {\n        arg<!UNSAFE_CALL!>.<!>hashCode()\n    }\n    var z = arg\n    z = z?.let { 42 }\n    if (z != null) {\n        arg<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n"
        },
        {
            "code": "data class SomeObject(val n: SomeObject?) {\n    fun doSomething(): Boolean = true\n    fun next(): SomeObject? = n    \n}\n\nfun list(start: SomeObject) {\n    var e: SomeObject? = start\n    while (e != null) {\n        // Smart cast due to the loop condition\n        if (!<!DEBUG_INFO_SMARTCAST!>e<!>.doSomething())\n            break\n        // We still have smart cast here despite of a break\n        e = <!DEBUG_INFO_SMARTCAST!>e<!>.next()\n    }\n    // e can be null because of next()\n    e<!UNSAFE_CALL!>.<!>doSomething()\n}"
        },
        {
            "code": "data class SomeObject(val n: SomeObject?) {\n    fun doSomething(): Boolean = true\n    fun next(): SomeObject? = n    \n}\n\n\nfun list(start: SomeObject) {\n    var e: SomeObject?\n    e = start\n    do {\n        // In theory smart cast is possible here\n        // But in practice we have a loop with changing e\n        // ?: should we \"or\" entrance type info with condition type info?\n        if (!e<!UNSAFE_CALL!>.<!>doSomething())\n            break\n        // Smart cast here is still not possible\n        e = e<!UNSAFE_CALL!>.<!>next()\n    } while (e != null)\n    // e can be null because of next()\n    e<!UNSAFE_CALL!>.<!>doSomething()\n}"
        },
        {
            "code": "// !LANGUAGE: +SoundSmartCastsAfterTry\n\nfun bar() {}\n\nfun foo() {\n    var s: String?\n    s = \"Test\"\n    try {\n        s = null\n    }\n    catch (ex: Exception) {}\n    finally {\n        bar()\n    }\n    s<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "public fun foo() {\n    var i: Int? = 1\n    if (i != null) {\n        while (i != 10) {\n            <!UNUSED_CHANGED_VALUE!>i<!UNSAFE_CALL!>++<!><!>      // Here smart cast should not be performed due to a successor\n            i = null\n        }\n    }\n}"
        },
        {
            "code": "public fun foo() {\n    var i: Int? = 1\n    if (i != null) {\n        while (i != 10) {\n            <!DEBUG_INFO_SMARTCAST!>i<!>++\n        }\n    }\n}"
        },
        {
            "code": "fun get(): String? {\n    return \"\"\n}\n\nfun foo(): Int {\n    var c: String? = get()\n    c!!.length\n    return <!DEBUG_INFO_SMARTCAST!>c<!>.length // Previous line should make !! unnecessary here.\n}"
        },
        {
            "code": "class My<T: Any>(val y: T?) {\n\n    fun get(): T = run {\n        val x = y\n        if (x == null) throw Exception()\n        <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n}"
        },
        {
            "code": "package o\n\nclass A {\n    infix fun foo(b: B) = b\n}\n\nclass B {\n    fun bar() {}\n}\n\nfun test(a: A, b: B?) {\n    a foo b!!\n    <!DEBUG_INFO_SMARTCAST!>b<!>.bar()\n}"
        },
        {
            "code": "class Wrapper<T>(var x: T)\n\ninline fun <reified T> change(w: Wrapper<T>, x: Any?) {\n    if (x is T) {\n        w.x = <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_NOT_NULL_ASSERTION\n// See KT-9126: Variable change does not affect data flow info for its fields\n\nclass My(val x: Int?)\n\nfun foo() {\n    var y: My? = My(42)\n    if (y!!.x != null) {\n        y = My(null)\n        y!!.x<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitSmartcastsOnLocalDelegatedProperty\n\nclass AlternatingDelegate {\n    var counter: Int = 0\n    operator fun getValue(thisRef: Any?, property: <!UNRESOLVED_REFERENCE!>KProperty<!><*>): Any? =\n        if (counter++ % 2 == 0) 42 else \"\"\n}\n\nfun failsWithClassCastException() {\n    val sometimesNotInt: Any? by AlternatingDelegate()\n\n    if (sometimesNotInt is Int) {\n        <!DEBUG_INFO_SMARTCAST, DEPRECATED_SMARTCAST!>sometimesNotInt<!>.inc()\n    }\n}"
        },
        {
            "code": "// See also: KT-11998\ndata class My(val x: Boolean?)\n\nfun doIt() {}\n\nfun foo(my: My) {\n    if (my.x != null) {\n        // my.x should be smart-cast\n        if (<!DEBUG_INFO_SMARTCAST!>my.x<!>) doIt()\n        when (<!DEBUG_INFO_SMARTCAST!>my.x<!>) {\n            true -> doIt()\n        }\n        when {\n            <!DEBUG_INFO_SMARTCAST!>my.x<!> -> doIt()\n        }\n    }\n}\n\nfun bar(x: Boolean?) {\n    if (x != null) {\n        // x should be smart-cast\n        if (<!DEBUG_INFO_SMARTCAST!>x<!>) doIt()\n        when (<!DEBUG_INFO_SMARTCAST!>x<!>) {\n            true -> doIt()\n        }\n        when {\n            <!DEBUG_INFO_SMARTCAST!>x<!> -> doIt()\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun trans(n: Int, f: () -> Boolean) = if (f()) n else null\n\nfun foo() {\n    var i: Int? = 5    \n    if (i != null) {\n        fun can(): Boolean {\n            i = null\n            return true\n        }\n        <!SMARTCAST_IMPOSSIBLE!>i<!>.hashCode()\n        trans(<!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>i<!>, ::can)\n        <!SMARTCAST_IMPOSSIBLE!>i<!>.hashCode()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(): String {\n    var s: String?\n    s = null\n    <!DEBUG_INFO_CONSTANT!>s<!>?.length\n    <!OI;DEBUG_INFO_CONSTANT!>s<!><!UNSAFE_CALL!>.<!>length\n    if (<!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>s<!> == null<!>) return <!ALWAYS_NULL!>s<!>!!\n    var t: String? = \"y\"\n    if (t == null) t = \"x\"\n    var x: Int? = null\n    if (x == null) <!TYPE_MISMATCH!><!OI;DEBUG_INFO_CONSTANT!>x<!> += null<!>\n    return <!DEBUG_INFO_SMARTCAST!>t<!> + s\n}\n\nfun String?.gav() {}\n\nfun bar(s: String?) {\n    if (s != null) return\n    <!OI;DEBUG_INFO_CONSTANT!>s<!>.gav()\n    <!DEBUG_INFO_CONSTANT!>s<!> <!USELESS_CAST!>as? String<!>\n    <!DEBUG_INFO_CONSTANT!>s<!> <!USELESS_CAST!>as String?<!>\n    <!ALWAYS_NULL!>s<!> as String\n}"
        },
        {
            "code": "// FILE: p/My.java\n\npackage p;\n\nimport org.jetbrains.annotations.*;\n\nclass My {\n    @Nullable static String create() {\n        return \"\";\n    }\n}\n\n// FILE: test.kt\n\npackage p\n\nfun bar(x: String) = x\n\nfun test(x: String?): Any {\n    val y = My.create()\n    val z = x ?: y!!\n    bar(<!TYPE_MISMATCH!>y<!>)\n    // !! / ?. is necessary here, because y!! above may not be executed\n    y?.hashCode()\n    y!!.hashCode()\n    return z\n}\n"
        },
        {
            "code": "class D(val a: String, val b: Boolean)\n\nfun foo(p: Boolean, v: D?): String {\n    if (p && v!!.b) <!DEBUG_INFO_SMARTCAST!>v<!>.a\n    else v<!UNSAFE_CALL!>.<!>a\n    if (p && v!! == D(\"?\", false)) <!DEBUG_INFO_SMARTCAST!>v<!>.a\n    else v<!UNSAFE_CALL!>.<!>a\n    if (p || v!!.b) v<!UNSAFE_CALL!>.<!>a\n    else <!DEBUG_INFO_SMARTCAST!>v<!>.a\n    if (p || v!! == D(\"?\", false)) v<!UNSAFE_CALL!>.<!>a\n    else <!DEBUG_INFO_SMARTCAST!>v<!>.a\n    return \"\"\n} \n"
        },
        {
            "code": "// See KT-6293: Smart cast doesn't work after object literal\nabstract class Runnable {\n    abstract fun run()\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    if (c is Int) {\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        // This object breaks data flow info propagation\n        val k = object: Runnable() {\n            override fun run() = Unit\n        }\n        k.run()\n        // Smart cast should work but error is reported\n        return <!DEBUG_INFO_SMARTCAST!>c<!> + d\n    }\n    else return -1\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nabstract class Runnable {\n    abstract fun run()\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    val a: Int? = 1\n    if (c is Int) {\n        val k = object: Runnable() {\n            init {\n                a!!.toInt()\n            }\n            override fun run() = Unit\n        }\n        k.run()\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        // a is not null because of k constructor, but we do not know it\n        return a <!UNSAFE_OPERATOR_CALL!>+<!> d\n    }\n    else return -1\n}\n"
        },
        {
            "code": "abstract class Runnable(val arg: Int) {\n    abstract fun run(): Int\n}\n\ninterface Wrapper {\n    fun run(): Int\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    val a: Int? = 1\n    if (c is Int) {\n        val k = object: Wrapper, Runnable(a!!) {\n            override fun run() = arg\n        }\n        k.run()\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        return <!DEBUG_INFO_SMARTCAST!>a<!> + d\n    }\n    else return -1\n}\n"
        },
        {
            "code": "abstract class Runnable(val arg: Int) {\n    abstract fun run(): Int\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    val a: Int? = 1\n    if (c is Int) {\n        val k = object: Runnable(a!!) {\n            override fun run() = arg\n        }\n        k.run()\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        return <!DEBUG_INFO_SMARTCAST!>a<!> + d\n    }\n    else return -1\n}\n"
        },
        {
            "code": "// See KT-6293: Smart cast doesn't work after object literal\nabstract class Runnable {\n    abstract fun run()\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    if (c is Int) {\n        var k: Runnable\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        k = object: Runnable() {\n            override fun run() = Unit\n        }\n        // Unnecessary but not important smart cast\n        k.run()\n        return <!DEBUG_INFO_SMARTCAST!>c<!> + d\n    }\n    else return -1\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nabstract class Runnable {\n    abstract fun run()\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    var a: Int?\n    if (c is Int) {\n        a = 2\n        val k = object: Runnable() {\n            init {\n                a = null\n            }\n            override fun run() = Unit\n        }\n        k.run()\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        // a is captured so smart cast is not possible\n        return d + <!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>a<!>\n    }\n    else return -1\n}\n"
        },
        {
            "code": "// See KT-6293: Smart cast doesn't work after object literal\nabstract class Runnable {\n    abstract fun run()\n}\n\nfun foo(): Int {\n    val c: Int? = null\n    if (c is Int) {\n        val d: Int = <!DEBUG_INFO_SMARTCAST!>c<!>\n        object: Runnable() {\n            override fun run() = Unit\n        }.run()\n        return <!DEBUG_INFO_SMARTCAST!>c<!> + d\n    }\n    else return -1\n}\n"
        },
        {
            "code": "//  Anonymous object's initialization does not affect smart casts\n\nabstract class A(val s: String) {\n    fun bar(): String = s\n}\n\nfun foo(o: String?): Int {\n    val a = object : A(o!!){}\n    a.bar()\n    return <!DEBUG_INFO_SMARTCAST!>o<!>.length\n}\n"
        },
        {
            "code": "fun trans(n: Int, f: () -> Boolean) = if (f()) n else null\n\nfun foo() {\n    var i: Int? = 5    \n    if (i != null) {\n        class Changing {\n            fun bar() {\n                i = null\n            }\n        }\n        <!SMARTCAST_IMPOSSIBLE!>i<!>.hashCode()\n        Changing().bar()\n        <!SMARTCAST_IMPOSSIBLE!>i<!>.hashCode()\n    }\n}\n"
        },
        {
            "code": "// Test for a potential byte code mistake for a postfix operation on a smart casted variable\npublic fun box() : Int {\n    var i : Int? \n    i = 10\n    val ii: Int = <!DEBUG_INFO_SMARTCAST!>i<!>\n    // k also should be Int\n    val k : Int = <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>i<!>++<!>\n    // KT-7561: both i and i++ should be Int, otherwise VerifyError can arise here\n    // VerifyError reason: byte code tries to store (i++) result which is Int (smart cast)\n    // into a j which is Int?\n    val j = <!DEBUG_INFO_SMARTCAST!>i<!>++\n    // and m also\n    val m = ++<!DEBUG_INFO_SMARTCAST!>i<!>\n    return <!DEBUG_INFO_SMARTCAST!>j<!> + k + m + <!DEBUG_INFO_SMARTCAST!>i<!> + ii\n}\n"
        },
        {
            "code": "fun test(x: Any?): Any {\n    val z = x ?: x!!\n    // x is not null in both branches\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n    return z\n}\n"
        },
        {
            "code": "fun foo() {\n    class My {\n        val x: Int\n        init {\n            var y: Int?\n            y = 42\n            x = <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(s: Any?): String {\n    val t = when {\n        // To resolve: String U Nothing? = String?\n        s is String -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> null\n    } ?: \"\"\n    return t\n}\n\nfun bar(s: Any?): String {\n    // To resolve: String U Nothing? = String?\n    val t = (if (s == null) {\n        null\n    }\n    else {\n        val u: Any? = null\n        if (u !is String) return \"\"\n        <!DEBUG_INFO_SMARTCAST!>u<!>\n    }) ?: \"xyz\"\n    // Ideally we should have smart cast to String here\n    return t\n}\n\nfun baz(s: String?, r: String?): String {\n    val t = r ?: when {\n        s != null -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> \"\"\n    }\n    return t\n}\n\nfun withNull(s: String?): String {\n    val t = s <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>\n    // Error: nullable\n    return <!TYPE_MISMATCH!>t<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitSmartcastsOnLocalDelegatedProperty\n\nclass AlternatingDelegate {\n    var counter: Int = 0\n    operator fun getValue(thisRef: Any?, property: <!UNRESOLVED_REFERENCE!>KProperty<!><*>): Any? =\n    if (counter++ % 2 == 0) 42 else \"\"\n}\n\nfun failsWithClassCastException() {\n    val sometimesNotInt: Any? by AlternatingDelegate()\n\n    if (sometimesNotInt is Int) {\n        <!SMARTCAST_IMPOSSIBLE!>sometimesNotInt<!>.inc()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass Immutable(val x: String?) {\n    fun foo(): String {\n        if (x != null) return <!DEBUG_INFO_SMARTCAST!>x<!>\n        return \"\"\n    }\n}\n\nclass Mutable(var y: String?) {\n    fun foo(): String {\n        if (y != null) return <!SMARTCAST_IMPOSSIBLE!>y<!>\n        return \"\"\n    }\n}"
        },
        {
            "code": "class Bar {\n    fun bar() {}\n}\n\nclass Foo(var x: Any) {\n    init {\n        if (x is Bar) {\n            val y = x\n            // Error: x is not stable, Type(y) = Any\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.bar()\n            y.<!UNRESOLVED_REFERENCE!>bar<!>()\n            if (y == x) {\n                // Still error\n                y.<!UNRESOLVED_REFERENCE!>bar<!>()\n            }\n            if (x !is Bar && y != x) {\n                // Still error\n                y.<!UNRESOLVED_REFERENCE!>bar<!>()\n            }\n        }\n    }\n}"
        },
        {
            "code": "interface IA\ninterface IB\ninterface IC\n\nobject Host : IB\n\nobject Prop : IA {\n    val Host.foo: Callee get() = Callee\n}\n\nobject Callee\n\nobject Invoke : IC {\n    operator fun Callee.invoke() { }\n}\n\nfun test(a: IA, b: IB, c: IC) {\n    with(a) lambdaA@{\n        with(b) lambdaB@{\n            with(c) lambdaC@{\n                if (this@lambdaA is Prop && this@lambdaB is Host && this@lambdaC is Invoke) {\n                    <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>foo<!>()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun gav(arg: Any): String { return if (arg is String) <!DEBUG_INFO_SMARTCAST!>arg<!> else \"\" }\n\npublic fun foo(x: String?): Int {\n    var y: Any\n    do {\n        y = \"\"\n        y = gav(if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>)\n    } while (bar())\n    y.hashCode()\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\npublic fun foo(x: String?): Int {\n    var y: Any\n    do {\n        // This and hashCode() below are needed just to prevent \n        // UNINITIALIZED_VARIABLE, UNUSED_VALUE, ...\n        y = \"\" \n        y = if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>\n    } while (bar())\n    y.hashCode()\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun gav(z: String, w: String, arg: Any): String \n{ return if (arg is String) <!DEBUG_INFO_SMARTCAST!>arg<!> else if (z != \"\") z else w }\n\npublic fun foo(x: String?, z: String?, w: String?): Int {\n    do {\n        gav(z!!, w!!, if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>)\n    } while (bar())\n    // w is not null because of w!!\n    <!DEBUG_INFO_SMARTCAST!>w<!>.length\n    // z is not null because of z!!\n    <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun foo(s: String?): Int {\n    while (s!!.length > 0) {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n    return <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "fun checkJump(x: Int?, y: Int?) {\n    while (true) {\n        if (x ?: break == 0) {\n            y!!\n        } else {\n            y!!\n        }\n        // Ok\n        <!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()\n    }\n    // Smart cast here is erroneous: y is nullable\n    y<!UNSAFE_CALL!>.<!>hashCode()\n}\n"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun foo(s: String?): Int {\n    do {\n        if (bar()) break\n    } while (s==null)\n    // This call is unsafe due to break\n    return s<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !LANGUAGE: +SoundSmartcastFromLoopConditionForLoopAssignedVariables\n\nfun foo() {\n    var x: String? = \"123\"\n    while (x!!.length < 42) {\n        x = null\n        break\n\n    }\n    // TODO: this testdata fixates undesired behavior (it should be an unsafe call)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length // 'x' is unsoundly smartcasted here\n}\n\nfun bar() {\n    var x: List<Int>? = ArrayList<Int>(1)\n    for (i in x!!) {\n        x = null\n        break\n\n    }\n    // TODO: this testdata fixates undesired behavior (it should be an unsafe call)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.size // 'x' is unsoundly smartcasted here\n}"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun foo(s: String?): Int {\n    while (s==null) {\n        if (bar()) break\n    }\n    // Call is unsafe due to break\n    return s<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    while(true) {\n        if (p==null) return -1\n        if (x()) break\n        // p is not null\n        <!DEBUG_INFO_SMARTCAST!>p<!>.length\n    }\n    // while (true) loop body with return is executed at least once\n    // so p is not null here\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "public fun foo(x: String?, y: String?): Int {\n    while (true) {\n        (if (x != null) break else y) ?: y!!\n        // y is not null in both branches but it's hard to determine\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    // y can be null because of the break\n    return y<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !LANGUAGE: -SoundSmartcastFromLoopConditionForLoopAssignedVariables\n\nfun foo() {\n    var x: String? = \"123\"\n    while (x!!.length < 42) {\n        x = null\n        break\n\n    }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length // 'x' is unsoundly smartcasted here\n}\n\nfun bar() {\n    var x: List<Int>? = ArrayList<Int>(1)\n    for (i in x!!) {\n        x = null\n        break\n\n    }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.size // 'x' is unsoundly smartcasted here\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // Exotic variant with unused literal\n    do <!UNUSED_LAMBDA_EXPRESSION!>{ ->\n        p!!.length\n    }<!> while (!x())\n    // Literal is not called so p.length is unsafe\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun foo(s: String?): Int {\n    do {\n    } while (s!!.length > 0)\n    return <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun foo(s: String?): Int {\n    do {\n        if (bar()) break\n    } while (s!!.length > 0)\n    // This call is unsafe due to break\n    return s<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "public fun foo(p: String?, y: String?): Int {\n    do {\n        // After the check, smart cast should work\n        if (y == null) {\n            \"null\".toString()\n            break\n        }\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n        p!!.length\n    } while (true)\n    return y?.length ?: -1\n}"
        },
        {
            "code": "public fun foo(x: String?, y: String?): Int {\n    do {\n        // After the check, smart cast should work\n        if (x != null) {\n            if (x == \"abc\") break\n            y!!.length\n        } else {\n            y!!.length\n        }\n        // y!! in both branches\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    } while (true)\n    // break is possible before so !! is necessary\n    return y!!.length\n}"
        },
        {
            "code": "fun main() {\n    var result: String? = null\n    var i = 0\n    while (result == null) {\n        if (i == 10) result = \"non null\"\n        else i++\n    }\n    <!DEBUG_INFO_SMARTCAST!>result<!>.length\n}"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun gav(w: String, arg: Any, z: String): String \n{ return if (arg is String) <!DEBUG_INFO_SMARTCAST!>arg<!> else if (z != \"\") z else w }\n\npublic fun foo(x: String?, z: String?, w: String?): Int {\n    do {\n        gav(w!!, if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>, z!!)\n    } while (bar())\n    // w is not null because of w!!\n    <!DEBUG_INFO_SMARTCAST!>w<!>.length\n    // z is nullable despite of z!!\n    z<!UNSAFE_CALL!>.<!>length\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "public fun foo(x: String?): Int {\n    do {\n        // After the check, smart cast should work\n        x ?: x!!.length\n        // x is not null in both branches\n        if (<!DEBUG_INFO_SMARTCAST!>x<!>.length == 0) break\n    } while (true)\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\nfun y(): Boolean { return false }\n\npublic fun foo(p: String?): Int {\n    do {\n        if (y()) break\n        // We do not always reach this statement\n        p!!.length\n    } while (!x())\n    // Here we have do while loop but p is still nullable due to break before\n    return p<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // See KT-6283\n    do {\n        if (p != null) break\n    } while (!x())\n    // p can be null despite of the break\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    while(true) {\n        if (x()) break\n        if (p==null) return -1\n        // p is not null\n        <!DEBUG_INFO_SMARTCAST!>p<!>.length\n    }\n    // p can be null because break is earlier than return\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun bar(): Boolean { return true }\n\npublic fun foo(x: String?): Int {\n    var y: Int?\n    y = 0\n    loop@ do {\n        <!DEBUG_INFO_SMARTCAST!>y<!> += when (x) {\n            null -> break@loop\n            \"abc\" -> return 0\n            \"xyz\" -> return 1\n            else -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        }         \n        // y is always Int after when\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    } while (bar())\n    // y is always Int even here\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "public fun foo(x: String?): Int {\n    loop@ while (true) {\n        when (x) {\n            null -> break@loop\n            \"abc\" -> return 0\n            \"xyz\" -> return 1\n            else -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        }         \n    }\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // Like whileTrue but 2 == 2 is in use\n    while(2 == 2) {\n        p!!.length\n        if (x()) break\n    }\n    // Smart cast should not work in this case, see KT-6284\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun foo(s: String?): Int {\n    while (s==null) {\n    }\n    return <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "public fun foo(x: String?): Int {\n    while (true) {\n        // After the check, smart cast should work\n        val y = if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>\n        // y is not null in both branches\n        y.length\n    }\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "public fun foo(x: String?, y: String?): Int {\n    while (true) {\n        val z = x ?: if (y == null) break else <!DEBUG_INFO_SMARTCAST!>y<!>\n        // z is not null in both branches\n        z.length\n        // y is nullable if x != null\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    // y is null because of the break\n    return y<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun gav(z: String, arg: Any): String { return if (arg is String) <!DEBUG_INFO_SMARTCAST!>arg<!> else z }\n\npublic fun foo(x: String?, z: String?): Int {\n    do {\n        gav(z!!, if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>)\n    } while (bar())\n    // z is not null because of z!!\n    <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {    \n    while(x()) {\n        p!!.length\n        if (x()) break\n    }\n    // p is nullable because it's possible loop body is not executed at all\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?, r: String?, q: String?): Int {\n    while(true) {\n        q!!.length\n        do {\n            do {\n                p!!.length\n            } while (!x())\n        } while (r == null)\n        if (!x()) break\n    }\n    // Smart cast is possible everywhere\n    <!DEBUG_INFO_SMARTCAST!>r<!>.length\n    <!DEBUG_INFO_SMARTCAST!>q<!>.length\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "public fun foo(p: String?, y: String?): Int {\n    do {\n        // After this !!, y. should be smartcasted in loop as well as outside\n        y!!.length\n        if (p == null) break\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    } while (true)\n    return <!DEBUG_INFO_SMARTCAST!>y<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // See KT-6283\n    do {\n        p!!.length\n        if (p == \"abc\") continue\n    } while (!x())\n    // p should be smart casted despite of continue\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?, r: String?, q: String?): Int {\n    while(true) {\n        q!!.length\n        do {\n            p!!.length\n        } while (r == null)\n        if (!x()) break\n    }\n    // Smart cast is possible everywhere\n    <!DEBUG_INFO_SMARTCAST!>r<!>.length\n    <!DEBUG_INFO_SMARTCAST!>q<!>.length\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?, r: String?): Int {\n    outer@ do {\n        do {\n            p!!.length\n            if (!x()) continue@outer\n        } while (r == null)  \n    } while (!x())\n    // Auto cast NOT possible due to long continue\n    r<!UNSAFE_CALL!>.<!>length\n    // Auto cast possible\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // KT-6284\n    while(true) {\n        p!!.length\n        if (x()) break\n    }\n    // while (true) loop body is executed at least once\n    // so p is not null here\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?, r: String?): Int {\n    do {\n        do {\n            p!!.length\n        } while (r == null)  \n    } while (!x())\n    // Auto cast possible\n    <!DEBUG_INFO_SMARTCAST!>r<!>.length\n    // Auto cast possible\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "public fun foo(x: String?): Int {\n    do {\n        // After the check, smart cast should work\n        x ?: break\n        // x is not null in both branches\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    } while (true)\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun x(p: String): Boolean { return p == \"abc\" }\n\npublic fun foo(p: String?, r: String?, q: String?): Int {\n    while(true) {\n        q!!.length\n        loop@ do {\n            while(true) {\n                p!!.length\n                if (x(<!DEBUG_INFO_SMARTCAST!>p<!>)) break@loop\n                if (x(<!DEBUG_INFO_SMARTCAST!>q<!>)) break\n            }\n        } while (r == null)\n        if (!x(<!DEBUG_INFO_SMARTCAST!>p<!>)) break\n    }\n    // Long break allows r == null\n    r<!UNSAFE_CALL!>.<!>length\n    // Smart cast is possible\n    <!DEBUG_INFO_SMARTCAST!>q<!>.length\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "public fun foo(x: String?, y: String?): Int {\n    while (true) {\n        val z = (if (y == null) break else x) ?: <!DEBUG_INFO_SMARTCAST!>y<!>\n        // z is not null in both branches\n        z.length\n        // y is not null in both branches\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    }\n    // y is null because of the break\n    return y<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\nfun y(): Boolean { return false }\n\npublic fun foo(p: String?): Int {\n    do {\n        if (y()) continue\n        // We do not always reach this statement\n        p!!.length\n    } while (!x())\n    // Here we have do while loop but p is still nullable due to continue before\n    return p<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // See KT-6283\n    do {\n        p!!.length\n    } while (!x())\n    // Do-while loop is executed at least once, so\n    // p should be not null here\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "public fun foo(x: String?, y: String?): Int {\n    while (true) {\n        x ?: if (y == null) break\n        // y is nullable if x != null\n        y<!UNSAFE_CALL!>.<!>length\n    }\n    // y is null because of the break\n    return y<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun foo(s: String?): Int {\n    while (s!!.length > 0) {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n        if (bar()) break\n    }\n    return <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?, r: String?, q: String?): Int {\n    while(true) {\n        q!!.length\n        do {\n            while(true) {\n                p!!.length\n                if (x()) break\n            }\n        } while (r == null)\n        if (!x()) break\n    }\n    // Smart cast is possible everywhere\n    <!DEBUG_INFO_SMARTCAST!>r<!>.length\n    <!DEBUG_INFO_SMARTCAST!>q<!>.length\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "public fun foo(x: String?): Int {\n    loop@ while (true) {\n        when (x) {\n            null -> return -1\n            \"abc\" -> return 0\n            \"xyz\" -> return 1\n            else -> break@loop\n        }         \n    }\n    // x is not null because of the break\n    // but we are not able to detect it\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?, r: String?, q: String?): Int {\n    outer@ while(true) {\n        q!!.length\n        do {\n            if (x()) continue@outer\n            do {\n                p!!.length\n            } while (!x())\n        } while (r == null)\n        if (!x()) break\n    }\n    // Smart cast is possible only for q\n    <!DEBUG_INFO_SMARTCAST!>q<!>.length\n    // But not possible for the others\n    r<!UNSAFE_CALL!>.<!>length\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    // See KT-6283\n    do {\n        p!!.length\n        if (p == \"abc\") break\n    } while (!x())\n    // p should be smart casted despite of break\n    return <!DEBUG_INFO_SMARTCAST!>p<!>.length\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\npublic fun foo(x: String?): Int {\n    var y: Any\n    loop@ while (true) {\n        y = when (x) {\n            null -> break@loop\n            \"abc\" -> return 0\n            \"xyz\" -> return 1\n            else -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        }         \n        // y is always Int after when\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    }    \n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun x(): Boolean { return true }\n\npublic fun foo(p: String?): Int {\n    while(true) {\n        if (x()) break\n        // We do not always reach this statement\n        p!!.length\n    }\n    // Here we have while (true) loop but p is nullable due to break before\n    return p<!UNSAFE_CALL!>.<!>length\n}"
        },
        {
            "code": "public fun foo(x: String?): Int {\n    var y: Any\n    while (true) {\n        y = if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n    // In future we can infer this initialization\n    <!UNINITIALIZED_VARIABLE!>y<!>.hashCode()\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun foo(x: String): String? = x\n\nfun calc(x: String?): Int {\n    do {\n        // Smart cast because of x!! in receiver\n        foo(x!!)?.subSequence(0, <!DEBUG_INFO_SMARTCAST!>x<!>.length)\n        // Smart cast because of x!! in receiver\n        if (<!DEBUG_INFO_SMARTCAST!>x<!>.length == 0) break\n    } while (true)\n    // Here x is also not null\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n"
        },
        {
            "code": "public fun foo(p: String?, y: String?): Int {\n    do {\n        // After the check, smart cast should work\n        if (y == null) break\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n        p!!.length\n    } while (true)\n    return y?.length ?: -1\n}"
        },
        {
            "code": "fun bar(): Boolean { return true }\n\nfun gav(arg: Any, z: String): String { return if (arg is String) <!DEBUG_INFO_SMARTCAST!>arg<!> else z }\n\npublic fun foo(x: String?, z: String?): Int {\n    do {\n        gav(if (x == null) break else <!DEBUG_INFO_SMARTCAST!>x<!>, z!!)\n    } while (bar())\n    // z is nullable despite of z!!\n    z<!UNSAFE_CALL!>.<!>length\n    // x is null because of the break\n    return x<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "fun foo(s: String?): Int {\n    do {\n    } while (s==null)\n    return <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "fun foo(x: String): String? = x\n\nfun calc(x: String?, y: String?): Int {\n    do {\n        // Smart cast because of x!! in receiver\n        foo(x!!)?.subSequence(0, if (<!DEBUG_INFO_SMARTCAST!>x<!>.length > 0) 5 else break)\n        y!!.length\n        // x is not null in condition but we do not see it yet\n    } while (x<!UNSAFE_CALL!>.<!>length > 0)\n    // y is nullable because of break\n    y<!UNSAFE_CALL!>.<!>length\n    // x is not null, at least in theory\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n"
        },
        {
            "code": "// See also KT-10992: we should have no errors for all unsafe hashCode() calls\n\nfun foo(arg: Any?) {\n    val x = arg <!USELESS_CAST!>as? Any<!> ?: return\n    <!DEBUG_INFO_SMARTCAST!>arg<!>.hashCode()\n    x.hashCode()\n}\n\nfun bar(arg: Any?) {\n    arg <!USELESS_CAST!>as? Any<!> ?: return\n    <!DEBUG_INFO_SMARTCAST!>arg<!>.hashCode()\n}\n\nfun gav(arg: Any?) {\n    arg as? String ?: return\n    <!DEBUG_INFO_SMARTCAST!>arg<!>.length\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_NOT_NULL_ASSERTION\n// Advancement of KT-9126\n\nclass My(val x: Int?) {\n    operator fun plus(y: My) = if (this.x != null) this else y\n}\n\nfun foo() {\n    var y: My? = My(42)\n    if (y!!.x != null) {\n        y = My(null)\n        (<!DEBUG_INFO_SMARTCAST!>y<!> + My(0)).x<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: Test.kt\n\nfun test() {\n    val my = My.create()\n    if (my == null) {\n        <!OI;DEBUG_INFO_CONSTANT!>my<!><!OI;UNSAFE_CALL!>.<!>foo()\n    }\n}\n\n"
        },
        {
            "code": "// See also KT-7800\n\nfun foo(): Int {\n    val x: Int = 1.let {\n        val value: Int? = null\n        if (value == null) {\n            return@let 1\n        }\n\n        <!DEBUG_INFO_SMARTCAST!>value<!> // smart-cast should be here\n    }\n    return x\n}"
        },
        {
            "code": "fun foo(x: String?) = x\n\nclass Test\n\nclass TestWithEquals {\n    override fun equals(other: Any?) = super.equals(other)\n}\n\nfun bar(i: Test?) {\n    if (i == null) foo(<!DEBUG_INFO_CONSTANT!>i<!>)\n}\n\nfun bar(i: TestWithEquals?) {\n    if (i == null) foo(<!DEBUG_INFO_CONSTANT!>i<!>)\n    if (null == i) foo(<!DEBUG_INFO_CONSTANT!>i<!>)\n    when (i) {\n        null -> foo(<!DEBUG_INFO_CONSTANT!>i<!>)\n    }\n}\n\nfun gav(i: TestWithEquals?, j: TestWithEquals?) {\n    if (j == null) {\n        if (i == <!DEBUG_INFO_CONSTANT!>j<!>) foo(<!DEBUG_INFO_CONSTANT!>i<!>)\n    }\n}"
        },
        {
            "code": "open class A {\n    class B : A() {\n        val a = \"FAIL\"\n    }\n\n    class C : A() {\n        val a = \"FATAL\"\n    }\n\n    fun foo(): String {\n        if (this is B) return <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>a<!>\n        else if (this is C) return <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>a<!>\n        return \"OK\"\n    }\n}\n\nfun A?.bar() {\n    if (this != null) <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>foo<!>()\n}\n\nfun A.gav() = if (this is A.B) <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>a<!> else \"\"\n\nclass C {\n    fun A?.complex(): String {\n        if (this is A.B) return <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>a<!>\n        else if (this != null) return <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>foo<!>()\n        else return \"\"\n    }\n}\n"
        },
        {
            "code": "open class T {\n    val x : Int? = null\n}\n\nclass A {\n    companion object: T() {\n    }\n}\n\nclass B {\n    companion object: T() {\n    }\n}\n\nfun test() {\n    if (A.x != null) {\n        useInt(<!DEBUG_INFO_SMARTCAST!>A.x<!>)\n        useInt(<!TYPE_MISMATCH!>B.x<!>)\n    }\n}\n\nfun useInt(i: Int) = i"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(arg: Int?) {\n    var x = arg\n    if (x == null) return\n    run {\n        // Unsafe because of owner modification\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        x = null\n    }\n    if (x != null) x = 42\n    // Unsafe because of lambda\n    <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n}"
        },
        {
            "code": "// See also KT-7817\n\nfun <R> synchronized(<!UNUSED_PARAMETER!>lock<!>: Any, block: () -> R): R = block()\n\nclass My {\n    val test: String\n        get() = synchronized(this) {\n            var x: String? = \"\"\n            if (x == null) {\n                x = \"s\"\n            }\n            <!DEBUG_INFO_SMARTCAST!>x<!>\n        }\n}"
        },
        {
            "code": "fun foo(p: String?): Int {\n    // We should get smart cast here\n    val x = if (p != null) { <!DEBUG_INFO_SMARTCAST!>p<!> } else \"a\"\n    return x.length\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// SKIP_TXT\n\nsealed class A\nsealed class B : A()\nsealed class C : A()\nobject BB : B()\nobject CC : C()\n\nfun foo(a: A) {\n    if (a is B) {\n        if (a is C) {\n            val t = when (<!DEBUG_INFO_SMARTCAST!>a<!>) {\n                is CC -> \"CC\"\n            }\n        }\n    }\n}\n\nfun foo2(a: A) {\n    if (a is C) {\n        if (a is B) {\n            val t = <!NO_ELSE_IN_WHEN!>when<!> (<!DEBUG_INFO_SMARTCAST!>a<!>) {\n                    is CC -> \"CC\"\n            }\n        }\n    }\n}"
        },
        {
            "code": "open class SuperFoo {\n    public fun bar(): String {\n        if (this is Foo) {\n            <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>superFoo<!>()\n            return baz()\n        }\n        return baz()\n    }\n\n    public fun baz() = \"OK\"\n}\n\nclass Foo : SuperFoo() {\n    public fun superFoo() {}\n}\n"
        },
        {
            "code": "public fun test(o: String?): Boolean {\n    return when {\n        // Data flow info should propagate from o == null to o.length\n        o == null<!COMMA_IN_WHEN_CONDITION_WITHOUT_ARGUMENT!>,<!> <!DEBUG_INFO_SMARTCAST!>o<!>.length == 0 -> false\n        else -> true\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// KT-5335\n\nfun foo(p1: String?, p2: String?) {\n    if (p2 != null) {\n        val v = p1 ?: <!DEBUG_INFO_SMARTCAST!>p2<!>\n        val size = v.length\n    }\n}\n"
        },
        {
            "code": "fun bar(x: Int?): Int {\n    if (x != null) return -1\n    if (<!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>x<!> == null<!>) return -2\n    // Should be unreachable\n    return 2 + 2\n}"
        },
        {
            "code": "//KT-1461 Front-end complains on overload resolution when superclass property is accessed from string template and implicit type cast is performed\npackage f\n\nopen class Super(val property : String) {}\n\nclass Sub(str : String) : Super(str) {}\n\nfun foo(sup : Super, sub : Sub) {\n    if (sup is Sub) {\n        println(\"${sup.property}\")\n        println(sup.property)\n    }\n    println(\"${sub.property}\")\n    println(sub.property)\n}\n\n//from library\nfun println(<!UNUSED_PARAMETER!>message<!> : Any?) { throw Exception() }"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline fun <reified T : CharSequence?> foo(y: Any?) {\n    if (y is T?) {\n        if (y != null) {\n            bar(<!DEBUG_INFO_SMARTCAST!>y<!>)\n        }\n    }\n}\n\nfun bar(x: CharSequence) {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// KT-10444 Do not ignore smart (unchecked) casts to the same classifier\n\nclass Qwe<T : Any>(val a: T?) {\n    fun test1(obj: Any) {\n        obj <!UNCHECKED_CAST!>as Qwe<T><!>\n        check(<!DEBUG_INFO_SMARTCAST!>obj<!>.a)\n    }\n\n    fun test1(obj: Qwe<*>) {\n        obj <!UNCHECKED_CAST!>as Qwe<T><!>\n        check(<!OI;DEBUG_INFO_SMARTCAST!>obj<!>.a)\n    }\n\n    fun check(a: T?) {\n    }\n}\n\nopen class Foo\nopen class Bar<T: Foo>(open val a: T?, open val b: T?) {\n    @Suppress(\"UNCHECKED_CAST\")\n    fun compare(obj: Any) {\n        if (obj !is Bar<*>) {\n            throw IllegalArgumentException()\n        }\n        if (System.currentTimeMillis() > 100) {\n            val b = (obj as Bar<T>).b\n            if (b == null) throw IllegalArgumentException()\n            check(<!DEBUG_INFO_SMARTCAST!>obj<!>.a, <!DEBUG_INFO_SMARTCAST!>b<!>)\n        }\n    }\n    fun check(a: T?, b: T) {\n    }\n}\n"
        },
        {
            "code": "fun baz(s: String?, u: String?): String {\n    val t = when(s) {\n        is String -> {\n            if (u == null) return <!DEBUG_INFO_SMARTCAST!>s<!>\n            <!DEBUG_INFO_SMARTCAST!>u<!>\n        }\n        else -> {\n            if (u == null) return \"\"\n            <!DEBUG_INFO_SMARTCAST!>u<!>\n        }\n    }\n    return t\n}"
        },
        {
            "code": "interface I1\ninterface I2\ninterface I3\ninterface I4\ninterface I5\n\noperator fun I1.component1() = 1\noperator fun I2.component2() = 2\noperator fun I3.component3() = 3\noperator fun I4.component4() = 4\noperator fun I5.component5() = 5\n\nfun test(x: Any): Int {\n    if (x is I1 && x is I2 && x is I3 && x is I4 && x is I5) {\n        val (t1, t2, t3, t4, t5) = <!DEBUG_INFO_SMARTCAST!>x<!>\n        return t1 + t2 + t3 + t4 + t5\n    }\n    else return 0\n}\n"
        },
        {
            "code": "// Works already in M11\n\nfun test(c : Class<*>) {\n    val sc = c <!UNCHECKED_CAST!>as Class<String><!>\n    // No ambiguous overload\n    c.getAnnotations();\n    sc.getAnnotations();\n}\n"
        },
        {
            "code": "interface A\nclass B : A {\n    operator fun invoke() = this\n}\n\nclass C : A\n\noperator fun C.invoke(): B = B()\n\nfun foo(arg: A): B? {\n    if (arg is B) return <!DEBUG_INFO_SMARTCAST!>arg<!>()\n\n    if (arg is C) return <!DEBUG_INFO_SMARTCAST!>arg<!>()\n\n    return null\n}\n\n"
        },
        {
            "code": "fun foo(x: String?, y: String?, z: String?) {\n    if ((x!!.hashCode() == 0 || y!!.hashCode() == 1) && z!!.hashCode() == 2) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        y<!UNSAFE_CALL!>.<!>length\n        // condition is true => z!! after and is called\n        <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        y<!UNSAFE_CALL!>.<!>length\n        z<!UNSAFE_CALL!>.<!>length\n    }\n    // First element is always analyzed\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    var xx = y ?: z\n    if ((xx!!.hashCode() == 0 && y!!.hashCode() == 1) || z!!.hashCode() == 2) {\n        <!DEBUG_INFO_SMARTCAST!>xx<!>.length\n        y<!UNSAFE_CALL!>.<!>length\n        z<!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>xx<!>.length\n        y<!UNSAFE_CALL!>.<!>length\n        // condition is false => z!! after or is called\n        <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    }\n    // First element is always analyzed\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    xx = y ?: z\n    if (xx!!.hashCode() == 0 && y!!.hashCode() == 1 && z!!.hashCode() == 2) {\n        // all three are called\n        <!DEBUG_INFO_SMARTCAST!>xx<!>.length\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n        <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>xx<!>.length\n        y<!UNSAFE_CALL!>.<!>length\n        z<!UNSAFE_CALL!>.<!>length\n    }\n    // First element is always analyzed\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    xx = y ?: z\n    if (xx!!.hashCode() == 0 || y!!.hashCode() == 1 || z!!.hashCode() == 2) {\n        <!DEBUG_INFO_SMARTCAST!>xx<!>.length\n        y<!UNSAFE_CALL!>.<!>length\n        z<!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        // all three are called\n        <!DEBUG_INFO_SMARTCAST!>xx<!>.length\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n        <!DEBUG_INFO_SMARTCAST!>z<!>.length\n    }\n}"
        },
        {
            "code": "fun baz(s: String?): String {\n    val t = if (s != null) <!DEBUG_INFO_SMARTCAST!>s<!>\n    else {\n        val u: String? = null\n        if (u == null) return \"\"\n        <!DEBUG_INFO_SMARTCAST!>u<!>\n    }\n    return t\n}\n"
        },
        {
            "code": "data class StringPair(val first: String, val second: String)\n\ninfix fun String.to(second: String) = StringPair(this, second)\n\nfun f(a: String?) {\n    if (a != null) {\n        val <!UNUSED_VARIABLE!>b<!>: StringPair = <!DEBUG_INFO_SMARTCAST!>a<!> to <!DEBUG_INFO_SMARTCAST!>a<!>\n    }\n}"
        },
        {
            "code": "/*\n    Here element has type Captured(*) because of resolution for `iterator()` on this.\n    and where we resolve `destination.add(element)` we approximate element to `Any` with smart cast to `R`.\n */\ninline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(<!DEBUG_INFO_SMARTCAST!>element<!>)\n    return destination\n}\n"
        },
        {
            "code": "fun calc(x: List<String>?) {\n    // x should be non-null in arguments list, despite of a chain\n    x?.subList(0, <!DEBUG_INFO_SMARTCAST!>x<!>.size)?.\n       subList(0, <!DEBUG_INFO_SMARTCAST!>x<!>.size)?.\n       get(<!DEBUG_INFO_SMARTCAST!>x<!>.size)\n}\n"
        },
        {
            "code": "fun calc(x: List<String>?): Int {\n    // x is not-null only inside subList\n    x?.subList(0, <!DEBUG_INFO_SMARTCAST!>x<!>.size - 1)<!UNSAFE_CALL!>.<!>get(x<!UNSAFE_CALL!>.<!>size)\n    return x!!.size\n}\n"
        },
        {
            "code": "fun calc(x: List<String>?, y: List<Int>?) {\n    // x and y should be non-null in arguments list, despite of a chains\n    x?.subList(y?.subList(1, 2)?.get(<!DEBUG_INFO_SMARTCAST!>y<!>.size) ?: 0,\n               y?.get(0) ?: 1) // But safe call is NECESSARY here for y\n     ?.get(<!DEBUG_INFO_SMARTCAST!>x<!>.size)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun calc(x: List<String>?, y: Int?): Int {\n    x?.get(y!! - 1) \n    // y!! above should not provide smart cast here\n    val yy: Int = <!TYPE_MISMATCH!>y<!>\n    return  yy + (x?.size ?: 0)\n}\n"
        },
        {
            "code": "fun String.foo(arg: Int) = this[arg]\n\nfun calc(x: String?) {\n    // x should be non-null in arguments list\n    x?.foo(<!DEBUG_INFO_SMARTCAST!>x<!>.length - 1)\n}\n"
        },
        {
            "code": "// FILE: Test.kt\nfun test() {\n    val foo = Foo.create(null)\n    foo?.bar.let {\n        // Error, foo?.bar is nullable\n        it<!UNSAFE_CALL!>.<!>length\n        // Foo is nullable but flexible, so call is considered safe here\n        foo.bar.length\n        // Correct\n        foo?.bar?.length\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun calc(x: List<String>?, y: Int?): Int {\n    x?.subList(y!! - 1, <!DEBUG_INFO_SMARTCAST!>y<!>)\n    // y!! above should not provide smart cast here\n    return <!TYPE_MISMATCH!>y<!>\n}\n"
        },
        {
            "code": "fun foo(x: String): String? = x\n\nfun calc(x: String?): Int {\n    // Smart cast because of x!! in receiver\n    foo(x!!)?.subSequence(0, <!DEBUG_INFO_SMARTCAST!>x<!>.length)?.length\n    // Smart cast because of x!! in receiver\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n"
        },
        {
            "code": "fun calc(x: List<String>?): Int {\n    // x should be non-null in arguments list\n    x?.get(<!DEBUG_INFO_SMARTCAST!>x<!>.size - 1)\n    // but not also here!\n    return x<!UNSAFE_CALL!>.<!>size\n}\n"
        },
        {
            "code": "// See KT-11007: Wrong smart cast to not-null type after safe calls in if / when expression\n\nval String.copy: String\n    get() = this\n\nfun foo() {\n    val s: String? = null\n    val ss = if (true) {\n        s?.length\n    } else {\n        s?.length\n    }\n    ss<!UNSAFE_CALL!>.<!>hashCode() // Smart-cast to Int, should be unsafe call\n    val sss = if (true) {\n        s?.copy\n    }\n    else {\n        s?.copy\n    }\n    sss<!UNSAFE_CALL!>.<!>length\n}\n\nclass My {\n    val String.copy2: String\n        get() = this\n\n    fun foo() {\n        val s: String? = null\n        val ss = if (true) {\n            s?.length\n        } else {\n            s?.length\n        }\n        ss<!UNSAFE_CALL!>.<!>hashCode()\n        val sss = if (true) {\n            s?.copy2\n        }\n        else {\n            s?.copy2\n        }\n        sss<!UNSAFE_CALL!>.<!>length\n    }\n}\n"
        },
        {
            "code": "// See KT-10056\nclass Foo(val bar: String)\n\nfun test(foo: Foo?) {\n    foo?.bar.let {\n        // Error, foo?.bar is nullable\n        it<!UNSAFE_CALL!>.<!>length\n        // Error, foo is nullable\n        foo<!UNSAFE_CALL!>.<!>bar.length\n        // Correct\n        foo?.bar?.length\n    }\n}"
        },
        {
            "code": "// See KT-7290\nclass MyClass(val x: String?)\nfun foo(y: MyClass?): Int {\n    // x here is smartcast but y is not\n    val z = y?.x?.subSequence(0, <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>y<!>.x<!>.length)\n    // !! is necessary here\n    y!!.x\n    return z?.length ?: -1\n}\nfun bar(y: MyClass?) {\n    y?.x!!.length\n    // !! is NOT necessary here, because y?.x != null\n    y<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.x\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun foo(x: String): String? = x\n\nfun calc(x: String?, y: Int?): Int {\n    // Smart cast because of x!! in receiver\n    foo(x!!)?.subSequence(y!!, <!DEBUG_INFO_SMARTCAST!>x<!>.length)?.length\n    // No smart cast possible\n    return <!TYPE_MISMATCH!>y<!>\n}\n"
        },
        {
            "code": "fun foo(y: Int) = y\n\nfun calc(x: List<String>?): Int {\n    foo(x!!.size)\n    // Here we should have smart cast because of x!!, despite of KT-7204 fixed\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.size\n}\n"
        },
        {
            "code": "fun foo(y: Int): Int {\n    return y + 1\n}\n\nfun calc(x: List<String>?): Int {\n    // x should be non-null in arguments list\n    return foo(x?.get(<!DEBUG_INFO_SMARTCAST!>x<!>.size - 1)!!.length)\n}\n"
        },
        {
            "code": "fun String.foo(y: Int) = y\n\nfun calc(x: List<String>?): Int {\n    \"abc\".foo(x!!.size)\n    // Here we should have smart cast because of x!!, despite of KT-7204 fixed\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.size\n}\n"
        },
        {
            "code": "fun String.bar(s: String) = s\n\nfun foo(s: String?) {\n    s?.bar(<!DEBUG_INFO_SMARTCAST!>s<!>)\n    s?.get(<!DEBUG_INFO_SMARTCAST!>s<!>.length)\n}"
        },
        {
            "code": "data class MyClass(val x: String?)\n\nfun foo(y: MyClass): Int {\n    val z = y.x?.subSequence(0, <!DEBUG_INFO_SMARTCAST!>y.x<!>.length)\n    return z?.length ?: -1\n}"
        },
        {
            "code": "fun calc(x: List<String>?): Int {\n    // x should be non-null in arguments list, including inner call\n    x?.get(<!DEBUG_INFO_SMARTCAST!>x<!>.get(<!DEBUG_INFO_SMARTCAST!>x<!>.size - 1).length)\n    // but not also here!\n    return x<!UNSAFE_CALL!>.<!>size\n}\n"
        },
        {
            "code": "fun calc(x: List<String>?): Int {\n    // x should be non-null in arguments list\n    x?.subList(<!DEBUG_INFO_SMARTCAST!>x<!>.size - 1, <!DEBUG_INFO_SMARTCAST!>x<!>.size)\n    // but not also here!\n    return x<!UNSAFE_CALL!>.<!>size\n}\n"
        },
        {
            "code": "class Bar(val gav: String)\n\nclass Foo(val bar: Bar, val nbar: Bar?) {\n    fun baz(s: String) = if (s != \"\") Bar(s) else null\n}\n\nfun String?.call(f: (String?) -> String?) = f(this)\n\nfun String.notNullLet(f: (String) -> Unit) = f(this)\n\nfun test(foo: Foo?) {\n    foo?.bar?.gav.let {\n        // Error, foo?.bar?.gav is nullable\n        it<!UNSAFE_CALL!>.<!>length\n        // Error, foo is nullable\n        foo<!UNSAFE_CALL!>.<!>bar.gav.length\n        // Correct\n        foo?.bar?.gav?.length\n    }\n    foo?.bar?.gav.call { it }?.notNullLet {\n        foo<!UNSAFE_CALL!>.<!>hashCode()\n        foo<!UNSAFE_CALL!>.<!>bar.hashCode()\n    }\n}\n\nfun testNotNull(foo: Foo) {\n    val s: String? = \"\"\n    foo.baz(s!!)?.gav.let {\n        it<!UNSAFE_CALL!>.<!>length\n        // Ok because of foo.\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length.hashCode()\n    }\n}\n\nfun testNullable(foo: Foo?) {\n    val s: String? = \"\"\n    foo?.baz(s!!)?.gav.let {\n        it<!UNSAFE_CALL!>.<!>length\n        // Ok because of foo?.\n        s?.length?.hashCode()\n    }\n}\n"
        },
        {
            "code": "fun calc(x: List<String>?): Int {\n    // x should be non-null in arguments list, despite of a chain\n    x?.subList(0, 1)?.get(<!DEBUG_INFO_SMARTCAST!>x<!>.size)\n    // But not here!\n    return x!!.size\n}\n"
        },
        {
            "code": "fun foo(x: String): String? = x\n\nfun calc(x: String?): Int {\n    // Smart cast because of x!! in receiver\n    foo(x!!)?.subSequence(0, <!DEBUG_INFO_SMARTCAST!>x<!>.length)\n    // Smart cast because of x!! in receiver\n    return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n"
        },
        {
            "code": "fun Any?.foo(my: My) = my === this\n\nclass My(val x: Any)\n\n// my is nullable in brackets because Any?.foo has nullable receiver\nfun foo(my: My?) = my?.x.foo(<!TYPE_MISMATCH!>my<!>)"
        },
        {
            "code": "fun calc(x: List<String>?): Int {\n    // After KT-5840 fix !! assertion should become unnecessary here\n    x?.get(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.size - 1)\n    // x?. or x!! above should not provide smart cast here\n    return x<!UNSAFE_CALL!>.<!>size\n}\n"
        },
        {
            "code": "fun foo(x: String): String? = x\n\nfun calc(x: String?, y: String?): Int {\n    // Smart cast because of y!! in receiver\n    x?.subSequence(y!!.subSequence(0, 1).length, <!DEBUG_INFO_SMARTCAST!>y<!>.length)\n    // No smart cast possible\n    return y<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: -SafeCastCheckBoundSmartCasts -BooleanElvisBoundSmartCasts\n// A set of examples for\n// \"If the result of a safe call is not null, understand that its receiver is not null\"\n// and some other improvements for nullability detection\n\nfun kt6840_1(s: String?) {\n    val hash = s?.hashCode()\n    if (hash != null) {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n}\n\nfun kt6840_2(s: String?) {\n    if (s?.hashCode() != null) {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n}\n\nfun kt1635(s: String?) {\n    s?.hashCode()!!\n    <!DEBUG_INFO_SMARTCAST!>s<!>.hashCode()\n}\n\nfun kt2127() {\n    val s: String? = \"\"\n    if (s?.length != null) {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.hashCode()\n    }\n}\n\nfun kt3356(s: String?): Int {\n    if (s?.length != 1) return 0\n    return <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}\n\nopen class SomeClass(val data: Any)\n\nclass SubClass(val extra: Any, data: Any) : SomeClass(data)\n\nfun kt4565_1(a: SomeClass?) {\n    val data = a?.data\n    if (data != null) {\n        <!DEBUG_INFO_SMARTCAST!>data<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.data.hashCode()\n    }\n    if (a?.data != null) {\n        // To be supported (?!)\n        data<!UNSAFE_CALL!>.<!>hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n        <!DEBUG_INFO_SMARTCAST!>a<!>.data.hashCode()\n    }\n    if (a?.data is String) {\n        <!DEBUG_INFO_SMARTCAST!>a<!>.data.<!UNRESOLVED_REFERENCE!>length<!>\n        data.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun kt4565_2(a: SomeClass?) {\n    // To be supported\n    if (a as? SubClass != null) {\n        a.<!UNRESOLVED_REFERENCE!>extra<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n    val extra = (a as? SubClass)?.extra\n    if (extra != null) {\n        a.<!UNRESOLVED_REFERENCE!>extra<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n}\n\nclass A(val y: Int)\n\nfun kt7491_1() {\n    val x: A? = A(42)\n    val <!UNUSED_VARIABLE!>z<!> = x?.y ?: return\n    <!DEBUG_INFO_SMARTCAST!>x<!>.y\n}\n\nfun getA(): A? = null\nfun useA(a: A): Int = a.hashCode()\n\nfun kt7491_2() {\n    val a = getA()\n    (a?.let { useA(<!DEBUG_INFO_SMARTCAST!>a<!>) } ?: a<!UNSAFE_CALL!>.<!>y ).toString()\n}\n\nfun String.correct() = true\n\nfun kt8492(s: String?) {\n    if (s?.correct() ?: false) {\n        // To be supported\n        s<!UNSAFE_CALL!>.<!>length\n    }\n}\n\nfun kt11085(prop: String?) {\n    when (prop?.hashCode()) {\n        1 -> <!DEBUG_INFO_SMARTCAST!>prop<!>.length\n    }\n}\n\nclass HttpExchange(val code: String)\n\nfun kt11313(arg: HttpExchange?) {\n    when (arg?.code) {\n        \"GET\" -> handleGet(<!DEBUG_INFO_SMARTCAST!>arg<!>)\n        \"POST\" -> handlePost(<!DEBUG_INFO_SMARTCAST!>arg<!>)\n    }\n}\n\nfun handleGet(arg: HttpExchange) = arg\n\nfun handlePost(arg: HttpExchange) = arg\n\nclass Wrapper {\n    fun unwrap(): String? = \"Something not consistent\"\n}\n\nfun falsePositive(w: Wrapper) {\n    if (w.unwrap() != null) {\n        // Here we should NOT have smart cast\n        <!SMARTCAST_IMPOSSIBLE!>w.unwrap()<!>.length\n    }\n}\n\nclass Invokable(val x: String) {\n    operator fun invoke() = x\n}\n\nclass InvokableProperty(val i: Invokable)\n\nfun checkInvokable(ip: InvokableProperty?) {\n    if (ip?.<!OI;UNSAFE_IMPLICIT_INVOKE_CALL!>i<!>() == \"Hello\") {\n        <!DEBUG_INFO_SMARTCAST!>ip<!>.hashCode()\n    }\n}"
        },
        {
            "code": "fun calc(x: List<String>?, y: Int?) {\n    // Smart cast should work here despite of KT-7204 fixed\n    x?.subList(0, y!!)?.get(<!DEBUG_INFO_SMARTCAST!>y<!>) \n}\n"
        },
        {
            "code": "class Foo(val bar: String?)\n\nfun test(foo: Foo?) {\n    foo!!.bar.let {\n        // Correct\n        <!DEBUG_INFO_SMARTCAST!>foo<!>.bar?.length\n        // Unnecessary\n        foo<!UNNECESSARY_SAFE_CALL!>?.<!>bar?.length\n    }\n    <!DEBUG_INFO_SMARTCAST!>foo<!>.bar?.length\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nfun case_0() {\n    val z: Any? = 10\n    val y = z.run {\n        this as Int\n        <!NI;DEBUG_INFO_SMARTCAST!>this<!> // error in NI: required Int, found Any?; just inferred to Any? in OI\n    }\n    y checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Any?>() }\n    y checkType { <!OI;TYPE_MISMATCH!>_<!><Int>() }\n}\n\nfun case_1(z: Any?) {\n    val y = z.run {\n        when (this) {\n            is String -> return@run <!NI;DEBUG_INFO_SMARTCAST!>this<!> // type mismatch in the new inference (required String, found Any?)\n            is Float -> \"\"\n            else -> return@run \"\"\n        }\n    }\n    y checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Any?>() }\n    y checkType { <!OI;TYPE_MISMATCH!>_<!><kotlin.String>() }\n    // y is inferred to Any?\n}\n\nfun case_2(z: Any?) {\n    val y = z.run {\n        when (this) {\n            is String -> <!DEBUG_INFO_SMARTCAST!>this<!>\n            is Float -> \"\"\n            else -> return@run \"\"\n        }\n    }\n    y checkType { _<kotlin.String>() }\n    // y is inferred to String\n}\n\nfun case_3(z: Any?) {\n    val y = z.let {\n        when (it) {\n            is String -> return@let <!NI;DEBUG_INFO_SMARTCAST!>it<!>\n            is Float -> \"\"\n            else -> return@let \"\"\n        }\n    }\n    y checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Any?>() }\n    y checkType { <!OI;TYPE_MISMATCH!>_<!><kotlin.String>() }\n    // y is inferred to String\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n\ninline fun <T> foo(t1: T, t2: T) = t1 ?: t2\n\ninline fun <T> bar(<!UNUSED_PARAMETER!>l<!>: (T) -> Unit): T = null!!\n\nfun use() {\n    var x: Int?\n    x = 5\n    // Write is AFTER\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n    // x is nullable at the second argument\n    foo(bar { x = null }, x!!)\n}\n"
        },
        {
            "code": "// See KT-10223\n\ninline fun <T> using(input: Any?, f: (Any?) -> T): T = f(input)\n\nval input: Any? = null\n\n// Error:(32, 24) Type inference failed. Expected type mismatch: inferred type is kotlin.Any? but kotlin.String was expected\nval test4: String = using(input) {\n    when (it) {\n        is String -> <!DEBUG_INFO_SMARTCAST!>it<!>\n        else -> throw RuntimeException()\n    }\n}"
        },
        {
            "code": "sealed class My(open val x: Int?) {\n    init {\n        if (<!DEBUG_INFO_LEAKING_THIS!>x<!> != null) {\n            // Should be error: property is open\n            <!DEBUG_INFO_LEAKING_THIS, SMARTCAST_IMPOSSIBLE!>x<!>.hashCode()\n        }\n    }\n}"
        },
        {
            "code": "interface Foo\nfun foo(): Foo? = null\n\nval foo: Foo = run {\n    run {\n        val x = foo()\n        if (x == null) throw Exception()\n        <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n}\n"
        },
        {
            "code": "// NB: should work after KT-5907 / KT-4450 fix\n\nval currentTimeMillis = 1234L\n\npublic class Foo(protected val maxParsingTimeInMillis: Long?) {\n\n    var parsingStartTimeStamp = 0L\n\n    protected fun checkForParsingTimeout(): Boolean {\n        if (maxParsingTimeInMillis == null)\n            return true\n        if (currentTimeMillis - parsingStartTimeStamp > <!DEBUG_INFO_SMARTCAST!>maxParsingTimeInMillis<!>)\n            return false\n        return true\n    }\n}"
        },
        {
            "code": "public class X {\n    public var x : String? = null\n    private var y: String? = \"abc\"\n    public fun fn(): Int {\n        if (x != null)\n            // Smartcast is not possible for variable properties\n            return <!SMARTCAST_IMPOSSIBLE!>x<!>.length\n        else if (y != null)\n            // Even if they are private\n            return <!SMARTCAST_IMPOSSIBLE!>y<!>.length\n        else\n            return 0\n    }\n}\n\n"
        },
        {
            "code": "public open class X {\n    protected val x : String? = null\n    public fun fn(): Int {\n        if (x != null)\n            // Smartcast is possible for protected value property in the same class\n            return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        else\n            return 0\n    }\n}\n\npublic class Y: X() {\n    public fun bar(): Int {\n        // Smartcast is possible even in derived class\n        return if (x != null) <!DEBUG_INFO_SMARTCAST!>x<!>.length else 0\n    }\n}\n"
        },
        {
            "code": "public class X {\n    public val x : String? = null\n    public fun fn(): Int {\n        if (x != null)\n            // Smartcast is possible because it's value property with default getter\n            // used in the same module\n            return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        else\n            return 0\n    }\n}\n\n"
        },
        {
            "code": "public interface A {\n    public val x: Any\n}\n\npublic class B(override public val x: Any) : A {\n    fun foo(): Int {\n        if (x is String) {\n            return <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        } else {\n            return 0\n        }\n    }\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage a\n\npublic class X {\n    public val x : String? = null\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\npackage b\n\nimport a.X\n\npublic fun X.gav(): Int {\n    if (x != null)\n        // Smart cast is not possible if definition is in another module\n        return <!SMARTCAST_IMPOSSIBLE!>x<!>.length\n    else\n        return 0\n}\n\n// FILE: c.kt\n\npackage a\n\npublic fun X.gav(): Int {\n    if (x != null)\n        // Even if it's in the same package\n        return <!SMARTCAST_IMPOSSIBLE!>x<!>.length\n    else\n        return 0\n}\n"
        },
        {
            "code": "public open class A() {\n    public open val foo: Int? = 1\n}\n\ninfix fun Int.bar(i: Int) = i\n\nfun test() {\n    val p = A()\n    // For open value properties, smart casts should not work\n    if (p.foo is Int) <!SMARTCAST_IMPOSSIBLE!>p.foo<!> bar 11\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String? {\n        return null\n    }\n}\n\nclass Example {\n    private val p: String? by Delegate()\n\n    public val r: String? = \"xyz\"\n\n    public fun foo(): String {\n        // Smart cast is not possible if property is delegated\n        return <!NI;TYPE_MISMATCH!>if (p != null) <!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>p<!> else \"\"<!>\n    }\n\n    public fun bar(): String {\n        // But is possible for non-delegated value property even if it's public\n        return if (r != null) <!DEBUG_INFO_SMARTCAST!>r<!> else \"\"\n    }\n}\n"
        },
        {
            "code": "public class X {\n    private val x : String? = null\n    public val y: CharSequence?\n        get() = x?.subSequence(0, 1)\n    public fun fn(): Int {\n        if (y != null)\n            // With non-default getter smartcast is not possible\n            return <!SMARTCAST_IMPOSSIBLE!>y<!>.length\n        else\n            return 0\n    }\n}\n\n"
        },
        {
            "code": "// Smart casts on complex expressions\nfun baz(s: String?): Int {\n    if (s == null) return 0\n    return when(<!DEBUG_INFO_SMARTCAST!>s<!>) {\n        \"abc\" -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> \"xyz\"\n    }.length\n}\n\nvar ss: String? = null\n\nfun bar(): Int {\n    if (ss == null) return 0\n    // ss cannot be smart casted, so an error here\n    return when(ss) {\n        \"abc\" -> ss\n        else -> \"xyz\"\n    }<!UNSAFE_CALL!>.<!>length\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\noperator fun <K, V> MutableMap<K, V>.set(<!UNUSED_PARAMETER!>k<!>: K, <!UNUSED_PARAMETER!>v<!>: V) {}\n\nfun foo(a: MutableMap<String, String>, x: String?) {\n    a[x!!] = <!DEBUG_INFO_SMARTCAST!>x<!>\n    a[<!DEBUG_INFO_SMARTCAST!>x<!>] = x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n}\n\nfun foo1(a: MutableMap<String, String>, x: String?) {\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>a[<!NI;TYPE_MISMATCH!>x<!>]<!> = x!!\n    a[x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>] = <!DEBUG_INFO_SMARTCAST!>x<!>\n}"
        },
        {
            "code": "fun baz(s: String?): String {\n    if (s == null) return \"\"\n    // if explicit type String is given for t, problem disappears\n    val t = when(<!DEBUG_INFO_SMARTCAST!>s<!>) {\n        // !! is detected as unnecessary here\n        \"abc\" -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> \"xyz\"\n    }\n    return t\n}\n\nfun foo(s: String?): String {\n    val t = when {\n        s != null -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> \"\"\n    }\n    return t\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n// See KT-9143: smart cast on a variable nulled inside a lambda argument\ninline fun <T> foo(t1: T, t2: T) = t1 ?: t2\n\ninline fun <T> bar(<!UNUSED_PARAMETER!>l<!>: (T) -> Unit): T = null!!\n\nfun use() {\n    var x: Int?\n    x = 5\n    // Write to x is AFTER\n    <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n    // No smart cast should be here!\n    foo(bar { x = null }, <!SMARTCAST_IMPOSSIBLE!>x<!>.hashCode())\n}\n"
        },
        {
            "code": "class My(val z: Int) {\n    var x: Int = 0\n    constructor(arg: Int?): this(arg ?: 42) {\n        var y: Int?\n        y = arg\n        if (y != null) {\n            x = <!DEBUG_INFO_SMARTCAST!>y<!>\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -SafeCallBoundSmartCasts\n\nfun foo(arg: Int?) {\n    val x = arg\n    if (x != null) {\n        arg<!UNSAFE_CALL!>.<!>hashCode()\n    }\n    val y: Any? = arg\n    if (y != null) {\n        arg<!UNSAFE_CALL!>.<!>hashCode()\n    }\n    val yy: Any?\n    yy = arg\n    if (yy != null) {\n        arg<!UNSAFE_CALL!>.<!>hashCode()\n    }\n    var z = arg\n    z = z?.let { 42 }\n    if (z != null) {\n        arg<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n\nfun kt6840_1(s: String?) {\n    val hash = s?.hashCode()\n    if (hash != null) {\n        s<!UNSAFE_CALL!>.<!>length\n    }\n}\n\nfun kt6840_2(s: String?) {\n    if (s?.hashCode() != null) {\n        s<!UNSAFE_CALL!>.<!>length\n    }\n}\n\nfun kt1635(s: String?) {\n    s?.hashCode()!!\n    s<!UNSAFE_CALL!>.<!>hashCode()\n}\n\nfun kt2127() {\n    val s: String? = \"\"\n    if (s?.length != null) {\n        s<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}\n\nfun kt3356(s: String?): Int {\n    if (s?.length != 1) return 0\n    return s<!UNSAFE_CALL!>.<!>length\n}\n"
        },
        {
            "code": "package foo\n\nfun dispatch(request: Request) {\n    val <!UNUSED_VARIABLE!>url<!> = request.getRequestURI() as String\n\n    if (request.getMethod()?.length != 0) {\n    }\n}\n\ninterface Request {\n    fun getRequestURI(): String?\n    fun getMethod(): String?\n}\n"
        },
        {
            "code": "// !LANGUAGE: +BooleanElvisBoundSmartCasts\n\ninterface Order {\n    val expired: Boolean?\n\n    fun notExpired(): Boolean\n\n    fun doSomething()\n}\n\nfun foo(o: Any) {\n    val order = o as? Order\n    if (order?.expired ?: false) {\n        <!DEBUG_INFO_SMARTCAST!>order<!>.doSomething()\n    }\n    else {\n\n    }\n    if (order?.notExpired() ?: false) {\n        <!DEBUG_INFO_SMARTCAST!>order<!>.doSomething()\n    }\n}\n\nfun bar(o: Any) {\n    val order = o as? Order\n    if (order?.expired ?: true) {\n\n    }\n    else {\n        order<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.doSomething()\n    }\n    if (order?.notExpired() ?: true) {\n\n    }\n    else {\n        order<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.doSomething()\n    }\n}\n\nfun baz(o: Boolean?) {\n    if (o ?: false) {\n        <!DEBUG_INFO_SMARTCAST!>o<!>.hashCode()\n    }\n    if (o ?: true) {\n\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>o<!>.hashCode()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +BooleanElvisBoundSmartCasts\n// See KT-20752\n\nclass Unstable {\n    val first: String? get() = null\n}\n\nclass StringList {\n    fun remove(s: String) = s\n}\n\nfun StringList.remove(s: String?) = s ?: \"\"\n\nfun String.isEmpty() = this == \"\"\n\nfun foo(list: StringList, arg: Unstable) {\n    list.remove(arg.first)\n    if (arg.first?.isEmpty() ?: false) {\n        // Should be still resolved to extension, without smart cast or smart cast impossible\n        list.remove(<!OI;SMARTCAST_IMPOSSIBLE!>arg.first<!>)\n    }\n}\n\nclass UnstableBoolean {\n    val first: Boolean? get() = null\n}\n\nclass BooleanList {\n    fun remove(b: Boolean) = b\n}\n\nfun BooleanList.remove(b: Boolean?) = b ?: false\n\nfun bar(list: BooleanList, arg: UnstableBoolean) {\n    list.remove(arg.first)\n    if (arg.first ?: false) {\n        // Should be still resolved to extension, without smart cast or smart cast impossible\n        list.remove(<!OI;SMARTCAST_IMPOSSIBLE!>arg.first<!>)\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -BooleanElvisBoundSmartCasts\n\ninterface Order {\n    val expired: Boolean?\n\n    fun notExpired(): Boolean\n\n    fun doSomething()\n}\n\nfun foo(o: Any) {\n    val order = o as? Order\n    if (order?.expired ?: false) {\n        order<!UNSAFE_CALL!>.<!>doSomething()\n    }\n    else {\n\n    }\n    if (order?.notExpired() ?: false) {\n        order<!UNSAFE_CALL!>.<!>doSomething()\n    }\n}\n\nfun bar(o: Any) {\n    val order = o as? Order\n    if (order?.expired ?: true) {\n\n    }\n    else {\n        order!!.doSomething()\n    }\n    if (order?.notExpired() ?: true) {\n\n    }\n    else {\n        order!!.doSomething()\n    }\n}\n\nfun baz(o: Boolean?) {\n    if (o ?: false) {\n        o<!UNSAFE_CALL!>.<!>hashCode()\n    }\n    if (o ?: true) {\n\n    }\n    else {\n        o<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}"
        },
        {
            "code": "package foo\n\nclass A(val i: Int?) {\n    fun test1() {\n        if (this@A.i != null) {\n            useInt(<!DEBUG_INFO_SMARTCAST!>this.i<!>)\n            useInt(<!DEBUG_INFO_SMARTCAST!>i<!>)\n        }\n    }\n\n    inner class B {\n        fun test2() {\n            if (i != null) {\n                useInt(<!DEBUG_INFO_SMARTCAST!>this@A.i<!>)\n            }\n        }\n    }\n}\n\nfun A.foo() {\n    if (this@foo.i != null) {\n        useInt(<!DEBUG_INFO_SMARTCAST!>this.i<!>)\n        useInt(<!DEBUG_INFO_SMARTCAST!>i<!>)\n    }\n}\n\nfun test3() {\n    useFunction {\n        if(i != null) {\n            useInt(<!DEBUG_INFO_SMARTCAST!>this.i<!>)\n        }\n    }\n}\n\nfun useInt(i: Int) = i\nfun useFunction(f: A.() -> Unit) = f"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass My {\n    constructor(arg: Int?) {\n        run {\n            var x = arg\n            if (x == null) return@run\n            <!DEBUG_INFO_SMARTCAST!>x<!>.hashCode()\n        }   \n    }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun test() : Unit {\n  var x : Int? = 0\n  var y : Int = 0\n\n  checkSubtype<Int?>(x)\n  checkSubtype<Int>(y)\n  checkSubtype<Int>(x as Int)\n  checkSubtype<Int>(y <!USELESS_CAST!>as Int<!>)\n  checkSubtype<Int?>(x as Int?)\n  checkSubtype<Int?>(y as Int?)\n  checkSubtype<Int?>(x as? Int)\n  checkSubtype<Int?>(y as? Int)\n  checkSubtype<Int?>(x as? Int?)\n  checkSubtype<Int?>(y as? Int?)\n\n  val <!UNUSED_VARIABLE!>s<!> = \"\" as Any\n  (\"\" as String?)?.length\n  (<!REDUNDANT_LABEL_WARNING!>data@<!>(\"\" as String?))?.length\n  (<!WRONG_ANNOTATION_TARGET!>@MustBeDocumented()<!>( \"\" as String?))?.length\n  Unit\n}\n"
        },
        {
            "code": "fun ff(): Int {\n    var i = 1\n    <!UNUSED_LAMBDA_EXPRESSION!>{\n        val <!NAME_SHADOWING, UNUSED_VARIABLE!>i<!> = 2\n    }<!>\n    return i\n}"
        },
        {
            "code": "class A {\n    operator fun component1() = 42\n    operator fun component2() = 42\n}\n\nfun foo(a: A, c: Int) {\n    val (<!NAME_SHADOWING!>a<!>, b) = a\n    val arr = Array(2) { A() }\n    for ((<!NAME_SHADOWING, UNUSED_VARIABLE!>c<!>, <!UNUSED_VARIABLE!>d<!>) in arr)  {\n\n    }\n\n    val <!UNUSED_VARIABLE!>e<!> = a.toString() + b + c\n}\n"
        },
        {
            "code": "fun ff(): Int {\n    var i = 1\n    <!UNUSED_LAMBDA_EXPRESSION!>{ <!NAME_SHADOWING!>i<!>: Int -> i }<!>\n    return i\n}\n"
        },
        {
            "code": "fun ff(): Int {\n    var i = 1\n    for (<!NAME_SHADOWING!>i<!> in 0..10) {\n    }\n    return i\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo1(i: (Int) -> Unit) {}\nfun foo2(i: (Int, Int) -> Unit) {}\nfun foo3(i: (Pair) -> Unit) {}\n\nfun bar(x: Int, y: Int) {\n    foo1 { <!NAME_SHADOWING!>x<!> -> <!UNUSED_EXPRESSION!>x<!> }\n    foo2 { <!NAME_SHADOWING!>x<!>: Int, <!NAME_SHADOWING!>y<!>: Int -> x + y }\n    foo3 { (x, y) -> x + y }\n}\n\ndata class Pair(val a: Int, val b: Int)"
        },
        {
            "code": "fun f(<!UNUSED_PARAMETER!>i<!>: Int) {\n    for (j in 1..100) {\n        <!UNUSED_LAMBDA_EXPRESSION!>{\n            var <!NAME_SHADOWING, UNUSED_VARIABLE!>i<!> = 12\n        }<!>\n    }\n}"
        },
        {
            "code": "fun f(<!UNUSED_PARAMETER!>p<!>: Int): Int {\n    val <!NAME_SHADOWING!>p<!> = 2\n    return p\n}\n"
        },
        {
            "code": "fun f(): Int {\n    var i = 17\n    <!UNUSED_LAMBDA_EXPRESSION!>{ var <!NAME_SHADOWING, UNUSED_VARIABLE!>i<!> = 18 }<!>\n    return i\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ArrayLiteralsInAnnotations\n\nimport kotlin.reflect.KClass\n\nannotation class Foo(val a: Array<KClass<*>> = [])\n\nclass Gen<T>\n\nannotation class Bar(val a: Array<KClass<*>> = [Int::class, Array<Int>::class, Gen::class])\n\n@Foo([])\nfun test1() {}\n\n@Foo([Int::class, String::class])\nfun test2() {}\n\n@Foo([<!ARRAY_CLASS_LITERAL_REQUIRES_ARGUMENT!>Array::class<!>])\nfun test3() {}\n\n@Foo([<!CLASS_LITERAL_LHS_NOT_A_CLASS!>Gen<Int>::class<!>])\nfun test4() {}\n\n@Foo(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[\"\"]<!>)\nfun test5() {}\n\n@Foo(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[Int::class, 1]<!>)\nfun test6() {}\n\n@Bar\nfun test7() {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test(): Array<Int> {\n    <!UNSUPPORTED!>[1, 2]<!>\n    <!UNSUPPORTED!>[1, 2]<!>[0]\n    <!UNSUPPORTED!>[1, 2]<!>.get(0)\n\n    foo(<!UNSUPPORTED!>[\"\"]<!>)\n\n    val <!UNUSED_VARIABLE!>p<!> = <!UNSUPPORTED!>[1, 2]<!> <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>+<!> <!OI;UNSUPPORTED!>[3, 4]<!>\n\n    return <!UNSUPPORTED!>[1, 2]<!>\n}\n\nfun foo(<!UNUSED_PARAMETER!>a<!>: Array<String> = <!UNSUPPORTED!>[\"\"]<!>) {}\n\nclass A(val a: Array<Int> = <!UNSUPPORTED!>[]<!>)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ArrayLiteralsInAnnotations\n\nannotation class Foo(\n        val a: Array<String> = [\"/\"],\n        val b: Array<String> = [],\n        val c: Array<String> = [\"1\", \"2\"]\n)\n\nannotation class Bar(\n        val a: Array<String> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[' ']<!>,\n        val b: Array<String> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[\"\", <!EMPTY_CHARACTER_LITERAL!>''<!>]<!>,\n        val c: Array<String> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[1]<!>\n)\n\nannotation class Base(\n        val a0: IntArray = [],\n        val a1: IntArray = [1],\n        val b1: FloatArray = [1f],\n        val b0: FloatArray = []\n)\n\nannotation class Err(\n        val a: IntArray = [<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1L<!>],\n        val b: Array<String> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[1]<!>\n)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNSUPPORTED\n\nfun basicTypes() {\n    val a: IntArray = [1]\n    val b: ByteArray = [1]\n    val c: BooleanArray = [true, false]\n    val d: CharArray = ['a']\n    val e: ShortArray = [1]\n    val f: FloatArray = [1.0f]\n    val g: LongArray = [1]\n    val h: DoubleArray = [1.0]\n}\n\nfun basicTypesWithErrors() {\n    val a: IntArray = [<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>]\n    val b: ShortArray = [<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>]\n    val c: CharArray = [<!TYPE_MISMATCH!>\"a\"<!>]\n}"
        },
        {
            "code": "// !LANGUAGE: -ArrayLiteralsInAnnotations\nannotation class Foo(\n        val a: IntArray = <!UNSUPPORTED_FEATURE!>[]<!>,\n        val b: FloatArray = <!UNSUPPORTED_FEATURE!>[1f, 2f]<!>,\n        val c: Array<String> = <!UNSUPPORTED_FEATURE!>[\"/\"]<!>\n)\n\n@Foo\nfun test1() {}\n\n@Foo(a = <!UNSUPPORTED_FEATURE!>[1, 2]<!>, c = <!UNSUPPORTED_FEATURE!>[\"a\"]<!>)\nfun test2() {}\n\n@Foo(<!UNSUPPORTED_FEATURE!>[1]<!>, <!UNSUPPORTED_FEATURE!>[3f]<!>, <!UNSUPPORTED_FEATURE!>[\"a\"]<!>)\nfun test3() {}\n\nfun test4() {\n    <!UNSUPPORTED!>[1, 2]<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ArrayLiteralsInAnnotations, +ProhibitAssigningSingleElementsToVarargsInNamedForm\n\nannotation class Ann1(vararg val a: String = [])\nannotation class Ann2(vararg val a: Int = [1, 2])\nannotation class Ann3(vararg val a: Float = [1f])\nannotation class Ann4(vararg val a: String = [\"/\"])\n\nannotation class Ann5(vararg val a: Ann4 = [])\nannotation class Ann6(vararg val a: Ann4 = [Ann4(*[\"a\", \"b\"])])\n\nannotation class Ann7(vararg val a: Long = [1L, <!NULL_FOR_NONNULL_TYPE!>null<!>, <!TYPE_MISMATCH!>\"\"<!>])\n\n@Ann1(*[])\nfun test1_0() {}\n\n@Ann1(*[\"a\", \"b\"])\nfun test1_1() {}\n\n@Ann1(*<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[\"a\", 1, <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>null<!>]<!>)\nfun test1_2() {}\n\n@Ann2(*[])\nfun test2() {}\n\n@Ann3(a = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>[0f, <!DIVISION_BY_ZERO!>1 / 0f<!>]<!>)\nfun test3() {}\n\n@Ann5(Ann4(*[\"/\"]))\nfun test5() {}\n\n@Ann6(*[])\nfun test6() {}\n\nannotation class AnnArray(val a: Array<String>)\n\n@AnnArray(<!OI;NON_VARARG_SPREAD!>*<!>[\"/\"])\nfun testArray() {}\n\n@Ann1(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH, TYPE_MISMATCH!>[\"\"]<!>)\nfun testVararg() {}"
        },
        {
            "code": "// !LANGUAGE: +ArrayLiteralsInAnnotations\n\nconst val ONE = 1\n\nannotation class Foo(\n        val a: IntArray = [ONE],\n        val b: IntArray = [ONE, 2, 3]\n)\n\nval TWO = 2\n\nfun getOne() = ONE\nfun getTwo() = TWO\n\nannotation class Bar(\n        val a: IntArray = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>[TWO]<!>,\n        val b: IntArray = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>[1, TWO]<!>,\n        val c: IntArray = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>[getOne(), getTwo()]<!>\n)\n\nannotation class Baz(\n        val a: IntArray = [<!NULL_FOR_NONNULL_TYPE!>null<!>],\n        val b: IntArray = [1, <!NULL_FOR_NONNULL_TYPE!>null<!>, 2],\n        val c: IntArray = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>[<!NO_THIS!>this<!>]<!>\n)\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNSUPPORTED\n\nfun test() {\n    val a = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>[]<!>\n    val b: Array<Int> = []\n    val c = [1, 2]\n    val d: Array<Int> = [1, 2]\n    val e: Array<String> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[1]<!>\n\n    val f: IntArray = [1, 2]\n    val g = [f]\n}\n\nfun check() {\n    [1, 2] checkType { _<Array<Int>>() }\n    [\"\"] checkType { _<Array<String>>() }\n\n    val f: IntArray = [1]\n    [f] checkType { _<Array<IntArray>>() }\n\n    [1, \"\"] checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Array<Any>>() }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ArrayLiteralsInAnnotations\n\nannotation class Foo(val a: IntArray, val b: Array<String>, val c: FloatArray)\n\n@Foo([1], [\"/\"], [1f])\nfun test1() {}\n\n@Foo([], [], [])\nfun test2() {}\n\n@Foo([<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1f<!>], <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>[' ']<!>, [<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>])\nfun test3() {}\n\n@Foo(c = [1f], b = [\"\"], a = [1])\nfun test4() {}\n\n@Foo([1 + 2], [\"Hello, \" + \"Kotlin\"], [<!DIVISION_BY_ZERO!>1 / 0f<!>])\nfun test5() {}\n\nconst val ONE = 1\nval two = 2\n\n@Foo([ONE], [], [])\nfun test6() {}\n\n@Foo(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>[<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>ONE + two<!>]<!>, [], [])\nfun test7() {}\n\n@Foo(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>[<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>two<!>]<!>, [], [])\nfun test8() {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(<!UNUSED_PARAMETER!>f<!>: String.() -> Int) {}\nval test = foo(<!OI;TYPE_MISMATCH!>fun () = <!UNRESOLVED_REFERENCE!>length<!><!>)"
        },
        {
            "code": "val foo = fun(a: Int): String {\n    if (a == 1) return \"4\"\n    when (a) {\n        5 -> return \"2\"\n        3 -> return <!NULL_FOR_NONNULL_TYPE!>null<!>\n        2 -> return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>\n    }\n    return \"\"\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\nfun <T> listOf(): List<T> = null!!\n\nfun test(a: (Int) -> Int) {\n    test(fun (x) = 4)\n\n    test(fun (x) = x)\n\n    test(fun (x): Int { checkSubtype<Int>(x); return 4 })\n}\n\nfun test2(a: () -> List<Int>) {\n    test2(fun () = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>listOf<!>())\n}\n\nval a: (Int) -> Unit = fun(x) { checkSubtype<Int>(x) }\n\nval b: (Int) -> Unit = <!OI;TYPE_MISMATCH!>fun(<!EXPECTED_PARAMETER_TYPE_MISMATCH!>x: String<!>) {}<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun test() {\n    fun bar() {\n        val bas = fun() {\n            <!RETURN_NOT_ALLOWED!>return@bar<!>\n        }\n    }\n\n    val bar = fun() {\n        <!RETURN_NOT_ALLOWED!>return@test<!>\n    }\n}\n\nfun foo() {\n    val bal = bag@ fun () {\n        val bar = fun() {\n            <!RETURN_NOT_ALLOWED!>return@bag<!>\n        }\n        return@bag\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n\nfun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> = null!!\n\nfun autolabel(l: List<Int>) = l.map (fun (i: Int): Int {\n    return@map 4\n})\n\nfun unresolvedMapLabel(l: List<Int>) = l.map (l@ fun(i: Int): Int {\n    return<!UNRESOLVED_REFERENCE!>@map<!> 4\n})\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninterface B {\n    fun b_fun() {}\n}\n\nfun test(param: String) {\n\n    val local_val = 4\n    val bar = fun B.(fun_param: Int) {\n        param.length\n        b_fun()\n        val inner_bar = local_val + fun_param\n\n        <!UNRESOLVED_REFERENCE!>bar<!>\n    }\n\n    <!UNRESOLVED_REFERENCE!>inner_bar<!>\n    <!UNRESOLVED_REFERENCE!>fun_param<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n\nfun testReturnType(foo: String) {\n    val bar = fun () = foo\n\n    bar.checkType { _<() -> String>() }\n\n    val bas: () -> String = fun () = foo\n\n    val bag: () -> Int = <!OI;TYPE_MISMATCH!>fun () = foo<!>\n}\n\nfun testParamType() {\n    val bar = fun (bal: String){}\n\n    bar.checkType { _<(String) -> Unit>() }\n\n    val bas: (String) -> Unit = fun (param: String) {}\n    val bag: (Int) -> Unit = <!OI;TYPE_MISMATCH!>fun (<!EXPECTED_PARAMETER_TYPE_MISMATCH!>param: String<!>) {}<!>\n}\n\nfun testReceiverType() {\n    val bar = fun String.() {}\n\n    bar.checkType { _<String.() -> Unit>() }\n\n    val bas: String.() -> Unit = fun String.() {}\n\n    val bag: Int.() -> Unit = <!OI;TYPE_MISMATCH!>fun String.() {}<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER\n\ninterface A\nfun devNull(a: Any?){}\n\nval generic_fun = fun<!TYPE_PARAMETERS_NOT_ALLOWED!><T><!>(t: T): T = null!!\nval extension_generic_fun = fun<!TYPE_PARAMETERS_NOT_ALLOWED!><T><!>T.(t: T): T = null!!\n\nfun fun_with_where() = fun <!TYPE_PARAMETERS_NOT_ALLOWED!><T><!> T.(t: T): T where T: A = null!!\n\n\nfun outer() {\n    devNull(fun <!TYPE_PARAMETERS_NOT_ALLOWED!><T><!>() {})\n    devNull(fun <!TYPE_PARAMETERS_NOT_ALLOWED!><T><!> <!NI;UNRESOLVED_REFERENCE!>T<!>.() {})\n    devNull(fun <!TYPE_PARAMETERS_NOT_ALLOWED!><T><!> (): <!NI;UNRESOLVED_REFERENCE!>T<!> = null!!)\n    devNull(fun <!TYPE_PARAMETERS_NOT_ALLOWED!><T><!> (t: <!NI;UNRESOLVED_REFERENCE!>T<!>) {})\n    devNull(fun <!TYPE_PARAMETERS_NOT_ALLOWED!><T><!> () where T:A {})\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n\nval bar = fun(p: Int = <!ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE!>3<!>) {}\nval bas = fun(<!USELESS_VARARG_ON_PARAMETER!>vararg p: Int<!>) {}\n\nfun gar() = fun(p: Int = <!ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE!>3<!>) {}\nfun gas() = fun(<!USELESS_VARARG_ON_PARAMETER!>vararg p: Int<!>) {}\n\nfun outer(b: Any?) {\n    val bar = fun(p: Int = <!ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE!>3<!>) {}\n    val bas = fun(<!USELESS_VARARG_ON_PARAMETER!>vararg p: Int<!>) {}\n\n    fun gar() = fun(p: Int = <!ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE!>3<!>) {}\n    fun gas() = fun(<!USELESS_VARARG_ON_PARAMETER!>vararg p: Int<!>) {}\n\n    outer(fun(p: Int = <!ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE!>3<!>) {})\n    outer(fun(<!USELESS_VARARG_ON_PARAMETER!>vararg p: Int<!>) {})\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nannotation class ann\nval bas = <!NON_MEMBER_FUNCTION_NO_BODY!>fun ()<!>\n\nfun bar(a: Any) = <!NON_MEMBER_FUNCTION_NO_BODY!>fun ()<!>\n\nfun outer() {\n    bar(<!NON_MEMBER_FUNCTION_NO_BODY!>fun ()<!>)\n    bar(l@ <!NON_MEMBER_FUNCTION_NO_BODY!>fun ()<!>)\n    bar(<!NON_MEMBER_FUNCTION_NO_BODY!>@ann fun ()<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n\nval a = fun (<!CANNOT_INFER_PARAMETER_TYPE!>x<!>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\n\nval b: (Int) -> Int = fun (x) = x + 3\n\nval c: (Int, String) -> Int = <!OI;TYPE_MISMATCH!>fun <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>(x)<!> = 3<!>\n\nval d: (Int, String) -> Int = <!OI;TYPE_MISMATCH!>fun <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>(x)<!> = 3<!>\n\nval e: (Int, String) -> Int = <!OI;TYPE_MISMATCH!>fun <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>(<!EXPECTED_PARAMETER_TYPE_MISMATCH!>x: String<!>)<!> = 3<!>\n\nval f: (Int) -> Int = <!OI;TYPE_MISMATCH!>fun (<!EXPECTED_PARAMETER_TYPE_MISMATCH!>x: String<!>) = 3<!>\n\nfun test1(a: (Int) -> Unit) {\n    test1(fun (x) { checkSubtype<Int>(x)})\n}\n\nfun test2(a: (Int) -> Unit) {\n    test2(<!TYPE_MISMATCH!>fun (<!EXPECTED_PARAMETER_TYPE_MISMATCH!>x: String<!>) {}<!>)\n}\n\nfun test3(a: (Int, String) -> Unit) {\n    test3(<!TYPE_MISMATCH!>fun <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>(<!EXPECTED_PARAMETER_TYPE_MISMATCH!>x: String<!>)<!> {}<!>)\n}"
        },
        {
            "code": "fun foo() {\n    class A\n    fun bar() {}\n    (fun <!ANONYMOUS_FUNCTION_WITH_NAME!>bar<!>() {})\n    fun A.foo() {}\n    (fun A.<!ANONYMOUS_FUNCTION_WITH_NAME!>foo<!>() {})\n\n    run(fun <!ANONYMOUS_FUNCTION_WITH_NAME!>foo<!>() {})\n}\n"
        },
        {
            "code": "// http://youtrack.jetbrains.net/issue/KT-451\n// KT-451 Incorrect character literals cause assertion failures\n\nfun ff() {\n    val <!UNUSED_VARIABLE!>b<!> = <!EMPTY_CHARACTER_LITERAL!>''<!>\n    val <!UNUSED_VARIABLE!>c<!> = <!TOO_MANY_CHARACTERS_IN_CHARACTER_LITERAL!>'23'<!>\n    val <!UNUSED_VARIABLE!>d<!> = <!INCORRECT_CHARACTER_LITERAL!>'a<!>\n    val <!UNUSED_VARIABLE!>e<!> = <!INCORRECT_CHARACTER_LITERAL!>'ab<!>\n    val <!UNUSED_VARIABLE!>f<!> = '<!ILLEGAL_ESCAPE!>\\<!>'\n}\n\nfun test() {\n    <!UNUSED_EXPRESSION!>'a'<!>\n    <!UNUSED_EXPRESSION!>'\\n'<!>\n    <!UNUSED_EXPRESSION!>'\\t'<!>\n    <!UNUSED_EXPRESSION!>'\\b'<!>\n    <!UNUSED_EXPRESSION!>'\\r'<!>\n    <!UNUSED_EXPRESSION!>'\\\"'<!>\n    <!UNUSED_EXPRESSION!>'\\''<!>\n    <!UNUSED_EXPRESSION!>'\\\\'<!>\n    <!UNUSED_EXPRESSION!>'\\$'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\x<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\123<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\ra<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\000<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\000<!>'<!>\n    <!UNUSED_EXPRESSION!>'\\u0000'<!>\n    <!UNUSED_EXPRESSION!>'\\u000a'<!>\n    <!UNUSED_EXPRESSION!>'\\u000A'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\u<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\u0<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\u00<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\u000<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\u000z<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\\\u000<!>'<!>\n    <!UNUSED_EXPRESSION!>'<!ILLEGAL_ESCAPE!>\\<!>'<!>\n}\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nopen class KotlinClass1 : JavaClass1() {\n    public fun getSomethingKotlin1(): Int = 1\n}\n\nclass KotlinClass2 : JavaClass2() {\n    public fun getSomethingKotlin2(): Int = 1\n}\n\nfun foo(k: KotlinClass2) {\n    useInt(k.getSomething1())\n    useInt(k.something1)\n    useInt(k.getSomething2())\n    useInt(k.something2)\n    useInt(k.getSomethingKotlin1())\n    useInt(k.getSomethingKotlin2())\n    k.<!UNRESOLVED_REFERENCE!>somethingKotlin1<!>\n    k.<!UNRESOLVED_REFERENCE!>somethingKotlin2<!>\n}\n\nfun useInt(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.<!UNRESOLVED_REFERENCE!>something<!> = 1\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    <!VAL_REASSIGNMENT!>javaClass.something1<!>++\n    <!VAL_REASSIGNMENT!>javaClass.something2<!>++\n    <!VAL_REASSIGNMENT!>javaClass.something3<!>++\n    <!VAL_REASSIGNMENT!>javaClass.something4<!>++\n    <!VAL_REASSIGNMENT!>javaClass.something5<!> = null\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.<!UNRESOLVED_REFERENCE!>something1<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>something2<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>somethingStatic<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>somethingVoid<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>ter<!>\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nabstract class KotlinClass : JavaInterface1, JavaInterface2 {\n    override fun getSomething(): String = \"\"\n}\n\nfun foo(k: KotlinClass) {\n    useString(k.getSomething())\n    useString(k.something)\n    if (<!SENSELESS_COMPARISON!>k.something == null<!>) return\n\n    k.setSomething(1)\n    <!VAL_REASSIGNMENT!>k.something<!> = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n}\n\nfun useString(<!UNUSED_PARAMETER!>i<!>: String) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.<!DEPRECATION!>something1<!>\n\n    javaClass.<!DEPRECATION!>something2<!>\n    javaClass.something2 = 1\n    javaClass.something2++\n\n    javaClass.something3\n    javaClass.<!DEPRECATION!>something3<!> = 1\n    javaClass.<!DEPRECATION!>something3<!>++\n\n    javaClass.<!DEPRECATION!>something4<!>\n    javaClass.<!DEPRECATION!>something4<!> = 1\n    javaClass.<!DEPRECATION!>something4<!>++\n\n    javaClass.<!DEPRECATION!>something5<!>\n    javaClass.<!DEPRECATION!>something5<!> = 1\n    javaClass.<!DEPRECATION!>something5<!>++\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nabstract class KotlinClass : JavaInterface3 {\n    override fun getSomething(): String = \"\"\n}\n\nfun foo(k: KotlinClass) {\n    useString(k.getSomething())\n    useString(k.something)\n    if (<!SENSELESS_COMPARISON!>k.something == null<!>) return\n\n    k.setSomething(\"\")\n    k.something = \"\"\n}\n\nfun useString(<!UNUSED_PARAMETER!>i<!>: String) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\n\nfun foo(o: JavaClass2) {\n    useString(o.something)\n    o.something = \"\"\n    o.setSomething(1)\n    o.something = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> // we generate extension property for JavaClass2 with more specific type\n    o.something += \"1\"\n}\n\nfun useString(<!UNUSED_PARAMETER!>i<!>: String) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun JavaClass.foo() {\n    useInt(getSomething())\n    useInt(something)\n}\n\nfun useInt(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\npackage k\n\nimport JavaClass\n\nfun foo(javaClass: JavaClass) {\n    javaClass.somethingPublic\n    javaClass.<!INVISIBLE_MEMBER!>somethingProtected<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>somethingPrivate<!>\n    javaClass.<!INVISIBLE_MEMBER!>somethingPackage<!>\n    <!INVISIBLE_SETTER!>javaClass.somethingPublic<!> = 1\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nabstract class KotlinClass : JavaInterface3 {\n    override fun getSomething(): String = \"\"\n}\n\nfun foo(k: KotlinClass) {\n    useString(k.getSomething())\n    useString(k.something)\n    if (<!SENSELESS_COMPARISON!>k.something == null<!>) return\n\n    k.setSomething(\"\")\n    k.something = \"\"\n}\n\nfun useString(<!UNUSED_PARAMETER!>i<!>: String) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nclass KotlinClass {\n    public fun getSomething(): Int = 1\n}\n\nfun foo(javaClass: JavaClass, kotlinClass: KotlinClass) {\n    useInt(javaClass.getSomething())\n    useInt(javaClass.something)\n    <!VAL_REASSIGNMENT!>javaClass.something<!> = 1\n    javaClass.<!UNRESOLVED_REFERENCE!>Something<!>\n    useInt(kotlinClass.getSomething())\n    kotlinClass.<!UNRESOLVED_REFERENCE!>something<!>\n}\n\nfun useInt(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass. = javaClass. + 1\n    javaClass.<!UNRESOLVED_REFERENCE!><!>\n\n    javaClass.\n    javaClass.<!UNRESOLVED_REFERENCE!><!>\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nabstract class KotlinClass : JavaInterface1, JavaInterface2 {\n    override fun getSomething(): String = \"\"\n}\n\nfun foo(k: KotlinClass) {\n    useString(k.getSomething())\n    useString(k.something)\n    if (<!SENSELESS_COMPARISON!>k.something == null<!>) return\n\n    k.setSomething(\"\")\n    k.something = \"\"\n}\n\nfun useString(<!UNUSED_PARAMETER!>i<!>: String) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\n\nfun bar() = JavaClass::<!UNSUPPORTED!>foo<!>\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.url = javaClass.url + \"/\"\n    javaClass.htmlFile += \"1\"\n\n    javaClass.<!UNRESOLVED_REFERENCE!>URL<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>uRL<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>HTMLFile<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>hTMLFile<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>htmlfile<!>\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nabstract class KotlinClass : JavaClass(), KotlinInterface, JavaInterface {\n    override fun getSomething1(): Int = 1\n    override fun getSomething3(): String = \"\"\n    override fun setSomething4(value: String) {}\n    override fun getSomething5(): String = \"\"\n}\n\ninterface KotlinInterface {\n    public fun getSomething1(): Int\n    public fun getSomething4(): String\n}\n\nfun foo(k: KotlinClass) {\n    useInt(k.getSomething1())\n    useInt(k.something1)\n\n    useInt(k.getSomething2())\n    useInt(k.something2)\n\n    useString(k.getSomething3())\n    useString(k.something3)\n\n    k.setSomething4(\"\")\n    k.something4 += \"\"\n    k.setSomething4(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    k.something4 = <!NULL_FOR_NONNULL_TYPE!>null<!>\n\n    useString(k.getSomething5())\n    useString(k.something5)\n    k.setSomething5(1)\n    k.something5 = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n}\n\nfun useInt(<!UNUSED_PARAMETER!>i<!>: Int) {}\nfun useString(<!UNUSED_PARAMETER!>i<!>: String) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.a\n    javaClass.<!UNRESOLVED_REFERENCE!>A<!>\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\npackage k\n\nimport JavaClass\n\nfun foo(javaClass: JavaClass) {\n    val <!UNUSED_VARIABLE!>v<!> = javaClass.<!INVISIBLE_MEMBER!>something<!>\n    javaClass.<!INVISIBLE_MEMBER!>something<!> = 1\n    javaClass.<!INVISIBLE_MEMBER!>something<!>++\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nopen class KotlinClass {\n    public open fun getSomething1(): Int = 1\n\n    public open fun setSomething2(value: Int) {}\n}\n\nfun foo(javaClass: JavaClass) {\n    useInt(javaClass.getSomething1())\n    useInt(javaClass.<!UNRESOLVED_REFERENCE!>something1<!>)\n\n    javaClass.setSomething2(javaClass.getSomething2() + 1)\n    javaClass.something2 = javaClass.something2 + 1\n}\n\nfun useInt(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.isSomething = !javaClass.isSomething\n    javaClass.isSomething2 = !javaClass.isSomething2\n\n    javaClass.<!UNRESOLVED_REFERENCE!>something<!>\n    javaClass.isSomethingWrong\n    javaClass.<!UNRESOLVED_REFERENCE!>somethingWrong<!>\n\n    javaClass.<!FUNCTION_CALL_EXPECTED!>issueFlag<!>\n    javaClass.<!UNRESOLVED_REFERENCE!>isSueFlag<!>\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.getSomething()<!UNSAFE_CALL!>.<!>length\n    javaClass.something<!UNSAFE_CALL!>.<!>length\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun Any.foo(): Int {\n    if (this is JavaClass) {\n        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>something<!>++\n        return <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>x<!>\n    }\n    return 0\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(o: JavaInterface2): Int {\n    if (o is JavaClass) {\n        <!DEBUG_INFO_SMARTCAST!>o<!>.something++\n        return <!DEBUG_INFO_SMARTCAST!>o<!>.x + o.something2\n    }\n    return 0\n}\n\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: 1.kt\nfun fn() {}\nfun x(a: A, r: Runnable) {\n    a.foo(::fn) checkType { _<Int>() }\n    a.foo {} checkType { _<Int>() }\n\n    a.foo(null) checkType { _<Int>() }\n    a.foo(Runnable { }) checkType { _<Int>() }\n    a.foo(r) checkType { _<Int>() }\n\n    a.foo(123) checkType { _<String>() }\n    a.foo(\"\") checkType { _<String>() }\n\n    a.bar(::fn) checkType { _<Int>() }\n    a.bar {} checkType { _<Int>() }\n\n    a.bar(r) checkType { _<Int>() }\n\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>(null)\n\n    a.bar(null as Runnable?) checkType { _<Int>() }\n    a.bar(null as CharSequence?) checkType { _<String>() }\n\n    a.bar(\"\") checkType { _<String>() }\n    a.<!NONE_APPLICABLE!>bar<!>(123)\n}\n"
        },
        {
            "code": "// !LANGUAGE: -RefinedSamAdaptersPriority -NewInference\n// !CHECK_TYPE\n// FILE: 1.kt\nfun fn() {}\nfun x(r: Runnable) {\n    A.foo(::fn) checkType { _<String>() }\n    A.foo {} checkType { _<String>() }\n\n    A.foo(null) checkType { _<Int>() }\n    A.foo(Runnable { }) checkType { _<Int>() }\n    A.foo(r) checkType { _<Int>() }\n\n    A.foo(123) checkType { _<String>() }\n    A.foo(\"\") checkType { _<String>() }\n\n    A.bar(::fn) checkType { _<Int>() }\n    A.bar {} checkType { _<Int>() }\n\n    A.bar(r) checkType { _<Int>() }\n\n    A.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>(null)\n\n    A.bar(null as Runnable?) checkType { _<Int>() }\n    A.bar(null as CharSequence?) checkType { _<String>() }\n\n    A.bar(\"\") checkType { _<String>() }\n    A.<!NONE_APPLICABLE!>bar<!>(123)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.<!INVISIBLE_MEMBER!>doSomething<!> <!TYPE_MISMATCH!>{ }<!>\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\npublic interface I {\n    public fun doIt()\n}\n\nfun foo(javaClass: JavaClass) {\n    javaClass.<!DEPRECATION!>doSomething1<!> { bar() }\n    javaClass.<!DEPRECATION!>doSomething2<!> { bar() }\n}\n\nfun bar(){}\n\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass<String>): String {\n    return javaClass.doSomething(\"\", 1) { <!UNUSED_ANONYMOUS_PARAMETER!>s<!>: String -> \"\" }\n}\n\n"
        },
        {
            "code": "// FILE: KotlinFile1.kt\npackage k\n\nimport JavaClass\n\nfun foo(javaClass: JavaClass) {\n    javaClass.<!INVISIBLE_MEMBER!>doSomething<!> { }\n}\n\n// FILE: KotlinFile2.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.doSomething { }\n}\n\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: 1.kt\nfun fn() {}\nfun x(r: Runnable) {\n    A.foo(::fn) checkType { _<Int>() }\n    A.foo {} checkType { _<Int>() }\n\n    A.foo(null) checkType { _<Int>() }\n    A.foo(Runnable { }) checkType { _<Int>() }\n    A.foo(r) checkType { _<Int>() }\n\n    A.foo(123) checkType { _<String>() }\n    A.foo(\"\") checkType { _<String>() }\n\n    A.bar(::fn) checkType { _<Int>() }\n    A.bar {} checkType { _<Int>() }\n\n    A.bar(r) checkType { _<Int>() }\n\n    A.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>(null)\n\n    A.bar(null as Runnable?) checkType { _<Int>() }\n    A.bar(null as CharSequence?) checkType { _<String>() }\n\n    A.bar(\"\") checkType { _<String>() }\n    A.<!NONE_APPLICABLE!>bar<!>(123)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass) {\n    javaClass.doSomething(<!NAMED_ARGUMENTS_NOT_ALLOWED!>p<!> = 1) <!NI;TYPE_MISMATCH!>{\n        bar()\n    }<!>\n}\n\nfun bar(){}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nclass KotlinClass {\n    public fun doSomething(runnable: Runnable) { runnable.run() }\n}\n\npublic interface I {\n    public fun doIt()\n}\n\nfun foo(javaClass: JavaClass, kotlinClass: KotlinClass) {\n    javaClass.doSomething {\n        bar()\n    }\n\n    kotlinClass.doSomething <!TYPE_MISMATCH!>{\n        bar()\n    }<!>\n\n    javaClass.doSomething2 <!TYPE_MISMATCH!>{\n        bar()\n    }<!>\n}\n\nfun bar(){}\n\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\nfun foo(javaInterface: JavaInterface) {\n    val value = javaInterface.compute { \"\" }\n    value<!UNSAFE_CALL!>.<!>length\n}\n\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass<Int>) {\n    val <!UNUSED_VARIABLE!>a<!>: String = javaClass.doSomething1(\"\", 1) { p: String -> p }\n    val <!UNUSED_VARIABLE!>b<!>: String = javaClass.doSomething2(\"\", 1, true) { p: Int -> p }\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: KotlinFile.kt\nfun foo(javaClass: JavaClass<Int>): Int {\n    val inner = javaClass.createInner<String>()\n    return <!TYPE_MISMATCH!>inner.<!NI;TYPE_MISMATCH!>doSomething(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, \"\") <!TYPE_MISMATCH!>{ }<!><!><!>\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: -RefinedSamAdaptersPriority -NewInference\n// !CHECK_TYPE\n// FILE: 1.kt\nfun fn() {}\nfun x(a: A, r: Runnable) {\n    a.foo(::fn) checkType { _<String>() }\n    a.foo {} checkType { _<String>() }\n\n    a.foo(null) checkType { _<Int>() }\n    a.foo(Runnable { }) checkType { _<Int>() }\n    a.foo(r) checkType { _<Int>() }\n\n    a.foo(123) checkType { _<String>() }\n    a.foo(\"\") checkType { _<String>() }\n\n    a.bar(::fn) checkType { _<Int>() }\n    a.bar {} checkType { _<Int>() }\n\n    a.bar(r) checkType { _<Int>() }\n\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>(null)\n\n    a.bar(null as Runnable?) checkType { _<Int>() }\n    a.bar(null as CharSequence?) checkType { _<String>() }\n\n    a.bar(\"\") checkType { _<String>() }\n    a.<!NONE_APPLICABLE!>bar<!>(123)\n}\n"
        },
        {
            "code": "// FILE: KotlinFile.kt\npackage k\n\nimport JavaClass\n\nfun foo(javaClass: JavaClass) {\n    javaClass.<!INVISIBLE_MEMBER!>doSomething<!> {\n        bar()\n    }\n}\n\nclass X : JavaClass() {\n    fun foo(other: JavaClass) {\n        doSomething { bar() }\n        other.<!INVISIBLE_MEMBER!>doSomething<!> { bar() }\n    }\n}\n\nfun bar(){}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: KotlinFile.kt\nfun foo(javaInterface: JavaInterface) {\n    javaInterface.doIt(<!NULL_FOR_NONNULL_TYPE!>null<!>) { }\n    javaInterface.doIt(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun Int.gg() = null\n\nfun ff() {\n    val a: Int = 1\n    val <!UNUSED_VARIABLE!>b<!>: Int = <!TYPE_MISMATCH!>a<!UNNECESSARY_SAFE_CALL!>?.<!>gg()<!>\n}\n"
        },
        {
            "code": "// http://youtrack.jetbrains.net/issue/KT-413\n\nopen class A {\n    fun f() {}\n}\n\nclass B : A() {\n    fun g() {\n        super<!UNEXPECTED_SAFE_CALL!>?.<!>f()\n    }\n}"
        },
        {
            "code": "val z: Boolean = true\nval b: Byte = 0\nval s: Short = 0\nval i: Int = 0\nval j: Long = 0L\nval f: Float = 0.0f\nval d: Double = 0.0\nval c: Char = '0'\n\nval nz: Boolean? = true\nval nb: Byte? = 0\nval ns: Short? = 0\nval ni: Int? = 0\nval nj: Long? = 0L\nval nf: Float? = 0.0f\nval nd: Double? = 0.0\nval nc: Char? = '0'\n\nval n: Number = 0\nval nn: Number? = 0\nval a: Any = 0\nval na: Any? = 0\n\n// Identity for primitive values of same type\nval test_zz = <!DEPRECATED_IDENTITY_EQUALS!>z === z<!> || <!DEPRECATED_IDENTITY_EQUALS!>z !== z<!>\nval test_bb = <!DEPRECATED_IDENTITY_EQUALS!>b === b<!> || <!DEPRECATED_IDENTITY_EQUALS!>b !== b<!>\nval test_ss = <!DEPRECATED_IDENTITY_EQUALS!>s === s<!> || <!DEPRECATED_IDENTITY_EQUALS!>s !== s<!>\nval test_ii = <!DEPRECATED_IDENTITY_EQUALS!>i === i<!> || <!DEPRECATED_IDENTITY_EQUALS!>i !== i<!>\nval test_jj = <!DEPRECATED_IDENTITY_EQUALS!>j === j<!> || <!DEPRECATED_IDENTITY_EQUALS!>j !== j<!>\nval test_ff = <!DEPRECATED_IDENTITY_EQUALS!>f === f<!> || <!DEPRECATED_IDENTITY_EQUALS!>f !== f<!>\nval test_dd = <!DEPRECATED_IDENTITY_EQUALS!>d === d<!> || <!DEPRECATED_IDENTITY_EQUALS!>d !== d<!>\nval test_cc = <!DEPRECATED_IDENTITY_EQUALS!>c === c<!> || <!DEPRECATED_IDENTITY_EQUALS!>c !== c<!>\n\n// Identity for primitive values of different types (no extra error)\nval test_zb = <!EQUALITY_NOT_APPLICABLE!>z === b<!> || <!EQUALITY_NOT_APPLICABLE!>z !== b<!>\n\n// Primitive vs nullable\nval test_znz = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>z === nz<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nz === z<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>z !== nz<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nz !== z<!>\nval test_bnb = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b === nb<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nb === b<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b !== nb<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nb !== b<!>\nval test_sns = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s === ns<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>ns === s<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s !== ns<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>ns !== s<!>\nval test_ini = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i === ni<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>ni === i<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i !== ni<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>ni !== i<!>\nval test_jnj = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j === nj<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nj === j<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j !== nj<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nj !== j<!>\nval test_fnf = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f === nf<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nf === f<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f !== nf<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nf !== f<!>\nval test_dnd = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d === nd<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nd === d<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d !== nd<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nd !== d<!>\nval test_cnc = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>c === nc<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nc === c<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>c !== nc<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nc !== c<!>\n\n// Primitive number vs Number\nval test_bn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b === n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n === b<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b !== n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n !== b<!>\nval test_sn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s === n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n === s<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s !== n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n !== s<!>\nval test_in = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i === n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n === i<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i !== n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n !== i<!>\nval test_jn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j === n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n === j<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j !== n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n !== j<!>\nval test_fn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f === n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n === f<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f !== n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n !== f<!>\nval test_dn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d === n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n === d<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d !== n<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>n !== d<!>\n\n// Primitive number vs Number?\nval test_bnn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b === nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn === b<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b !== nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn !== b<!>\nval test_snn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s === nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn === s<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s !== nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn !== s<!>\nval test_inn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i === nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn === i<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i !== nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn !== i<!>\nval test_jnn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j === nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn === j<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j !== nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn !== j<!>\nval test_fnn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f === nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn === f<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f !== nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn !== f<!>\nval test_dnn = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d === nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn === d<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d !== nn<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>nn !== d<!>\n\n// Primitive vs Any\nval test_za = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>z === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === z<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>z !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== z<!>\nval test_ba = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === b<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== b<!>\nval test_sa = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === s<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== s<!>\nval test_ia = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === i<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== i<!>\nval test_ja = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === j<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== j<!>\nval test_fa = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === f<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== f<!>\nval test_da = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === d<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== d<!>\nval test_ca = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>c === a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a === c<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>c !== a<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a !== c<!>\n\n// Primitive vs Any?\nval test_zna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>z === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === z<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>z !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== z<!>\nval test_bna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === b<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>b !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== b<!>\nval test_sna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === s<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>s !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== s<!>\nval test_ina = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === i<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>i !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== i<!>\nval test_jna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === j<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>j !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== j<!>\nval test_fna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === f<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>f !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== f<!>\nval test_dna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === d<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>d !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== d<!>\nval test_cna = <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>c === na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na === c<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>c !== na<!> || <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>na !== c<!>"
        },
        {
            "code": "// !LANGUAGE: -SingleUnderscoreForParameterName\n\ndata class A(val x: Int, val y: Int)\n\nfun foo(a: Array<A>) {\n    val (<!UNSUPPORTED_FEATURE!>_<!>, y) = A(1, 2)\n    y.hashCode()\n\n    val q1: (Int, String) -> Unit = {\n        <!UNSUPPORTED_FEATURE!>_<!>, s -> s.hashCode()\n    }\n    q1(1, \"\")\n\n    val q2: (Int, String) -> Unit = fun(<!UNSUPPORTED_FEATURE!>_<!>: Int, s: String) {\n        s.hashCode()\n    }\n    q2(1, \"\")\n\n    val q3: (A) -> Unit = {\n        (<!UNSUPPORTED_FEATURE!>_<!>, y) -> y.hashCode()\n    }\n    q3(A(2, 3))\n\n    for ((<!UNSUPPORTED_FEATURE!>_<!>, z) in a) {\n        z.hashCode()\n    }\n}\n"
        },
        {
            "code": "object O {\n    // This is correct, foo is the same\n    tailrec fun foo(i: Int): Int = if (i < 0) 0 else O.foo(i - 1)\n}\n\nclass A {\n    <!NO_TAIL_CALLS_FOUND!>tailrec fun foo(i: Int)<!> = if (i < 0) 0 else A.foo(i - 1)\n\n    companion object {\n        fun foo(i: Int) = 42 + i\n    }\n}\n\nclass B {\n    <!NO_TAIL_CALLS_FOUND!>tailrec fun foo(i: Int)<!> = if (i < 0) 0 else O.foo(i - 1)\n}"
        },
        {
            "code": "package p\n\npublic fun foo(a: Any) {\n    a is Map<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>\n    a is <!NO_TYPE_ARGUMENTS_ON_RHS!>Map<!>\n    a is Map<out Any?, Any?>\n    a is Map<*, *>\n    a is Map<<!SYNTAX!><!>>\n    a is List<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Map<!>>\n    a is <!NO_TYPE_ARGUMENTS_ON_RHS!>List<!>\n    a is Int\n\n    (a as <!NO_TYPE_ARGUMENTS_ON_RHS!>Map<!>) is <!INCOMPATIBLE_TYPES!>Int<!>\n}"
        },
        {
            "code": "interface A\ninterface B : A\n\ninterface ListA : List<A>\ninterface ListB : List<B>\n\ninterface Z<<!INCONSISTENT_TYPE_PARAMETER_BOUNDS, INCONSISTENT_TYPE_PARAMETER_BOUNDS, INCONSISTENT_TYPE_PARAMETER_BOUNDS!>T<!>> where T : ListA, T : ListB\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: java/util/Collection.java\npackage java.util;\n\npublic class Collection {\n  public void foo() {}\n}\n\n// FILE: test/Usage.java\npackage test;\n\nimport java.util.*;\n\npublic class Usage {\n  void foo(Collection c) {\n    c.foo();\n  }\n}\n\n// FILE: Kotlin.kt\npackage test\n\nfun foo(u: Usage) {\n  u.foo(null)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <T> foo(t: T<!TYPE_ARGUMENTS_NOT_ALLOWED!><String, Int><!>) {}\n\ninterface A\nclass B<T: A>\nfun <T> foo1(t: T<!TYPE_ARGUMENTS_NOT_ALLOWED!><B<<!UPPER_BOUND_VIOLATED!>String<!>>><!>) {}"
        },
        {
            "code": "// FILE: p/Base.java\n\npackage p;\n\nimport java.util.*;\n\npublic class Base<T> {\n    void coll(Collection<?> r) {}\n}\n\n// FILE: k.kt\npackage p\n\nclass Derived: p.Base<String>()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: main.kt\nclass Inv<T>(val x: T)\n\nclass A<T : Inv<in T>> {\n    fun foo(): T = null!!\n}\n\nclass Inv2<<!FINITE_BOUNDS_VIOLATION!>T : Inv2<in T><!>>(val x: T)\n\nfun main(a: A<*>, j: JavaClass<*>, i2: Inv2<*>) {\n    // Probably it's too restrictive to suppose star projection type here as Any?,\n    // but looks like we can refine it later\n    a.foo() checkType { _<Any?>() }\n    j.foo() checkType { _<Any?>() }\n    i2.x checkType { _<Any?>() }\n\n    j.bar(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>, <!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>Any()<!>)\n    j.bar(null)\n}\n\n"
        },
        {
            "code": "// FILE: p/Base.java\n\npackage p;\n\npublic class Base<T> {\n    void foo(R<?> r) {}\n}\n\n// FILE: k.kt\npackage p\n\nclass R<T: R<T>>\n\nclass Derived: p.Base<String>()"
        },
        {
            "code": "class A\ninterface I0<T : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>>\ninterface I1<T> where T : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>\ninterface I2<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!><!>> where T : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>\n\nfun <E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>> foo0() {}\nfun <E> foo1() where E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!> {}\nfun <<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!><!>> foo2() where E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!> {}\n\nval <E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>> E.p1: Int\n        get() = 1\nval <E> E.p2: Int where E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>\n        get() = 1\nval <<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!><!>> E.p3: Int where E : A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>\n        get() = 1\n\n// See KT-8200\ninterface X\npublic class EnumAttribute<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T : X<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><T><!><!>>(val klass: Class<T>) where T : Enum<T>\n"
        },
        {
            "code": "class D<A : D<A, <!UPPER_BOUND_VIOLATED!>String<!>>, B : D<A, B>>\n"
        },
        {
            "code": "// JAVAC_SKIP\n// FILE: main.kt\nfun foo() {\n    JavaClass().foo(Any())\n    JavaClass().bar(<!TYPE_MISMATCH!>Any()<!>)\n    JavaClass().bar(\"\")\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\n\nclass Foo<T> {\n    class Bar<X> {\n        class Baz {\n\n        }\n    }\n}\n\nfun <T> a() {}\n\nfun test() {\n    Foo::class\n    Foo.Bar::class\n    Foo.Bar.Baz::class\n\n    a<Foo.Bar<String>>()\n    a<Foo.Bar.Baz>()\n\n    Foo<String>.<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Bar<!>::class\n    Foo<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><String><!>.Bar.Baz::class\n\n    a<Foo<String>.<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Bar<!>>()\n    a<Foo<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><String><!>.Bar.Baz>()\n\n    a<Foo.Bar<Int>>()\n    a<Foo.Bar<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><Int><!>.Baz>()\n}\n\nfun <T: Foo<String.<!UNRESOLVED_REFERENCE!>Bar<!>>> x() {}\nfun Foo<String>.<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Bar<!>.ext() {}\n\nfun ex1(<!UNUSED_PARAMETER!>a<!>: Foo<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><String><!>.Bar<String>): Foo<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><String><!>.Bar<String> {\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "interface I1\ninterface I2\nopen class C\n\ninterface A1<K, V> where V : K, V : <!REPEATED_BOUND!>K<!>\ninterface A2<K, V, W> where W : K, W : <!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER!>V<!>\ninterface A3<K, <!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER!>V<!>> where V : I1, V : K, V : I2\ninterface A4<<!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER!>K<!>, V> where K : I1, K : I2, K : C, K : V, V : I2, V : I1\n\nfun <K, V> f1() where V : K, V : <!REPEATED_BOUND!>K<!> {}\nfun <K, V, W> f2() where W : K, W : <!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER!>V<!> {\n    fun <T> f3() where T : K, T : <!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER!>V<!> {}\n    fun <T> f4() where T : K, T : <!REPEATED_BOUND!>K<!> {}\n}\nfun <K, V, <!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER!>W<!>> f3() where W : K, W : V, W : Any {}\n"
        },
        {
            "code": "// See KT-9438: Enforce the Single Instantiation Inheritance Rule for type parameters\n\ninterface A\n\ninterface B\n\ninterface D<T>\n\ninterface IncorrectF<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T : D<A><!>> where T : <!REPEATED_BOUND!>D<B><!>\n\ninterface CorrectF<T> where T : D<A>, T : <!REPEATED_BOUND!>D<B><!>\n\ninterface G<T>\n\ninterface IncorrectH<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T : G<D<A>><!>> where T : <!REPEATED_BOUND!>G<D<T>><!>\n\ninterface CorrectH<T> where T : G<D<A>>, T : <!REPEATED_BOUND!>G<D<B>><!>\n\ninterface incorrectJ<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T: G<D<T>><!>> where T : <!REPEATED_BOUND!>G<D<T?>><!>\n\ninterface correctJ<T> where T : G<D<T>>, T : <!REPEATED_BOUND!>G<D<T?>><!>\n\nfun <T> bar() where T : D<A>, T : <!REPEATED_BOUND!>D<B><!> {}\n"
        },
        {
            "code": "open class SuperOuter<E> {\n    inner open class SuperInner<F>\n}\n\nclass DerivedOuter<G> : SuperOuter<G>() {\n    inner class DerivedInner<H> : SuperOuter<G>.SuperInner<H>()\n}\n\nfun bare(x: SuperOuter<*>.SuperInner<*>, y: Any?) {\n    if (<!USELESS_IS_CHECK!>x is SuperOuter.SuperInner<!>) return\n    if (y is <!NO_TYPE_ARGUMENTS_ON_RHS!>SuperOuter.SuperInner<!>) {\n        return\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n\nclass Outer<E> {\n    inner class Inner {\n        fun foo() = this\n        fun baz(): Inner = this\n    }\n\n    fun bar() = Inner()\n\n    fun set(inner: Inner) {}\n}\n\nfun factoryString(): Outer<String>.Inner = null!!\n\nfun <T> infer(x: T): Outer<T>.Inner = null!!\nval inferred = infer(\"\")\n\nfun main() {\n    val outer: Outer<out String> = Outer<String>()\n\n    checkSubtype<Outer<out String>.Inner>(outer.bar())\n    checkSubtype<Outer<out String>.Inner>(outer.Inner())\n    checkSubtype<Outer<*>.Inner>(outer.bar())\n    checkSubtype<Outer<*>.Inner>(outer.Inner())\n\n    checkSubtype<Outer<out CharSequence>.Inner>(outer.bar())\n    checkSubtype<Outer<out CharSequence>.Inner>(outer.Inner())\n\n    outer.<!OI;MEMBER_PROJECTED_OUT!>set<!>(<!NI;TYPE_MISMATCH!>outer.bar()<!>)\n    outer.<!OI;MEMBER_PROJECTED_OUT!>set<!>(<!NI;TYPE_MISMATCH!>outer.Inner()<!>)\n\n    val x: Outer<String>.Inner = factoryString()\n    outer.<!OI;MEMBER_PROJECTED_OUT!>set<!>(<!NI;TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nclass Outer<E> {\n    inner open class InnerBase<F>\n    inner class Inner<H> : InnerBase<H>() {\n        val prop: E = null!!\n    }\n\n    fun foo(x: InnerBase<String>, y: Any?, z: Outer<*>.InnerBase<String>) {\n        if (x is Inner) {\n            <!DEBUG_INFO_SMARTCAST!>x<!>.prop.checkType { _<E>() }\n        }\n\n        if (y is <!NO_TYPE_ARGUMENTS_ON_RHS!>Inner<!>) return\n\n        if (z is Inner) {\n            <!OI;DEBUG_INFO_SMARTCAST!>z<!>.prop.checkType { _<Any?>() }\n            return\n        }\n\n        if (y is Outer<*>.Inner<*>) {\n            <!DEBUG_INFO_SMARTCAST!>y<!>.prop.checkType { _<Any?>() }\n        }\n    }\n\n    fun bar(x: InnerBase<String>, y: Any?, z: Outer<*>.InnerBase<String>) {\n        x as Inner\n        y as <!NO_TYPE_ARGUMENTS_ON_RHS!>Inner<!>\n        z as Inner\n    }\n}\n"
        },
        {
            "code": "class Outer<E> {\n    inner class Inner<F, G> {\n        inner abstract class Inner2Base\n        inner class Inner2 : Inner2Base()\n\n        inner abstract class Inner3Base<B>\n        inner class Inner3<H> : Inner3Base<H>()\n    }\n\n    fun foo(x: Outer<*>.Inner<*, *>.Inner2Base) {\n        if (x is Inner.Inner2) return\n    }\n}\n\nfun bare(x: Outer<*>.Inner<*, *>.Inner2Base, y: Outer<*>.Inner<*, *>.Inner3Base<Int>) {\n    if (x is Outer.Inner.Inner2) return\n    if (y is Outer.Inner.Inner3) return\n    if (y is Outer<String>.Inner.<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inner3<!>) return\n    if (y is <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Outer<!>.Inner<String, Int>.Inner3<Double>) return\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\nimport Outer.Inner\n\n\nclass Outer<E> {\n    inner class Inner\n\n    fun foo() {\n        class E\n        val x: Inner = Inner()\n    }\n\n    class Nested {\n        fun bar(x: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'Outer'\")!>Inner<!>) {}\n    }\n}\n\nclass E\n\nfun bar(x: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'Outer'\")!>Inner<!>) {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER -UNUSED_VARIABLE\n// JAVAC_EXPECTED_FILE\nimport java.util.*\n\nclass A<T> : AbstractCollection<T>() {\n    override fun iterator(): MyIt = MyIt()\n\n    override val size: Int\n        get() = 1\n\n    inner class MyIt : MutableIterator<T> {\n        override fun next(): T {\n            throw UnsupportedOperationException()\n        }\n\n        override fun hasNext(): Boolean {\n            throw UnsupportedOperationException()\n        }\n\n        override fun remove() {\n            throw UnsupportedOperationException()\n        }\n    }\n}\n\nfun <E> commonSupertype(x: E, y: E): E = x\n\nfun foo() {\n    var myIt = A<String>().iterator()\n    myIt = <!TYPE_MISMATCH!>A<Int>().iterator()<!>\n\n    val csIt: Iterator<CharSequence> = A<String>().iterator()\n\n    commonSupertype(A<String>().iterator(), A<Int>().iterator()).checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><A<out Any>.MyIt>() }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n\nclass Outer<E> {\n    inner class Inner {\n        fun foo() = this\n        fun baz(): Inner = this\n    }\n\n    fun bar() = Inner()\n\n    fun set(inner: Inner) {}\n}\n\nfun factoryString(): Outer<String>.Inner = null!!\n\nfun <T> infer(x: T): Outer<T>.Inner = null!!\nval inferred = infer(\"\")\n\nfun main() {\n    val outer = Outer<String>()\n\n    checkSubtype<Outer<String>.Inner>(outer.bar())\n    checkSubtype<Outer<String>.Inner>(outer.Inner())\n    checkSubtype<Outer<*>.Inner>(outer.bar())\n    checkSubtype<Outer<*>.Inner>(outer.Inner())\n\n    checkSubtype<Outer<CharSequence>.Inner>(<!TYPE_MISMATCH!>outer.bar()<!>)\n    checkSubtype<Outer<CharSequence>.Inner>(<!TYPE_MISMATCH!>outer.Inner()<!>)\n\n    outer.set(outer.bar())\n    outer.set(outer.Inner())\n\n    val x: Outer<String>.Inner = factoryString()\n    outer.set(x)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass Outer<out E, in F> {\n    inner class Inner {\n        fun unsafe1(x: <!TYPE_VARIANCE_CONFLICT!>E<!>) {}\n        fun unsafe2(x: Collection<<!TYPE_VARIANCE_CONFLICT!>E?<!>>) {}\n        fun unsafe3(): <!TYPE_VARIANCE_CONFLICT!>F?<!> = null\n        fun unsafe4(): Collection<<!TYPE_VARIANCE_CONFLICT!>F<!>>? = null\n    }\n\n    // Should be errors\n    // Refinement of variance checker is needed\n    fun foo(x: Inner) {}\n    fun bar(): Inner? = null\n}\n"
        },
        {
            "code": "import A.B.D\nimport A.B.C\nimport A.B.D.Innermost\n\nclass A<T> {\n    inner class B<F> {\n        inner class C<E>\n        inner class D {\n            inner class Innermost<X>\n        }\n    }\n\n    class Nested {\n        val x: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'A'\")!>B<!><String>? = null\n        val y: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'A'\")!>B<!><String>.C<String>? = null\n        val z: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'A'\")!>B<!><String>.D? = null\n\n        val c: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'B'\")!>C<!><Int>? = null\n        val d: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'B'\")!>D<!>? = null\n\n        val innerMost: <!OUTER_CLASS_ARGUMENTS_REQUIRED(\"class 'B'\")!>Innermost<!><String>? = null\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n\nclass Outer<in E> {\n    inner class Inner {\n        fun foo() = this\n        fun baz(): Inner = this\n    }\n\n    fun bar() = Inner()\n\n    fun set(inner: Inner) {}\n}\n\nfun factoryString(): Outer<String>.Inner = null!!\n\nfun <T> infer(x: T): Outer<T>.Inner = null!!\nval inferred = infer(\"\")\n\nfun main() {\n    val outer = Outer<CharSequence>()\n\n    checkSubtype<Outer<CharSequence>.Inner>(outer.bar())\n    checkSubtype<Outer<CharSequence>.Inner>(outer.Inner())\n    checkSubtype<Outer<*>.Inner>(outer.bar())\n    checkSubtype<Outer<*>.Inner>(outer.Inner())\n\n    checkSubtype<Outer<String>.Inner>(outer.bar())\n    checkSubtype<Outer<String>.Inner>(outer.Inner())\n\n    outer.set(outer.bar())\n    outer.set(outer.Inner())\n\n    val x: Outer<String>.Inner = factoryString()\n    outer.set(<!TYPE_MISMATCH!>x<!>)\n    val y: Outer<CharSequence>.Inner = infer<CharSequence>(\"\")\n    outer.set(y)\n\n    outer.set(infer<Any>(\"\"))\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n// FILE: test.kt\n\npackage test\n\nclass Outer<E> {\n    inner class Inner<F, G> {\n        inner class Inner2\n        inner class Inner3<H>\n    }\n\n    class Nested<I> {\n        inner class Inner4<K>\n    }\n\n    object Obj {\n        class Nested2<J> {\n            inner class Inner5<L>\n        }\n    }\n}\n\n// FILE: main.kt\n\nimport test.*;\n\nclass A\nclass B\nclass C\nclass D\n\nfun ok1(): Outer<A>.Inner<B, C>.Inner2 = null!!\nfun ok2(): Outer<A>.Inner<B, C>.Inner2 = null!!\nfun ok22(): test.Outer<A>.Inner<B, C>.Inner3<D> = null!!\nfun ok3(): Outer.Nested<A>.Inner4<B> = null!!\nfun ok4(): Outer.Obj.Nested2<A>.Inner5<B> = null!!\nfun ok5(): test.Outer.Obj.Nested2<A>.Inner5<B> = null!!\n\n// All arguments are resolved\nfun errorTypeWithArguments(): <!UNRESOLVED_REFERENCE!>Q<!><A>.<!DEBUG_INFO_MISSING_UNRESOLVED!>W<!><B, C, D>.<!DEBUG_INFO_MISSING_UNRESOLVED!>R<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>M<!> = null!!\n\nfun error1(): Outer<A>.Inner<B>.Inner3<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><C, D><!> = null!!\nfun error2(): Outer<A>.Inner<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><B, C, D><!>.Inner2 = null!!\nfun error3(): <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Outer<!>.Inner<A, B>.Inner3<C> = null!!\n\nfun error4(): Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><A><!>.Nested<B>.Inner4<C> = null!!\nfun error5(): Outer<!TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED!><A><!>.Obj.Nested2<B>.Inner5<C> = null!!\nfun error6(): Outer.Obj<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><A><!>.Nested2<B>.Inner5<C> = null!!\n\nfun error7(): test<!TYPE_ARGUMENTS_NOT_ALLOWED!><String><!>.Outer.Obj.Nested2<A>.Inner5<B> = null!!"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n\nclass Outer<E> {\n    inner class Inner<F> {\n        fun instance() = this@Outer\n        fun foo(): E = null!!\n        fun bar(e: E, f: F) {}\n        fun baz(): F = null!!\n\n        fun act() {\n            foo().checkType { _<E>() }\n            outerE().checkType { _<E>() }\n            instance().checkType { _<Outer<E>>() }\n            instance().outerE().checkType { _<E>() }\n\n            bar(foo(), baz())\n            bar(outerE(), baz())\n            bar(instance().outerE(), baz())\n\n            bar(topLevel().Inner<E>().baz(), <!TYPE_MISMATCH!>topLevel().Inner<E>().baz()<!>)\n            bar(<!TYPE_MISMATCH!>topLevel().Inner<E>().foo()<!>, <!TYPE_MISMATCH!>topLevel().Inner<E>().baz()<!>)\n\n            setE(foo())\n        }\n    }\n\n    fun outerE(): E = null!!\n\n    fun setE(e: E) {}\n    fun setInner(inner: Inner<Int>) {}\n}\n\nfun topLevel(): Outer<String> = null!!\n\nfun foo() {\n    val strInt: Outer<String>.Inner<Int> = Outer<String>().Inner()\n\n    strInt.foo().checkType { _<String>() }\n    strInt.baz().checkType { _<Int>() }\n\n    strInt.instance().setE(\"\")\n    strInt.instance().outerE().checkType { _<String>() }\n\n    strInt.instance().Inner<Double>().checkType { _<Outer<String>.Inner<Double>>() }\n\n    Outer<String>().setInner(strInt)\n    Outer<CharSequence>().setInner(<!TYPE_MISMATCH!>strInt<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VALUE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n\nclass Outer<T> {\n    inner class Inner\n    fun foo(x: Outer<String>.Inner, y: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Outer<!>.Inner, z: Inner) {\n        var inner = Inner()\n        x.checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><Inner>() }\n        x.checkType { _<Outer<String>.Inner>() }\n        z.checkType { _<Inner>() }\n        z.checkType { _<Outer<T>.Inner>() }\n\n        inner = <!TYPE_MISMATCH!>x<!>\n    }\n\n    class Nested\n    fun bar(x: Outer.Nested) {\n        var nested = Nested()\n        nested = x\n\n        x.checkType { _<Nested>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n\nclass Outer<E> {\n    inner class Inner<F> {\n        fun foo() = this\n        fun baz(): Inner<String> = null!!\n    }\n\n    fun innerFactory(): Outer<E>.Inner<String> = null!!\n\n    fun bar() = Inner<E>()\n    fun set(inner: Inner<out E>) {}\n\n    fun inside() {\n        innerFactory().checkType { _<Inner<String>>() }\n    }\n}\n\nfun factoryString(): Outer<String>.Inner<String> = null!!\n\nfun <T, Y> infer(x: T, y: Y): Outer<T>.Inner<Y> = null!!\nval inferred = infer(\"\", 1)\n\nfun main() {\n    val outer = Outer<String>()\n\n    checkSubtype<Outer<String>.Inner<String>>(outer.bar())\n    checkSubtype<Outer<String>.Inner<Int>>(outer.Inner<Int>())\n    checkSubtype<Outer<*>.Inner<*>>(outer.bar())\n    checkSubtype<Outer<*>.Inner<*>>(outer.Inner<Int>())\n\n    checkSubtype<Outer<CharSequence>.Inner<CharSequence>>(<!TYPE_MISMATCH!>outer.bar()<!>)\n    checkSubtype<Outer<CharSequence>.Inner<CharSequence>>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>outer.<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>Inner()<!><!>)\n\n    outer.set(outer.bar())\n    outer.set(outer.Inner())\n\n    val x: Outer<String>.Inner<String> = factoryString()\n    outer.set(x)\n}\n"
        },
        {
            "code": "class Outer<E : Any> {\n    inner class Inner<F, G>\n}\n\nval x: Outer<<!UPPER_BOUND_VIOLATED!>String?<!>>.Inner<String, Int> = null!!\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\nopen class Outer<E> {\n    inner class Inner<F>\n\n}\n\nclass Derived : Outer<String>() {\n    // Inner<Int> here means Outer<String>.Inner<Int>\n    fun foo(x: Inner<Int>) {}\n}\n\nclass A {\n    companion object : Outer<String>()\n\n    // Does not work, could be Outer<String>.Inner<Int>\n    // TODO: Should work?\n    fun foo(x: <!DEPRECATED_ACCESS_BY_SHORT_NAME, OUTER_CLASS_ARGUMENTS_REQUIRED!>Inner<!><Int>) {\n        // Inner<Char>() call use companion as implicit receiver\n        val y: Outer<String>.Inner<Char> = Inner<Char>()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\nopen class Outer<E> {\n    inner class Inner<F>\n\n}\n\nclass Derived : Outer<String>() {\n    // Inner<Int> here means Outer<String>.Inner<Int>\n    fun foo(x: Inner<Int>) {}\n}\n\nclass A {\n    companion object : Outer<String>()\n\n    // Does not work, could be Outer<String>.Inner<Int>\n    // TODO: Should work?\n    fun foo(x: <!UNRESOLVED_REFERENCE!>Inner<!><Int>) {\n        // Inner<Char>() call use companion as implicit receiver\n        val y: Outer<String>.Inner<Char> = Inner<Char>()\n    }\n}\n"
        },
        {
            "code": "interface Inv<X>\nclass Outer<E> {\n    inner class Inner\n\n    class Nested : Inv<<!OUTER_CLASS_ARGUMENTS_REQUIRED!>Inner<!>>\n    object Obj : Inv<<!OUTER_CLASS_ARGUMENTS_REQUIRED!>Inner<!>>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass A<R1, R2, R3, R4, R5, R6>\n\nclass Outer<T> {\n    inner class Inner<F> {\n        private fun <E> foobar() = {\n            open class LocalOuter<X, Y> {\n                inner class LocalInner<Z> {\n                    fun a() = A<T, F, E, X, Y, Z>()\n                }\n\n                typealias LocalAlias<W> = A<T, F, E, X, Y, W>\n            }\n\n            class Derived : LocalOuter<Double, Short>() {\n                fun foo(): LocalInner<Long> = null!!\n                fun bar(): LocalAlias<Char> = null!!\n            }\n\n            Derived()\n        }\n\n        private fun noParameters() = {\n            open class LocalOuter2<X, Y> {\n                inner class LocalInner2<Z> {\n                    fun a() = A<T, F, Any, X, Y, Z>()\n                }\n\n                typealias LocalAlias2<W> = A<T, F, Any, X, Y, W>\n            }\n\n            class Derived2 : LocalOuter2<Double, Short>() {\n                fun foo(): LocalInner2<Long> = null!!\n                fun bar(): LocalAlias2<Char> = null!!\n            }\n            Derived2()\n        }\n\n        fun test(z: Outer<String>.Inner<F>) {\n            var x = foobar<String>()\n            x = foobar<String>()\n\n            x().foo().a() checkType { _<A<T, F, String, Double, Short, Long>>() }\n            x().bar() checkType { _<A<T, F, String, Double, Short, Char>>() }\n\n            x = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>foobar<Int>()<!>\n            x = <!TYPE_MISMATCH!>z.<!NI;TYPE_MISMATCH!>foobar<String>()<!><!>\n\n            var y = noParameters()\n            y = noParameters()\n\n            y().foo().a() checkType { _<A<T, F, Any, Double, Short, Long>>() }\n            y().bar() checkType { _<A<T, F, Any, Double, Short, Char>>() }\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER -TOPLEVEL_TYPEALIASES_ONLY\n\nclass A<R1, R2, R3, R4>\n\nprivate fun <E> foobar() = {\n    open class LocalOuter<X, Y> {\n        inner class LocalInner<Z> {\n            fun a() = A<E, X, Y, Z>()\n        }\n\n        typealias LocalAlias<W> = A<E, X, Y, W>\n    }\n\n    class Derived : LocalOuter<Double, Short>() {\n        fun foo(): LocalInner<Long> = null!!\n        fun bar(): LocalAlias<Char> = null!!\n    }\n\n    Derived()\n}\n\nprivate fun noParameters() = {\n    open class LocalOuter2<X, Y> {\n        inner class LocalInner2<Z> {\n            fun a() = A<Any, X, Y, Z>()\n        }\n\n        typealias LocalAlias2<W> = A<Any, X, Y, W>\n    }\n\n    class Derived2 : LocalOuter2<Double, Short>() {\n        fun foo(): LocalInner2<Long> = null!!\n        fun bar(): LocalAlias2<Char> = null!!\n    }\n\n    Derived2()\n}\n\nfun test() {\n    var x = foobar<String>()\n    x = foobar<String>()\n\n    x().foo().a() checkType { _<A<String, Double, Short, Long>>() }\n    x().bar() checkType { _<A<String, Double, Short, Char>>() }\n\n    x = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>foobar<Int>()<!>\n\n    var y = noParameters()\n    y = noParameters()\n\n    y().foo().a() checkType { _<A<Any, Double, Short, Long>>() }\n    y().bar() checkType { _<A<Any, Double, Short, Char>>() }\n}\n"
        },
        {
            "code": "fun <<!CYCLIC_GENERIC_UPPER_BOUND!>T : F?<!>, <!CYCLIC_GENERIC_UPPER_BOUND!>F : T?<!>> foo1() {}\n\nfun <T : F?, <!CYCLIC_GENERIC_UPPER_BOUND!>F : E<!>, <!CYCLIC_GENERIC_UPPER_BOUND!>E : F?<!>> foo2() {}\n\nfun <<!CYCLIC_GENERIC_UPPER_BOUND!>T<!>, <!CYCLIC_GENERIC_UPPER_BOUND!>F<!>> foo3() where T : F?, F : T {}\n\nfun <T, <!CYCLIC_GENERIC_UPPER_BOUND!>F<!>, <!CYCLIC_GENERIC_UPPER_BOUND!>E<!>> foo4() where T : F?, F : E, E : F? {}"
        },
        {
            "code": "class A1<T : <!CYCLIC_GENERIC_UPPER_BOUND!>F?<!>, F : <!CYCLIC_GENERIC_UPPER_BOUND!>T?<!>>\n\nclass A2<T : F?, F : <!CYCLIC_GENERIC_UPPER_BOUND!>E<!>, E : <!CYCLIC_GENERIC_UPPER_BOUND!>F?<!>>\n\nclass A3<T, F> where T : <!CYCLIC_GENERIC_UPPER_BOUND!>F?<!>, F : <!CYCLIC_GENERIC_UPPER_BOUND!>T?<!>\n\nclass A4<T, F, E> where T : F?, F : <!CYCLIC_GENERIC_UPPER_BOUND!>E<!>, E : <!CYCLIC_GENERIC_UPPER_BOUND!>F<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nfun myFun(i : String) {}\nfun myFun(i : Int) {}\n\nfun test1() {\n    <!NI;NONE_APPLICABLE!>myFun<!><!OI;WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>(3)\n    <!NONE_APPLICABLE!>myFun<!><String>('a')\n}\n\nfun test2() {\n    val m0 = java.util.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>HashMap<!>()\n    val m1 = java.util.HashMap<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><String, String, String><!>()\n    val m2 = java.util.HashMap<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><String><!>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nclass In<in T>() {\n    fun f(<!UNUSED_PARAMETER!>t<!> : T) : Unit {}\n    fun f(<!UNUSED_PARAMETER!>t<!> : Int) : Int = 1\n    fun f1(<!UNUSED_PARAMETER!>t<!> : T) : Unit {}\n}\n\nclass Out<out T>() {\n    fun f() : T {throw IllegalStateException()}\n    fun f(a : Int) : Int = a\n}\n\nclass Inv<T>() {\n    fun f(t : T) : T = t\n    fun inf(<!UNUSED_PARAMETER!>t<!> : T) : Unit {}\n    fun outf() : T {throw IllegalStateException()}\n}\n\nfun testInOut() {\n    In<String>().f(\"1\");\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> In<<!REDUNDANT_PROJECTION!>in<!> String>).f(\"1\")\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> In<*>).<!NONE_APPLICABLE!>f<!>(\"1\") // Wrong Arg\n\n    In<String>().f(1);\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> In<<!REDUNDANT_PROJECTION!>in<!> String>).f(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> In<*>).f(1);\n\n    Out<Int>().f(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Out<<!REDUNDANT_PROJECTION!>out<!> Int>).f(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Out<*>).f(1)\n\n    Out<Int>().f()\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Out<<!REDUNDANT_PROJECTION!>out<!> Int>).f()\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Out<*>).f()\n\n    Inv<Int>().f(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<in Int>).f(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<out Int>).<!OI;MEMBER_PROJECTED_OUT!>f<!>(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) // !!\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<*>).<!OI;MEMBER_PROJECTED_OUT!>f<!>(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) // !!\n\n    Inv<Int>().inf(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<in Int>).inf(1)\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<out Int>).<!OI;MEMBER_PROJECTED_OUT!>inf<!>(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) // !!\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<*>).<!OI;MEMBER_PROJECTED_OUT!>inf<!>(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) // !!\n\n    Inv<Int>().outf()\n    checkSubtype<Int>(<!TYPE_MISMATCH!>(null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<in Int>).outf()<!>) // Type mismatch\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<out Int>).outf()\n    (null <!CAST_NEVER_SUCCEEDS!>as<!> Inv<*>).outf()\n\n    Inv<Int>().outf(<!TOO_MANY_ARGUMENTS!>1<!>) // Wrong Arg\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nimport java.util.stream.Collectors\nimport java.util.stream.IntStream\n\nfun main() {\n    val xs = IntStream.<!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>range<!>(0, 10).mapToObj { it.toString() }\n            .collect(Collectors.toList())\n    xs[0]\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// NI_EXPECTED_FILE\n\ninterface A\nfun <T: A, R: T> emptyStrangeMap(): Map<T, R> = TODO()\nfun test7() : Map<A, A> = emptyStrangeMap()\n\nfun test() = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyStrangeMap<!>()\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNREACHABLE_CODE -UNUSED_PARAMETER\n// !CHECK_TYPE\n// !WITH_NEW_INFERENCE\n// t is unused due to KT-4233\ninterface Tr<T> {\n    var v: T\n}\n\nfun test(t: Tr<*>) {\n    t.v = null!!\n    <!SETTER_PROJECTED_OUT!>t.v<!> = \"\"\n    <!SETTER_PROJECTED_OUT!>t.v<!> = null\n    t.v checkType { _<Any?>() }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !WITH_NEW_INFERENCE\ninterface Tr<T> {\n    var v: Tr<T>\n}\n\nfun test(t: Tr<*>) {\n    <!SETTER_PROJECTED_OUT!>t.v<!> = t\n    t.v checkType { _<Tr<*>>() }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNREACHABLE_CODE\ninterface Tr<T> {\n    var v: T\n}\n\nclass C {\n    operator fun plusAssign(<!UNUSED_PARAMETER!>c<!>: C) {}\n}\n\nfun test(t: Tr<out C>) {\n    // No error because no real assignment happens\n    t.v += null!!\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNREACHABLE_CODE\n// !WITH_NEW_INFERENCE\ninterface Tr<T> {\n    var v: T\n}\n\nfun test(t: Tr<out String>) {\n    // resolved as t.v = t.v + null!!, where type of right operand is String,\n    // so TYPE_MISMATCH: String is not <: of Captured(out String)\n    <!SETTER_PROJECTED_OUT!>t.v<!> += null!!\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: GA.kt\n\npackage test.x\n\nopen class GA<T> protected constructor()\n\n// FILE: Main.kt\npackage test\n\nimport test.x.GA\n\nclass C : GA<Any>() {\n    companion object {\n        fun bar() = <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>GA<!><Any>() // Should be error\n    }\n}\n\nfun main(args: Array<String>) {\n    C.bar()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nfun <T> magic(): T = null!!\n\nclass Q {\n    private fun <E> foo() = {\n        class C {\n            val prop: E = magic()\n        }\n        C()\n    }\n\n    private var x = <!DEBUG_INFO_LEAKING_THIS!>foo<!><CharSequence>()()\n    private var y = <!DEBUG_INFO_LEAKING_THIS!>foo<!><String>()()\n\n    fun bar() {\n        x = <!TYPE_MISMATCH!>y<!>\n        x = foo<CharSequence>()()\n        y = foo<String>()()\n\n        x.prop.checkType { _<CharSequence>() }\n        y.prop.checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nfun <T> magic(): T = null!!\n\nclass Q {\n    private fun <E> foo() =\n        object {\n            val prop: E = magic()\n        }\n\n    private var x = <!DEBUG_INFO_LEAKING_THIS!>foo<!><CharSequence>()\n    private var y = <!DEBUG_INFO_LEAKING_THIS!>foo<!><String>()\n\n    fun bar() {\n        x = <!TYPE_MISMATCH!>y<!>\n        x = foo<CharSequence>()\n        y = foo<String>()\n\n        x.prop.checkType { _<CharSequence>() }\n        y.prop.checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// NI_EXPECTED_FILE\nprivate class Outer<E> {\n    private inner class Inner<out F> {\n        private fun <G> foo() = {\n            fun baz() = {\n                class Local {\n                    val e: E = magic()\n                    val f: F = magic()\n                    val g: G = magic()\n                }\n                Local()\n            }\n            baz()()\n        }\n\n        private var doubleCharSequenceInt = Outer<Double>().Inner<CharSequence>().foo<Int>()()\n        private var doubleStringNumber = Outer<Double>().Inner<String>().foo<Number>()()\n        private var doubleStringInt = Outer<Double>().Inner<String>().foo<Int>()()\n\n        private fun bar() {\n            doubleCharSequenceInt = <!TYPE_MISMATCH!>doubleStringNumber<!>\n            doubleCharSequenceInt = doubleStringInt\n\n            doubleStringInt = Outer<Double>().Inner<String>().foo<Int>()()\n\n            doubleStringInt.e.checkType { _<Double>() }\n            doubleStringInt.f.checkType { _<String>() }\n            doubleStringInt.g.checkType { _<Int>() }\n        }\n    }\n}\n\nfun <T> magic(): T = null!!\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun <T> magic(): T = null!!\n\nclass Q {\n    private fun <E, F> foo() = {\n        class C<G> {\n            val e: E = magic()\n            val f: F = magic()\n            val g: G = magic()\n        }\n        C<F>()\n    }\n\n    private var x = <!DEBUG_INFO_LEAKING_THIS!>foo<!><CharSequence, Number>()()\n\n    fun bar() {\n        x.e.checkType { _<CharSequence>() }\n        x.f.checkType { _<Number>() }\n        x.g.checkType { _<Number>() }\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass X {\n    abstract class Y<T : Any>\n\n    fun <T : Any> foo(y: Y<T>, t: T) {\n    }\n}\n\n\nfun testStar(y: X.Y<*>, t: Any) {\n    X().foo(y, <!TYPE_MISMATCH(\"CapturedType(*)\", \"Any\")!>t<!>)\n}\n\nfun testOut(y: X.Y<out Any>, t: Any) {\n    X().foo(y, <!TYPE_MISMATCH(\"CapturedType(out Any)\", \"Any\")!>t<!>)\n}\n\nfun testIn(y: X.Y<in Any>, t: Any) {\n    X().foo(y, t)\n}\n\nfun <T : Any> testWithParameter(y: X.Y<T>, t: Any) {\n    X().foo(y, <!TYPE_MISMATCH(\"T\", \"Any\")!>t<!>)\n}\n\nfun <T : Any> testWithCapturedParameter(y: X.Y<out T>, t: Any) {\n    X().foo(y, <!TYPE_MISMATCH(\"CapturedType(out T)\", \"Any\")!>t<!>)\n}\n"
        },
        {
            "code": "fun <E> foo(x: Any, y: Any) : Any {\n    class C\n    // without E?\n    if(x is <!CANNOT_CHECK_FOR_ERASED!>C<!>) {\n        return x\n    }\n\n    if (1 == 2) {\n        x <!UNCHECKED_CAST!>as C<!>\n    }\n\n    if (2 == 3) {\n        x <!UNCHECKED_CAST!>as? C<!>\n    }\n\n    class Outer<F> {\n        inner class Inner\n    }\n\n    // bare type\n    if (y is <!NO_TYPE_ARGUMENTS_ON_RHS!>Outer.Inner<!>) {\n        return y\n    }\n\n    y <!UNCHECKED_CAST!>as Outer<*>.Inner<!>\n\n    return C()\n}\n\nfun noTypeParameters(x: Any) : Any {\n    class C\n    if(x is C) {\n        return x\n    }\n\n    return C()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// See KT-9893\nopen class A\n\npublic interface I<T : A> {\n    public fun foo(): T?\n}\n\nfun acceptA(a: A) {\n}\n\nfun main(i: I<*>) {\n    i.foo() checkType { _<A?>() }\n    acceptA(<!TYPE_MISMATCH!>i.foo()<!>) // i.foo() should be nullable but isn't\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\ninterface A<out K> {\n    fun foo(x: @UnsafeVariance K): Unit\n}\n\nfun test(a: A<*>) {\n    a.foo(<!NI;NULL_FOR_NONNULL_TYPE!>null<!>)\n    a.foo(<!NI;TYPE_MISMATCH!>Any()<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// See KT-7296\ninterface A<T>\ninterface B<T> : A<A<T>>\n\nfun foo(x : B<*>) {\n    bar1(<!TYPE_MISMATCH!>x<!>) // this should not be valid\n    bar2(x)\n    bar3(x)\n}\n\nfun bar1(x : A<A<*>>) { }\nfun bar2(x : A<out A<*>>) { }\nfun bar3(x : A<*>) { }\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Out<out X>\nclass In<in Y>\nclass Inv<Z>\n\nclass A<T> {\n    fun <E : Out<T>> foo1(x: E) = 1\n    fun <F : Inv<T>> foo2(x: F) = 1\n    fun <G : In<T>>  foo3(x: G) = 1\n}\n\nfun foo2(a: A<out CharSequence>, b: A<in CharSequence>) {\n    a.<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo1<!>(<!NI;TYPE_MISMATCH!>Out<CharSequence>()<!>)\n    a.foo1<<!UPPER_BOUND_VIOLATED!>Out<CharSequence><!>>(<!NI;TYPE_MISMATCH!>Out()<!>)\n\n    a.foo1(Out())\n    a.foo1(Out<Nothing>())\n\n    a.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>foo2<!>(<!NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>Inv<!>()<!>)\n    a.<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo2<!>(<!NI;TYPE_MISMATCH!>Inv<CharSequence>()<!>)\n    a.foo2<<!UPPER_BOUND_VIOLATED!>Inv<CharSequence><!>>(<!NI;TYPE_MISMATCH!>Inv()<!>)\n\n    a.foo3(In())\n    a.foo3(In<CharSequence>())\n    a.foo3<In<CharSequence>>(In())\n\n    b.foo1(Out())\n    b.foo1(Out<CharSequence>())\n    b.foo1<Out<CharSequence>>(Out())\n\n    b.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>foo2<!>(<!NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>Inv<!>()<!>)\n    b.<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo2<!>(<!NI;TYPE_MISMATCH!>Inv<CharSequence>()<!>)\n    b.foo2<<!UPPER_BOUND_VIOLATED!>Inv<CharSequence><!>>(<!NI;TYPE_MISMATCH!>Inv()<!>)\n\n\n    b.<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo3<!>(<!NI;TYPE_MISMATCH!>In<CharSequence>()<!>)\n    b.foo3<<!UPPER_BOUND_VIOLATED!>In<CharSequence><!>>(<!NI;TYPE_MISMATCH!>In()<!>)\n\n    b.foo3(In<Any?>())\n    b.foo3(In())\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface C<out T>\ninterface MC<T> : C<T> {\n    fun addAll(x: C<T>): Boolean\n    fun addAllMC(x: MC<out T>): Boolean\n    fun addAllInv(x: MC<T>): Boolean\n}\n\ninterface Open\nclass Derived : Open\n\nfun <T> mc(): MC<T> = null!!\nfun <T> c(): C<T> = null!!\n\nfun foo(x: MC<out Open>) {\n    x.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>x<!>)\n    x.addAllMC(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>x<!>)\n\n    x.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>mc<Open>()<!>)\n    x.addAllMC(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>mc<Open>()<!>)\n\n    x.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>mc<Derived>()<!>)\n    x.addAllMC(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>mc<Derived>()<!>)\n\n    x.addAll(c())\n    x.addAll(c<Nothing>())\n\n    x.<!OI;MEMBER_PROJECTED_OUT!>addAllInv<!>(<!NI;TYPE_MISMATCH!>mc<Open>()<!>)\n    x.addAll(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T> {\n    operator fun plus(x: Out<T>): A<T> = this\n    operator fun set(x: Int, y: Out<T>) {}\n    operator fun get(x: Out<T>) = 1\n}\n\nclass Out<out F>\n\nfun test(a: A<out CharSequence>, y: Out<CharSequence>) {\n    a + <!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>\n    a[1] = <!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>\n    a[<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>]\n\n    a + Out<Nothing>()\n    a[1] = Out<Nothing>()\n    a[Out<Nothing>()]\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass Inv<E>\nclass C<R> {\n    fun bindTo(property: Inv<R>) {}\n}\n\nfun foo(x: Any?, y: C<*>) {\n    y.<!OI;MEMBER_PROJECTED_OUT!>bindTo<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\n\n    if (x is C<*>) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.<!OI;MEMBER_PROJECTED_OUT!>bindTo<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\n        with(<!DEBUG_INFO_SMARTCAST!>x<!>) {\n            <!OI;MEMBER_PROJECTED_OUT!>bindTo<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\n        }\n    }\n\n    with(x) {\n        if (this is C<*>) {\n            <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST, OI;MEMBER_PROJECTED_OUT!>bindTo<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A<T> {\n    fun T.foo() {}\n    fun Out<T>.bar() {}\n}\nclass Out<out E>\n\nfun test(x: A<out CharSequence>, y: Out<CharSequence>) {\n    with(x) {\n        // TODO: this diagnostic could be replaced with TYPE_MISMATCH_DUE_TO_TYPE_PROJECTION\n        \"\".<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>()\n        <!OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>bar<!>()\n\n        with(y) {\n            <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>bar<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Out<out T>\nclass In<in T> {\n    fun invoke1(x: T) {}\n    fun invoke2(x: Out<T>) {}\n}\n\ninterface A<E> {\n    fun foo(): In<E>\n}\n\nfun test(a: A<out CharSequence>, y: Out<CharSequence>) {\n    val i = a.foo()\n    // TODO: These diagnostic are wrong, type of 'i' --- 'In<Nothing>' is not projected itself,\n    // but it's approximation result caused by 'a' projection\n    i.invoke1(<!TYPE_MISMATCH!>\"\"<!>)\n    i.invoke2(<!TYPE_MISMATCH!>y<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nclass Out<out T> {\n    fun id() = this\n    fun foobar(x: Any) {}\n}\n\nclass A<E> {\n    inline fun foo(block: () -> E) {}\n    inline fun bar(block: () -> Out<E>) {}\n}\n\nfun test(a: A<out CharSequence>, z: Out<CharSequence>) {\n    a.foo {\n        val x: String = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> // Should be no TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS\n        <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>\"\"<!>\n    }\n    a.bar { <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>Out<CharSequence>()<!> }\n    a.bar { Out() }\n    a.bar { <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>z.id()<!> }\n\n    a.foo {\n        z.foobar(if (1 > 2) return@foo <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>\"\"<!> else \"\")\n        <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>\"\"<!>\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !CHECK_TYPE\nimport java.util.ArrayList\n\nclass ListOfLists<T>(public val x : ArrayList<ArrayList<T>>)\n\nfun main() {\n    val a : ArrayList<ArrayList<String>> = ArrayList()\n    val b : ListOfLists<String> = ListOfLists(a)\n    val c : ListOfLists<*> = b\n    val d : ArrayList<ArrayList<*>> = <!TYPE_MISMATCH!>c.x<!>\n\n    c.x checkType { _<ArrayList<out ArrayList<*>>>() }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T> {\n    operator fun plus(x: T): A<T> = this\n    operator fun set(x: Int, y: T) {}\n    operator fun get(x: T) = 1\n}\n\nfun test(a: A<out CharSequence>) {\n    a <!OI;MEMBER_PROJECTED_OUT!>+<!> <!NI;TYPE_MISMATCH!>\"\"<!>\n    <!OI;MEMBER_PROJECTED_OUT!>a[1]<!> = <!NI;TYPE_MISMATCH!>\"\"<!>\n    <!OI;MEMBER_PROJECTED_OUT!>a[<!NI;TYPE_MISMATCH!>\"\"<!>]<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface A<T>\ninterface B<E> {\n    fun foo(x: A<in E>)\n}\n\nfun foo(x: B<in CharSequence>, y: A<CharSequence>) {\n    x.foo(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\n// FILE: main.kt\nfun test(clazz: Clazz<*>) {\n    clazz.t checkType { _<Any?>() }\n    clazz.getSuperClass() checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Clazz<*>?>() }\n    clazz.getSuperClass().t checkType { _<Any?>() }\n\n    clazz.superClass checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Clazz<*>?>() }\n    clazz.superClass.t checkType { _<Any?>() }\n\n    // See KT-9294\n    if (clazz.superClass == null) {\n        throw NullPointerException()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T> {\n    fun foo(x: T, y: T) {}\n}\n\nfun test(a: A<out CharSequence>) {\n    a.<!OI;MEMBER_PROJECTED_OUT!>foo<!>(<!NI;TYPE_MISMATCH!>\"\"<!>, <!NI;TYPE_MISMATCH!>\"\"<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T> {\n    fun foo(vararg x: T) {}\n}\n\nfun test(a: A<out CharSequence>, y: Array<out CharSequence>) {\n    a.<!OI;MEMBER_PROJECTED_OUT!>foo<!>(<!NI;TYPE_MISMATCH!>\"\"<!>, <!NI;TYPE_MISMATCH!>\"\"<!>, <!NI;TYPE_MISMATCH!>\"\"<!>)\n    a.foo(*<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>)\n    // TODO: TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS probably redundant\n    a.<!OI;MEMBER_PROJECTED_OUT!>foo<!>(*<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>y<!>, <!NI;TYPE_MISMATCH!>\"\"<!>)\n}\n"
        },
        {
            "code": "open class C<T : C<T>>\nclass TestOK : C<TestOK>()\nclass TestFail : C<<!UPPER_BOUND_VIOLATED!>C<<!UPPER_BOUND_VIOLATED!>TestFail<!>><!>>()\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n// Issues: KT-25105\n\nclass Message1\nclass Task<T>\nobject Message2\nenum class Message3\ndata class Message4(val x: Int)\ninterface Manager<T> {}\n\nobject MessageManager1 : Manager<Message1> {\n    fun <T : <!FINAL_UPPER_BOUND!>Message1<!>> execute1(task: Task<T>) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Int<!>> execute2(task: T) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Message2<!>> execute3() {}\n}\n\nobject MessageManager2 : Manager<Message3> {\n    fun <T : Message3> execute4() {}\n}\n\nobject MessageManager3 : Manager<Message4> {\n    fun <T : <!FINAL_UPPER_BOUND!>Message4<!>> execute5() {}\n}\n\nclass MessageManager4 : Manager<Message1> {\n    fun <T : <!FINAL_UPPER_BOUND!>Message1<!>> execute1(task: Task<T>) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Int<!>> execute2(task: T) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Message2<!>> execute3() {}\n}\n\nclass MessageManager5 : Manager<Message3> {\n    fun <T : Message3> execute4() {}\n}\n\nclass MessageManager6 : Manager<Message4> {\n    fun <T : <!FINAL_UPPER_BOUND!>Message4<!>> execute5() {}\n}\n\ninterface MessageManager7 : Manager<Message4> {\n    fun <T : <!FINAL_UPPER_BOUND!>Message4<!>> execute5() {}\n}\n\ninterface MessageManager8 : Manager<Message1> {\n    fun <T : <!FINAL_UPPER_BOUND!>Message1<!>> execute1(task: Task<T>) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Int<!>> execute2(task: T) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Message2<!>> execute3() {}\n}\n\ninterface MessageManager9 : Manager<Message3> {\n    fun <T : Message3> execute4() {}\n}\n\nobject MessageManager10 : <!UNRESOLVED_REFERENCE!>Message5<!><Int>() {\n    fun <T : <!FINAL_UPPER_BOUND!>Int<!>> execute() {}\n}\n\nclass MessageManager11<A> : <!UNRESOLVED_REFERENCE!>Message5<!><<!UNRESOLVED_REFERENCE!>Message5<!><A>>() {\n    fun <T : <!UNRESOLVED_REFERENCE!>Message5<!><A>> execute() {}\n}\n\ndata class MessageManager12(val x: Int) : <!UNRESOLVED_REFERENCE!>Message5<!><Message2>() {\n    fun <T : <!FINAL_UPPER_BOUND!>Message2<!>> execute() {}\n}\n\nsealed class MessageManager13<A> : <!UNRESOLVED_REFERENCE!>Message5<!><A>() {\n    fun <T : A> execute() {}\n}\n\nclass MessageManager14 : Manager<Message2> {\n    val <T : <!FINAL_UPPER_BOUND!>Message2<!>> T.x get() = 10\n    var <T : <!FINAL_UPPER_BOUND!>Message2<!>> T.y\n        get() = 10\n        set(value) {}\n}\n\nobject MessageManager15 : Manager<Int> {\n    val <T : <!FINAL_UPPER_BOUND!>Int<!>> T.x get() = 10\n    var <T : <!FINAL_UPPER_BOUND!>Int<!>> T.y\n        get() = 10\n        set(value) {}\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    val foo: Any?\n}\n\ninterface C: A {\n    override val foo: String\n}\ninterface B: A {\n    override var foo: String?\n}\n\nfun <T> test(a: T) where T : B, T : C {\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> = \"\"\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> = null\n\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><String>() }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    val foo: Any?\n}\n\ninterface C: A {\n    override val foo: String?\n}\ninterface B: A {\n    override var foo: String\n}\n\nfun <T> test(a: T) where T : B, T : C {\n    a.foo = \"\"\n    a.foo = <!NULL_FOR_NONNULL_TYPE!>null<!>\n\n    a.foo.checkType { _<String>() }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface A {\n    fun foo()\n}\n\ninterface C: A\ninterface B: A\n\nfun <T> test(x: T) where T : C?, T : B? {\n    x?.foo()\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.foo()\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A {\n    fun foo(): CharSequence\n}\n\ninterface B {\n    fun foo(): String?\n}\n\nfun <T> test(x: T) where T : B, T : A {\n    x.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>()\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// Incorrect \"type mismatch\" error for generic extension safe call (required not-null, found nullable)\n\n// FILE: A.kt\n\nclass A<T> {\n    fun gav() = \"\"\n}\nfun <R> foo(x: R) = x\nfun <T> A<T>.bar() = \"\"\nfun <T> B<T>.bar() = \"\"\n\nfun foo(l: A<String>?) {\n    // No errors should be here\n    foo(l?.bar()) checkType { _<String?>() }\n    foo(l?.gav()) checkType { _<String?>() }\n    if (l != null) {\n        foo(l<!UNNECESSARY_SAFE_CALL!>?.<!>bar()) checkType { _<String>() }\n        foo(l<!UNNECESSARY_SAFE_CALL!>?.<!>gav()) checkType { _<String>() }\n    }\n}\n\nfun fooNotNull(l: A<String>) {\n    // No errors should be here\n    foo(l<!UNNECESSARY_SAFE_CALL!>?.<!>bar()) checkType { _<String>() }\n    foo(l<!UNNECESSARY_SAFE_CALL!>?.<!>gav()) checkType { _<String>() }\n}\n\nfun bar() {\n    val l = B.create<String>()\n    foo(l?.bar()) checkType { _<String?>() }\n    foo(l?.gav()) checkType { _<String?>() }\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n// Issues: KT-25105\n\nclass Message1\nclass Task<T>\nobject Message2\nenum class Message3\ndata class Message4(val x: Int)\n\nsealed class Message5<T> {\n    open fun <A : T> execute() {}\n}\n\ninterface Manager<T> {\n    fun <A : T> execute1(task: Task<A>) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Int<!>> execute2(task: T) {}\n    fun <T : <!FINAL_UPPER_BOUND!>Message2<!>> execute3() {}\n    fun <A : T> execute4() {}\n    fun <A : T> execute5() {}\n    val <A : T> A.x get() = 10\n    var <A : T> A.y\n        get() = 10\n        set(value) {}\n}\n\nobject MessageManager1 : Manager<Message1> {\n    override fun <T : Message1> execute1(task: Task<T>) {}\n    override fun <T : Int> execute2(task: T) {}\n    override fun <T : Message2> execute3() {}\n}\n\nobject MessageManager2 : Manager<Message3> {\n    override fun <T : Message3> execute4() {}\n}\n\nobject MessageManager3 : Manager<Message4> {\n    override fun <T : Message4> execute5() {}\n}\n\nclass MessageManager4 : Manager<Message1> {\n    override fun <T : Message1> execute1(task: Task<T>) {}\n    override fun <T : Int> execute2(task: T) {}\n    override fun <T : Message2> execute3() {}\n}\n\nclass MessageManager5 : Manager<Message3> {\n    override fun <T : Message3> execute4() {}\n}\n\nclass MessageManager6 : Manager<Message4> {\n    override fun <T : Message4> execute5() {}\n}\n\ninterface MessageManager7 : Manager<Message4> {\n    override fun <T : Message4> execute5() {}\n}\n\ninterface MessageManager8 : Manager<Message1> {\n    override fun <T : Message1> execute1(task: Task<T>) {}\n    override fun <T : Int> execute2(task: T) {}\n    override fun <T : Message2> execute3() {}\n}\n\ninterface MessageManager9 : Manager<Message3> {\n    override fun <T : Message3> execute4() {}\n}\n\nobject MessageManager10 : Message5<Int>() {\n    override fun <T : Int> execute() {}\n}\n\nclass MessageManager11<A> : Message5<Message5<A>>() {\n    override fun <T : Message5<A>> execute() {}\n}\n\ndata class MessageManager12(val x: Int) : Message5<Message2>() {\n    override fun <T : Message2> execute() {}\n}\n\nsealed class MessageManager13<A> : Message5<A>() {\n    override fun <T : A> execute() {}\n}\n\nclass MessageManager14 : Manager<Message2> {\n    override val <T : Message2> T.x get() = 10\n    override var <T : Message2> T.y\n        get() = 10\n        set(value) {}\n}\n\nobject MessageManager15 : Manager<Int> {\n    override val <T : Int> T.x get() = 10\n    override var <T : Int> T.y\n        get() = 10\n        set(value) {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<T : CharSequence>(x: T)\n\nfun <E : CharSequence> foo1(x: E) {}\nfun <E : CharSequence> E.foo2() {}\n\nfun <F : String?> bar(x: F) {\n    <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>A<!>(<!NI;TYPE_MISMATCH!>x<!>)\n    A<<!UPPER_BOUND_VIOLATED!>F<!>>(x)\n\n    <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo1<!>(<!NI;TYPE_MISMATCH!>x<!>)\n    foo1<<!UPPER_BOUND_VIOLATED!>F<!>>(x)\n\n    x<!NI;UNSAFE_CALL!>.<!><!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo2<!>()\n    x.foo2<<!UPPER_BOUND_VIOLATED!>F<!>>()\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A\ninterface B {\n    fun test() {}\n}\n\nfun <K> select(a: K, b: K): K = a\n\nfun test(a: A?, b: B?) {\n    b as A?\n    a as B?\n    val c = select(a, b)\n    if (c != null) {\n        <!DEBUG_INFO_SMARTCAST!>c<!>.test()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION,-UNUSED_VARIABLE\n\nfun <T : CharSequence?> T.bar1() {}\nfun CharSequence?.bar2() {}\n\nfun <T : CharSequence> T.bar3() {}\n\nfun <T : String?> foo(x: T) {\n    x<!UNSAFE_CALL!>.<!>length\n    x?.length\n\n    if (1 == 1) {\n        x!!.length\n    }\n\n\n    x.bar1()\n    x.bar2()\n\n    x?.bar1()\n    x?.bar2()\n\n    x<!NI;UNSAFE_CALL!>.<!><!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar3<!>()\n\n    x?.let { it<!OI;UNSAFE_CALL!>.<!>length }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION,-UNUSED_VARIABLE,-UNUSED_PARAMETER,-ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE,-UNUSED_VALUE\n\nfun <T : CharSequence> bar1(x: T) {}\nfun bar2(x: CharSequence) {}\nfun bar3(x: String) {}\n\nfun <T : CharSequence?> foo(x: T) {\n    var y1: CharSequence = \"\"\n    var y2: String = \"\"\n    if (x != null) {\n        if (<!SENSELESS_COMPARISON!>x != null<!>) {}\n\n        y1 = <!DEBUG_INFO_SMARTCAST!>x<!>\n        y2 = <!TYPE_MISMATCH!>x<!>\n\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar1<!>(<!NI;DEBUG_INFO_SMARTCAST!>x<!>)\n        bar1<CharSequence>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar2(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar3(<!TYPE_MISMATCH!>x<!>)\n    }\n\n    if (x is String) {\n        y1 = <!DEBUG_INFO_SMARTCAST!>x<!>\n        y2 = <!DEBUG_INFO_SMARTCAST!>x<!>\n\n        bar1(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar2(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar3(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n\n    if (x is CharSequence) {\n        y1 = <!DEBUG_INFO_SMARTCAST!>x<!>\n        y2 = <!TYPE_MISMATCH!>x<!>\n\n        bar1(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar2(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar3(<!TYPE_MISMATCH!>x<!>)\n    }\n\n    if (1 == 1) {\n        val y = x!!\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar1<!>(<!NI;DEBUG_INFO_SMARTCAST!>x<!>)\n        bar1<CharSequence>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar2(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        bar3(<!TYPE_MISMATCH!>x<!>)\n\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar1<!>(y)\n        bar2(<!OI;DEBUG_INFO_SMARTCAST!>y<!>)\n        bar3(<!TYPE_MISMATCH!>y<!>)\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\nfun simpleTypeAndNumberType(b: Comparable<*>?) {\n    if (b is Byte?) {\n        <!DEBUG_INFO_SMARTCAST!>b<!>!!.dec()\n    }\n}\n\nfun <T> typeParmeterAndNumberType(b: T?) {\n    if (b is Byte?) {\n        b!!.dec()\n    }\n}\n\nfun anyAndNumberType(b: Any?) {\n    if (b is Byte?) {\n        <!DEBUG_INFO_SMARTCAST!>b<!>!!.dec()\n    }\n}\n\nfun comparableAndNumberType(b: Comparable<Byte>?) {\n    if (b is Byte?) {\n        <!DEBUG_INFO_SMARTCAST!>b<!>!!.dec()\n    }\n}\n\nobject SeparateTypes {\n    interface A\n    interface B {\n        fun foo() {}\n    }\n\n    fun separate(a: A?) {\n        if (a is B?) {\n            a!!.foo()\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION,-UNUSED_VARIABLE\n\nfun <T : CharSequence?> T.bar1() {}\nfun CharSequence?.bar2() {}\n\nfun <T : CharSequence> T.bar3() {}\nfun CharSequence.bar4() {}\n\nfun <T : String?> T.foo() {\n    if (this != null) {\n        if (<!SENSELESS_COMPARISON!>this != null<!>) {}\n\n        <!NI;DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>length<!>\n        this<!UNNECESSARY_SAFE_CALL!>?.<!>length\n\n        <!NI;DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>bar1<!>()\n        bar2()\n        <!NI;DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST, OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar3<!>()\n        <!NI;DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>bar4<!>()\n\n\n        this<!UNNECESSARY_SAFE_CALL!>?.<!>bar1()\n    }\n\n    <!UNSAFE_CALL!>length<!>\n\n    if (this is String) {\n        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>length<!>\n        this<!UNNECESSARY_SAFE_CALL!>?.<!>length\n\n        <!NI;DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>bar1<!>()\n        bar2()\n        <!NI;DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST, OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar3<!>()\n    }\n}"
        },
        {
            "code": "fun <T : Any?> foo(x: T) {\n    if (x is String?) {\n        x<!UNSAFE_CALL!>.<!>length\n\n        if (x != null) {\n            <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        }\n    }\n\n    if (x is String) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VALUE,-UNUSED_VARIABLE,-ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE,-VARIABLE_WITH_REDUNDANT_INITIALIZER\n\nclass A<T : CharSequence?, E1 : T, E2: T?> {\n    fun T.bar() {}\n\n    fun foo(x: E1, y: E2) {\n        x.bar()\n\n        if (1 == 1) {\n            y<!UNSAFE_CALL!>.<!>bar()\n        }\n\n        x?.bar()\n        y?.bar()\n\n\n        var t: T = x\n        var tN: T? = y\n\n        // condition needed to make smart cast on tN impossible\n        if (1 == 1) {\n            tN = x\n        }\n\n        if (1 == 1) {\n            t = <!TYPE_MISMATCH!>tN<!>\n        }\n\n        t = <!TYPE_MISMATCH!>y<!>\n\n        if (y != null) {\n            t = <!DEBUG_INFO_SMARTCAST!>y<!>\n        }\n\n        if (tN != null) {\n            t = <!DEBUG_INFO_SMARTCAST!>tN<!>\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A<T : CharSequence>\n\nfun <S : CharSequence?> foo1(a: A<<!UPPER_BOUND_VIOLATED!>S<!>>) {}\n\nclass B1<E : String?> : A<<!UPPER_BOUND_VIOLATED!>E<!>>\nclass B2<E : CharSequence?> : A<<!UPPER_BOUND_VIOLATED!>E<!>>\nclass B3<E> : A<<!UPPER_BOUND_VIOLATED!>E<!>>\n\nclass B4<E : CharSequence> : A<E>\n\nfun <X : CharSequence, Y1 : X, Y2: Y1?> foo(a: A<X>, b: A<Y1>, c: A<<!UPPER_BOUND_VIOLATED!>Y2<!>>) {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION,-UNUSED_VARIABLE\n\nfun <T : CharSequence?> T.bar1() {}\nfun CharSequence?.bar2() {}\n\nfun <T : CharSequence> T.bar3() {}\nfun CharSequence.bar4() {}\n\nfun <T : CharSequence?> foo(x: T) {\n\n    if (x != null) {\n        if (<!SENSELESS_COMPARISON!>x != null<!>) {}\n\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        x<!UNNECESSARY_SAFE_CALL!>?.<!>length\n\n        <!NI;DEBUG_INFO_SMARTCAST!>x<!>.bar1()\n        x.bar2()\n        <!NI;DEBUG_INFO_SMARTCAST!>x<!>.<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar3<!>()\n        <!DEBUG_INFO_SMARTCAST!>x<!>.bar4()\n\n\n        x<!UNNECESSARY_SAFE_CALL!>?.<!>bar1()\n    }\n\n    x<!UNSAFE_CALL!>.<!>length\n\n    if (x is String) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        x<!UNNECESSARY_SAFE_CALL!>?.<!>length\n\n        <!NI;DEBUG_INFO_SMARTCAST!>x<!>.bar1()\n        x.bar2()\n        <!DEBUG_INFO_SMARTCAST!>x<!>.bar3()\n    }\n\n    if (x is CharSequence) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        x<!UNNECESSARY_SAFE_CALL!>?.<!>length\n\n        <!NI;DEBUG_INFO_SMARTCAST!>x<!>.bar1()\n        x.bar2()\n        <!DEBUG_INFO_SMARTCAST!>x<!>.bar3()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE\n\nfun <E> bar(x: E) {}\n\nfun <T> foo(): T {\n    val x1: T = <!NULL_FOR_NONNULL_TYPE!>null<!>\n    val x2: T? = null\n\n    bar<T>(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    bar<T?>(null)\n\n    return <!NULL_FOR_NONNULL_TYPE!>null<!>\n}\n\nfun <T> baz(): T? = null\n\nfun <T> foobar(): T = <!NULL_FOR_NONNULL_TYPE!>null<!>\n\nclass A<F> {\n    fun xyz(x: F) {}\n\n    fun foo(): F {\n        val x1: F = <!NULL_FOR_NONNULL_TYPE!>null<!>\n        val x2: F? = null\n\n        xyz(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n        bar<F?>(null)\n\n        return <!NULL_FOR_NONNULL_TYPE!>null<!>\n    }\n\n    fun baz(): F? = null\n\n    fun foobar(): F = <!NULL_FOR_NONNULL_TYPE!>null<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE\n\nclass A<F> {\n    fun <E : F> foo1(x: E) = x\n    fun <E : F?> foo2(x: E) = x\n\n    fun <Z : F, W : Z?> bar(x: F, y: F?, z: Z, w: W) {\n        foo1<F>(x)\n\n        val x1 = foo1(x)\n        x1.checkType { _<F>() }\n\n        foo2<F>(x)\n\n        val x2 = foo2(x)\n        x2.checkType { _<F>() }\n\n        foo1<<!UPPER_BOUND_VIOLATED!>F?<!>>(y)\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo1<!>(<!NI;TYPE_MISMATCH!>y<!>)\n        foo2<F?>(y)\n\n        val x3 = foo2(y)\n        x3.checkType { _<F?>() }\n\n        foo1<F>(<!TYPE_MISMATCH!>y<!>)\n        foo2<F>(<!TYPE_MISMATCH!>y<!>)\n\n        foo1<Z>(z)\n\n        val x4 = foo1(z)\n        x4.checkType { _<Z>() }\n\n        foo2<Z>(z)\n\n        val x5 = foo2(z)\n        x4.checkType { _<Z>() }\n\n        foo1<<!UPPER_BOUND_VIOLATED!>W<!>>(w)\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo1<!>(<!NI;TYPE_MISMATCH!>w<!>)\n        foo2<W>(w)\n\n        val x6 = foo2(w)\n        x6.checkType { _<W>() }\n\n        foo1<<!UPPER_BOUND_VIOLATED!>W<!>>(w)\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE\n\nclass A<F> {\n    class Inv<Q>\n    fun <E : Inv<F>> fooInv1(x: E) = x\n    fun <E : Inv<F?>> fooInv2(x: E) = x\n\n    class In<in Q>\n    fun <E : In<F>> fooIn1(x: E) = x\n    fun <E : In<F?>> fooIn2(x: E) = x\n\n    class Out<out Q>\n    fun <E : Out<F>> fooOut1(x: E) = x\n    fun <E : Out<F?>> fooOut2(x: E) = x\n\n    fun <Z : F, W : Z?> bar() {\n        // F\n        fooInv1<Inv<F>>(Inv<F>())\n        fooInv2<<!UPPER_BOUND_VIOLATED!>Inv<F><!>>(Inv<F>())\n        fooInv1(Inv<F>())\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooInv2<!>(<!NI;TYPE_MISMATCH!>Inv<F>()<!>)\n\n        fooIn1<In<F?>>(In<F?>())\n        fooIn2<In<F?>>(In<F?>())\n        fooIn1(In<F?>())\n        fooIn2(In<F?>())\n\n        fooOut1<Out<F>>(Out<F>())\n        fooOut2<Out<F>>(Out<F>())\n        fooOut1(Out<F>())\n        fooOut2(Out<F>())\n\n        // Z\n        fooInv1<<!UPPER_BOUND_VIOLATED!>Inv<Z><!>>(Inv<Z>())\n        fooInv2<<!UPPER_BOUND_VIOLATED!>Inv<Z><!>>(Inv<Z>())\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooInv1<!>(<!NI;TYPE_MISMATCH!>Inv<Z>()<!>)\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooInv2<!>(<!NI;TYPE_MISMATCH!>Inv<Z>()<!>)\n\n        fooIn1<<!UPPER_BOUND_VIOLATED!>In<Z?><!>>(In<Z?>())\n        fooIn2<<!UPPER_BOUND_VIOLATED!>In<Z?><!>>(In<Z?>())\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooIn1<!>(<!NI;TYPE_MISMATCH!>In<Z?>()<!>)\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooIn2<!>(<!NI;TYPE_MISMATCH!>In<Z?>()<!>)\n\n        fooOut1<Out<Z>>(Out<Z>())\n        fooOut2<Out<Z>>(Out<Z>())\n        fooOut1(Out<Z>())\n        fooOut2(Out<Z>())\n\n        // W\n        fooInv1<<!UPPER_BOUND_VIOLATED!>Inv<W><!>>(Inv<W>())\n        fooInv2<<!UPPER_BOUND_VIOLATED!>Inv<W><!>>(Inv<W>())\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooInv1<!>(<!NI;TYPE_MISMATCH!>Inv<W>()<!>)\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooInv2<!>(<!NI;TYPE_MISMATCH!>Inv<W>()<!>)\n\n        fooIn1<<!UPPER_BOUND_VIOLATED!>In<W?><!>>(In<W?>())\n        fooIn2<<!UPPER_BOUND_VIOLATED!>In<W?><!>>(In<W?>())\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooIn1<!>(<!NI;TYPE_MISMATCH!>In<W?>()<!>)\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooIn2<!>(<!NI;TYPE_MISMATCH!>In<W?>()<!>)\n\n        fooOut1<<!UPPER_BOUND_VIOLATED!>Out<W><!>>(Out<W>())\n        fooOut2<Out<W>>(Out<W>())\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooOut1<!>(<!NI;TYPE_MISMATCH!>Out<W>()<!>)\n        fooOut2(Out<W>())\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun <E : String?, T : ((CharSequence) -> Unit)?> foo(x: E, y: T) {\n    if (x != null) {\n        <!NI;UNSAFE_CALL, OI;UNSAFE_IMPLICIT_INVOKE_CALL!>y<!>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n\n    if (y != null) {\n        <!DEBUG_INFO_SMARTCAST!>y<!>(<!TYPE_MISMATCH!>x<!>)\n    }\n\n    if (x != null && y != null) {\n        <!DEBUG_INFO_SMARTCAST!>y<!>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\ninline fun <T, reified S> foo(x: T?, y: T): T {\n    if (x is S) return <!TYPE_MISMATCH!>x<!>\n    return y\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE\n\nfun <T : CharSequence?> bar1(x: T) {}\n\nfun bar2(x: CharSequence?) {}\n\nfun <T : CharSequence> bar3(x: T) {}\n\nfun bar4(x: String) {}\n\nfun <T : String?> foo(x: T) {\n    bar1(x)\n    bar2(x)\n\n    <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>bar3<!>(<!NI;TYPE_MISMATCH!>x<!>)\n    bar4(<!TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "public fun foo(a: Any, <!UNUSED_PARAMETER!>b<!>: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Map<!>) {\n    when (a) {\n        is Map<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!> -> {}\n        is <!NO_TYPE_ARGUMENTS_ON_RHS!>Map<!> -> {}\n        is Map<out Any?, Any?> -> {}\n        is <!DUPLICATE_LABEL_IN_WHEN!>Map<*, *><!> -> {}\n        is Map<<!SYNTAX!><!>> -> {}\n        is List<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Map<!>> -> {}\n        is <!NO_TYPE_ARGUMENTS_ON_RHS!>List<!> -> {}\n        is Int -> {}\n        else -> {}\n    }\n}"
        },
        {
            "code": "interface I0<T : <!UNRESOLVED_REFERENCE!>Unresolved0<!><String>>\ninterface I1<T> where T : <!UNRESOLVED_REFERENCE!>Unresolved1<!><String>\ninterface I2<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T : <!UNRESOLVED_REFERENCE!>Unresolved2<!><String><!>> where T : <!UNRESOLVED_REFERENCE!>Unresolved3<!><String>\n\nfun <E : <!UNRESOLVED_REFERENCE!>Unresolved4<!><String>> foo0() {}\nfun <E> foo1() where E : <!UNRESOLVED_REFERENCE!>Unresolved5<!><String> {}\nfun <<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>E : <!UNRESOLVED_REFERENCE!>Unresolved6<!><String><!>> foo2() where E : <!UNRESOLVED_REFERENCE!>Unresolved7<!><String> {}\n\nval <E : <!UNRESOLVED_REFERENCE!>Unresolved7<!>> E.p1: Int\n        get() = 1\nval <E> E.p2: Int where E : <!UNRESOLVED_REFERENCE!>Unresolved8<!>\n        get() = 1\nval <<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>E : <!UNRESOLVED_REFERENCE!>Unresolved9<!><!>> E.p3: Int where E : <!UNRESOLVED_REFERENCE!>Unresolved10<!>\n        get() = 1\n"
        },
        {
            "code": "\nfun<T1, <!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T2, T3, <!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T4> foo() {\n\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline fun <reified T> f(): T = throw UnsupportedOperationException()\n\nfun <T> id(p: T): T = p\n\nfun <A> main() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>f<!>()\n\n    val <!UNUSED_VARIABLE!>a<!>: A = <!TYPE_PARAMETER_AS_REIFIED!>f<!>()\n    f<<!TYPE_PARAMETER_AS_REIFIED!>A<!>>()\n\n    val <!UNUSED_VARIABLE!>b<!>: Int = f()\n    f<Int>()\n\n    val <!UNUSED_VARIABLE!><!>: A = id(<!NI;TYPE_PARAMETER_AS_REIFIED, TYPE_PARAMETER_AS_REIFIED!>f<!>())\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -NOT_YET_SUPPORTED_IN_INLINE\n\ninline fun<reified T> foo(x: T) {\n    fun<<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> R> bar() {\n\n    }\n\n    bar<T>()\n}\n"
        },
        {
            "code": "\nfun <T: Any> dereferenceClass(): Any =\n        <!TYPE_PARAMETER_AS_REIFIED!>T::class<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline operator fun <reified T> T.plus(p: T): T = this\n\ninline operator fun <reified T> T.invoke(): T  = this\n\nfun <A> main(tp: A, any: Any) {\n    tp <!TYPE_PARAMETER_AS_REIFIED!>+<!> tp\n    any + any\n\n    <!TYPE_PARAMETER_AS_REIFIED!>tp<!>()\n    any()\n}"
        },
        {
            "code": "val <<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T> T.v: T\n    get() = throw UnsupportedOperationException()\n"
        },
        {
            "code": "class C<<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T>\n\nfun <A> main(<!UNUSED_PARAMETER!>p1<!>: C<A>, <!UNUSED_PARAMETER!>p2<!>: C<Int>) {\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A<F>\n\ninline fun <reified T> foo(x: A<T>) {}\n\nfun test(x: A<out CharSequence>) {\n    <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>foo<!>(x)\n}\n"
        },
        {
            "code": "class A<T1, <!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T2, T3, <!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T4> {\n    fun<<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> R> foo(): T2 = throw UnsupportedOperationException()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass C<<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T>\n\nfun <T> id(p: T): T = p\n\nfun <A> main() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>C<!>()\n\n    val <!UNUSED_VARIABLE!>a<!>: C<A> = <!TYPE_PARAMETER_AS_REIFIED!>C<!>()\n    C<<!TYPE_PARAMETER_AS_REIFIED!>A<!>>()\n\n    val <!UNUSED_VARIABLE!>b<!>: C<Int> = C()\n    C<Int>()\n\n    // TODO svtk, uncomment when extensions are called for nested calls!\n    //val < !UNUSED_VARIABLE!>< !>: C<A> = id(< !TYPE_PARAMETER_AS_REIFIED!>C< !>())\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-5508 Stackoverflow in type substitution\n\nabstract class A<T> {\n    public abstract fun foo(x: T)\n    public abstract fun bar(x: T)\n\n    public inner abstract class B<S> : A<B<S>>() {\n        public inner <!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class C<!><U> : <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>B<!><C<U>>()\n        {\n            // Here B<C<U>> means A<A<A<T>.B<S>>.B<A<T>.B<S>.C<U>>>.B<A<A<T>.B<S>>.B<A<T>.B<S>.C<U>>.C<U>>\n            // while for being a correct override it should be A<A<T>.B<S>>.B<A<T>.B<S>.C<U>>\n            // It happens because at the beginning we search implicit arguments for an outer classes through supertypes\n            // See TypeResolver.computeImplicitOuterClassArguments for clarifications\n            <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: B<C<U>>)  {\n                throw UnsupportedOperationException()\n            }\n\n            override fun bar(x: A<A<T>.B<S>>.B<A<T>.B<S>.C<U>>) {\n                throw UnsupportedOperationException()\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nenum class Color {\n    RED {\n        fun <T : <!ENUM_ENTRY_AS_TYPE, FINAL_UPPER_BOUND!>RED<!>> simpleName(): <!ENUM_ENTRY_AS_TYPE!>RED<!> = null!!\n    }\n}\n\nclass MyColor(val x: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>, y: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>) : Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> {\n\n    var z: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> = <!TYPE_MISMATCH!>Color.RED<!>\n    set(arg: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>) { z = arg }\n\n    fun foo(arg: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>): Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> = arg\n\n    fun bar(): Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> {\n        class Local : Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>\n        fun local(arg: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>): Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> = arg\n        val temp: Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> = <!TYPE_MISMATCH!>Color.RED<!>\n        temp <!USELESS_CAST!>as? Color.<!ENUM_ENTRY_AS_TYPE!>RED<!><!>\n        if (<!USELESS_IS_CHECK!>temp is <!IS_ENUM_ENTRY!>Color.<!ENUM_ENTRY_AS_TYPE!>RED<!><!><!>) {\n        return temp <!USELESS_CAST!>as Color.<!ENUM_ENTRY_AS_TYPE!>RED<!><!>\n    }\n        val obj = object : Color.<!ENUM_ENTRY_AS_TYPE!>RED<!> {}\n        if (<!USELESS_IS_CHECK!>obj is <!IS_ENUM_ENTRY!>Color.<!ENUM_ENTRY_AS_TYPE!>RED<!><!><!>) {\n        return obj\n    }\n        return <!TYPE_MISMATCH!>Color.RED<!>\n    }\n}\n\nfun create(): Array<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>? = null\n\ninterface Your<T : <!FINAL_UPPER_BOUND!>Color.<!ENUM_ENTRY_AS_TYPE!>RED<!><!>>\n\nclass His : Your<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>\n\nfun <T : <!FINAL_UPPER_BOUND!>Color.<!ENUM_ENTRY_AS_TYPE!>RED<!><!>> otherCreate(): Array<T>? = null\n\ntypealias RedAlias = Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>\n\ntypealias ArrayOfEnumEntry = Array<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>\n\ntypealias ArrayOfEnumEntryAlias = Array<RedAlias>\n\nfun <T> bar(a: Any): T = a <!UNCHECKED_CAST!>as T<!>\n\nfun <T> foo() {\n    foo<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>()\n    foo<RedAlias>()\n    bar<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>(Color.RED)\n}\n\nfun Array<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>.foo(entries: Array<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>>): Array<Color.<!ENUM_ENTRY_AS_TYPE!>RED<!>> = null!!"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNREACHABLE_CODE\n\nfun none() {}\n\nfun unitEmptyInfer() {}\nfun unitEmpty() : Unit {}\nfun unitEmptyReturn() : Unit {return}\nfun unitIntReturn() : Unit {return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>}\nfun unitUnitReturn() : Unit {return Unit}\nfun test1() : Any = {<!RETURN_NOT_ALLOWED, RETURN_TYPE_MISMATCH!>return<!>}\nfun test2() : Any = a@ {return@a 1}\nfun test3() : Any { <!RETURN_TYPE_MISMATCH!>return<!> }\nfun test4(): ()-> Unit = { <!RETURN_NOT_ALLOWED, RETURN_TYPE_MISMATCH!>return@test4<!> }\nfun test5(): Any = l@{ return@l }\nfun test6(): Any = {<!RETURN_NOT_ALLOWED!>return<!> 1}\n\nfun bbb() {\n    return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n}\n\nfun foo(<!UNUSED_PARAMETER!>expr<!>: StringBuilder): Int {\n    val c = 'a'\n    when(c) {\n        0.toChar() -> throw Exception(\"zero\")\n        else -> throw Exception(\"nonzero\" + c)\n    }\n}\n\n\nfun unitShort() : Unit = Unit\nfun unitShortConv() : Unit = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\nfun unitShortNull() : Unit = <!NULL_FOR_NONNULL_TYPE!>null<!>\n\nfun intEmpty() : Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun intShortInfer() = 1\nfun intShort() : Int = 1\n//fun intBlockInfer()  {1}\nfun intBlock() : Int {return 1}\nfun intBlock1() : Int {<!UNUSED_EXPRESSION!>1<!><!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun intString(): Int = <!TYPE_MISMATCH!>\"s\"<!>\nfun intFunctionLiteral(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 10 }<!>\n\nfun blockReturnUnitMismatch() : Int {<!RETURN_TYPE_MISMATCH!>return<!>}\nfun blockReturnValueTypeMismatch() : Int {return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>3.4<!>}\nfun blockReturnValueTypeMatch() : Int {return 1}\nfun blockReturnValueTypeMismatchUnit() : Int {return <!TYPE_MISMATCH!>Unit<!>}\n\nfun blockAndAndMismatch() : Int {\n    <!UNUSED_EXPRESSION!>true && false<!>\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockAndAndMismatch1() : Int {\n    return <!TYPE_MISMATCH!>true && false<!>\n}\nfun blockAndAndMismatch2() : Int {\n    (return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!>) && (return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>false<!>)\n}\n\nfun blockAndAndMismatch3() : Int {\n    <!UNUSED_EXPRESSION!>true || false<!>\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockAndAndMismatch4() : Int {\n    return <!TYPE_MISMATCH!>true || false<!>\n}\nfun blockAndAndMismatch5() : Int {\n    (return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!>) || (return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>false<!>)\n}\nfun blockReturnValueTypeMatch1() : Int {\n    return <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (1 > 2) <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!> else <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>2.0<!><!>\n}\nfun blockReturnValueTypeMatch2() : Int {\n    return <!TYPE_MISMATCH!><!INVALID_IF_AS_EXPRESSION!>if<!> (1 > 2) 1<!>\n}\nfun blockReturnValueTypeMatch3() : Int {\n    return <!TYPE_MISMATCH!><!INVALID_IF_AS_EXPRESSION!>if<!> (1 > 2) else 1<!>\n}\nfun blockReturnValueTypeMatch4() : Int {\n    if (1 > 2)\n        return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>\n    else return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2.0<!>\n}\nfun blockReturnValueTypeMatch5() : Int {\n    if (1 > 2)\n        return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>\n    return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2.0<!>\n}\nfun blockReturnValueTypeMatch6() : Int {\n    if (1 > 2)\n    else return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>\n    return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2.0<!>\n}\nfun blockReturnValueTypeMatch7() : Int {\n    if (1 > 2)\n    <!UNUSED_EXPRESSION!>1.0<!>\n    else <!UNUSED_EXPRESSION!>2.0<!>\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockReturnValueTypeMatch8() : Int {\n    if (1 > 2)\n    <!UNUSED_EXPRESSION!>1.0<!>\n    else <!UNUSED_EXPRESSION!>2.0<!>\n    return 1\n}\nfun blockReturnValueTypeMatch9() : Int {\n    if (1 > 2)\n    <!UNUSED_EXPRESSION!>1.0<!>\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockReturnValueTypeMatch10() : Int {\n    return <!TYPE_MISMATCH!><!INVALID_IF_AS_EXPRESSION!>if<!> (1 > 2)\n    1<!>\n}\nfun blockReturnValueTypeMatch11() : Int {\n    if (1 > 2)\n    else <!UNUSED_EXPRESSION!>1.0<!>\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockReturnValueTypeMatch12() : Int {\n    if (1 > 2)\n        return 1\n    else return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>\n}\nfun blockNoReturnIfValDeclaration(): Int {\n    val <!UNUSED_VARIABLE!>x<!> = 1\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockNoReturnIfEmptyIf(): Int {\n    if (1 < 2) {} else {}\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun blockNoReturnIfUnitInOneBranch(): Int {\n    if (1 < 2) {\n        return 1\n    } else {\n        if (3 < 4) {\n        } else {\n            return 2\n        }\n    }\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun nonBlockReturnIfEmptyIf(): Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (1 < 2) <!OI;TYPE_MISMATCH!>{}<!> else <!OI;TYPE_MISMATCH!>{}<!><!>\nfun nonBlockNoReturnIfUnitInOneBranch(): Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (1 < 2) <!OI;TYPE_MISMATCH!>{}<!> else 2<!>\n\nval a = <!RETURN_NOT_ALLOWED!>return<!> 1\n\nclass A() {\n}\nfun illegalConstantBody(): Int = <!TYPE_MISMATCH!>\"s\"<!>\nfun illegalConstantBlock(): String {\n    return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n}\nfun illegalIfBody(): Int =\n        <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (1 < 2) <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>'a'<!> else { <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!> }<!>\nfun illegalIfBlock(): Boolean {\n    if (1 < 2)\n        return false\n    else { return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> }\n}\nfun illegalReturnIf(): Char {\n    return <!NI;TYPE_MISMATCH!>if (1 < 2) 'a' else { <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> }<!>\n}\n\nfun returnNothing(): Nothing {\n    throw <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n}\nfun f(): Int {\n    if (1 < 2) { return 1 } else returnNothing()\n}\n\nfun f1(): Int = if (1 < 2) 1 else returnNothing()\n\npublic fun f2() = 1\nclass B() {\n    protected fun f() = \"ss\"\n}\n\nfun testFunctionLiterals() {\n    val <!UNUSED_VARIABLE!>endsWithVarDeclaration<!> : () -> Boolean = {\n        <!EXPECTED_TYPE_MISMATCH!>val <!UNUSED_VARIABLE!>x<!> = 2<!>\n    }\n\n    val <!UNUSED_VARIABLE!>endsWithAssignment<!>: () -> Int = {\n        var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>x<!> = 1\n        <!EXPECTED_TYPE_MISMATCH!><!UNUSED_VALUE!>x =<!> 333<!>\n    }\n\n    val <!UNUSED_VARIABLE!>endsWithReAssignment<!>: () -> Int = {\n        var x = 1\n        <!ASSIGNMENT_TYPE_MISMATCH!>x += 333<!>\n    }\n\n    val <!UNUSED_VARIABLE!>endsWithFunDeclaration<!> : () -> String = {\n        var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>x<!> = 1\n        <!UNUSED_VALUE!>x =<!> 333\n        <!EXPECTED_TYPE_MISMATCH!>fun meow() : Unit {}<!>\n    }\n\n    val <!UNUSED_VARIABLE!>endsWithObjectDeclaration<!> : () -> Int = {\n        var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>x<!> = 1\n        <!UNUSED_VALUE!>x =<!> 333\n        <!EXPECTED_TYPE_MISMATCH, LOCAL_OBJECT_NOT_ALLOWED!>object A<!> {}\n    }\n\n    val <!UNUSED_VARIABLE!>expectedUnitReturnType1<!>: () -> Unit = {\n        val <!UNUSED_VARIABLE!>x<!> = 1\n    }\n\n    val <!UNUSED_VARIABLE!>expectedUnitReturnType2<!>: () -> Unit = {\n        fun meow() : Unit {}\n        <!LOCAL_OBJECT_NOT_ALLOWED!>object A<!> {}\n    }\n\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface Tr\n\nclass A { companion object }\nclass B { companion object : Tr }\n\nfun Any.f1() {}\nfun Any?.f2() {}\nfun Tr.f3() {}\nfun Tr?.f4() {}\nfun A.f5() {}\n\nfun test() {\n    A.f1()\n    A.f2()\n    B.f3()\n    B.f4()\n    A.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>f5<!>()\n    B.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>f5<!>()\n}"
        },
        {
            "code": "interface T {\n    fun foo() {}\n    fun buzz() {}\n    fun buzz1(i : Int) {}\n}\n\nfun T.bar() {}\n\nfun T.<!EXTENSION_SHADOWED_BY_MEMBER!>buzz<!>() {}\nfun T.buzz1() {}\n\nclass C : T {\n    fun test() {\n        fun T.<!EXTENSION_SHADOWED_BY_MEMBER!>buzz<!>() {}\n        fun T.buzz1() {}\n        super.foo() // OK\n        <!SUPER_CANT_BE_EXTENSION_RECEIVER!>super<!>.bar() // Error\n        super.buzz() // OK, resolved to a member\n        <!SUPER_CANT_BE_EXTENSION_RECEIVER!>super<!>.buzz1() // Resolved to an extension\n        super.buzz1(<!TYPE_MISMATCH!>\"\"<!>) // Resolved to a member\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-1875 Safe call should be binded with receiver or this object (but not with both by default)\n\npackage kt1875\n\nfun foo(a : Int?, b : Int.(Int)->Int) = a?.b(1) //unnecessary safe call warning\n\ninterface T {\n    val f : ((i: Int) -> Unit)?\n}\n\nfun test(t: T) {\n    t<!NI;UNSAFE_CALL!>.<!><!OI;UNSAFE_IMPLICIT_INVOKE_CALL!>f<!>(1) //unsafe call error\n    t.f?.invoke(1)\n}\n\nfun test1(t: T?) {\n    t<!UNSAFE_CALL!>.<!><!FUNCTION_EXPECTED!>f<!>(1) // todo resolve f as value and report UNSAFE_CALL\n    t<!NI;UNSAFE_CALL!>?.<!><!OI;UNSAFE_IMPLICIT_INVOKE_CALL!>f<!>(1)\n    t<!UNSAFE_CALL!>.<!>f?.invoke(1)\n    t?.f?.invoke(1)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: b.kt\npackage outer\n\nfun Int?.optint() : Unit {}\nval Int?.optval : Unit get() = Unit\n\nfun <T: Any, E> T.foo(<!UNUSED_PARAMETER!>x<!> : E, y : A) : T   {\n  y.plus(1)\n  y plus 1\n  y + 1.0\n\n  this<!UNNECESSARY_SAFE_CALL!>?.<!>minus<T>(this)\n\n  return this\n}\n\nclass A\n\ninfix operator fun A.plus(<!UNUSED_PARAMETER!>a<!> : Any) {\n\n  1.foo()\n  true.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(<!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>\n\n  <!UNUSED_EXPRESSION!>1<!>\n}\n\noperator fun A.plus(<!UNUSED_PARAMETER!>a<!> : Int) {\n  <!UNUSED_EXPRESSION!>1<!>\n}\n\noperator fun <T> T.minus(<!UNUSED_PARAMETER!>t<!> : T) : Int = 1\n\nfun test() {\n  val <!UNUSED_VARIABLE!>y<!> = 1.abs\n}\nval Int.abs : Int\n  get() = if (this > 0) this else -this;\n\n<!EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT!>val <T> T.foo : T<!>\n\nfun Int.foo() = this\n\n// FILE: b.kt\npackage null_safety\n\nimport outer.*\n\n        fun parse(<!UNUSED_PARAMETER!>cmd<!>: String): Command? { return null  }\n        class Command() {\n        //  fun equals(other : Any?) : Boolean\n          val foo : Int = 0\n        }\n\n        fun Any.<!EXTENSION_SHADOWED_BY_MEMBER!>equals<!>(<!UNUSED_PARAMETER!>other<!> : Any?) : Boolean = true\n        fun Any?.equals1(<!UNUSED_PARAMETER!>other<!> : Any?) : Boolean = true\n        fun Any.equals2(<!UNUSED_PARAMETER!>other<!> : Any?) : Boolean = true\n\n        fun main() {\n\n            System.out.print(1)\n\n            val command = parse(\"\")\n\n            command.foo\n\n            command<!UNSAFE_CALL!>.<!>equals(null)\n            command?.equals(null)\n            command.equals1(null)\n            command?.equals1(null)\n\n            val c = Command()\n            c<!UNNECESSARY_SAFE_CALL!>?.<!>equals2(null)\n\n            if (command == null) <!UNUSED_EXPRESSION!>1<!>\n        }\n"
        },
        {
            "code": "// FILE: B.kt\nfun Any?.bar() = 42\n\nfun f1() = A.<!UNRESOLVED_REFERENCE!>bar<!>()\nfun f2() = A.Nested.<!UNRESOLVED_REFERENCE!>bar<!>()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage bar\n\n\n// should be thrown away\n\nfun <R> List<R>.a() {}\n\nfun test1(i: Int?) {\n    1.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>a<!>()\n    i.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>a<!>()\n}\n\nfun <R> test2(c: Collection<R>) {\n    c.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>a<!>()\n}\n\nfun Int.foo() {}\n\nfun test3(s: String?) {\n    \"\".<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>()\n    s.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>()\n    \"\".<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>(1)\n    s.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!>(\"a\")\n}\n\ninterface A\nfun <T: A> T.c() {}\n\nfun test4() {\n    1.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>c<!>()\n}\n\n\n// should be an error on receiver, shouldn't be thrown away\n\nfun test5() {\n    <!OI;TYPE_MISMATCH!>1<!>.<!NI;FUNCTION_EXPECTED!>(fun String.()=1)<!>()\n}\n\nfun <R: Any> R?.sure() : R = this!!\n\nfun <T> test6(l: List<T>?) {\n    <!OI;TYPE_MISMATCH!>l<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>sure<!><<!OI;UPPER_BOUND_VIOLATED!>T<!>>()\n}\n\n\nfun List<String>.b() {}\n\nfun test7(l: List<String?>) {\n    <!OI;TYPE_MISMATCH!>l<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>b<!>()\n}\n\nfun test8(l: List<Any>?) {\n    <!OI;TYPE_MISMATCH!>l<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>b<!>()\n}"
        },
        {
            "code": "class A(foo: Int.() -> Unit) {\n    init {\n        4.foo()\n    }\n}\n\nfun test(foo: Int.(String) -> Unit) {\n    4.foo(\"\")\n    4.foo(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>p1<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    4.foo(<!NAMED_ARGUMENTS_NOT_ALLOWED!>p2<!> = \"\")\n}"
        },
        {
            "code": "//KT-819 Redeclaration error for extension properties with the same name and different receivers\n\nimport java.io.*\n\nval InputStream.buffered : BufferedInputStream\n    get() = if(this is BufferedInputStream) <!DEBUG_INFO_SMARTCAST!>this<!> else BufferedInputStream(this)\n\nval Reader.buffered : BufferedReader\n    get() = if(this is BufferedReader) <!DEBUG_INFO_SMARTCAST!>this<!> else BufferedReader(this)\n\n\n//more tests\nopen class A() {\n    open fun String.foo() {}\n    open fun Int.foo() {}\n\n    open val String.foo: Int\n        get() = 0\n    open val Int.foo: Int\n        get() = 1\n}\n\nclass B() : A() {\n    override fun String.foo() {}\n    override fun Int.foo() {}\n\n    override val String.foo: Int\n        get() = 0\n    override val Int.foo: Int\n        get() = 0\n\n    fun use(s: String) {\n        s.foo\n        s.foo()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface JPAEntityClass<D> {\n    fun <T> T.findByName(s: String): D {null!!}\n}\n\nclass Foo {\n    companion object : JPAEntityClass<Foo>\n}\n\nfun main() {\n    with(\"\", {\n        Foo.<!UNRESOLVED_REFERENCE!>findByName<!>(\"\")\n    })\n    with(Foo) {\n        findByName(\"\")\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-3563 Compiler requiring java.io.File, and it's unclear why\n\npackage bar\n\nimport java.io.File\n\nclass Customer(<!UNUSED_PARAMETER!>name1<!>: String)\n\nfun foo(f: File, c: Customer) {\n    f.name1\n\n    c.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>name1<!> // name1 should be unresolved here\n}\n\nval File.name1: String\n    get() = getName()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nclass A {}\n\nfun test(a1: A, a2: A) {\n    val <!UNUSED_VARIABLE!>range<!> = \"island\"..\"isle\"\n\n    a1<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>..<!>a2\n}\n\n\npublic operator fun <T: Comparable<T>> T.rangeTo(<!UNUSED_PARAMETER!>that<!>: T): ClosedRange<T> {\n    throw UnsupportedOperationException()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T> getT() {}\nfun <A, B> getTT() {}\nfun <A, B, C> getTTT(<!UNUSED_PARAMETER!>x<!> : Any) {}\nfun foo(<!UNUSED_PARAMETER!>a<!> : Any?) {}\n\npublic fun main() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getT<!><<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>>()\n    <!UNRESOLVED_REFERENCE!>ggetT<!><<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>>()\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getTT<!><<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>, <!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>>()\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getTT<!><<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>, Int>()\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getTT<!><Int, <!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>>()\n    foo(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getTTT<!><Int, <!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>*<!>, Int>(1))\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\nfun test(<!VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION!>a<!>) {\n\n}\n\nclass A(a<!SYNTAX!><!>)\n\nval bar = fun(<!CANNOT_INFER_PARAMETER_TYPE!>a<!>){}\n\nval la = { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> }\nval las = { a: Int -> }"
        },
        {
            "code": "fun foo(f : () -> Unit) {\n    val <!UNUSED_VARIABLE!>x<!> : Unit = f()\n}\n"
        },
        {
            "code": "class X {\n  <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val x : Int<!>\n}\n\nopen class Y() {\n  val x : Int = 2\n}\n\nclass Y1 {\n  val x : Int get() = 1\n}\n\nclass Z : Y() {\n}\n\n//KT-650 Prohibit creating class without constructor.\n\nclass MyIterable<T> : Iterable<T>\n{\n    override fun iterator(): Iterator<T>  = MyIterator()\n\n    inner class MyIterator : Iterator<T>\n    {\n        override fun hasNext(): Boolean = false\n        override fun next(): T {\n            throw UnsupportedOperationException()\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun f(c: LongRange): Int {\n    return c.<!FUNCTION_EXPECTED!>start<!>()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo(x: String) {}\nfun foo(x: Int) {}\nfun foo(x: Int, y: String) {}\n\nfun bar(nullX: Int?, nullY: String?, notNullY: String) {\n    foo(<!TYPE_MISMATCH!>nullX<!>)\n    foo(<!TYPE_MISMATCH!>nullX<!>, notNullY)\n    foo(<!TYPE_MISMATCH!>nullX<!>, <!TYPE_MISMATCH!>nullY<!>)\n    <!NONE_APPLICABLE!>foo<!>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -SENSELESS_COMPARISON, -DEBUG_INFO_SMARTCAST\n\nfun <T: Any?> test1(t: Any?): Any {\n    return t <!UNCHECKED_CAST!>as T<!> ?: \"\"\n}\n\nfun <T: Any> test2(t: Any?): Any {\n    return t <!UNCHECKED_CAST!>as T<!> <!USELESS_ELVIS!>?: \"\"<!>\n}\n\nfun <T: Any?> test3(t: Any?): Any {\n    if (t != null) {\n        return t <!USELESS_ELVIS!>?: \"\"<!>\n    }\n\n    return 1\n}\n\nfun takeNotNull(s: String) {}\nfun <T> notNull(): T = TODO()\nfun <T> nullable(): T? = null\nfun <T> dependOn(x: T) = x\n\nfun test() {\n    takeNotNull(notNull() ?: \"\")\n    takeNotNull(nullable() ?: \"\")\n\n    val x: String? = null\n    takeNotNull(dependOn(x) ?: \"\")\n    takeNotNull(dependOn(dependOn(x)) ?: \"\")\n    takeNotNull(dependOn(dependOn(x as String)) <!USELESS_ELVIS!>?: \"\"<!>)\n\n    if (x != null) {\n        takeNotNull(dependOn(x) <!USELESS_ELVIS!>?: \"\"<!>)\n        takeNotNull(dependOn(dependOn(x)) <!USELESS_ELVIS!>?: \"\"<!>)\n        takeNotNull(dependOn(dependOn(x) as? String) ?: \"\")\n    }\n\n    takeNotNull(bar()!!)\n}\n\ninline fun <reified T : Any> reifiedNull(): T? = null\n\nfun testFrom13648() {\n    takeNotNull(reifiedNull() ?: \"\")\n}\n\nfun bar() = <!UNRESOLVED_REFERENCE!>unresolved<!>"
        },
        {
            "code": "fun <NN: Any, NNN: NN> nonMisleadingNullable(\n        <!UNUSED_PARAMETER!>nn<!>: NN?,\n        <!UNUSED_PARAMETER!>nnn<!>: NNN?\n) {}\n\nfun <T, N: T, INDIRECT: N> misleadingNullableSimple(\n        <!UNUSED_PARAMETER!>t<!>: T?,\n        <!UNUSED_PARAMETER!>t2<!>: T?,\n        <!UNUSED_PARAMETER!>n<!>: N?,\n        <!UNUSED_PARAMETER!>ind<!>: INDIRECT?\n) {}\n\nfun <T> interactionWithRedundant(<!UNUSED_PARAMETER!>t<!>: T?<!REDUNDANT_NULLABLE!>?<!>) {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: test.kt\n\nfun test(j: J, nullStr: String?, nullByte: Byte?, nullDouble: Double?) {\n    j.foo(nullStr)\n    j.foo(<!TYPE_MISMATCH!>nullDouble<!>)\n    j.foo(nullByte)\n}"
        },
        {
            "code": "class A {\n    val b = B()\n}\nclass B\noperator fun B.invoke(i: Int) = i\n\nfun foo(i: Int) = i\n\nfun test(a: A?) {\n    a?.b(1) //should be no warning\n    foo(<!TYPE_MISMATCH!>a?.b(1)<!>) //no warning, only error\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun <T> test(t: T): T {\n    if (t != null) {\n        return t<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n    return <!ALWAYS_NULL!>t<!>!!\n}\n\nfun <T> T.testThis(): String {\n    if (this != null) {\n        return this<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.toString()\n    }\n    return this!!.toString()\n}\n\n"
        },
        {
            "code": "class Generic<T>\n\nfun redundantNullable(\n        <!UNUSED_PARAMETER!>i<!>: Int?<!REDUNDANT_NULLABLE!>?<!>,\n        <!UNUSED_PARAMETER!>three<!>: Int?<!REDUNDANT_NULLABLE!>?<!><!REDUNDANT_NULLABLE!>?<!>,\n        <!UNUSED_PARAMETER!>gOut<!>: Generic<Int>?<!REDUNDANT_NULLABLE!>?<!>,\n        <!UNUSED_PARAMETER!>gIn<!>: Generic<Int?<!REDUNDANT_NULLABLE!>?<!>>\n) {\n}"
        },
        {
            "code": "interface A\ninterface X: A<!NULLABLE_SUPERTYPE!>?<!><!REDUNDANT_NULLABLE!>?<!> {\n\n}\n\nfun <T> interaction(t: T) {\n    if (t == null) {}\n\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun <T> test(t: T): String? {\n    if (t != null) {\n        return t<!UNNECESSARY_SAFE_CALL!>?.<!>toString()\n    }\n    return <!DEBUG_INFO_CONSTANT!>t<!>?.toString()\n}\n\nfun <T> T.testThis(): String? {\n    if (this != null) {\n        return this<!UNNECESSARY_SAFE_CALL!>?.<!>toString()\n    }\n    return <!OI;DEBUG_INFO_CONSTANT!>this<!>?.toString()\n}"
        },
        {
            "code": "fun test(x: Int?) {\n     <!TYPE_MISMATCH!>x<!> in 1..2\n}"
        },
        {
            "code": "interface P<U, Y>\n\nclass A<T> {\n    class B {\n        fun test() {\n            class C<W>() : P<W, <!UNRESOLVED_REFERENCE!>T<!>> {\n                <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object : P<<!UNRESOLVED_REFERENCE!>W<!>, <!UNRESOLVED_REFERENCE!>T<!>> {\n                }\n\n                inner class D : P<W, <!UNRESOLVED_REFERENCE!>T<!>>\n            }\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +InnerClassInEnumEntryClass -NestedClassesInEnumEntryShouldBeInner\n\nenum class Enum {\n    ENTRY_WITH_CLASS {\n        inner class TestInner\n\n        <!NESTED_CLASS_DEPRECATED!>class TestNested<!>\n\n        <!NESTED_CLASS_DEPRECATED!>interface TestInterface<!>\n\n        <!NESTED_CLASS_DEPRECATED!>object TestObject<!>\n\n        <!NESTED_CLASS_DEPRECATED!>enum class TestEnumClass<!> {\n            OTHER_ENTRY\n        }\n\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {}\n    }\n}\n"
        },
        {
            "code": "// KT-6026 Exception on instantiating a nested class in an anonymous object\n\nval oo = object {\n    // Forbidden in KT-13510\n    <!NESTED_CLASS_NOT_ALLOWED!>class Nested<!>\n\n    fun f1() = Nested(<!TOO_MANY_ARGUMENTS!>11<!>)\n}\n"
        },
        {
            "code": "open class SomeClass<T>\nclass TestSome<P> {\n    companion object : SomeClass<<!UNRESOLVED_REFERENCE!>P<!>>() {\n    }\n}\n\nclass Test {\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : <!DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>InnerClass<!>() {\n        val a = object: <!DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>InnerClass<!>() {\n        }\n\n        fun more(): InnerClass {\n            val b = <!RESOLUTION_TO_CLASSIFIER!>InnerClass<!>()\n\n            val <!UNUSED_VARIABLE!>testVal<!> = <!UNRESOLVED_REFERENCE!>inClass<!>\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n\n            return <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b<!>\n        }\n    }\n\n    val inClass = 12\n    fun foo() {}\n\n    open inner class <!CYCLIC_SCOPES_WITH_COMPANION!>InnerClass<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: -InnerClassInEnumEntryClass -NestedClassesInEnumEntryShouldBeInner\n\nenum class Enum {\n    ENTRY_WITH_CLASS {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class TestInner\n\n        <!NESTED_CLASS_DEPRECATED!>class TestNested<!>\n\n        <!NESTED_CLASS_DEPRECATED!>interface TestInterface<!>\n\n        <!NESTED_CLASS_DEPRECATED!>object TestObject<!>\n\n        <!NESTED_CLASS_DEPRECATED!>enum class TestEnumClass<!> {\n            OTHER_ENTRY\n        }\n\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {}\n    }\n}\n"
        },
        {
            "code": "package test\n\nclass B {\n    class B {\n      fun foo(<!UNUSED_PARAMETER!>b<!>: B.C) {\n      }\n      class C {\n      }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// KT-4351 Cannot resolve reference to self in init of class local to function\n\nfun f() {\n    class MyClass() {\n        init {\n            val x: MyClass = MyClass()\n        }\n\n        fun member() {\n            val x: MyClass = MyClass()\n        }\n    }\n\n    <!LOCAL_OBJECT_NOT_ALLOWED!>object MyObject<!> {\n        init {\n            val obj: MyObject = MyObject\n        }\n    }\n\n    val x: MyClass = MyClass()\n}\n\nval closure = {\n    class MyClass {\n        init {\n            val x: MyClass = MyClass()\n        }\n    }\n}"
        },
        {
            "code": "class Outer {\n    open class OpenNested\n    class FinalNested\n    \n    open inner class OpenInner\n    class FinalInner\n\n    class Nested1 : OpenNested()\n    class Nested2 : <!FINAL_SUPERTYPE!>FinalNested<!>()\n    class Nested3 : <!DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>OpenInner<!>()\n    class Nested4 : <!FINAL_SUPERTYPE!>FinalInner<!>()\n\n    inner class Inner1 : OpenNested()\n    inner class Inner2 : <!FINAL_SUPERTYPE!>FinalNested<!>()\n    inner class Inner3 : OpenInner()\n    inner class Inner4 : <!FINAL_SUPERTYPE!>FinalInner<!>()\n}"
        },
        {
            "code": "// NI_EXPECTED_FILE\n\ninterface Trait {\n    fun bar() = 42\n}\n\nclass Outer : Trait {\n    class Nested {\n        val t = this<!UNRESOLVED_REFERENCE!>@Outer<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n        val s = <!DEBUG_INFO_MISSING_UNRESOLVED!>super<!><!UNRESOLVED_REFERENCE!>@Outer<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n        \n        inner class NestedInner {\n            val t = this<!UNRESOLVED_REFERENCE!>@Outer<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n            val s = <!DEBUG_INFO_MISSING_UNRESOLVED!>super<!><!UNRESOLVED_REFERENCE!>@Outer<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n        }\n    }\n    \n    inner class Inner {\n        val t = this@Outer.bar()\n        val s = super@Outer.bar()\n    }\n}"
        },
        {
            "code": "interface Trait {\n    fun bar() = 42\n}\n\nclass Outer : Trait {\n    fun foo() {\n        val <!UNUSED_VARIABLE!>t<!> = this@Outer\n        val <!UNUSED_VARIABLE!>s<!> = super@Outer.bar()\n        \n        class Local : Trait {\n            val t = this@Outer\n            val s = super@Outer.bar()\n            \n            inner class Inner {\n                val t = this@Local\n                val s = super@Local.bar()\n                \n                val tt = this@Outer\n                val ss = super@Outer.bar()\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "class Outer {\n    class Nested {\n        fun foo() {\n            class Local {\n                val state = <!UNRESOLVED_REFERENCE!>outerState<!>\n            }\n        }\n    }\n    \n    val outerState = 42\n}"
        },
        {
            "code": "open class Outer {\n    private class PrivateNested\n    private inner class PrivateInner\n\n    protected class ProtectedNested\n    protected inner class ProtectedInner\n\n    public class PublicNested\n    public inner class PublicInner\n}\n\nclass Derived : Outer() {\n    fun foo() {\n        Outer.<!INVISIBLE_MEMBER!>PrivateNested<!>()\n        super.<!INVISIBLE_MEMBER!>PrivateInner<!>()\n\n        Outer.ProtectedNested()\n        super.ProtectedInner()\n\n        Outer.PublicNested()\n        super.PublicInner()\n    }\n}\n\nfun foo() {\n    Outer.<!INVISIBLE_MEMBER!>PrivateNested<!>()\n    Outer().<!INVISIBLE_MEMBER!>PrivateInner<!>()\n\n    Outer.<!INVISIBLE_MEMBER!>ProtectedNested<!>()\n    Outer().<!INVISIBLE_MEMBER!>ProtectedInner<!>()\n\n    Outer.PublicNested()\n    Outer().PublicInner()\n}\n"
        },
        {
            "code": "class Outer {\n    inner class Inner {\n        annotation <!NESTED_CLASS_NOT_ALLOWED(\"Annotation class\")!>class TestNestedAnnotation<!>\n    }\n}"
        },
        {
            "code": "//KT-5854 Incorrect 'Nested class should be qualified'\n\nclass A {\n    class Nested {\n\n    }\n\n    fun foo() {\n        Nested(<!TOO_MANY_ARGUMENTS!>1<!>) //two errors here, the first one is wrong\n    }\n}\n"
        },
        {
            "code": "class Outer {\n    inner class Inner {\n        <!NESTED_CLASS_NOT_ALLOWED(\"Interface\")!>interface TestNestedInterface<!>\n    }\n}"
        },
        {
            "code": "package f\n\nobject A {\n    class LoginFormPage() : Request({\n        val <!UNUSED_VARIABLE!>failed<!> = session.get(\"LOGIN_FAILED\")\n    })\n}\n\nclass B {\n    companion object {\n        class LoginFormPage() : Request({\n            val <!UNUSED_VARIABLE!>failed<!> = session.get(\"LOGIN_FAILED\")\n        })\n    }\n\n    class C {\n        class LoginFormPage() : Request({\n            val <!UNUSED_VARIABLE!>failed<!> = session.get(\"LOGIN_FAILED\")\n        })\n    }\n}\n\nopen class Request(private val handler: ActionContext.() -> Unit) {}\n\ninterface ActionContext {\n    val session : Map<String, String>\n}"
        },
        {
            "code": "class Outer {\n    class Nested\n    inner class Inner\n    \n    fun Inner.foo() {\n        Outer()\n        Nested()\n        Inner()\n    }\n    \n    fun Nested.bar() {\n        Outer()\n        Nested()\n        Inner()\n    }\n    \n    fun Outer.baz() {\n        Outer()\n        Nested()\n        Inner()\n    }\n}\n\nfun Outer.foo() {\n    Outer()\n    <!UNRESOLVED_REFERENCE!>Nested<!>()\n    Inner()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n// FILE: Outer.kt\npackage abc\nclass Outer {\n    inner class Inner() {\n        constructor(x: Int) : this() {}\n    }\n\n    companion object {\n        fun Inner(x: String) {}\n\n        fun baz() {\n            // Diagnostic here could be better (why can't I call the constructor above?)\n            Inner(<!NO_VALUE_FOR_PARAMETER!>)<!>\n            Inner(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n            Inner(\"\")\n        }\n    }\n}\n\nfun foo() {\n    Outer.Inner(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    Outer.Inner(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    Outer.Inner(\"\")\n}\n\n// FILE: imported.kt\nimport abc.Outer\nimport abc.Outer.Inner\nimport abc.Outer.Companion.Inner\n\nfun bar() {\n    Inner(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    Inner(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    Inner(\"\")\n\n    with(Outer()) {\n        Inner()\n        Inner(1)\n        Inner(\"\")\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +InnerClassInEnumEntryClass\n<!WRONG_MODIFIER_TARGET!>inner<!> fun foo() {}\n<!WRONG_MODIFIER_TARGET!>inner<!> val prop = 42\n\n<!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class A\n<!WRONG_MODIFIER_TARGET!>inner<!> interface B\n<!WRONG_MODIFIER_TARGET!>inner<!> object C\n\nclass D {\n    inner class E\n    <!WRONG_MODIFIER_TARGET!>inner<!> interface F\n    <!WRONG_MODIFIER_TARGET!>inner<!> object G\n    <!WRONG_MODIFIER_TARGET!>inner<!> enum class R\n    <!WRONG_MODIFIER_TARGET!>inner<!> annotation class S\n    <!WRONG_MODIFIER_TARGET!>inner<!> companion object\n}\n\nenum class H {\n    I0 {\n        inner class II0\n    },\n    <!WRONG_MODIFIER_TARGET!>inner<!> I {\n        inner class II\n    };\n    \n    inner class J\n}\n\ninterface K {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class L\n}\n\nobject N {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class O\n}\n\nclass P {\n    companion object {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class Q\n    }\n}\n\nval R = object {\n    inner class S\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n// FILE: Outer.kt\npackage abc\nclass Outer {\n    inner class Inner() {\n        constructor(x: Int) : this() {}\n    }\n\n    companion object {\n\n        fun baz() {\n            <!RESOLUTION_TO_CLASSIFIER!>Inner<!>()\n            <!RESOLUTION_TO_CLASSIFIER!>Inner<!>(1)\n        }\n    }\n}\n\nfun foo() {\n    Outer.<!RESOLUTION_TO_CLASSIFIER!>Inner<!>()\n    Outer.<!RESOLUTION_TO_CLASSIFIER!>Inner<!>(1)\n}\n\n// FILE: imported.kt\nimport abc.Outer\nimport abc.Outer.Inner\n\nfun bar() {\n    <!RESOLUTION_TO_CLASSIFIER!>Inner<!>()\n    <!RESOLUTION_TO_CLASSIFIER!>Inner<!>(1)\n\n    with(Outer()) {\n        Inner()\n        Inner(1)\n    }\n}"
        },
        {
            "code": "open class Base {\n    fun foo() {}\n}\n\nclass Derived : Base() {\n    class Nested {\n        fun bar() = <!UNRESOLVED_REFERENCE!>foo<!>()\n    }\n}"
        },
        {
            "code": "// NI_EXPECTED_FILE\n\nclass Outer {\n    fun function() = 42\n    val property = \"\"\n    \n    class Nested {\n        fun f() = <!UNRESOLVED_REFERENCE!>function<!>()\n        fun g() = <!UNRESOLVED_REFERENCE!>property<!>\n        fun h() = this<!UNRESOLVED_REFERENCE!>@Outer<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>function<!>()\n        fun i() = this<!UNRESOLVED_REFERENCE!>@Outer<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>property<!>\n    }\n    \n    inner class Inner {\n        fun innerFun() = function()\n        val innerProp = property\n        fun innerThisFun() = this@Outer.function()\n        val innerThisProp = this@Outer.property\n        \n        inner class InnerInner {\n            fun f() = innerFun()\n            fun g() = innerProp\n            fun h() = this@Inner.innerFun()\n            fun i() = this@Inner.innerProp\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nopen class A {\n    class NC {}\n    inner class IC {}\n    interface NI {}\n}\n\ninterface I {\n    class NC {}\n    interface NI {}\n}\n\nclass B : A() {\n\n}\n\nclass C : I {\n\n}\n\nclass D : A(), I {\n\n}\n\nfun test() {\n    val ac: A.NC = A.NC()\n    val aic: A.IC = A().IC()\n    val ai: A.NI? = null\n\n    val ic: I.NC = I.NC()\n    val ii: I.NI? = null\n\n    val bc: B.<!UNRESOLVED_REFERENCE!>NC<!> = B.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val bic: B.<!UNRESOLVED_REFERENCE!>IC<!> = B().IC()\n    val bi: B.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n\n    val cc: C.<!UNRESOLVED_REFERENCE!>NC<!> = C.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val ci: C.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n\n    val dc: D.<!UNRESOLVED_REFERENCE!>NC<!> = D.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val dic: D.<!UNRESOLVED_REFERENCE!>IC<!> = D().IC()\n    val di: D.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n}\n"
        },
        {
            "code": "// FILE: a.kt\nclass A {\n    class B {\n        class C\n    }\n}\n\n// FILE: b.kt\nimport A.B\nimport A.B.C\n\nval a = A()\nval b = B()\nval ab = A.B()\nval c = C()\nval bc = B.C()\nval abc = A.B.C()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nclass Outer {\n    class Nested<T>\n}\n\nfun nested() = Outer.Nested<Int>()\nfun noArguments() = Outer.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>Nested<!>()\nfun noArgumentsExpectedType(): Outer.Nested<String> = Outer.Nested()\nfun manyArguments() = Outer.Nested<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><String, Int><!>()\n"
        },
        {
            "code": "class Outer {\n    class Nested {\n        class NestedNested\n    }\n\n    inner class Inner {\n        inner class InnerInner\n    }\n}\n\nfun f1() = Outer()\nfun f2() = Outer.Nested()\nfun f3() = Outer.Nested.NestedNested()\nfun f4() = Outer.<!RESOLUTION_TO_CLASSIFIER!>Inner<!>()\nfun f5() = Outer.Inner.<!RESOLUTION_TO_CLASSIFIER!>InnerInner<!>()\nfun f6() = Outer().Inner()\nfun f7() = Outer().Inner().InnerInner()\n"
        },
        {
            "code": "// !LANGUAGE: -InnerClassInEnumEntryClass\n<!WRONG_MODIFIER_TARGET!>inner<!> fun foo() {}\n<!WRONG_MODIFIER_TARGET!>inner<!> val prop = 42\n\n<!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class A\n<!WRONG_MODIFIER_TARGET!>inner<!> interface B\n<!WRONG_MODIFIER_TARGET!>inner<!> object C\n\nclass D {\n    inner class E\n    <!WRONG_MODIFIER_TARGET!>inner<!> interface F\n    <!WRONG_MODIFIER_TARGET!>inner<!> object G\n    <!WRONG_MODIFIER_TARGET!>inner<!> enum class R\n    <!WRONG_MODIFIER_TARGET!>inner<!> annotation class S\n    <!WRONG_MODIFIER_TARGET!>inner<!> companion object\n}\n\nenum class H {\n    I0 {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class II0\n    },\n    <!WRONG_MODIFIER_TARGET!>inner<!> I {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class II\n    };\n    \n    inner class J\n}\n\ninterface K {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class L\n}\n\nobject N {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class O\n}\n\nclass P {\n    companion object {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class Q\n    }\n}\n\nval R = object {\n    inner class S\n}\n"
        },
        {
            "code": "class Outer<T> {\n    class Nested {\n        fun foo(t: <!UNRESOLVED_REFERENCE!>T<!>) = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>t<!>\n    }\n    \n    class Nested2<T> {\n        fun foo(t: T) = t\n    }\n    \n    inner class Inner {\n        fun foo(t: T) = t\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInEnumEntryShouldBeInner\n\nclass A {\n    inner class B {\n        <!NESTED_CLASS_NOT_ALLOWED!>class C<!>\n    }\n    \n    fun foo() {\n        class B {\n            <!NESTED_CLASS_NOT_ALLOWED!>class C<!>\n        }\n    }\n}\n\nfun foo() {\n    class B {\n        <!NESTED_CLASS_NOT_ALLOWED!>class C<!>\n    }\n}\n\n\nenum class E {\n    E1 {\n        <!NESTED_CLASS_NOT_ALLOWED!>class D<!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +InnerClassInEnumEntryClass +NestedClassesInEnumEntryShouldBeInner\n\nenum class Enum {\n    ENTRY_WITH_CLASS {\n        inner class TestInner\n\n        <!NESTED_CLASS_NOT_ALLOWED!>class TestNested<!>\n\n        <!NESTED_CLASS_NOT_ALLOWED!>interface TestInterface<!>\n\n        <!NESTED_CLASS_NOT_ALLOWED!>object TestObject<!>\n\n        <!NESTED_CLASS_NOT_ALLOWED!>enum class TestEnumClass<!> {\n            OTHER_ENTRY\n        }\n\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {}\n    }\n}\n"
        },
        {
            "code": "class Test {\n    @<!UNRESOLVED_REFERENCE!>ClassObjectAnnotation<!>\n    @NestedAnnotation\n    companion object {\n        annotation class ClassObjectAnnotation\n    }\n\n    annotation class NestedAnnotation\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// FILE: K.kt\n\nclass K : D()\n\n// FILE: test.kt\n\nfun test() {\n    val ac: A.NC = A.NC()\n    val aic: A.IC = A().IC()\n    val ai: A.NI? = null\n\n    val ic: I.NC = I.NC()\n    val ii: I.NI? = null\n\n    val bc: B.<!UNRESOLVED_REFERENCE!>NC<!> = B.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val bic: B.<!UNRESOLVED_REFERENCE!>IC<!> = B().IC()\n    val bi: B.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n\n    val cc: C.<!UNRESOLVED_REFERENCE!>NC<!> = C.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val ci: C.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n\n    val dc: D.<!UNRESOLVED_REFERENCE!>NC<!> = D.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val dic: D.<!UNRESOLVED_REFERENCE!>IC<!> = D().IC()\n    val di: D.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n\n    val kc: K.<!UNRESOLVED_REFERENCE!>NC<!> = K.<!UNRESOLVED_REFERENCE!>NC<!>()\n    val kic: K.<!UNRESOLVED_REFERENCE!>IC<!> = K().IC()\n    val ki: K.<!UNRESOLVED_REFERENCE!>NI<!>? = null\n}\n"
        },
        {
            "code": "class Test {\n    @`InnerAnnotation` <!REPEATED_ANNOTATION!>@InnerAnnotation<!>\n    companion <!CYCLIC_SCOPES_WITH_COMPANION, CYCLIC_SCOPES_WITH_COMPANION!>object<!> : StaticClass(), <!DEBUG_INFO_UNRESOLVED_WITH_TARGET, MANY_CLASSES_IN_SUPERTYPE_LIST, UNRESOLVED_REFERENCE!>InnerClass<!>() {\n\n    }\n\n    annotation class InnerAnnotation\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>StaticClass<!>\n\n    open inner class <!CYCLIC_SCOPES_WITH_COMPANION!>InnerClass<!>\n}"
        },
        {
            "code": "class Outer1 {\n    class Nested\n\n    class C1 { val b = Nested() }\n    class C2(val b: Any = Nested())\n    inner class C3 { val b = Nested() }\n    inner class C4(val b: Any = Nested())\n\n    inner class Inner\n\n    class C5 { val b = <!RESOLUTION_TO_CLASSIFIER!>Inner<!>() }\n    class C6(val b: Any = <!RESOLUTION_TO_CLASSIFIER!>Inner<!>())\n    inner class C7 { val b = Inner() }\n    inner class C8(val b: Any = Inner())\n}\n\n\nclass Outer2 {\n    class Nested {\n        fun foo() = Outer2()\n        fun bar() = <!RESOLUTION_TO_CLASSIFIER!>Inner<!>()\n    }\n    inner class Inner {\n        fun foo() = Outer2()\n        fun bar() = Nested()\n    }\n\n    fun foo() {\n        Nested()\n        Inner()\n    }\n}\n"
        },
        {
            "code": "// SKIP_TXT\nclass Outer {\n    inner class Inner1 {\n        <!NESTED_CLASS_NOT_ALLOWED(\"Object\")!>object Obj1<!>\n\n        companion <!NESTED_CLASS_NOT_ALLOWED(\"Companion object\")!>object Obj2<!>\n\n        inner class Inner2 {\n            <!NESTED_CLASS_NOT_ALLOWED(\"Object\")!>object Obj3<!>\n        }\n    }\n}\n"
        },
        {
            "code": "class Test {\n    companion object {\n        fun test(<!UNUSED_PARAMETER!>t<!>: TestInner) = 42\n    }\n\n    class TestStatic {\n        fun test(<!UNUSED_PARAMETER!>t<!>: TestInner) = 42\n    }\n\n    inner class TestInner\n}"
        },
        {
            "code": "interface N { fun foo() = 1 }\n\nclass WithClassObject {\n    companion object {}\n\n    class Nested()\n    class NestedWithClassObject { companion object : N }\n    enum class NestedEnum { A }\n    object NestedObj : N { operator fun invoke() = 1 }\n}\n\nclass WithoutClassObject {\n    class Nested()\n    class NestedWithClassObject { companion object : N }\n    enum class NestedEnum { A }\n    object NestedObj : N { operator fun invoke() = 1 }\n}\n\nobject Obj {\n    class Nested()\n    class NestedWithClassObject { companion object : N }\n    enum class NestedEnum { A }\n    object NestedObj : N { operator fun invoke() = 1 }\n}\n\nfun test(with: WithClassObject, without: WithoutClassObject, obj: Obj) {\n    with.<!UNRESOLVED_REFERENCE!>Nested<!>()\n    with.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedWithClassObject<!>\n    with.<!UNRESOLVED_REFERENCE!>NestedWithClassObject<!>()\n    with.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedWithClassObject<!>.foo()\n    with.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedEnum<!>.A\n    with.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>NestedObj<!>\n    with.<!RESOLUTION_TO_CLASSIFIER!>NestedObj<!>()\n    with.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>NestedObj<!>.foo()\n\n    without.<!UNRESOLVED_REFERENCE!>Nested<!>()\n    without.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedWithClassObject<!>\n    without.<!UNRESOLVED_REFERENCE!>NestedWithClassObject<!>()\n    without.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedWithClassObject<!>.foo()\n    without.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedEnum<!>.A\n    without.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>NestedObj<!>\n    without.<!RESOLUTION_TO_CLASSIFIER!>NestedObj<!>()\n    without.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>NestedObj<!>.foo()\n\n    obj.<!UNRESOLVED_REFERENCE!>Nested<!>()\n    obj.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedWithClassObject<!>\n    obj.<!UNRESOLVED_REFERENCE!>NestedWithClassObject<!>()\n    obj.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedWithClassObject<!>.foo()\n    obj.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>NestedEnum<!>.A\n    obj.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>NestedObj<!>\n    obj.<!RESOLUTION_TO_CLASSIFIER!>NestedObj<!>()\n    obj.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>NestedObj<!>.foo()\n}"
        },
        {
            "code": "// !LANGUAGE: -NestedClassesInEnumEntryShouldBeInner\n\nclass A {\n    inner class B {\n        <!NESTED_CLASS_NOT_ALLOWED!>class C<!>\n    }\n    \n    fun foo() {\n        class B {\n            <!NESTED_CLASS_NOT_ALLOWED!>class C<!>\n        }\n    }\n}\n\nfun foo() {\n    class B {\n        <!NESTED_CLASS_NOT_ALLOWED!>class C<!>\n    }\n}\n\n\nenum class E {\n    E1 {\n        <!NESTED_CLASS_DEPRECATED!>class D<!>\n    }\n}\n"
        },
        {
            "code": "class Outer {\n    inner class Inner {\n        <!NESTED_CLASS_NOT_ALLOWED(\"Enum class\")!>enum class TestNestedEnum<!>\n    }\n}"
        },
        {
            "code": "open class SomeClass<T>\nclass TestSome<P> {\n    object Some : SomeClass<<!UNRESOLVED_REFERENCE!>P<!>>() {\n    }\n}\n\nclass Test {\n    object Some : <!DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>InnerClass<!>() {\n        val a = object: <!DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>InnerClass<!>() {\n        }\n\n        fun more(): InnerClass {\n            val b = <!RESOLUTION_TO_CLASSIFIER!>InnerClass<!>()\n\n            val <!UNUSED_VARIABLE!>testVal<!> = <!UNRESOLVED_REFERENCE!>inClass<!>\n            <!UNRESOLVED_REFERENCE!>foo<!>()\n\n            return <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b<!>\n        }\n    }\n\n    val inClass = 12\n    fun foo() {\n    }\n\n    open inner class InnerClass\n}\n"
        },
        {
            "code": "fun box() : String {\n    val s = \"abc\"\n    val test1 = \"\"\"$s\"\"\"\n    if (test1 != \"abc\") return \"Fail 1: $test1\"\n\n    val test2 = \"\"\"${s}\"\"\"\n    if (test2 != \"abc\") return \"Fail 2: $test2\"\n\n    val test3 = \"\"\" \"$s\" \"\"\"\n    if (test3 != \" \\\"abc\\\" \") return \"Fail 3: $test3\"\n\n    val test4 = \"\"\" \"${s}\" \"\"\"\n    if (test4 != \" \\\"abc\\\" \") return \"Fail 4: $test4\"\n\n    val test5 =\n\"\"\"\n  ${s.length}\n\"\"\"\n    if (test5 != \"\\n  3\\n\") return \"Fail 5: $test5\"\n\n    val test6 = \"\"\"\\n\"\"\"\n    if (test6 != \"\\\\n\") return \"Fail 6: $test6\"\n\n    val test7 = \"\"\"\\${'$'}foo\"\"\"\n    if (test7 != \"\\\\\\$foo\") return \"Fail 7: $test7\"\n\n    val test8 = \"\"\"$ foo\"\"\"\n    if (test8 != \"$ foo\") return \"Fail 8: $test8\"\n\n    return \"OK\"\n}\n\n\nfun new() : String {\n  return \"\"\"\n    sdfasdf\n    ${<!UNRESOLVED_REFERENCE!>a<!>}\n    ds\"asdfas\n    $<!UNRESOLVED_REFERENCE!>b<!>\n    asgfaf\n  \"\"\"\n\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -EXTENSION_SHADOWED_BY_MEMBER\n\nimport kotlin.reflect.KProperty\n\ninterface Example {\n    operator fun plus(o: Example): Example\n    operator fun div(o: Example): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus(o: Example, s: String = \"\"): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minus(vararg o: Example): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus(): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minus(): Example\n\n    operator fun unaryPlus(): Example\n    operator fun unaryMinus(): Example\n\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun unaryPlus(s: String = \"\"): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun unaryMinus(o: Example)\n\n    operator fun inc(): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun dec(): Example?\n\n    operator fun plusAssign(n: Int)\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minusAssign(n: Int): String\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun divAssign(n: Int, a: String = \"\")\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun modAssign(vararg n: Int)\n\n    operator fun compareTo(other: Example): Int\n\n    override operator fun equals(other: Any?): Boolean\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun equals(a: String): Boolean\n\n    operator fun contains(n: Int): Boolean\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun contains(n: Int, s: String = \"\"): Boolean\n\n    operator fun invoke()\n\n    operator fun get(n: Int)\n    operator fun get(n: Int, n2: Int)\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun get()\n\n    operator fun set(n: Int, v: Int)\n    operator fun set(n: Int, n2: Int, v: Int)\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun set(v: Int)\n\n    operator fun rangeTo(o: Int)\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun rangeTo(o: Int, o2: Int)\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun rangeTo(vararg o: String)\n\n    operator fun component1(): Int\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun component1(n: Int): Int\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun componentN(): Int\n\n    operator fun iterator(): String\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun iterator(n: Int): String\n\n    operator fun next(): String\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun next(n: Int): String\n\n    operator fun hasNext(): Boolean\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun hasNext(n: Int): String\n\n    infix fun i1(n: Int)\n    <!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun i1(n: Int, n2: Int)\n    <!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun i1(vararg n: Int)\n}\n\nclass OkDelegates {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = \"\"\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, s: String): String = \"\"\n    operator fun setValue(thisRef: Any?, prop: Any, n: Int) {}\n    operator fun setValue(thisRef: Any?, prop: Any?, s: String) {}\n}\n\nclass DelegatesWithErrors {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun getValue(thisRef: Any?, prop: String): String = \"\"\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun setValue(thisRef: Any?, prop: String, value: String) {}\n\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun setValue(thisRef: Any?, prop: KProperty<*>, vararg n: Int) {}\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun setValue(thisRef: Any?, prop: KProperty<*>, f: Float = 0.0f) {}\n\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun getValue(prop: KProperty<*>): String = \"\"\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun setValue(prop: KProperty<*>, value: String) {}\n}\n\ninterface Example2 {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun inc(s: String): Example\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun dec()\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun compareTo(vararg other: Example): Int\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun contains(vararg n: Int): Boolean\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun hasNext(): Int\n}\n\ninterface Example3 {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun compareTo(other: Example, s: String = \"\"): Int\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun contains(n: Int)\n}\n\n\n\n\noperator fun Example.plus(<!UNUSED_PARAMETER!>o<!>: Any): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\noperator fun Example.div(<!UNUSED_PARAMETER!>o<!>: Example): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.plus(<!UNUSED_PARAMETER!>o<!>: Example, <!UNUSED_PARAMETER!>s<!>: String = \"\"): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.minus(vararg <!UNUSED_PARAMETER!>o<!>: Example): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.plus(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.minus(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.unaryPlus(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\noperator fun Example.unaryMinus(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.unaryPlus(<!UNUSED_PARAMETER!>s<!>: String = \"\"): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.unaryMinus(<!UNUSED_PARAMETER!>o<!>: Example) {}\n\noperator fun Example.inc(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.dec(): Example? {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.plusAssign(<!UNUSED_PARAMETER!>n<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.minusAssign(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.divAssign(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>a<!>: String = \"\") {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.modAssign(vararg <!UNUSED_PARAMETER!>n<!>: Int) {}\n\noperator fun Example.compareTo(<!UNUSED_PARAMETER!>other<!>: Example): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.equals(<!UNUSED_PARAMETER!>a<!>: String): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.contains(<!UNUSED_PARAMETER!>n<!>: Int): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.contains(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>s<!>: String = \"\"): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.invoke() {}\n\noperator fun Example.get(<!UNUSED_PARAMETER!>n<!>: Int) {}\noperator fun Example.get(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>n2<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.get() {}\n\noperator fun Example.set(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>v<!>: Int) {}\noperator fun Example.set(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>n2<!>: Int, <!UNUSED_PARAMETER!>v<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n\noperator fun Example.rangeTo(<!UNUSED_PARAMETER!>o<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.rangeTo(<!UNUSED_PARAMETER!>o<!>: Int, <!UNUSED_PARAMETER!>o2<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.rangeTo(vararg <!UNUSED_PARAMETER!>o<!>: String) {}\n\noperator fun Example.component1(): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.component1(<!UNUSED_PARAMETER!>n<!>: Int): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.componentN(): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.iterator(): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.iterator(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.next(): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.next(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\noperator fun Example.hasNext(): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Example.hasNext(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\ninfix fun Example.i1(<!UNUSED_PARAMETER!>n<!>: Int) {}\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun Example.i1(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>n2<!>: Int) {}\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun Example.i1(vararg <!UNUSED_PARAMETER!>n<!>: Int) {}\n\n\n\n\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus(<!UNUSED_PARAMETER!>o<!>: String): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun div(<!UNUSED_PARAMETER!>o<!>: Example): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus(<!UNUSED_PARAMETER!>o<!>: Example, <!UNUSED_PARAMETER!>s<!>: String = \"\"): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minus(vararg <!UNUSED_PARAMETER!>o<!>: Example): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun unaryPlus(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun unaryMinus(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun unaryPlus(<!UNUSED_PARAMETER!>s<!>: String = \"\"): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun unaryMinus(<!UNUSED_PARAMETER!>o<!>: Example) {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun inc(): Example {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun dec(): Example? {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plusAssign(<!UNUSED_PARAMETER!>n<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minusAssign(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun divAssign(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>a<!>: String = \"\") {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun modAssign(vararg <!UNUSED_PARAMETER!>n<!>: Int) {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun compareTo(<!UNUSED_PARAMETER!>other<!>: Example): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun equals(<!UNUSED_PARAMETER!>a<!>: String): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun contains(<!UNUSED_PARAMETER!>n<!>: Int): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun contains(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>s<!>: String = \"\"): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun invoke() {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun get(<!UNUSED_PARAMETER!>n<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun get(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>n2<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun get() {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun set(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>v<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun set(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>n2<!>: Int, <!UNUSED_PARAMETER!>v<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun rangeTo(<!UNUSED_PARAMETER!>o<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun rangeTo(<!UNUSED_PARAMETER!>o<!>: Int, <!UNUSED_PARAMETER!>o2<!>: Int) {}\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun rangeTo(vararg <!UNUSED_PARAMETER!>o<!>: String) {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun component1(): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun component1(<!UNUSED_PARAMETER!>n<!>: Int): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun componentN(): Int {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun iterator(): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun iterator(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun next(): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun next(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun hasNext(): Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun hasNext(<!UNUSED_PARAMETER!>n<!>: Int): String {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun i1(<!UNUSED_PARAMETER!>n<!>: Int) {}\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun i1(<!UNUSED_PARAMETER!>n<!>: Int, <!UNUSED_PARAMETER!>n2<!>: Int) {}\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun i1(vararg <!UNUSED_PARAMETER!>n<!>: Int) {}\n"
        },
        {
            "code": "fun <T: (Int) -> String> foo() {}\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T: (kotlin.Int) -> kotlin.String<!>> bar = fun (x: Int): String { return x.toString() }\n\nclass A<T, U, V> where T : () -> Unit, U : (Int) -> Double, V : (T, U) -> U\n\ninterface B<T, U : (T) -> Unit>"
        },
        {
            "code": "class Foo<<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T : Cloneable<!>> where T : Comparable<T> {\n    fun <<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>U : Cloneable<!>> foo(u: U): U where U: Comparable<U> {\n        fun <<!BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER, MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>T: Any<!>> bar() where T: U {}\n        return u\n    }\n\n    val <<!MISPLACED_TYPE_PARAMETER_CONSTRAINTS!>U : Cloneable<!>> U.foo: U? where U: Comparable<U>\n       get() { return null }\n}\n\nclass Bar<T : Cloneable, U> where U: Comparable<T> {\n\n}"
        },
        {
            "code": "interface I1\n\nclass A1<T> where T : I1, T : <!REPEATED_BOUND!>I1<!>\nclass A2<T> where T : I1, T : <!REPEATED_BOUND!>I1?<!>\nclass A3<K, V> where K : V, K : <!REPEATED_BOUND!>V<!>\n\nfun <T> f1() where T : I1, T : <!REPEATED_BOUND!>I1<!> {}\n"
        },
        {
            "code": "fun <<!UPPER_BOUND_CANNOT_BE_ARRAY!>A : Array<Any><!>> f1() {}\nfun <T, <!UPPER_BOUND_CANNOT_BE_ARRAY!>A : Array<out T><!>> f2() {}\nfun <S, T : S, <!UPPER_BOUND_CANNOT_BE_ARRAY!>A<!>> f3() where A : Array<out S>, A : <!REPEATED_BOUND!>Array<out T><!> {}\n\nfun <<!UPPER_BOUND_CANNOT_BE_ARRAY!>T : <!FINAL_UPPER_BOUND!>IntArray<!><!>> f4() {}\n\nfun <<!UPPER_BOUND_CANNOT_BE_ARRAY!>T<!>> f5() where T : Array<Any> {}\n\nval <<!UPPER_BOUND_CANNOT_BE_ARRAY!>T : Array<Any?><!>> T.v: String get() = \"\"\n\nclass C2<T, <!UPPER_BOUND_CANNOT_BE_ARRAY!>A : Array<out T><!>>\ninterface C3<S, T : S, <!UPPER_BOUND_CANNOT_BE_ARRAY!>A<!>> where A : Array<out S>, A : <!REPEATED_BOUND!>Array<out T><!>\n\nfun foo() {\n    class C1<<!UPPER_BOUND_CANNOT_BE_ARRAY!>A : Array<Any><!>> {\n        fun <<!UPPER_BOUND_CANNOT_BE_ARRAY!>A : Array<Any><!>, <!UPPER_BOUND_CANNOT_BE_ARRAY!>B : Array<Any><!>, C : A> f() {}\n    }\n}\n"
        },
        {
            "code": "fun <T: <!UPPER_BOUND_IS_EXTENSION_FUNCTION_TYPE!>Int.() -> String<!>> foo() {}\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T: <!UPPER_BOUND_IS_EXTENSION_FUNCTION_TYPE!>Int.() -> String<!><!>> bar = fun (x: Int): String { return x.toString() }\n\nclass A<T> where T : <!UPPER_BOUND_IS_EXTENSION_FUNCTION_TYPE!>Double.(Int) -> Unit<!>\n\ninterface B<T, U : <!UPPER_BOUND_IS_EXTENSION_FUNCTION_TYPE!>T.() -> Unit<!>>"
        },
        {
            "code": "open class C1\nopen class C2\nopen class C3 : C2()\n\nclass A1<T> where T : C1, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C2<!>\nclass A2<T> where T : C1, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C2<!>, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C3<!>\nclass A3<T> where T : C2, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C3<!>\nclass A4<T> where T : C3, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C2<!>\n\nfun <T> f1() where T : C1, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C2<!>, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C3<!> {}\nfun <T> f2() where T : C2, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C3<!> {}\nfun <T> f3() where T : C3, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C2<!> {}\n\nenum class E1\nclass A5<T> where T : C1, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>E1<!>\n\nobject O1\nclass A6<<!CONFLICTING_UPPER_BOUNDS!>T<!>> where T : <!FINAL_UPPER_BOUND!>O1<!>, T : <!ONLY_ONE_CLASS_BOUND_ALLOWED!>C2<!>\n"
        },
        {
            "code": "fun foo<!DEPRECATED_TYPE_PARAMETER_SYNTAX!><T><!>() {\n    fun bar<!DEPRECATED_TYPE_PARAMETER_SYNTAX!><T><!>() {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNCHECKED_CAST\n// !WITH_NEW_INFERENCE\n// WITH_RUNTIME\n// WITH_REFLECT\n// SKIP_TXT\n\nimport kotlin.reflect.*\n\nprivate object Scope {\n    class Inv<T>\n\n    class Delegate<T>(private val p: Inv<in T>) {\n        operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n            return materialize()\n        }\n    }\n\n    fun <T> materialize(): T = Any() as T\n\n    fun test(i: Inv<out Number>) {\n        val <!UNUSED_VARIABLE!>p<!>: Int by <!IMPLICIT_NOTHING_AS_TYPE_PARAMETER!>Scope.Delegate(i)<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -REDUNDANT_PROJECTION -CONFLICTING_PROJECTION\n\ninterface G\n\nval <T> T.a: Int\n    get() = 3\n\nval <T1, T2> Map<T1, T2>.b: String\n    get() = \"asds\"\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T : G<!>> G.c: Int get() = 5\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T1<!>, T2, T3> List<Map<T2, T3>>.d: Int get() = 6\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T: Any<!>> G.e: T?\n    get() = null\n\nval <T> List<Map<Int, Map<String, T>>>.f: Int get() = 7\n\nval <T> List<Map<Int, Map<String, out T>>>.g: Int get() = 7\nval <T> List<Map<Int, Map<String, in T>>>.h: Int get() = 7\n\nval <T> List<Map<T, Map<T, T>>>.i: Int get() = 7\n\nvar <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T1<!>, <!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T2<!>, <!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T3<!>, <!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T4<!>> p = 1\n\nclass C<T1, T2> {\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>E<!>> T1.a: Int get() = 3\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>E<!>> T2.b: Int get() = 3\n    val <E> E.c: Int get() = 3\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>E<!>> Map<T1, T2>.d: Int get() = 3\n    val <E> Map<T1, E>.e: Int get() = 3\n}\n\nval <T : Enum<T>> T.z1: Int\n    get() = 4\n\ninterface D<T : Enum<T>>\n\nval <X: D<*>> X.z2: Int\n    get() = 4\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>Y<!>> D<*>.z3: Int\n    get() = 4"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNCHECKED_CAST\n// !WITH_NEW_INFERENCE\n// SKIP_TXT\n// Issue: KT-20849\n\nfun <T>test_1(x: T): T = null as T\nfun <T>test_2(x: () -> T): T = null as T\n\nfun case_1() {\n    null?.run { return }\n    null!!.<!UNREACHABLE_CODE!>run { throw Exception() }<!>\n}\n\nfun case_2() {\n    test_1 { null!! }\n    test_2 { null!! }\n}\n\nfun case_3() {\n    test_1 { throw Exception() }\n    test_2 { throw Exception() }\n}\n\nfun case_6() {\n    null!!\n}\n\nfun case_7(x: Boolean?) {\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (x) {\n        true -> throw Exception()\n        false -> throw Exception()\n        null -> throw Exception()\n    }<!>\n}\n\nfun <T> something(): T = Any() as T\n\nclass Context<T>\n\nfun <T> Any.decodeIn(typeFrom: Context<in T>): T = something()\n\nfun <T> Any?.decodeOut1(typeFrom: Context<out T>): T {\n    return <!NI;TYPE_MISMATCH!>this?.<!IMPLICIT_NOTHING_AS_TYPE_PARAMETER, NI;IMPLICIT_NOTHING_AS_TYPE_PARAMETER!>decodeIn<!>(typeFrom) ?: <!OI;TYPE_MISMATCH!>kotlin.Unit<!><!>\n}\n\nfun <T> Any.decodeOut2(typeFrom: Context<out T>): T {\n    <!UNREACHABLE_CODE!>val x: Nothing =<!> this.decodeIn(typeFrom)\n}\n\nfun <T> Any.decodeOut3(typeFrom: Context<out T>): T {\n    <!UNREACHABLE_CODE!>val x =<!> this.<!IMPLICIT_NOTHING_AS_TYPE_PARAMETER!>decodeIn<!>(typeFrom)\n}\n\nfun <T> Any.decodeOut4(typeFrom: Context<out T>): T {\n    <!UNREACHABLE_CODE!>val x: Any =<!> this.<!IMPLICIT_NOTHING_AS_TYPE_PARAMETER!>decodeIn<!>(typeFrom)\n}\n\nclass TrieNode<out E> {\n    companion object {\n        internal val EMPTY = TrieNode<Nothing>()\n    }\n}\nclass PersistentHashSet<out E>(root: TrieNode<E>) {\n    companion object {\n        internal val EMPTY = PersistentHashSet(TrieNode.EMPTY)\n    }\n}\n\ninterface F<in T>\nfun <T> F<T>.join() = {}\n\nfun main() {\n    val f: Any = Any()\n    (f as F<*>).join()\n}\n\nfun bug(worker: Worker<Unit>) {\n    stateless<Boolean, Nothing, Unit> {\n        onWorkerOutput(worker)\n    }\n}\n\nfun <StateT, OutputT : Any, T> RenderContext<StateT, OutputT>.onWorkerOutput(worker: Worker<T>): Unit = Unit\n\nfun <InputT, OutputT : Any, RenderingT> stateless(\n    render: RenderContext<Nothing, OutputT>.(input: InputT) -> RenderingT\n) { }\n\ninterface Worker<out T>\n\ninterface RenderContext<StateT, in OutputT : Any>\n\nval emptyOrNull: List<Nothing>? = null\nval x = emptyOrNull?.<!IMPLICIT_NOTHING_AS_TYPE_PARAMETER!>get<!>(0)\n\nval errorCompletion = { <!UNUSED_ANONYMOUS_PARAMETER!>e<!>: Throwable -> throw Exception() }\n\nfun test1() {\n    errorCompletion(Exception(\"fail\"))\n}\nfun test2() {\n    errorCompletion.invoke(Exception(\"fail\"))\n}\n"
        },
        {
            "code": "\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T : K<!>, K> K.a: Int get() = 4\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T<!>, K> K.b: Int where T : K\n    get() = 4\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T<!>, K> K.c: Int where T : List<K>\n    get() = 4\n\nval <T, K> K.d: Int where K : T\n    get() = 4\n\nval <T, K> K.e: Int where K : List<T>\n    get() = 4\n\ninterface G\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T<!>> G.x1: Int where T : G\n    get() = 4\n\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>X<!>, Y, Z> Z.x2: Int where X : Y, Z : Y\n    get() = 4\n\nval <X, Y: Map<Z, X>, Z: List<List<Y>>> Z.x3: Int\n    get() = 5\n\nval <X, Y: Map<X, List<Z>>, Z> Map<X, List<Y>>.x4: Int\n    get() = 5"
        },
        {
            "code": "interface Base {\n    var v : Int\n        get() = 1\n        set(<!UNUSED_PARAMETER!>v<!>) {}\n}\n    \nopen class Left() : Base\n\ninterface Right : Base\n\nclass Diamond() : Left(), Right\n"
        },
        {
            "code": "// http://youtrack.jetbrains.net/issue/KT-418\n\nfun ff() {\n    val i: Int = 1\n    val <!UNUSED_VARIABLE!>a<!>: Int = i<!UNNECESSARY_SAFE_CALL!>?.<!>plus(2)\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ExtendedMainConvention\n\n// FILE: a.kt\n<!CONFLICTING_OVERLOADS!>fun main()<!> {}\n\n// FILE: b.kt\n<!CONFLICTING_OVERLOADS!>fun main()<!> {}\n"
        },
        {
            "code": "//KT-2418 Front-end allows enum constants with same name\r\n\r\npackage kt2418\r\n\r\nenum class A {\r\n    <!REDECLARATION!>FOO<!>,\r\n    <!REDECLARATION!>FOO<!>\r\n}\r\n\r\nenum class B {\r\n    FOO;\r\n    \r\n    fun FOO() {}\r\n}\r\n\r\nenum class C {\r\n    <!REDECLARATION!>FOO<!>;\r\n    \r\n    val <!REDECLARATION!>FOO<!> = 1\r\n}\r\n\r\nenum class D {\r\n    <!REDECLARATION!>FOO<!>;\r\n    \r\n    class <!REDECLARATION!>FOO<!> {}\r\n}\r\n\r\n"
        },
        {
            "code": "// FILE: test1.kt\nclass <!CONFLICTING_OVERLOADS!>A<!>\nclass B<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n    <!CONFLICTING_OVERLOADS!>constructor(x: Int, y: Int)<!>: this(x + y)\n}\n\n// FILE: test2.kt\n<!CONFLICTING_OVERLOADS!>fun A()<!> {}\n<!CONFLICTING_OVERLOADS!>fun B(x: Int)<!> = x\n<!CONFLICTING_OVERLOADS!>fun B(x: Int, y: Int)<!> = x + y"
        },
        {
            "code": "// KT-9733 No error shown for 2 \"main\" functions in the same file\n\n<!CONFLICTING_OVERLOADS!>fun main(args: Array<String>)<!> {}\n<!CONFLICTING_OVERLOADS!>fun main(args: Array<String>)<!> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface WithInvoke {\n    operator fun invoke()\n    operator fun invoke(s: String)\n    operator fun <T> invoke(x: T, y: Int)\n    fun invoke(i: Int)\n}\n\ninterface Test1 {\n    val test1: WithInvoke\n}\n\nfun Test1.<!EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE!>test1<!>() {}\nfun Test1.<!EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE!>test1<!>(s: String) {}\nfun Test1.test1(i: Int) {}\nfun Test1.<!EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE!>test1<!>(x: Any, y: Int) {}\nfun <T : Number> Test1.<!EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE!>test1<!>(x: T, y: Int) {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Test1 {\n    fun test1() {}\n}\nfun Test1.<!EXTENSION_SHADOWED_BY_MEMBER!>test1<!>() {}\n\ninterface Test2 {\n    fun test2(x: String) {}\n}\nfun Test2.test2(x: Any) {}\n\ninterface Test3 {\n    fun test3(x: Any) {}\n}\nfun Test3.<!EXTENSION_SHADOWED_BY_MEMBER!>test3<!>(x: String) {}\nfun <T : Any?> Test3.test3(x: T) {}\n\ninterface Test4 {\n    fun <T> test4(x: T) {}\n}\nfun Test4.<!EXTENSION_SHADOWED_BY_MEMBER!>test4<!>(x: String) {}\n\ninterface Test5 {\n    fun <T> test5(x: T) {}\n}\nfun <T : Number> Test5.<!EXTENSION_SHADOWED_BY_MEMBER!>test5<!>(x: T) {}\n\ninterface Test6 {\n    fun <T : List<Any>> test6(x: T) {}\n}\nfun <T : Set<Any>> Test6.test6(x: T) {}\n"
        },
        {
            "code": "interface Test {\n    fun invoke()\n    operator fun invoke(i: Int): Int\n}\n\noperator fun Test.invoke() {}\noperator fun Test.<!EXTENSION_SHADOWED_BY_MEMBER!>invoke<!>(i: Int) = i"
        },
        {
            "code": "interface G<T> {\n    fun foo()\n    val bar: Int\n}\n\nfun <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>.foo() {}\nval <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>.bar: Int get() = 42"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Outer {\n    inner class Test1\n    inner class Test2(val x: Int)\n    inner class Test3(val x: Any)\n    inner class Test4<T>(val x: T)\n    inner class Test5(val x: Int) {\n        constructor() : this(0)\n        private constructor(z: String) : this(z.length)\n    }\n\n    class TestNested\n\n    internal class TestInternal\n    protected class TestProtected\n    private class TestPrivate\n}\n\nfun Outer.<!EXTENSION_FUNCTION_SHADOWED_BY_INNER_CLASS_CONSTRUCTOR!>Test1<!>() {}\nfun Outer.<!EXTENSION_FUNCTION_SHADOWED_BY_INNER_CLASS_CONSTRUCTOR!>Test2<!>(x: Int) {}\nfun Outer.<!EXTENSION_FUNCTION_SHADOWED_BY_INNER_CLASS_CONSTRUCTOR!>Test3<!>(x: String) {}\nfun <T> Outer.Test3(x: T) {}\nfun <T : Number> Outer.<!EXTENSION_FUNCTION_SHADOWED_BY_INNER_CLASS_CONSTRUCTOR!>Test4<!>(x: T) {}\nfun Outer.<!EXTENSION_FUNCTION_SHADOWED_BY_INNER_CLASS_CONSTRUCTOR!>Test5<!>() {}\nfun Outer.Test5(z: String) {}\n\nfun Outer.TestNested() {}\nfun Outer.TestInternal() {}\nfun Outer.TestProtected() {}\nfun Outer.TestPrivate() {}"
        },
        {
            "code": "interface IFoo {\n    fun foo(i: Int): Int\n    infix fun bar(i: Int): Int\n}\n\ninfix fun IFoo.foo(i: Int) = i\ninfix fun IFoo.<!EXTENSION_SHADOWED_BY_MEMBER!>bar<!>(i: Int) = i"
        },
        {
            "code": "class WithPublicInvoke {\n    public operator fun invoke() {}\n}\n\nclass WithInternalInvoke {\n    internal operator fun invoke() {}\n}\n\nclass WithProtectedInvoke {\n    protected operator fun invoke() {}\n}\n\nclass WithPrivateInvoke {\n    private operator fun invoke() {}\n}\n\nclass Test {\n    public fun publicFoo() {}\n    internal fun internalFoo() {}\n    protected fun protectedFoo() {}\n    private fun privateFoo() {}\n\n    public val publicVal = 42\n    internal val internalVal = 42\n    protected val protectedVal = 42\n    private val privateVal = 42\n\n    public val withPublicInvoke = WithPublicInvoke()\n    public val withInternalInvoke = WithInternalInvoke()\n    public val withProtectedInvoke = WithProtectedInvoke()\n    public val withPrivateInvoke = WithPrivateInvoke()\n}\n\nprivate fun Test.<!EXTENSION_SHADOWED_BY_MEMBER!>publicFoo<!>() {}\nfun Test.internalFoo() {}\nfun Test.protectedFoo() {}\nfun Test.privateFoo() {}\n\nval Test.<!EXTENSION_SHADOWED_BY_MEMBER!>publicVal<!>: Int get() = 42\nval Test.internalVal: Int get() = 42\nval Test.protectedVal: Int get() = 42\nval Test.privateVal: Int get() = 42\n\nfun Test.<!EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE!>withPublicInvoke<!>() {}\nfun Test.wihtInternalInvoke() {}\nfun Test.withProtectedInvoke() {}\nfun Test.withPrivateInvoke() {}"
        },
        {
            "code": "interface IFooBar {\n    fun foo()\n    val bar: Int\n}\n\nclass Host {\n    fun IFooBar.<!EXTENSION_SHADOWED_BY_MEMBER!>foo<!>() {}\n    val IFooBar.<!EXTENSION_SHADOWED_BY_MEMBER!>bar<!>: Int get() = 42\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ndata class DataClass(val x: Int)\n\nfun DataClass.<!EXTENSION_SHADOWED_BY_MEMBER!>component1<!>() = 42"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface IBase {\n    fun foo()\n    val bar: Int\n}\n\nobject Impl : IBase {\n    override fun foo() {}\n    override val bar: Int get() = 42\n}\n\nobject Test : IBase by Impl\n\nfun Test.<!EXTENSION_SHADOWED_BY_MEMBER!>foo<!>() {}\nval Test.<!EXTENSION_SHADOWED_BY_MEMBER!>bar<!>: Int get() = 42"
        },
        {
            "code": "interface IFoo {\n    fun foo()\n}\n\nfun outer() {\n    fun IFoo.<!EXTENSION_SHADOWED_BY_MEMBER!>foo<!>() {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Test1 {\n    val test1: Int\n}\nval Test1.<!EXTENSION_SHADOWED_BY_MEMBER!>test1<!>: Int get() = 42\n\ninterface Test2 {\n    var test2: Int\n}\nval Test2.<!EXTENSION_SHADOWED_BY_MEMBER!>test2<!>: Int get() = 42\n\ninterface Test3 {\n    val test3: Int\n}\nvar Test3.<!EXTENSION_SHADOWED_BY_MEMBER!>test3<!>: Int get() = 42; set(v) {}\n\ninterface Test4 {\n    val test4: Int\n}\nvar Test4.<!EXTENSION_SHADOWED_BY_MEMBER!>test4<!>: Int get() = 42; set(v) {}\n\n"
        },
        {
            "code": "// FILE: f.kt\npackage a\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>b<!> {}\n// FILE: f.kt\npackage a.<!PACKAGE_OR_CLASSIFIER_REDECLARATION!>b<!>\n// FILE: f.kt\npackage a.<!PACKAGE_OR_CLASSIFIER_REDECLARATION!>b<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n// FILE: file1.kt\ntypealias <!REDECLARATION!>Test<!> = String\n\nval <!REDECLARATION!>Test<!> = 42\n\nclass Outer {\n    typealias <!REDECLARATION!>Test<!> = String\n\n    val <!REDECLARATION!>Test<!> = 42\n}\n\ntypealias <!REDECLARATION!>Test2<!> = String\n\n// FILE: file2.kt\nval <!REDECLARATION!>Test2<!> = 42\n"
        },
        {
            "code": "enum class A {\n    <!REDECLARATION!>name<!>\n}\n"
        },
        {
            "code": "val <!REDECLARATION!>a<!> : Int = 1\nval <!REDECLARATION!>a<!> : Int = 1\nval <!REDECLARATION!>a<!> : Int = 1\n\nval <!REDECLARATION!>b<!> : Int = 1\nval <!REDECLARATION!>b<!> : Int = 1\nval <!REDECLARATION!>b<!> : Int = 1\nval <!REDECLARATION!>b<!> : Int = 1\n\n<!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here too\n<!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here\n<!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here\n<!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here\n\n<!CONFLICTING_OVERLOADS!>fun bar()<!> {} // and here\n<!CONFLICTING_OVERLOADS!>fun bar()<!> {} // and here\n<!CONFLICTING_OVERLOADS!>fun bar()<!> {} // and here\n\nclass A {\n    val <!REDECLARATION!>a<!> : Int = 1\n    val <!REDECLARATION!>a<!> : Int = 1\n    val <!REDECLARATION!>a<!> : Int = 1\n\n    val <!REDECLARATION!>b<!> : Int = 1\n    val <!REDECLARATION!>b<!> : Int = 1\n    val <!REDECLARATION!>b<!> : Int = 1\n    val <!REDECLARATION!>b<!> : Int = 1\n\n    <!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here too\n    <!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here\n    <!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here\n    <!CONFLICTING_OVERLOADS!>fun foo()<!> {} // and here\n\n    <!CONFLICTING_OVERLOADS!>fun bar()<!> {} // and here\n    <!CONFLICTING_OVERLOADS!>fun bar()<!> {} // and here\n    <!CONFLICTING_OVERLOADS!>fun bar()<!> {} // and here\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ExtendedMainConvention\n\n// FILE: a.kt\n<!CONFLICTING_OVERLOADS!>suspend fun main(<!UNUSED_PARAMETER!>args<!>: Array<String>)<!> {}\n\n// FILE: b.kt\n<!CONFLICTING_OVERLOADS!>suspend fun main(<!UNUSED_PARAMETER!>args<!>: Array<String>)<!> {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\nclass C(val x: Int)\n\n<!CONFLICTING_OVERLOADS!>typealias CC = C<!>\n\n<!CONFLICTING_OVERLOADS!>fun CC(x: Int)<!> = x\n\nclass Outer {\n    class C(val x: Int)\n\n    <!CONFLICTING_OVERLOADS!>typealias CC = C<!>\n\n    <!CONFLICTING_OVERLOADS!>fun CC(x: Int)<!> = x\n}\n"
        },
        {
            "code": "fun test0(f: (String, String) -> Unit) {\n    f(\"\", \"\")\n}\n\nfun test1(f: (<!DUPLICATE_PARAMETER_NAME_IN_FUNCTION_TYPE!>a<!>: Int, <!DUPLICATE_PARAMETER_NAME_IN_FUNCTION_TYPE!>a<!>: Int) -> Unit) {\n    f(1, 1)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY\n// FILE: file1.kt\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>SomeClass<!>\n\ntypealias <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>SomeClass<!> = Any\ntypealias <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>SomeClass<!> = Any\ntypealias <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>SomeClass<!> = Any\n\nclass Outer {\n    class <!REDECLARATION!>Nested<!>\n\n    typealias <!REDECLARATION!>Nested<!> = Any\n    typealias <!REDECLARATION!>Nested<!> = Any\n    typealias <!REDECLARATION!>Nested<!> = Any\n}\n\n// FILE: file2.kt\ntypealias <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>SomeClass<!> = Any"
        },
        {
            "code": "val <!REDECLARATION!>Test1<!> = null\nclass <!REDECLARATION!>Test1<!>\n\nval <!REDECLARATION!>Test2<!> = null\ninterface <!REDECLARATION!>Test2<!>\n\nval <!REDECLARATION!>Test3<!> = null\nobject <!REDECLARATION!>Test3<!>\n\nval <!PACKAGE_OR_CLASSIFIER_REDECLARATION, REDECLARATION!>Test4<!> = null\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION, REDECLARATION!>Test4<!>\ninterface <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>Test4<!>\nobject <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>Test4<!>"
        },
        {
            "code": "// FILE: a.kt\n<!CONFLICTING_OVERLOADS!>fun main()<!> {}\n\nsuspend fun main(args: Array<String>) {}\n\n// FILE: b.kt\n<!CONFLICTING_OVERLOADS!>fun main()<!> {}\n"
        },
        {
            "code": "package foo\n\nval Int.<!REDECLARATION!>foo<!>: Int get() = 2\nval Int.<!REDECLARATION!>foo<!>: Int get() = 3\n"
        },
        {
            "code": "// FILE: a.kt\nval <!REDECLARATION!>a<!> : Int = 1\n<!CONFLICTING_OVERLOADS!>fun f()<!> {\n}\n\n// FILE: b.kt\nval <!REDECLARATION!>a<!> : Int = 1\n<!CONFLICTING_OVERLOADS!>fun f()<!> {\n}\n"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\ninterface A\ninterface B : A\n\nprivate fun validFun() {}\nprivate val validVal = 1\n\n<!CONFLICTING_OVERLOADS!>private fun invalidFun0()<!> {}\nprivate val <!REDECLARATION!>invalidProp0<!> = 1\n\n// NB invalidFun0 and invalidProp0 are conflicting overloads, since the following is an ambiguity:\nfun useInvalidFun0() = <!OVERLOAD_RESOLUTION_AMBIGUITY!>invalidFun0<!>()\nfun useInvalidProp0() = <!OVERLOAD_RESOLUTION_AMBIGUITY!>invalidProp0<!>\n\n<!CONFLICTING_OVERLOADS!>private fun invalidFun1()<!> {}\n<!CONFLICTING_OVERLOADS!>private fun invalidFun1()<!> {}\n\n<!CONFLICTING_OVERLOADS!>private fun invalidFun2()<!> {}\n<!CONFLICTING_OVERLOADS!>public fun invalidFun2()<!> {}\n\n<!CONFLICTING_OVERLOADS!>public fun invalidFun3()<!> {}\n\n<!CONFLICTING_OVERLOADS!>private fun invalidFun4()<!> {}\n<!CONFLICTING_OVERLOADS!>public fun invalidFun4()<!> {}\n\npublic fun validFun2(a: A) = a\npublic fun validFun2(b: B) = b\n\n// FILE: b.kt\npackage a\n\nprivate fun validFun() {}\nprivate val validVal = 1\n\n<!CONFLICTING_OVERLOADS!>private fun invalidFun0()<!> {}\n\nprivate val <!REDECLARATION!>invalidProp0<!> = 1\n\n<!CONFLICTING_OVERLOADS!>internal fun invalidFun3()<!> {}\n<!CONFLICTING_OVERLOADS!>internal fun invalidFun4()<!> {}\n\n// FILE: c.kt\npackage a\n\n<!CONFLICTING_OVERLOADS!>public fun invalidFun0()<!> {}\n\npublic val <!REDECLARATION!>invalidProp0<!> = 1"
        },
        {
            "code": "// FILE: f.kt\npackage redeclarations\n  object <!PACKAGE_OR_CLASSIFIER_REDECLARATION, REDECLARATION!>A<!> {\n    val x : Int = 0\n\n    val A = 1\n  }\n\n  class <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!> {}\n\n  val <!PACKAGE_OR_CLASSIFIER_REDECLARATION, REDECLARATION!>A<!> = 1\n\n// FILE: f.kt\n  package redeclarations.<!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!>\n    class A {}\n"
        },
        {
            "code": "class A {\n    companion object B {\n        class <!REDECLARATION!>G<!>\n        val <!REDECLARATION!>G<!> = 1\n    }\n}"
        },
        {
            "code": "// FILE: f1.kt\npackage test\n\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!>\nclass F1\n\n// FILE: f2.kt\npackage test\n\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!>\nclass F2"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo\ninterface Bar\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> foo(x: T): T<!> where T: Foo, T: Bar {null!!}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: Foo): Foo<!> {null!!}\nfun foo(x: Bar): Bar {null!!}\n"
        },
        {
            "code": "interface Test1<<!REDECLARATION!>T<!>, <!REDECLARATION!>T<!>>\ninterface Test2<<!REDECLARATION!>X<!>, Y, <!REDECLARATION!>X<!>>\n\nclass Outer<T> {\n    interface TestNested<T>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -DUPLICATE_CLASS_NAMES\n// KT-3525\nobject B {\n    class <!REDECLARATION!>C<!>\n    class <!REDECLARATION!>C<!>\n\n    val <!REDECLARATION!>a<!> : Int = 1\n    val <!REDECLARATION!>a<!> : Int = 1\n}"
        },
        {
            "code": "fun <<!REDECLARATION, REDECLARATION!>T<!>, <!REDECLARATION, REDECLARATION!>T<!>> Pair() {}\n\nclass P<<!REDECLARATION!>T<!>, <!REDECLARATION!>T<!>> {}\n\nval <<!REDECLARATION, TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T<!>, <!REDECLARATION!>T<!>> T.foo : Int\n    get() = 1"
        },
        {
            "code": "fun Foo() = 42\n\nobject Foo {\n    fun Bar() = 239\n\n    object Bar\n}\n\n\n\n<!CONFLICTING_OVERLOADS!>fun En()<!> = 239\n\nenum class <!CONFLICTING_OVERLOADS!>En<!> {\n    ENTRY,\n\n    SUBCLASS { };\n\n    fun ENTRY() = 42\n\n    fun SUBCLASS() = ENTRY()\n}\n"
        },
        {
            "code": "public class A() {\r\n    public val <!REDECLARATION!>FOO<!>: String = \"test\"\r\n\r\n    public class <!REDECLARATION!>FOO<!>() { }\r\n}\r\n\r\npublic class B() {\r\n   companion object {\r\n      public val <!REDECLARATION!>FOO<!>: String = \"test\"\r\n      \r\n      public class <!REDECLARATION!>FOO<!>() { }\r\n   }\r\n}\r\n"
        },
        {
            "code": "// !DIAGNOSTICS: -DUPLICATE_CLASS_NAMES\n//KT-2438 Prohibit inner classes with the same name\n\npackage kt2438\n\nclass B {\n    class <!REDECLARATION!>C<!>\n    class <!REDECLARATION!>C<!>\n}\n\n\n\nclass A {\n    class <!REDECLARATION!>B<!>\n    \n    companion object {\n        class <!REDECLARATION!>B<!>\n        class <!REDECLARATION!>B<!>\n    }\n    \n    class <!REDECLARATION!>B<!>\n}\n"
        },
        {
            "code": "enum class E {\n    FIRST,\n\n    SECOND;\n\n    companion object {\n        class FIRST\n\n        val SECOND = <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    }\n}"
        },
        {
            "code": "//!LANGUAGE: -DefaultMethodsCallFromJava6TargetError\n// FILE: 1.kt\n\nimport JavaInterface.testStatic\n\ninterface KotlinInterface : JavaInterface {\n    fun fooo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET!>testStatic<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n        object  {\n            fun run () {\n                super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n            }\n        }\n    }\n\n    val propertyy: String\n        get() {\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n            object  {\n                fun run () {\n                    super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                }\n            }\n            return \"\"\n        }\n\n    override fun testOverride(): String {\n        return \"OK\";\n    }\n}\n\ninterface KotlinInterfaceIndirectInheritance : KotlinInterface {\n    fun foooo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET!>testStatic<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n        object  {\n            fun run () {\n                super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n            }\n        }\n    }\n\n    val propertyyy: String\n        get() {\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n            object  {\n                fun run () {\n                    super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                }\n            }\n            return \"\"\n        }\n}\n\nopen class KotlinClass : JavaInterface {\n    fun foo(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET!>testStatic<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>testOverride<!>()\n\n        object  {\n            fun run () {\n                super@KotlinClass.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n            }\n        }\n    }\n\n    val property: String\n        get() {\n            super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n            super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>testOverride<!>()\n\n            object  {\n                fun run () {\n                    super@KotlinClass.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n                }\n            }\n            return \"\"\n        }\n}\n\nclass KotlinClassIndirectInheritance : KotlinClass() {\n    fun foo2(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET!>testStatic<!>()\n        super.test()\n        super.testOverride()\n\n        object  {\n            fun run () {\n                super@KotlinClassIndirectInheritance.test()\n            }\n        }\n    }\n\n    val property2: String\n        get() {\n            super.test()\n            super.testOverride()\n\n            object  {\n                fun run () {\n                    super@KotlinClassIndirectInheritance.test()\n                }\n            }\n            return \"\"\n        }\n}\n\nclass KotlinClassIndirectInheritance2 : KotlinInterfaceIndirectInheritance {\n    fun foo(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET!>testStatic<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n        super.testOverride()\n\n        object  {\n            fun run () {\n                super@KotlinClassIndirectInheritance2.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n            }\n        }\n    }\n\n    val property: String\n        get() {\n            super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n            super.testOverride()\n\n            object  {\n                fun run () {\n                    super@KotlinClassIndirectInheritance2.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET!>test<!>()\n                }\n            }\n            return \"\"\n        }\n}\n\nfun test() {\n    JavaInterface.<!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET!>testStatic<!>()\n    KotlinClass().foo()\n    KotlinClass().property\n    KotlinClassIndirectInheritance2().foo()\n    KotlinClassIndirectInheritance2().property\n\n    KotlinClass().test()\n    KotlinClass().property\n    KotlinClass().testOverride()\n    KotlinClassIndirectInheritance().testOverride()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\nimport JavaInterface.testStatic\n\ninterface KotlinInterface : JavaInterface {\n    fun fooo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n        test()\n        testOverride()\n    }\n\n    override fun testOverride(): String {\n        return \"OK\";\n    }\n}\n\ninterface KotlinInterfaceIndirectInheritance : KotlinInterface {\n    fun foooo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n        testOverride()\n        super.testOverride()\n    }\n}\n\nopen class KotlinClass : JavaInterface {\n    fun foo(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testOverride<!>()\n    }\n}\n\nclass KotlinClassIndirectInheritance : KotlinClass() {\n    fun foo2(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.test()\n        super.testOverride()\n    }\n}\n\nclass KotlinClassIndirectInheritance2 : KotlinInterfaceIndirectInheritance {\n    fun foo(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n        super.testOverride()\n    }\n}\n\nfun test() {\n    JavaInterface.<!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n    KotlinClass().foo()\n    KotlinClassIndirectInheritance2().foo()\n\n    KotlinClass().test()\n    KotlinClass().testOverride()\n    KotlinClassIndirectInheritance().testOverride()\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nopen class B {\n    // check that final is not overridden\n    open protected var foo: Int = 1\n}\n\nclass C1 : A() {\n    override var foo: Int = 2\n}\n\nclass C2 : F() {\n    <!OVERRIDING_FINAL_MEMBER!>override<!> var foo: Int = 3\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nopen class B {\n    open val foo: Int = 1\n}\n\nclass C1 : A() {\n    override val foo: Int = 2\n}\n\nclass C2 : F() {\n    <!OVERRIDING_FINAL_MEMBER!>override<!> val foo: Int = 3\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nopen class B {\n    open var isFoo: Int = 1\n}\n\nclass C1 : A() {\n    override var isFoo: Int = 2\n}\n\nclass C2 : F() {\n    <!OVERRIDING_FINAL_MEMBER!>override<!> var isFoo: Int = 3\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: K.kt\n\nimport java.io.Serializable\n\nfun cloneable(c: Cloneable) = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>J<!>(<!NI;TYPE_MISMATCH!>c<!>)\n\nfun serializable(s: Serializable) = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>J<!>(<!NI;TYPE_MISMATCH!>s<!>)\n\nfun <T> both(t: T) where T : Cloneable, T : Serializable = J(t)\n"
        },
        {
            "code": "// FILE: a/M.java\npackage a;\n\npublic class M {\n    int m;\n}\n\n// FILE: b/F.java\npackage b;\n\nimport a.M;\n\npublic class F extends M {\n}\n\n// FILE: c.kt\npackage c\n\nimport b.F\n\nfun f() {\n    F().<!INVISIBLE_MEMBER!>m<!>\n}\n"
        },
        {
            "code": "// FILE: main.kt\ninterface K {\n    fun bar(): CharSequence\n    fun baz(): String\n}\n\ninterface A : J, K\n\nfun main(j: J, j2: J2, a: A) {\n    j.<!DEPRECATION!>foo<!>()\n    j2.<!DEPRECATION!>foo<!>()\n    a.<!DEPRECATION!>foo<!>()\n\n    j.<!DEPRECATION!>bar<!>()\n    j2.<!DEPRECATION!>bar<!>()\n    a.<!DEPRECATION!>bar<!>()\n\n    j.<!DEPRECATION!>baz<!>()\n    j2.baz()\n    a.baz()\n}\n"
        },
        {
            "code": "// FILE: main.kt\ninterface WithDeprecation {\n    @Deprecated(\"\")\n    fun foo()\n}\n\nclass A : J(), WithDeprecation {\n    override fun foo() {}\n}\n\nfun main() {\n    J().<!DEPRECATION!>foo<!>()\n\n    J2().<!DEPRECATION!>foo<!>()\n    A().<!DEPRECATION!>foo<!>()\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\ninterface A : J {\n    override fun foo()\n}\n\nfun main(j: J, j2: J2, a: A) {\n    j.<!DEPRECATION!>foo<!>()\n    j2.foo()\n    a.foo()\n}\n"
        },
        {
            "code": "// FILE: j/OnSubscribe.java\npackage j;\n\npublic interface OnSubscribe<T> {\n    void f();\n}\n\n// FILE: j/Observable.java\npackage j;\n\npublic class Observable<T> {\n\n    protected Observable(OnSubscribe<T> f) {\n    }\n}\n\n// FILE: Kotlin.kt\n\nimport j.*\n\nclass K : Observable<String>({})\n\nclass J : Observable<String>(null)\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun main() {\n    A.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> { \"Hello!\" }\n    A.foo(Runnable { <!UNUSED_EXPRESSION!>\"Hello!\"<!> })\n}"
        },
        {
            "code": "// FILE: Usage.kt\n\nclass A : X() {\n    // TODO: DEBUG_INFO_MISSING_UNRESOLVED indicates a bug here\n    override fun getFoo() = <!DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>foo<!>\n}"
        },
        {
            "code": "// FILE: main.kt\n\ninterface A {\n    val size: Int\n}\n\nclass C : B() {\n    override val size: Int get() = 1\n}\n\nfun foo() {\n    C().<!OVERLOAD_RESOLUTION_AMBIGUITY!>size<!>\n}"
        },
        {
            "code": "// FILE: a/M.java\npackage a;\n\npublic class M {\n    public static class Inner {\n        private int i;\n        public Inner(int i) {\n            this.i = i;\n        }\n\n        public int getI() {\n            return i;\n        }\n    }\n}\n\n// FILE: b.kt\npackage b\n\nimport a.M.Inner\n\nfun foo() {\n    doSmth(Inner(87))\n}\n\nfun doSmth(b: Inner) = b\n"
        },
        {
            "code": "// FILE: B.kt\n\nimport aa.A.use\nimport aa.A.useList\n\nfun testPrimitives(b: Byte, ss: Short, i: Int, l: Long, d: Double, s: String, f: Float, bool: Boolean) {\n    use(b)\n    use(ss)\n    use(i)\n    use(l)\n    use(s)\n    use(f)\n    use(d)\n    use(bool)\n}\n\nclass N\nclass S: java.io.Serializable\n\nfun testArrays(ia: IntArray, ai: Array<Int>, an: Array<N>, a: Array<S>) {\n    use(ia)\n    use(ai)\n    use(an)\n    use(a)\n}\n\nfun testLiterals() {\n    use(1)\n    use(1.0)\n    use(11111111111111)\n    use(\"Asdsd\")\n    use(true)\n}\n\nfun testNotSerializable(l: List<Int>) {\n    use(<!TYPE_MISMATCH!>l<!>)\n    use(<!TYPE_MISMATCH!>N()<!>)\n}\n\nenum class C {\n    E, E2\n}\n\nfun testEnums(a: Enum<*>) {\n    use(C.E)\n    use(C.E2)\n    use(a)\n}\n\nfun testLists(a: List<Int>) {\n    useList(a)\n}\n\n// FILE: aa/A.java\npackage aa;\n\npublic class A {\n    public static void use(java.io.Serializable s) { }\n    public static void useList(java.util.List<? extends java.io.Serializable> s) { }\n}"
        },
        {
            "code": "//FILE:a/JC.java\npackage a;\n\nimport java.util.Iterator;\n\npublic interface JC<T> {\n    public Iterator<T> getIterator();\n\n    public void setIterator(Iterator<T> iterator);\n\n    public Iterable<T> getIterable();\n\n    public void setIterable(Iterable<T> iterable);\n}\n\n//FILE:n.kt\npackage n\n\nimport a.JC\n\nfun foo(c: JC<Int>, iterator: Iterator<Int>, iterable: Iterable<Int>) {\n    val mutableIterator: MutableIterator<Int>? = c.getIterator()\n    c.setIterator(mutableIterator)\n    c.setIterator(iterator)\n\n    val mutableIterable: MutableIterable<Int>? = c.getIterable()\n    c.setIterable(mutableIterable)\n    c.setIterable(iterable)\n}\n"
        },
        {
            "code": "// FILE: test.kt\ninterface KTrait : Test {\n    fun ktest() {\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n        test()\n    }\n}\n\n\ninterface KTrait2 : KTrait {\n    fun ktest2() {\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n        test()\n    }\n}\n\nclass A : KTrait {\n    fun a() {\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n\n        test()\n    }\n}\n\n\nclass A2 : KTrait2 {\n    fun a() {\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n\n        test()\n    }\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nclass K : C()\n\nfun main() {\n    I.a\n    I.<!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>foo<!>()\n\n    C.a\n    C.b\n    C.<!UNRESOLVED_REFERENCE!>foo<!>()\n    C.bar()\n\n    K.<!UNRESOLVED_REFERENCE!>a<!>\n    K.<!UNRESOLVED_REFERENCE!>b<!>\n    K.<!UNRESOLVED_REFERENCE!>foo<!>()\n    K.<!UNRESOLVED_REFERENCE!>bar<!>()\n}\n"
        },
        {
            "code": "// FILE: test.kt\nfun test(a: A, first: B<Int>, second: B<Int?>) {\n    a.foo()\n    a.foo(0)\n\n    a.bar(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.bar(0)\n\n    first.foo()\n    first.foo(5)\n\n    second.foo()\n    second.foo(5)\n}"
        },
        {
            "code": "// FILE: F.kt\nopen class F {\n    open fun foo(x: String = \"0\") {\n    }\n}\n\n// FILE: main.kt\nfun main() {\n    val a = A()\n    val c = C()\n    val d = D()\n    val e = E()\n\n    val ac: A = C()\n    val bd: B = D()\n\n    a.first()\n    c.first()\n    ac.first()\n\n    d.first(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    bd.first(<!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    e.first()\n\n    val g = G()\n    g.foo()\n    g.foo(\"ok\")\n\n    val m = M()\n    m.foo()\n\n}\n\n"
        },
        {
            "code": "// FILE: test.kt\nfun main() {\n    val a = A()\n\n    a.first()\n    a.first(\"arg\")\n\n    a.second()\n    a.second(\"arg\")\n    a.second(\"first\", \"second\")\n\n    a.third(\"OK\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.third(\"first\", \"second\")\n\n    a.fourth(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.fourth(\"first\")\n    a.fourth(\"first\", \"second\")\n\n    a.wrong(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.wrong(42)\n}\n\n"
        },
        {
            "code": "// FILE: test.kt\nfun main() {\n    val test = A()\n    test.dollarName(`$` = \"hello\")\n    test.dollarName(\"hello\")\n    test.dollarName(<!NAMED_PARAMETER_NOT_FOUND!>host<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    test.numberName(`42` = \"world\")\n    test.numberName(\"world\")\n    test.numberName(<!NAMED_PARAMETER_NOT_FOUND!>field<!> = \"world\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n}"
        },
        {
            "code": "// FILE: D.kt\nopen class D {\n    open fun call(foo: String) {\n    }\n}\n\n// FILE: test.kt\nfun main() {\n    val a = A()\n    val b = B()\n    val c = C()\n\n    a.call(foo = \"hello\")\n    a.call(<!NAMED_PARAMETER_NOT_FOUND!>arg<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.call(\"hello\")\n\n    b.call(<!NAMED_PARAMETER_NOT_FOUND!>foo<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    b.call(<!NAMED_PARAMETER_NOT_FOUND!>arg<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    b.call(bar = \"hello\")\n    b.call(\"hello\")\n\n    c.call(foo = \"hello\")\n    c.call(<!NAMED_PARAMETER_NOT_FOUND!>arg<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    c.call(\"hello\")\n\n    val e = E()\n    val f = F()\n\n    e.call(<!NAMED_PARAMETER_NOT_FOUND!>foo<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    e.call(<!NAMED_PARAMETER_NOT_FOUND!>bar<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    e.call(baz = \"hello\")\n    e.call(\"hello\")\n\n    f.call(foo = \"hello\")\n    f.call(<!NAMED_PARAMETER_NOT_FOUND!>baaam<!> = \"hello\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    f.call(\"hello\")\n\n    val g = G()\n    val h = H()\n    g.foo(\"ok\", <!NAMED_ARGUMENTS_NOT_ALLOWED!>foo<!> = \"hohoho\")\n    g.foo(\"ok\", \"hohoho\")\n    h.foo(\"ok\", <!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>foo<!> = \"hohoho\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    h.foo(\"ok\", \"hohoho\")\n}\n"
        },
        {
            "code": "\n// FILE: test.kt\nfun main() {\n    val test = A()\n    test.same(\"hello\", \"world\")\n    test.same(ok = \"hello\", <!ARGUMENT_PASSED_TWICE!>ok<!> = <!UNRESOLVED_REFERENCE!>world<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    test.same(\"hello\", <!ARGUMENT_PASSED_TWICE!>ok<!> = \"world\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n}"
        },
        {
            "code": "// FILE: test.kt\nfun main() {\n    val test = A()\n    test.emptyName(\"first\", 42)\n    test.emptyName(\"first\", <!NAMED_ARGUMENTS_NOT_ALLOWED!>ok<!> = 42)\n\n    test.missingName(<!NAMED_ARGUMENTS_NOT_ALLOWED!>`first`<!> = \"arg\")\n    test.missingName(\"arg\")\n\n    test.numberName(\"first\")\n}"
        },
        {
            "code": "// FILE: B.kt\nenum class B {\n    X,\n    Y;\n}\n\n// FILE: test.kt\nfun test(){\n    val a = A()\n    a.a()\n    a.a(Signs.HELLO)\n    a.b()\n    a.b(B.X)\n    a.foooo(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.foooo(B.Y)\n    a.bar(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    a.baz(<!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    a.bam(<!NO_VALUE_FOR_PARAMETER!>)<!>\n}"
        },
        {
            "code": "// FILE: test.kt\nfun main(a: A, b: B) {\n    a.first()\n    a.second()\n    a.third()\n    a.fourth()\n\n    b.first(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    b.second(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    b.third(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    b.fourth(<!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n\n"
        },
        {
            "code": "// KT-4149 static members of Java private nested class are accessible from Kotlin\n\n// FILE: javaPackage/Foo.java\n\npackage javaPackage;\n\npublic class Foo {\n    private static class Bar {\n        public static void doSmth() {\n        }\n    }\n}\n\n// FILE: 1.kt\n\nfun main() {\n    javaPackage.Foo.<!INVISIBLE_REFERENCE!>Bar<!>.<!INVISIBLE_MEMBER!>doSmth<!>()\n}"
        },
        {
            "code": "//FILE: a/MyJavaClass.java\npackage a;\n\nclass MyJavaClass {\n    static int staticMethod() {\n        return 1;\n    }\n\n    static class NestedClass {\n        static int staticMethodOfNested() {\n            return 1;\n        }\n    }\n}\n\n//FILE:a.kt\npackage a\n\nval <!EXPOSED_PROPERTY_TYPE!>mc<!> = MyJavaClass()\nval x = MyJavaClass.staticMethod()\nval y = MyJavaClass.NestedClass.staticMethodOfNested()\nval <!EXPOSED_PROPERTY_TYPE!>z<!> = MyJavaClass.NestedClass()\n\n//FILE: b.kt\npackage b\n\nimport a.<!INVISIBLE_REFERENCE!>MyJavaClass<!>\n\nval <!EXPOSED_PROPERTY_TYPE!>mc1<!> = <!INACCESSIBLE_TYPE!><!INVISIBLE_MEMBER!>MyJavaClass<!>()<!>\n\nval x = <!INVISIBLE_REFERENCE!>MyJavaClass<!>.<!INVISIBLE_MEMBER!>staticMethod<!>()\nval y = <!INVISIBLE_REFERENCE!>MyJavaClass<!>.<!INVISIBLE_REFERENCE!>NestedClass<!>.<!INVISIBLE_MEMBER!>staticMethodOfNested<!>()\nval <!EXPOSED_PROPERTY_TYPE!>z<!> = <!INACCESSIBLE_TYPE!><!INVISIBLE_REFERENCE!>MyJavaClass<!>.<!INVISIBLE_MEMBER!>NestedClass<!>()<!>\n\n//FILE: c.kt\npackage a.c\n\nimport a.<!INVISIBLE_REFERENCE!>MyJavaClass<!>\n\nval <!EXPOSED_PROPERTY_TYPE!>mc1<!> = <!INACCESSIBLE_TYPE!><!INVISIBLE_MEMBER!>MyJavaClass<!>()<!>\n\nval x = <!INVISIBLE_REFERENCE!>MyJavaClass<!>.<!INVISIBLE_MEMBER!>staticMethod<!>()\nval y = <!INVISIBLE_REFERENCE!>MyJavaClass<!>.<!INVISIBLE_REFERENCE!>NestedClass<!>.<!INVISIBLE_MEMBER!>staticMethodOfNested<!>()\nval <!EXPOSED_PROPERTY_TYPE!>z<!> = <!INACCESSIBLE_TYPE!><!INVISIBLE_REFERENCE!>MyJavaClass<!>.<!INVISIBLE_MEMBER!>NestedClass<!>()<!>"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: main.kt\n\nclass B : A() {\n    <!OVERRIDING_FINAL_MEMBER!>override<!> val size: Int = 1\n}\n"
        },
        {
            "code": "// FILE: a/Statics.java\n\npackage a;\n\npublic class Statics {\n    public static void foo(Runnable r) {}\n}\n\n// FILE: test.kt\n\npackage b;\n\nimport a.Statics.foo\n\nfun test() {\n    foo {}\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: main.kt\nfun main() {\n    J <!NI;TYPE_MISMATCH!>{ <!EXPECTED_PARAMETER_TYPE_MISMATCH!>s: String<!> -> s}<!> // should be prohibited, because SAM value parameter has nullable type\n    J { \"\" + it<!UNSAFE_CALL!>.<!>length }\n    J { <!NI;NULL_FOR_NONNULL_TYPE, NULL_FOR_NONNULL_TYPE!>null<!> }\n    J { <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>it?.length?.toString()<!> }\n\n    J2 <!NI;TYPE_MISMATCH!>{ <!EXPECTED_PARAMETER_TYPE_MISMATCH!>s: String<!> -> s}<!>\n    J2 { \"\" + it<!UNSAFE_CALL!>.<!>length }\n    J2 { <!NI;NULL_FOR_NONNULL_TYPE, NULL_FOR_NONNULL_TYPE!>null<!> }\n    J2 { <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>it?.length?.toString()<!> }\n}\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: foo/A.java\npackage foo;\n\npublic class A {\n    static void f(B b) {\n        b.g();\n    }\n\n    public interface B {\n        void g();\n    }\n}\n\n// FILE: bar/sample.kt\n\npackage bar\n\nfun main() {\n    foo.A.<!INVISIBLE_MEMBER!>f<!> {}\n}"
        },
        {
            "code": "// FILE: a/Statics.java\n\npackage a;\n\npublic class Statics {\n    public static void foo(Runnable r) {}\n}\n\n// FILE: test.kt\n\npackage b\n\nimport a.Statics.*\n\nfun test() {\n    foo {}\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// FILE: kt1.kt\npackage kt\n\ninline class Z(val value: Int)\n\ninterface IFoo<T> {\n    fun foo(): T\n}\n\nopen class KFooZ : IFoo<Z> {\n    override fun foo(): Z = Z(42)\n}\n\n// FILE: j/J.java\npackage j;\n\nimport kt.Z;\nimport kt.KFooZ;\n\npublic class J extends KFooZ {\n}\n\n// FILE: kt2.kt\npackage kt\n\nimport j.J\n\nfun jfoo(x: J) = x.foo()"
        },
        {
            "code": "//FILE: Bbb.kt\nopen class Bbb\n\n//FILE: Ddd.kt\nimport Ccc\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: main.kt\n\nclass Out<out E> {\n    fun x(): E = null!!\n}\n\nclass In<in F> {\n    fun y(f: F) {}\n}\n\nfun test() {\n    A.foo().x() checkType { _<Any?>() }\n    A.bar().<!OI;MEMBER_PROJECTED_OUT!>y<!>(<!NI;NULL_FOR_NONNULL_TYPE!>null<!>)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\nimport JavaInterface.testStatic\n\ninterface KotlinInterface : JavaInterface {\n    fun fooo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n        object  {\n            fun run () {\n                super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n            }\n        }\n    }\n\n    val propertyy: String\n        get() {\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n            object  {\n                fun run () {\n                    super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                }\n            }\n            return \"\"\n        }\n\n    override fun testOverride(): String {\n        return \"OK\";\n    }\n}\n\ninterface KotlinInterfaceIndirectInheritance : KotlinInterface {\n    fun foooo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n        object  {\n            fun run () {\n                super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n            }\n        }\n    }\n\n    val propertyyy: String\n        get() {\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n\n            object  {\n                fun run () {\n                    super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                }\n            }\n            return \"\"\n        }\n}\n\nopen class KotlinClass : JavaInterface {\n    fun foo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testOverride<!>()\n\n        object  {\n            fun run () {\n                super@KotlinClass.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n            }\n        }\n    }\n\n    val property: String\n        get() {\n            super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n            super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testOverride<!>()\n\n            object  {\n                fun run () {\n                    super@KotlinClass.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n                }\n            }\n            return \"\"\n        }\n}\n\nclass KotlinClassIndirectInheritance : KotlinClass() {\n    fun foo2(){\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.test()\n        super.testOverride()\n\n        object  {\n            fun run () {\n                super@KotlinClassIndirectInheritance.test()\n            }\n        }\n    }\n\n    val property2: String\n        get() {\n            super.test()\n            super.testOverride()\n\n            object  {\n                fun run () {\n                    super@KotlinClassIndirectInheritance.test()\n                }\n            }\n            return \"\"\n        }\n}\n\nclass KotlinClassIndirectInheritance2 : KotlinInterfaceIndirectInheritance {\n    fun foo() {\n        <!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n        super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n        super.testOverride()\n\n        object  {\n            fun run () {\n                super@KotlinClassIndirectInheritance2.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n            }\n        }\n    }\n\n    val property: String\n        get() {\n            super.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n            super.testOverride()\n\n            object  {\n                fun run () {\n                    super@KotlinClassIndirectInheritance2.<!DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>test<!>()\n                }\n            }\n            return \"\"\n        }\n}\n\nfun test() {\n    JavaInterface.<!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>testStatic<!>()\n    KotlinClass().foo()\n    KotlinClass().property\n    KotlinClassIndirectInheritance2().foo()\n    KotlinClassIndirectInheritance2().property\n\n    KotlinClass().test()\n    KotlinClass().property\n    KotlinClass().testOverride()\n    KotlinClassIndirectInheritance().testOverride()\n}\n"
        },
        {
            "code": "// FILE: Sub.kt\nclass Sub() : Super() {\n    fun foo(<!UNUSED_PARAMETER!>r<!> : (() -> Unit)?) {\n    }\n}"
        },
        {
            "code": "class Foo {\n  companion object {\n    val bar = 1\n\n    fun test(<!UNUSED_PARAMETER!>a<!>: Foo.<!UNRESOLVED_REFERENCE!>`object`<!>) {\n\n    }\n\n  }\n}"
        },
        {
            "code": "// FILE: a/M.java\npackage a;\n\npublic class M {\n    public class Inner {\n\n    }\n\n    public static class Nested {\n\n    }\n\n    private class PrInner {\n\n    }\n\n    private static class PrNested {\n\n    }\n}\n\n// FILE: b.kt\npackage b\n\nfun f() {\n  val <!UNUSED_VARIABLE!>c1<!>: a.M.Inner\n  val <!UNUSED_VARIABLE!>c2<!>: a.M.Nested\n  val <!UNUSED_VARIABLE!>c3<!>: a.M.<!INVISIBLE_REFERENCE!>PrInner<!>\n  val <!UNUSED_VARIABLE!>c4<!>: a.M.<!INVISIBLE_REFERENCE!>PrNested<!>\n\n}\n\n"
        },
        {
            "code": "//FILE:_03_collections/CollectionTest.java\npackage _03_collections;\n\nimport java.util.List;\n\npublic class CollectionTest {\n    public static void add(List<Integer> ints) {\n        ints.add(5);\n    }\n}\n\n//FILE:n.kt\npackage _03_collections\n\nimport java.util.ArrayList\n\nfun test() {\n  val <!UNUSED_VARIABLE!>c<!> = CollectionTest()\n  CollectionTest.add(ArrayList())\n}\n"
        },
        {
            "code": "// JAVAC_SKIP\n// FILE: main.kt\nfun main(x: A) {\n    x.b().bar()\n    x.<!MISSING_DEPENDENCY_CLASS!>f<!>().<!UNRESOLVED_REFERENCE!>foobaz<!>()\n\n    <!UNRESOLVED_REFERENCE!>D<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>baz<!>()\n}\n"
        },
        {
            "code": "// FILE: test/JavaClass.java\n\npackage test;\n\npublic class JavaClass {\n    protected static int field;\n\n    protected static String method() {\n        return \"\";\n    }\n}\n\n// FILE: test.kt\n\npackage test\n\nfun test() {\n    JavaClass.field\n    JavaClass.method()\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage a\n\nimport <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.Iterator<!>\nimport <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<!> as Comp\n\nfun bar(any: Any): <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Iterable<Int><!>? {\n    val <!UNUSED_VARIABLE!>a<!>: <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<String><!>? = null\n    val <!UNUSED_VARIABLE!>b<!>: Iterable<<!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Integer<!>>\n    val <!UNUSED_VARIABLE!>c<!> : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Iterator<String><!>? = null\n\n    if (any is <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Iterator<*><!>) {\n        checkSubtype<<!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Iterator<*><!>>(<!DEBUG_INFO_SMARTCAST!>any<!>)\n    }\n    any as <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Iterator<*><!>\n    return null\n}"
        },
        {
            "code": "// FILE: aa/A.java\npackage aa;\n\npublic class A {\n    public void f() { }\n}\n\n// FILE: B.kt\nimport aa.A\n\nfun foo(a: A) = a.f()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// FILE: main.kt\n\n// TODO: It's effectively impossible to perform super call to such constructor\n// if there is not enough information to infer corresponding arguments\n// May be we could add some special syntax for such arguments\nclass B1(x: List<String>) : <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!><!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>A<!><CharSequence><!>(\"\", x)\nclass B2(x: List<Int>) : <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>A<CharSequence>(\"\", x)<!>\n\nclass C : A<CharSequence> {\n    constructor(x: List<String>) : <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>super<!>(\"\", x)\n    constructor(x: List<Int>, y: Int) : <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>super<!>(\"\", x)\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nfun test(x: List<Int>, y: List<String>) {\n    A(\"\", x) // inferred as Any!\n    A(\"\", y)\n\n    A<String>(\"\", <!TYPE_MISMATCH!>x<!>)\n\n    A<Any>(\"\", x)\n    A<String>(\"\", y)\n    A<CharSequence>(\"\", y)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// FILE: main.kt\nfun test(x: List<Int>, y: List<String>) {\n    Outer<Int>().Inner(\"\", y, 1) checkType { _<Outer<Int>.Inner<String>>() }\n    Outer<Int>().Inner<CharSequence, String, Int>(\"\", y, 1) checkType { _<Outer<Int>.Inner<CharSequence>>() }\n\n    Outer<Int>().Inner(\"\", x, 1) checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Outer<Int>.Inner<Any>>() }\n    Outer<Int>().Inner<CharSequence, String, Int>(\"\", <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>x<!>, 1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n// FILE: main.kt\n\nfun test(x: List<Int>, y: List<String>) {\n    var z: A<Double> = A(\"\", x) // E inferred from expected type\n    z = A(\"\", y)\n\n    z = A<Double, String>(\"\", <!TYPE_MISMATCH!>x<!>)\n\n    z = A<Double, Any>(\"\", x)\n    z = A<Double, String>(\"\", y)\n    z = A<Double, CharSequence>(\"\", y)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: main.kt\n\nclass Inv<T>\n\nfun test(x: Inv<Int>, y: Inv<String>) {\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>A<!>(\"\", <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>x<!>)\n    A(\"\", y)\n\n    A<String>(\"\", <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>x<!>)\n\n    A<Any>(\"\", <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>x<!>)\n    A<String>(\"\", y)\n    A<CharSequence>(\"\", <!TYPE_MISMATCH!>y<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// FILE: main.kt\n\nclass B1(x: List<String>) : A<CharSequence>(\"\", x)\nclass B2(x: List<Int>) : <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>A<CharSequence>(\"\", x)<!>\n\nclass C : A<CharSequence> {\n    constructor(x: List<String>) : super(\"\", x)\n    constructor(x: List<Int>, y: Int) : <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>super<!>(\"\", x)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: main.kt\n\nfun foo() = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>C<!>(<!NO_VALUE_FOR_PARAMETER!>)<!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// FILE: main.kt\n\nfun test(x: List<Int>, y: List<String>) {\n    A(\"\", x) checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><A<Any?>>() }\n    A(\"\", y) checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><A<String?>>() }\n\n    A<CharSequence, String>(\"\", <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>x<!>)\n    A<CharSequence, String>(\"\", y)\n}\n"
        },
        {
            "code": "//KT-2606 Filter java.util.* import\npackage n\n\nimport java.util.*\nimport java.lang.annotation.*\n\nfun bar() : Iterator<Int>? {\n    val <!UNUSED_VARIABLE!>i<!> : Iterable<<!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Integer<!>>\n    val <!UNUSED_VARIABLE!>a<!> : Annotation\n    return null\n}"
        },
        {
            "code": "// FILE: AC.kt\n\ninterface A {\n    val a: Int\n}\n\n// FILE: C.kt\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class C<!> : B()\n\nfun main() {\n    C().a\n}"
        },
        {
            "code": "//FILE: a/C.java\n// KT-1431 StackOverflowException in IDE when using JavaFX builders\npackage a;\n\npublic class C<B extends C<B>> {\n    public static C<?> create() { return null; }\n    public C foo() {return null;}\n}\n\n//FILE: d.kt\npackage d\n\nimport a.C\n\nfun test() {\n    C.create().foo()\n}\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: p/G.java\n\npackage p;\n\npublic interface G<TG> {\n}\n\n// FILE: p/A.kt\n\npackage p;\n\npublic interface A<TA> {\n    fun foo(p: A<TA>)\n}\n\n// FILE: p/B.java\n\npackage p;\n\npublic class B<TB> implements A<TB> {\n    void foo(A<TB> p) {}\n}\n\n// FILE: p/C.java\n\npackage p;\n\npublic class C<TC> extends B<TC> implements A<TC> {\n}\n\n// FILE: p/P.java\n\npackage p;\n\npublic class P {\n}\n\n// FILE: k.kt\n\nimport p.*\n\nabstract class K: C<P>() {\n\n}\n\nabstract class AL: java.util.ArrayList<P>() {\n\n}"
        },
        {
            "code": "//FILE: foo.kt\nfun main() {\n    val c: Type\n    <!NON_EXHAUSTIVE_WHEN!>when<!> (<!UNINITIALIZED_VARIABLE, UNUSED_EXPRESSION!>c<!>)  {\n\n    }\n}\n\n\n\n"
        },
        {
            "code": "// FILE: main.kt\n\nfun foo(b: B) {\n    // See KT-9182\n    b.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(1)\n    b.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>(2.0)\n}\n"
        },
        {
            "code": "// FILE: a/Test.java\npackage a;\n\npublic class Test<T> {\n  T t() {return null;}\n}\n// FILE: b.kt\npackage a\n\nfun foo() {\n  // If this fails, it means that we have broken the rule that Java returns are always nullable\n  a.Test<Int>().t() + 1\n}\n"
        },
        {
            "code": "// KT-4021 Java's Package visibilty does not work for static methods\n\n// FILE: foo/Bar.java\n\npackage foo;\n\nclass Bar {\n    static void baz() {}\n}\n\n// FILE: main.kt\n\npackage foo\n\nfun main() {\n    Bar.baz()\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: test.kt\n\nfun main() {\n    checkSubtype<Any>(Y().fooN())\n    Y().barN(<!NULL_FOR_NONNULL_TYPE!>null<!>);\n}\n"
        },
        {
            "code": "// FILE: B.kt\n\nimport aa.B\n\nfun use() {\n    // checking that CONST is of platform type\n    B.CONST = null\n    B.CONST?.length\n    B.CONST.length\n}\n\n// FILE: aa/A.java\npackage aa;\n\npublic class A {\n    public static int CONST = 3;\n}\n\n// FILE: aa/B.java\npackage aa;\n\npublic class B extends A {\n    public static String CONST = null;\n}"
        },
        {
            "code": "// FILE: p/A.java\n\npackage p;\n\npublic interface A {\n    <TA> void foo(TA p);\n}\n\n// FILE: p/B.java\n\npackage p;\n\npublic class B implements A {\n    <TB> void foo(TB p) {}\n}\n\n// FILE: p/C.java\n\npackage p;\n\npublic class C extends B implements A {\n}\n\n// FILE: k.kt\n\nimport p.*\n\nabstract class K: C() {\n\n}\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: backend/asmutil/AsmUtil.java\npackage backend.asmutil;\n\nimport org.jetbrains.annotations.NotNull;\nimport static frontend.JvmDeclarationOrigin.NO_ORIGIN;\n\npublic class AsmUtil {\n\n    @NotNull\n    public static String doSmth(String s) {\n        Object or = NO_ORIGIN;\n        return \"OK\";\n    }\n}\n\n// FILE: First.kt\npackage frontend\npublic class JvmDeclarationOrigin {\n    companion object {\n        public val NO_ORIGIN: JvmDeclarationOrigin = JvmDeclarationOrigin()\n    }\n}\n\n// FILE: Second.kt\npackage backend\n\nimport backend.asmutil.AsmUtil.doSmth\n\nopen public class ECallable  {\n    fun test() {\n        doSmth(\"\")\n    }\n}\n\n/* KT-5848 */\n\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: test.kt\n\nfun main() {\n    checkSubtype<Any>(Y().fooN())\n    Y().barN(<!NULL_FOR_NONNULL_TYPE!>null<!>);\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// FILE: main.kt\nfun main() {\n    A().foo <!TYPE_MISMATCH!>{\n        <!OI;CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>x<!> ->\n        \"\"\n    }<!>\n\n    A.bar <!TYPE_MISMATCH!>{\n        <!OI;CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>x<!> ->\n        \"\"\n    }<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// FILE: main.kt\nfun main() {\n    A().foo {\n        x -> x.hashCode()\n    }\n\n    A.bar {\n        x -> x.hashCode()\n    }\n\n\n    // baz\n    A.baz {\n        x -> x.toString() // OK\n    }\n\n    A.baz {\n        x -> <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>x.hashCode()<!>\n    }\n\n    val block: (String) -> Any? = {\n        x -> x.hashCode()\n    }\n\n    A().foo(block)\n    A.bar(block)\n\n    val block2: (String) -> CharSequence? = {\n        x -> x.toString()\n    }\n\n    A.baz(<!TYPE_MISMATCH!>block<!>)\n    A.baz(block2)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -PARAMETER_NAME_CHANGED_ON_OVERRIDE\n// JAVAC_EXPECTED_FILE\n// FILE: main.kt\nabstract class KA<T> : java.util.AbstractList<T>() {\n    override fun contains(x: T) = false\n}\n\nabstract class KB : java.util.AbstractList<String>(), IC {\n    override fun contains(element: String) = false\n}\n\n\n// Raw?\n\nfun foo(\n        a: A<String>, b: B, ic: IC,\n        ka: KA<String>, kb: KB,\n        al: java.util.ArrayList<String>\n) {\n    a.contains(\"\")\n    a.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in a\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in a\n\n    b.contains(\"\")\n    b.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in b\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in b\n\n    ic.contains(\"\")\n    ic.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in ic\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in ic\n\n    ka.contains(\"\")\n    ka.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in ka\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in ka\n\n    kb.contains(\"\")\n    kb.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in kb\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in kb\n\n    al.contains(\"\")\n    al.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in al\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in al\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -PARAMETER_NAME_CHANGED_ON_OVERRIDE\n// JAVAC_EXPECTED_FILE\n// FILE: main.kt\nabstract class KA<T> : java.util.AbstractList<T>() {\n    override fun containsAll(x: Collection<T>) = false\n}\n\nabstract class KB : java.util.AbstractList<String>(), IC {\n    override fun containsAll(elements: Collection<String>) = false\n}\n\nfun foo(\n        a: A<String>, b: B, ic: IC,\n        ka: KA<String>, kb: KB,\n        al: java.util.ArrayList<String>,\n        cs: Collection<String>, ca: Collection<Any?>\n) {\n    a.containsAll(cs)\n    a.containsAll(<!TYPE_MISMATCH!>ca<!>)\n\n    b.containsAll(cs)\n    b.containsAll(<!TYPE_MISMATCH!>ca<!>)\n\n    ic.containsAll(cs)\n    ic.containsAll(<!TYPE_MISMATCH!>ca<!>)\n\n    ka.containsAll(cs)\n    ka.containsAll(<!TYPE_MISMATCH!>ca<!>)\n\n    kb.containsAll(cs)\n    kb.containsAll(<!TYPE_MISMATCH!>ca<!>)\n\n    al.containsAll(cs)\n    al.containsAll(<!TYPE_MISMATCH!>ca<!>)\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nclass Y : X()\nclass <!CONFLICTING_JVM_DECLARATIONS!>Y2<!> : X() {\n    <!CONFLICTING_JVM_DECLARATIONS!>override fun removeAt(index: Int)<!> = \"\"\n}\n\nfun main() {\n    X().remove(\"\")\n    X().removeAt(1)\n\n    val y: MutableList<String> = Y()\n    y.removeAt(1)\n\n    Y().remove(\"\")\n    Y().removeAt(1)\n\n    X().remove(\"\")\n    X().removeAt(1)\n}\n"
        },
        {
            "code": "import java.util.*\nfun foo() {\n    val al = ArrayList<String>()\n    al.size\n    al.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    al.contains(\"\")\n\n    al.remove(\"\")\n    al.removeAt(1)\n\n    val hs = HashSet<String>()\n    hs.size\n    hs.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    hs.contains(\"\")\n\n    hs.remove(\"\")\n\n\n    val hm = HashMap<String, Int>()\n    hm.size\n    hm.containsKey(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    hm.containsKey(\"\")\n\n    hm[<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>]\n    hm[\"\"]\n\n    hm.remove(\"\")\n}\n"
        },
        {
            "code": "// FILE: X.kt\nclass X : A()\n\nfun main() {\n    val x = X()\n    x[0]\n    x.size\n    x.remove(\"\")\n    x.remove(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -PARAMETER_NAME_CHANGED_ON_OVERRIDE\n\n// FILE: main.kt\nabstract class <!CONFLICTING_JVM_DECLARATIONS!>KA<!> : A() {\n    <!CONFLICTING_JVM_DECLARATIONS!>override fun contains(x: String)<!> = false\n}\n\nfun foo(a: A, ka: KA) {\n    a.contains(\"\")\n    a.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in a\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in a\n\n    ka.contains(\"\")\n    ka.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \"\" in ka\n    <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> in ka\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: AImpl.kt\n\npublic abstract class AImpl {\n    fun add(element: String): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun remove(element: String): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun addAll(elements: Collection<String>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun addAll(index: Int, elements: Collection<String>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun removeAll(elements: Collection<String>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun retainAll(elements: Collection<String>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun clear() {\n        throw UnsupportedOperationException()\n    }\n\n    fun set(index: Int, element: String): String {\n        throw UnsupportedOperationException()\n    }\n\n    fun add(index: Int, element: String) {\n        throw UnsupportedOperationException()\n    }\n\n    fun remove(index: Int): String {\n        throw UnsupportedOperationException()\n    }\n\n    fun listIterator(): MutableListIterator<String> {\n        throw UnsupportedOperationException()\n    }\n\n    fun listIterator(index: Int): MutableListIterator<String> {\n        throw UnsupportedOperationException()\n    }\n\n    fun subList(fromIndex: Int, toIndex: Int): MutableList<String> {\n        throw UnsupportedOperationException()\n    }\n\n    val size: Int\n        get() = throw UnsupportedOperationException()\n\n    fun isEmpty(): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun contains(element: Any?): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun containsAll(elements: Collection<*>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    fun get(index: Int): String {\n        throw UnsupportedOperationException()\n    }\n\n    fun indexOf(element: String): Int {\n        throw UnsupportedOperationException()\n    }\n\n    fun lastIndexOf(element: String): Int {\n        throw UnsupportedOperationException()\n    }\n\n    fun iterator(): MutableIterator<String> {\n        throw UnsupportedOperationException()\n    }\n}\n\n\n// FILE: X.kt\nclass X : A()\n\nfun main() {\n    val x = X()\n    x[0]\n    x.size\n    x.remove(\"\")\n    x.remove(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n}\n"
        },
        {
            "code": "fun test() {\n    <!INVISIBLE_MEMBER!>Double<!>()\n    <!INVISIBLE_MEMBER!>Float<!>()\n    <!INVISIBLE_MEMBER!>Long<!>()\n    <!INVISIBLE_MEMBER!>Int<!>()\n    <!INVISIBLE_MEMBER!>Short<!>()\n    <!INVISIBLE_MEMBER!>Byte<!>()\n    <!INVISIBLE_MEMBER!>Char<!>()\n    <!INVISIBLE_MEMBER!>Boolean<!>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-1293 Compiler doesn't show error when element of Array<Int?> is assigned to Int\n\npackage kt1293\n\nfun main() {\n    val intArray = arrayOfNulls<Int>(10)\n    val <!UNUSED_VARIABLE!>i<!> : Int = <!TYPE_MISMATCH!>intArray[0]<!>\n    requiresInt(<!TYPE_MISMATCH!>intArray[0]<!>)\n}\n\nfun requiresInt(<!UNUSED_PARAMETER!>i<!>: Int) {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\nfun <T> foo(a1: Array<T>, a2: Array<out T>): T = null!!\n\nfun test(a1: Array<in Int>, a2: Array<Int>) {\n\n    val c: Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>foo(a1, a2)<!>\n\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun <T> Array<T>.foo() {}\n\nfun test(array: Array<out Int>) {\n    array.foo()\n    <!OI;TYPE_MISMATCH!>array<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>foo<!><<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>out<!> Int>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun <T> foo(array: Array<Array<T>>): Array<Array<T>> = array\n\nfun test(array: Array<Array<out Int>>) {\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>foo<!>(<!NI;TYPE_MISMATCH!>array<!>)\n\n    val f: Array<out Array<out Int>> = <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>foo<!>(<!TYPE_MISMATCH!>array<!>)\n}\n"
        },
        {
            "code": "\nfun <T> Array<out T>.intersect(other: Iterable<T>) {\n    val set = toMutableSet()\n    set.retainAll(other)\n}\n\nfun <X> Array<out X>.toMutableSet(): MutableSet<X> = TODO()\nfun <Y> MutableCollection<in Y>.retainAll(<!UNUSED_PARAMETER!>elements<!>: Iterable<Y>) {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nfun <T : Any> Array<T?>.filterNotNull(): List<T> = throw Exception()\n\nfun test1(a: Array<out Int?>) {\n    val list = a.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>filterNotNull<!>()\n    <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>list<!> <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!NI;UNRESOLVED_REFERENCE!>_<!><List<Int>>() }\n}\n\nfun test2(vararg a: Int?) {\n    val list = a.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>filterNotNull<!>()\n    <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>list<!> <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!NI;UNRESOLVED_REFERENCE!>_<!><List<Int>>() }\n}"
        },
        {
            "code": "fun <V, R, M : MutableMap<in R, out V>> mapKeysTo(destination: M): Inv3<R, V, M> {\n    val foo = associateByTo(destination)\n\n    return foo\n}\n\nfun < Y, Z, T : MutableMap<in Y, out Z>> associateByTo(<!UNUSED_PARAMETER!>destination<!>: T): Inv3<Y, Z, T> = TODO()\n\ninterface Inv3<A, B, C>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A<T>\nclass B<T>\n\nfun <E> foo(b: B<in A<E>>) {}\nfun <E> baz(b: B<out A<E>>) {}\n\n// See KT-13950\nfun bar(b: B<in A<out Number>>, bOut: B<out A<out Number>>, bOut2: B<out A<Number>>) {\n    foo(b)\n    foo<Number>(b)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>baz<!>(<!NI;TYPE_MISMATCH!>bOut<!>)\n    baz<Number>(<!TYPE_MISMATCH!>bOut<!>)\n\n    baz(bOut2)\n    baz<Number>(bOut2)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// !CHECK_TYPE\n\nfun <T: Any> bar(a: Array<T>): Array<T?> =  null!!\n\nfun test1(a: Array<out Int>) {\n    val r: Array<out Int?> = <!NI;TYPE_MISMATCH!><!NI;UNSUPPORTED!>bar<!>(a)<!>\n    val t = <!NI;UNSUPPORTED!>bar<!>(a)\n    <!NI;UNSUPPORTED!>t<!> checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Array<out Int?>>() }\n}\n\nfun <T: Any> foo(l: Array<T>): Array<Array<T?>> = null!!\n\nfun test2(a: Array<out Int>) {\n    val r: Array<out Array<out Int?>> = <!NI;TYPE_MISMATCH!><!NI;UNSUPPORTED!>foo<!>(a)<!>\n    val t = <!NI;UNSUPPORTED!>foo<!>(a)\n    <!NI;UNSUPPORTED!>t<!> checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Array<out Array<out Int?>>>() }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// !CHECK_TYPE\n\nfun <T: Any> bar(a: Array<T>): Array<T?> =  null!!\n\nfun test1(a: Array<in Int>) {\n    val r: Array<in Int?> = <!OI;TYPE_INFERENCE_CANNOT_CAPTURE_TYPES!>bar<!>(<!NI;TYPE_MISMATCH!>a<!>)\n    <!OI;TYPE_INFERENCE_CANNOT_CAPTURE_TYPES!>bar<!>(<!NI;TYPE_MISMATCH!>a<!>)\n}\n\nfun <T: Any> foo(l: Array<T>): Array<Array<T?>> = null!!\n\nfun test2(a: Array<in Int>) {\n    val r: Array<out Array<in Int?>> = <!OI;TYPE_INFERENCE_CANNOT_CAPTURE_TYPES!>foo<!>(<!NI;TYPE_MISMATCH!>a<!>)\n    <!OI;TYPE_INFERENCE_CANNOT_CAPTURE_TYPES!>foo<!>(<!NI;TYPE_MISMATCH!>a<!>)\n}"
        },
        {
            "code": "interface Inv<T>\n\nfun <Y: X, X : Inv<out String>> foo(x: X, y: Y) {\n    val rX = bar(x)\n    rX.length\n\n    val rY = bar(y)\n    rY.length\n}\n\nfun <Y> bar(<!UNUSED_PARAMETER!>l<!>: Inv<Y>): Y = TODO()"
        },
        {
            "code": "open class Inv<T>(val value: String)\n\nfun <T : Inv<*>?, F: Inv<out Any>?, G : Inv<*>> test1(t: T, f: F, g: G?) {\n    if (t != null && f != null && g != null) {\n        <!DEBUG_INFO_SMARTCAST!>t<!>.value\n        <!DEBUG_INFO_SMARTCAST!>f<!>.value\n        <!DEBUG_INFO_SMARTCAST!>g<!>.value\n    }\n}\n\n// Actually, this behavior is very questional as capturing shouldn't be performed deeper than for 1 level\n// But we preserve behavior of old inference here for now\nfun <T : K, K : Inv<*>?> test2(t: T) {\n    if (t != null) {\n        <!DEBUG_INFO_SMARTCAST!>t<!>.value\n    }\n}\n\nfun <T : Inv<K>?, K : Inv<*>?> test3(t: T) {\n    if (t != null) {\n        <!DEBUG_INFO_SMARTCAST!>t<!>.value\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nimport java.util.*\n\nfun <T> g (<!UNUSED_PARAMETER!>f<!>: () -> List<T>) : T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun test() {\n    //here possibly can be a cycle on constraints\n    val <!UNUSED_VARIABLE!>x<!> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>g<!> { Collections.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>() }\n\n    val <!UNUSED_VARIABLE!>y<!> = g<Int> { Collections.emptyList() }\n    val <!UNUSED_VARIABLE!>z<!> : List<Int> = g { Collections.<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>() }\n}"
        },
        {
            "code": "fun test1(i: Int) = { <!CANNOT_INFER_PARAMETER_TYPE, NAME_SHADOWING!>i<!> ->\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>i<!>\n}(i)\n\nfun test2() = { <!CANNOT_INFER_PARAMETER_TYPE!>i<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>i<!> }(<!NO_VALUE_FOR_PARAMETER!>)<!>\n\nfun test3() = { <!CANNOT_INFER_PARAMETER_TYPE!>i<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>i<!> }(1)"
        },
        {
            "code": "<!MUST_BE_INITIALIZED!>val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T : <!UNRESOLVED_REFERENCE!>KClass<!><T>.<!DEBUG_INFO_MISSING_UNRESOLVED!>something<!><!>> abc<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See KT-6271\nfun foo() {\n    fun fact(n: Int) = {\n        if (n > 0) {\n            <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>fact<!>(<!DEBUG_INFO_MISSING_UNRESOLVED!>n<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>-<!> 1)<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>*<!> n\n        }\n        else {\n            1\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo() {\n    fun bar1() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar1<!>()<!>\n\n    fun bar2() = 1 + <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!NI;DEBUG_INFO_MISSING_UNRESOLVED!>bar2<!>()<!>\n    fun bar3() = id(<!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!NI;DEBUG_INFO_MISSING_UNRESOLVED!>bar3<!>()<!>)\n}\n\nfun <T> id(x: T) = x\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo() {\n    fun bar() = (fun() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>()<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo() {\n    fun bar() = {\n        <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>()<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage a\n\nfun <T> emptyList(): List<T> = throw Exception()\n\nfun <T> foo(f: T.() -> Unit, l: List<T>): T = throw Exception(\"$f$l\")\n\nfun test() {\n    val q = foo(fun Int.() {}, emptyList()) //type inference no information for parameter error\n    checkSubtype<Int>(q)\n\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>({}, <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>())\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun <T: Any> fooT22() : T? {\n  return null\n}\n\nfun foo1() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>fooT22<!>()\n}\n\nval n : Nothing = null.sure()\n\nfun <T : Any> T?.sure() : T = this!!\n"
        },
        {
            "code": "typealias SuspendFn = suspend () -> Unit\n\nval test1f: suspend () -> Unit = <!TYPE_MISMATCH!>fun () {}<!>\nval test2f: suspend Any.() -> Unit = <!TYPE_MISMATCH!>fun Any.() {}<!>\n\n// This is a bug in the old inference and should be fixed in new inference\n// see \"Fix anonymous function literals handling in type checker\" for more details\nval test3f: suspend Any.(Int) -> Int = <!TYPE_MISMATCH!>fun (k: Int) = k + 1<!>\nval test4f: SuspendFn = <!TYPE_MISMATCH!>fun Any.() {}<!>"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>a<!>: Any) {\n    foo({ <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>index<!> -> } {  })\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER\n\nfun <T, R : Any> foo(body: (R?) -> T): T = fail()\n\nfun test1() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!> {\n        true\n    }\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!> { <!CANNOT_INFER_PARAMETER_TYPE!>x<!> ->\n        true\n    }\n}\n\n\nfun <T, R> bar(body: (R) -> T): T = fail()\n\nfun test2() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!> {\n        true\n    }\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!> { <!CANNOT_INFER_PARAMETER_TYPE!>x<!> ->\n        true\n    }\n}\n\nfun <T, R> baz(body: (List<R>) -> T): T = fail()\n\nfun test3() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>baz<!> {\n        true\n    }\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>baz<!> { <!CANNOT_INFER_PARAMETER_TYPE!>x<!> ->\n        true\n    }\n}\n\nfun <T, R : Any> brr(body: (List<R?>) -> T): T = fail()\n\nfun test4() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>brr<!> {\n        true\n    }\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>brr<!> { <!CANNOT_INFER_PARAMETER_TYPE!>x<!> ->\n        true\n    }\n}\n\nfun fail(): Nothing = throw Exception()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nobject TestClass {\n    inline operator fun <T> invoke(task: () -> T) = task()\n}\n\nfun test(s: String): String {\n    val a = TestClass { TestClass { TestClass } }\n    a checkType { _<TestClass>() }\n\n    <!UNREACHABLE_CODE!>val b =<!> TestClass { return s }\n    <!UNREACHABLE_CODE!>b checkType { _<Nothing>() }<!>\n}"
        },
        {
            "code": "class R<T>\n\nfun <T> f(): R<T> = R<T>()\n\noperator fun Int.plusAssign(<!UNUSED_PARAMETER!>y<!>: R<Int>) {}\n\nfun box() {\n    1 += f()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -CONFLICTING_JVM_DECLARATIONS\npackage f\n\nfun <R> h(<!UNUSED_PARAMETER!>f<!>: (Boolean) -> R) = 1\nfun <R> h(<!UNUSED_PARAMETER!>f<!>: (String) -> R) = 2\n\nfun test() = <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>h<!>{ <!OI;CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>i<!> -> getAnswer() }\n\nfun getAnswer() = 42\n\n"
        },
        {
            "code": "// !LANGUAGE: +ExpectedTypeFromCast\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class bar\n\nfun <T> foo(): T = TODO()\n\nfun <V> id(value: V) = value\n\nval par1 = (foo()) as String\nval par2 = ((foo())) as String\n\nval par3 = (<!REDUNDANT_LABEL_WARNING!>dd@<!> (foo())) as String\n\nval par4 = ( @bar() (foo())) as String\n\nobject X {\n    fun <T> foo(): T = TODO()\n}\n\nval par5 = ( @bar() X.foo()) as String"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nclass Foo<T>\n\nfun <T> foo1(f: (T) -> Unit): Foo<T> = Foo()\ninline fun <reified T> foo2(f: (T) -> Unit): Foo<T> = Foo()\n\nfun test1() {\n    val f1: Foo<out Int> = foo1 { it checkType { _<Int>() } }\n    val f2: Foo<in Nothing> = foo1 { it <!UNREACHABLE_CODE!>checkType { _<Nothing>() }<!> }\n\n    val f3: Foo<out Int> = foo2 { it checkType { _<Int>() } }\n    val f4: Foo<in Nothing> = <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>foo2<!> { it <!UNREACHABLE_CODE!>checkType { _<Nothing>() }<!> }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun testLambda() {\n    val basicTest: (Int) -> Int = myRun {\n        val x: Any? = null\n        if (x is String) return@myRun { it -> <!DEBUG_INFO_SMARTCAST!>x<!>.length + it }\n        if (x !is Int) return@myRun { it -> it }\n\n        { it -> <!DEBUG_INFO_SMARTCAST!>x<!> + it }\n    }\n\n    val twoLambda: (Int) -> Int = myRun {\n        val x: Int = 1\n        run {\n            val y: Int = 2\n            { x + y }\n        }\n    }\n\n}\n\ninline fun <R> myRun(block: () -> R): R = block()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_JAVAC\n\n// FILE: test.kt\n\nfun test() {\n    val a = MySettings.getSettings()\n    a.getLinkedProjectsSettings()\n    a.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>linkedProjectsSettings<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// AssertionError in ConstraintSystem(The constraint shouldn't contain different type variables on both sides: Y <: X)\n\nclass A<X, Y : X>\n\nclass B<X, Y : X>(<!UNUSED_PARAMETER!>foo<!>: A<X, Y>) {\n    fun test1(a: A<X, Y>) {\n        B(a)\n        val b: B<X, Y> = B(a)\n        // crash here\n    }\n}\n\nclass C<X, Z, Y : X>\n\nclass D<X, Z, Y : X>(<!UNUSED_PARAMETER!>foo<!>: C<X, Z, Y>) {\n    fun test(a: C<Y, Y, Y>) {\n        val d: D<X, Y, Y> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>D(a)<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Inv<I>\ninterface Inv2<I>\n\nfun <T: Inv2<T>> foo(klass: Inv<T>): String? = null\n\nfun <X> bar(): Inv<X> = null!!\n\nfun test() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>())\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\n// FILE: test.kt\n\nfun test(e: <!UNRESOLVED_REFERENCE!>ErrorType<!>) {\n    Foo.foo {\n        Sam.Result.create(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>e<!>)\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Out<out T>\nclass In<in T>\nclass Inv<T>\n\nfun <R> choose1(c: Out<Out<R>>) {}\nfun <R> choose2(c: In<In<R>>) {}\nfun <R> choose3(c: Inv<Inv<R>>) {}\n\nfun f(o: Out<Out<*>>, i: In<In<*>>, inv: Inv<Inv<*>>) {\n    choose1(o)\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>choose2<!>(i)\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>choose3<!>(<!NI;TYPE_MISMATCH!>inv<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage c\n\nimport java.util.ArrayList\n\nfun Array<Int>.toIntArray(): IntArray = this.<!NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>mapTo<!>(<!NI;TYPE_MISMATCH!>IntArray(size)<!>, {it})<!>\n\nfun Array<Int>.toArrayList(): ArrayList<Int> = this.mapTo(ArrayList<Int>(size), {it})\n\npublic fun <T, R, C: MutableCollection<in R>> Array<out T>.mapTo(result: C, transform : (T) -> R) : C =\n        throw Exception(\"$result $transform\")\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_JAVAC\n\n// FILE: test.kt\n\nfun test() {\n    val a = MySettings.getSettings()\n    a.getLinkedProjectsSettings()\n    a.<!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>linkedProjectsSettings<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Inv<T>\n\nfun <K> foo(t: K?) = Inv<K>()\n\nfun <T> bar(t: T) = foo(t)\nfun <V1> bar1(t: V1): Inv<V1> = foo(t)\nfun <V2> bar2(t: V2): Inv<V2> = foo(t)\n\nfun <S> select(x: S, y: S): S = x\n\nfun <T> fail(t: T?) = if (t == null) bar(<!DEBUG_INFO_CONSTANT!>t<!>) else bar(<!DEBUG_INFO_SMARTCAST!>t<!>)\nfun <F> fail1(t: F?, n: Nothing?) = select(bar1(<!DEBUG_INFO_CONSTANT!>n<!>), bar2(t!!))\nfun <F> fail2(t: F?, n: Nothing?) = if (t == null) bar1(<!DEBUG_INFO_CONSTANT!>t<!>) else bar2(<!DEBUG_INFO_SMARTCAST!>t<!>)\nfun <F> fail3(t: F?) = select(bar1(null), bar2(t?.let { it }))\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\nclass Inv<T>(val x: T?)\n\nfun <K> create(y: K) = Inv(y)\nfun <K> createPrivate(y: K) = Inv(y)\n\nfun takeInvInt(i: Inv<Int>) {}\n\nfun <S> test(i: Int, s: S) {\n    val a = Inv(s)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<S>\")!>a<!>\n\n    val b = create(i)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int>\")!>b<!>\n\n    val c = createPrivate(i)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int>\")!>c<!>\n\n    takeInvInt(create(i))\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\ninterface A<T>\n\ninterface In<in T>\n\ninterface Out<out T>\n\nfun <T: Any> doT(t: T?): T = throw Exception(\"$t\")\nfun <T: Any> doOut(o: Out<T?>): T { throw Exception(\"$o\") }\nfun <T: Any> doIn(i: In<T?>) { throw Exception(\"$i\") }\nfun <T: Any> doA(i: A<T?>) { throw Exception(\"$i\") }\n\nfun test(out: Out<Int>, i: In<Int>, inv: A<Int>) {\n    // T? >: Int => T = Int\n    doT(1)\n    val r = doOut(out)\n    r checkType { _<Int>() }\n\n    // T? <: Int => error\n    <!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>doIn<!>(<!TYPE_MISMATCH!>i<!>)\n\n    // T? >: Int => error\n    <!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>doA<!>(<!TYPE_MISMATCH!>inv<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage h\n//+JDK\nimport java.util.*\n\nfun <T> id(t: T) : T = t\n\nfun <T> id1(t: T) = t\n\nfun <R> elem(t: List<R>): R = t.get(0)\n\nfun <R> elemAndList(<!UNUSED_PARAMETER!>r<!>: R, t: List<R>): R = t.get(0)\n\nfun <T> both(t1: T, <!UNUSED_PARAMETER!>t2<!>: T) : T = t1\n\nfun test1() {\n    val a = elem(list(2))\n    val b = id(elem(list(2)))\n    val c = id(id1(id(id1(list(33)))))\n    checkSubtype<Int>(a)\n    checkSubtype<Int>(b)\n    checkSubtype<List<Int>>(c)\n\n    val d : ArrayList<Int> = newList()\n    val e : ArrayList<Int> = id(newList())\n    val f : ArrayList<Int> = id(id1(id(id1(newList()))))\n\n    checkSubtype<List<Int>>(d)\n    checkSubtype<List<Int>>(e)\n    checkSubtype<List<Int>>(f)\n\n    val g = elemAndList(\"\", newList())\n    val h = elemAndList<Long>(1, newList<Long>())\n\n    checkSubtype<String>(g)\n    checkSubtype<Long>(h)\n\n    val i = both(1, \"\")\n    val j = both(id(1), id(\"\"))\n    checkSubtype<Any>(i)\n    checkSubtype<Any>(j)\n}\n\nfun <T> list(value: T) : ArrayList<T> {\n    val list = ArrayList<T>()\n    list.add(value)\n    return list\n}\n\nfun <S> newList() : ArrayList<S> {\n    return ArrayList<S>()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage typeConstructorMismatch\n//+JDK\n\nimport java.util.*\n\nfun test(set: Set<String>) {\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>elemAndList<!>(\"2\", <!TYPE_MISMATCH!>set<!>)\n\n    \"\".<!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>elemAndListWithReceiver<!>(\"\", <!TYPE_MISMATCH!>set<!>)\n}\n\nfun <R> elemAndList(r: R, <!UNUSED_PARAMETER!>t<!>: List<R>): R = r\nfun <R> R.elemAndListWithReceiver(r: R, <!UNUSED_PARAMETER!>t<!>: List<R>): R = r\n"
        },
        {
            "code": "package o\n\nfun foo(): String? {\n    return accept(JV<String?, Unit?>())\n}\n\nfun <R, D> accept(<!UNUSED_PARAMETER!>v<!>: JV<R, D>): R? = null\n\nopen class JV<R, D>()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ExpectedTypeFromCast\n\nfun <T> foo(): T = TODO()\n\nfun <V> id(value: V) = value\n\nval asString = foo() as String\n\nval viaId = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>id<!>(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>()) as String\n\nval insideId = id(foo() as String)\n\nval asList = foo() as List<String>\n\nval asStarList = foo() as List<*>\n\nval safeAs = foo() as? String\n\nval fromIs = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>() is String\nval fromNoIs = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>() !is String\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage f\n\nfun <R> h(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>a<!>: Any, <!UNUSED_PARAMETER!>r<!>: R, <!UNUSED_PARAMETER!>f<!>: (Boolean) -> Int) = 1\nfun <R> h(<!UNUSED_PARAMETER!>a<!>: Any, <!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>r<!>: R, <!UNUSED_PARAMETER!>f<!>: (Boolean) -> Int) = 1\n\nfun test() = <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>h<!>(1, 1, 1, { <!OI;CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>b<!> -> 42 })\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nclass TestClass {\n    inline operator fun <T> invoke(task: () -> T) = task()\n}\n\nfun <T> test(value: T, test: TestClass): T {\n    <!UNREACHABLE_CODE!>val x =<!> test { return value }\n    <!UNREACHABLE_CODE!>x checkType { _<Nothing>() }<!>\n\n    <!UNREACHABLE_CODE!>return value<!>\n}\n\n// ---\n\nclass Future<T>\n\ninterface FutureCallback<E> {\n    operator fun <T> invoke(f: (E) -> T): Future<T>\n}\n\nfun test(cb: FutureCallback<String>) {\n    val a = cb { it[0] }\n    a checkType { _<Future<Char>>() }\n\n    val b = cb { it }\n    b checkType { _<Future<String>>() }\n\n    val c = cb {}\n    c checkType { _<Future<Unit>>() }\n\n    cb.let { callback ->\n        val d = callback { it.length }\n        d checkType { _<Future<Int>>() }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// Related issue: KT-28654\n\nfun <K> select(): K = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>run { <!OI;TYPE_MISMATCH!><!>}<!>\n\nfun test() {\n    val x: Int = select()\n    val t = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>select<!>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nclass MyList<T>(<!UNUSED_PARAMETER!>t<!>: T) {}\n\nfun <T> getMyList(t: T)           : MyList<    T> = MyList(t)\nfun <T> getMyListToWriteTo(t: T)  : MyList< in T> = MyList(t)\nfun <T> getMyListToReadFrom(t: T) : MyList<out T> = MyList(t)\n\nfun <T> useMyList     (<!UNUSED_PARAMETER!>l<!>: MyList<    T>, <!UNUSED_PARAMETER!>t<!>: T) {}\nfun <T> writeToMyList (<!UNUSED_PARAMETER!>l<!>: MyList< in T>, <!UNUSED_PARAMETER!>t<!>: T) {}\nfun <T> readFromMyList(<!UNUSED_PARAMETER!>l<!>: MyList<out T>, <!UNUSED_PARAMETER!>t<!>: T) {}\n\nfun test1(int: Int, any: Any) {\n    val a0 : MyList<Any> = getMyList(int)\n\n    val a1 : MyList<Int> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>getMyList(any)<!>\n\n    val a2 : MyList<out Any> = getMyList(int)\n\n    val a3 : MyList<out Any> = getMyListToReadFrom(int)\n\n    val a4 : MyList<in Int> = getMyList(any)\n\n    val a5 : MyList<in Int> = getMyListToWriteTo(any)\n\n\n    val a6 : MyList<in Any> = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>getMyList<Int>(int)<!>\n    val a7 : MyList<in Any> = getMyList(int)\n\n    val a8 : MyList<in Any> = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>getMyListToReadFrom<Int>(int)<!>\n    val a9 : MyList<in Any> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>getMyListToReadFrom(int)<!>\n\n    val a10 : MyList<out Int> = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>getMyList<Any>(any)<!>\n    val a11 : MyList<out Int> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>getMyList(any)<!>\n\n    val a12 : MyList<out Int> = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>getMyListToWriteTo<Any>(any)<!>\n    val a13 : MyList<out Int> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>getMyListToWriteTo(any)<!>\n\n    useMyList(getMyList(int), int)\n    useMyList(getMyList(any), int)\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>useMyList<!>(getMyList(int), any)\n\n    readFromMyList(getMyList(int), any)\n    readFromMyList(getMyList(any), int)\n    readFromMyList<Int>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>getMyList(any)<!>, int)\n\n    readFromMyList<Int>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>getMyListToReadFrom(any)<!>, int)\n    readFromMyList(getMyListToReadFrom(any), int)\n\n    readFromMyList(getMyListToReadFrom(int), any)\n\n\n    writeToMyList(getMyList(any), int)\n    writeToMyList<Any>(getMyList(int), any)\n    writeToMyList(getMyList<Any>(int), any)\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>writeToMyList<!>(getMyList(int), any)\n\n    writeToMyList(getMyListToWriteTo(any), int)\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>writeToMyList<!>(getMyListToWriteTo(int), any)\n\n    readFromMyList(getMyListToWriteTo(any), any)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>writeToMyList<!>(getMyListToReadFrom(any), <!NI;TYPE_MISMATCH!>any<!>)\n\n    use(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)\n}\n\nfun use(vararg a: Any) = a"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage noInformationForParameter\n//+JDK\n\nimport java.util.*\n\nfun test() {\n    val <!UNUSED_VARIABLE!>n<!> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newList<!>()\n\n    val <!UNUSED_VARIABLE!>n1<!> : List<String> = newList()\n}\n\nfun <S> newList() : ArrayList<S> {\n    return ArrayList<S>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage d\n\nfun <T: Any> joinT(<!UNUSED_PARAMETER!>x<!>: Int, vararg <!UNUSED_PARAMETER!>a<!>: T): T? {\n    return null\n}\n\nfun <T: Any> joinT(<!UNUSED_PARAMETER!>x<!>: Comparable<*>, <!UNUSED_PARAMETER!>y<!>: T): T? {\n    return null\n}\n\nfun test() {\n    val x2 = <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>joinT<!>(<!TYPE_MISMATCH!>Unit<!>, \"2\")\n    checkSubtype<String?>(x2)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun fail1(c: suspend () -> Unit) {}\n\nfun fail2(c: () -> Unit) {}\n\nfun success1(c: suspend () -> Unit) {}\n\nfun test1() {\n    fail1(<!TYPE_MISMATCH!>fun () {}<!>)\n    fun fail2(c: suspend () -> Unit) {}\n    fail2(<!TYPE_MISMATCH!>fun () {}<!>)\n    fun success1(c: () -> Unit) {}\n    success1(fun() {})\n}\n\nsuspend fun fail3(c: suspend () -> Unit) {}\n\nsuspend fun fail4(c: () -> Unit) {}\n\nsuspend fun success2(c: suspend () -> Unit) {}\n\nsuspend fun test2() {\n    fail3(<!TYPE_MISMATCH!>fun () {}<!>)\n    fun fail4(c: suspend () -> Unit) {}\n    fail4(<!TYPE_MISMATCH!>fun () {}<!>)\n    fun success2(c: () -> Unit) {}\n    success2(fun() {})\n}"
        },
        {
            "code": "// FILE: p/J.java\npackage p;\n\npublic interface J {\n    public interface Super<T> {}\n    public interface Sub<T> extends Super<T> {}\n}\n\n// FILE: k.kt\n\nimport p.J.*\n\nclass Foo<T>: Sub<T> {\n    fun foo(): Super<T> {\n        return Foo()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nclass AbstractSelector<S, I>\nclass SelectorFor<S>\n\ninline operator fun <S, I> SelectorFor<S>.invoke(f: S.() -> I): AbstractSelector<S, I> = TODO()\n\nclass State(val p1: Double, val p2: () -> Int, val p3: String?)\n\nfun test(s: SelectorFor<State>): Double {\n    val a = s { p1 }\n    a checkType { _<AbstractSelector<State, Double>>() }\n\n    val b = s { p2 }\n    b checkType { _<AbstractSelector<State, () -> Int>>()}\n\n    val c = s { p3 }\n    c checkType { _<AbstractSelector<State, String?>>() }\n\n    val d = s { }\n    d checkType { _<AbstractSelector<State, Unit>>() }\n\n    val e = s { return p1 }\n    e checkType { _<AbstractSelector<State, Nothing>>() }\n\n    <!OI;UNREACHABLE_CODE!>return<!> null!!\n}"
        },
        {
            "code": "//KT-3395 mapOf function can't be used as literal\npackage b\n\nimport java.util.ArrayList\n\npublic fun <T> query(<!UNUSED_PARAMETER!>t<!>: T, <!UNUSED_PARAMETER!>args<!>: Map<String, Any>): List<T> {\n    return ArrayList<T>()\n}\n\nfun test(pair: Pair<String, Int>) {\n    val id = \"Hello\" // variable is marked as unused\n\n    println(\"Some\" + query(0, mapOf(id to 1)))\n\n    println(\"Some\" + query(0, mapOf(pair)))\n}\n\n\n//from standard library\nfun <K, V> mapOf(vararg <!UNUSED_PARAMETER!>values<!>: Pair<K, V>): Map<K, V> { throw Exception() }\n\ninfix fun <A,B> A.to(<!UNUSED_PARAMETER!>that<!>: B): Pair<A, B> { throw Exception() }\n\nfun println(<!UNUSED_PARAMETER!>message<!> : Any?) { throw Exception() }\n\nclass Pair<out A, out B> () {}\n\n//short example\nfun <T> foo(t: T) = t\n\nfun test(t: String) {\n\n    println(\"Some\" + foo(t)) // t was marked with black square\n}\n\n"
        },
        {
            "code": "package a\n\ninterface A {\n    val b: B\n    val nb: B?\n}\n\ninterface B {\n    fun foo(): Int\n}\n\nfun test(u: A?, x: A?, y: A?, z: A?, w: A, v: A?) {\n    u?.b?.foo()!! // was UNNECESSARY_SAFE_CALL everywhere, because result type (of 'foo()') wasn't made nullable\n    u<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.b<!UNNECESSARY_SAFE_CALL!>?.<!>foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    x?.b!!.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    // x?.b is not null\n    x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n\n    y?.nb?.foo()!!\n    y<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.nb?.foo()!!\n    z?.nb!!.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    // z?.nb is not null\n    z<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.nb!!.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n\n    w.b<!UNNECESSARY_SAFE_CALL!>?.<!>foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    w.b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    w.nb?.foo()!!\n    w.nb!!.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n\n    v!!.b.foo()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n}\n\nfun B?.bar(): Int = 1\nfun B?.baz(): Int? = 1\n\nfun doInt(i: Int) = i\n\nfun test(a: A?) {\n    doInt(a?.b.bar()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    doInt(a?.b.baz()!!)\n}"
        },
        {
            "code": "class A<T> {\n    fun <S> foo(s: S): S = s\n    fun <U> bar(<!UNUSED_PARAMETER!>s<!>: U): List<T> = null!!\n\n    fun test() = foo(bar(\"\"))\n}\n"
        },
        {
            "code": "package j\n\ninterface MyFunc<T> {}\n\nclass A(val b: B) {\n}\n\nclass B {\n    operator fun <T> invoke(<!UNUSED_PARAMETER!>f<!>: (T) -> T): MyFunc<T> = throw Exception()\n}\n\nfun <R> id(r: R) = r\n\nfun foo(a: A) {\n    val <!UNUSED_VARIABLE!>r<!> : MyFunc<Int> = id (a.b { x -> x + 14 })\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage h\n\ninterface A<T> {}\n\nfun <T> newA(): A<T> = throw Exception()\n\ninterface Z\n\nfun <T> id(t: T): T = t\n\n//binary expressions\n//identifier\ninfix fun <T> Z.foo(a: A<T>): A<T> = a\n\nfun test(z: Z) {\n    z <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!> <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>()\n    val a: A<Int> = id(z foo newA())\n    val b: A<Int> = id(z.foo(newA()))\n    use(a, b)\n}\n\n//binary operation expression\noperator fun <T> Z.plus(a: A<T>): A<T> = a\n\nfun test1(z: Z) {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>id<!>(z <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>+<!> <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>())\n    val a: A<Z> = z + newA()\n    val b: A<Z> = z.plus(newA())\n    val c: A<Z> = id(z + newA())\n    val d: A<Z> = id(z.plus(newA()))\n    use(a, b, c, d)\n}\n\n//comparison operation\noperator fun <T> Z.compareTo(a: A<T>): Int { use(a); return 1 }\n\nfun test2(z: Z) {\n    val a: Boolean = id(z <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!><<!> <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>())\n    val b: Boolean = id(z < newA<Z>())\n    use(a, b)\n}\n\n//'equals' operation\nfun Z.<!EXTENSION_SHADOWED_BY_MEMBER!>equals<!>(any: Any): Int { use(any); return 1 }\n\nfun test3(z: Z) {\n    z <!NI;EQUALS_MISSING!>==<!> <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>()\n    z == newA<Z>()\n    id(z <!NI;EQUALS_MISSING!>==<!> <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>())\n    id(z == newA<Z>())\n\n    id(z === <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>())\n    id(z === newA<Z>())\n}\n\n//'in' operation\nfun test4(collection: Collection<A<*>>) {\n    id(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>newA<!>() in collection)\n    id(newA<Int>() in collection)\n}\n\n//boolean operations\nfun <T> toBeOrNot(): Boolean = throw Exception()\n\nfun test5() {\n    if (<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>toBeOrNot<!>() && <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>toBeOrNot<!>()) {}\n    if (toBeOrNot<Int>() && toBeOrNot<Int>()) {}\n}\n\n//use\nfun use(vararg a: Any?) = a"
        },
        {
            "code": "package a\n\nfun test(c: C) {\n    foo(<!TYPE_MISMATCH!>c.b<!>)\n}\n\nfun foo(s: String) = s\n\nclass C(val b: Int) {}"
        },
        {
            "code": "package a\n\nfun foo(l: List<Int>): Int = l.get(0)\n\nfun <T> emptyList(): List<T> = throw Exception()\n\nfun <T: Any> makeNullable(<!UNUSED_PARAMETER!>t<!>: T): T? = null\n\nfun bar(i: Int) = i\nfun bar(a: Any) = a\n\nfun test(array: Array<Int>) {\n    bar(array[foo(emptyList())])\n\n    bar(foo(emptyList()) + foo(a.emptyList()))\n\n    bar(makeNullable(foo(emptyList())) ?: 0)\n}"
        },
        {
            "code": "//KT-3461 Nullable argument allowed where shouldn't be\npackage a\n\nclass F {\n    fun p(): String? = null\n}\n\nfun foo(<!UNUSED_PARAMETER!>s<!>: String) {}\n\nfun r(): Int? = null\n\nfun test() {\n    foo(<!TYPE_MISMATCH!>F().p()<!>)\n    foo(<!TYPE_MISMATCH!>r()<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage f\n\nfun <T> f(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>c<!>: Collection<T>): List<T> {throw Exception()}\nfun <T> f(<!UNUSED_PARAMETER!>a<!>: Any, <!UNUSED_PARAMETER!>l<!>: List<T>): Collection<T> {throw Exception()}\n\nfun <T> test(<!UNUSED_PARAMETER!>l<!>: List<T>) {\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>f<!>(1, <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>())\n}\n\nfun <T> emptyList(): List<T> {throw Exception()}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ExpectedTypeFromCast\n// !DIAGNOSTICS: -UNUSED_VARIABLE -DEBUG_INFO_LEAKING_THIS\n\n// FILE: a/View.java\npackage a;\n\npublic class View {\n\n}\n\n// FILE: a/Test.java\npackage a;\n\npublic class Test {\n    public <T extends View> T findViewById(int id);\n}\n\n// FILE: 1.kt\npackage a\n\n\nclass X : View()\n\nclass Y<T> : View()\n\nval xExplicit: X = Test().findViewById(0)\nval xCast = Test().findViewById(0) as X\n\nval xCastExplicitType = Test().findViewById<X>(0) as X\nval xSafeCastExplicitType = Test().findViewById<X>(0) <!USELESS_CAST!>as? X<!>\n\nval yExplicit: Y<String> = Test().findViewById(0)\nval yCast = Test().findViewById(0) as Y<String>\n\n\nclass TestChild : Test() {\n    val xExplicit: X = findViewById(0)\n    val xCast = findViewById(0) as X\n\n    val yExplicit: Y<String> = findViewById(0)\n    val yCast = findViewById(0) as Y<String>\n}\n\nfun test(t: Test) {\n    val xExplicit: X = t.findViewById(0)\n    val xCast = t.findViewById(0) as X\n\n    val yExplicit: Y<String> = t.findViewById(0)\n    val yCast = t.findViewById(0) as Y<String>\n}\n\nfun test2(t: Test?) {\n    val xSafeCallSafeCast = t?.findViewById(0) as? X\n    val xSafeCallSafeCastExplicitType = t?.findViewById<X>(0) <!USELESS_CAST!>as? X<!>\n\n    val xSafeCallCast = t?.findViewById(0) as X\n    val xSafeCallCastExplicitType = t<!UNNECESSARY_SAFE_CALL!>?.<!>findViewById<X>(0) as X\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !IDIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun case_1(a: MutableList<out MutableList<MutableList<MutableList<MutableList<MutableList<MutableList<Int?>?>?>?>?>?>?>?) {\n    if (a != null) {\n        val b = <!OI;DEBUG_INFO_SMARTCAST!>a<!>[0] // no SMARTCAST diagnostic\n        if (b != null) {\n            val c = <!DEBUG_INFO_SMARTCAST!>b<!>[0]\n            if (c != null) {\n                val d = <!DEBUG_INFO_SMARTCAST!>c<!>[0]\n                if (d != null) {\n                    val e = <!DEBUG_INFO_SMARTCAST!>d<!>[0]\n                    if (e != null) {\n                        val f = <!DEBUG_INFO_SMARTCAST!>e<!>[0]\n                        if (f != null) {\n                            val g = <!DEBUG_INFO_SMARTCAST!>f<!>[0]\n                            if (g != null) {\n                                val h = <!DEBUG_INFO_SMARTCAST!>g<!>[0]\n                                if (h != null) {\n                                    <!DEBUG_INFO_SMARTCAST!>h<!>.inc()\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfun case_2(a: MutableList<out MutableList<MutableList<MutableList<out MutableList<MutableList<MutableList<out Int?>?>?>?>?>?>?>?) {\n    if (a != null) {\n        val b = <!OI;DEBUG_INFO_SMARTCAST!>a<!>[0] // no SMARTCAST diagnostic\n        if (b != null) {\n            val c = <!DEBUG_INFO_SMARTCAST!>b<!>[0]\n            if (c != null) {\n                val d = <!DEBUG_INFO_SMARTCAST!>c<!>[0]\n                if (d != null) {\n                    val e = <!OI;DEBUG_INFO_SMARTCAST!>d<!>[0] // no SMARTCAST diagnostic\n                    if (e != null) {\n                        val f = <!DEBUG_INFO_SMARTCAST!>e<!>[0]\n                        if (f != null) {\n                            val g = <!DEBUG_INFO_SMARTCAST!>f<!>[0]\n                            if (g != null) {\n                                val h = <!OI;DEBUG_INFO_SMARTCAST!>g<!>[0] // no SMARTCAST diagnostic\n                                if (h != null) {\n                                    <!DEBUG_INFO_SMARTCAST!>h<!>.inc()\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfun case_3(a: MutableList<MutableList<MutableList<MutableList<MutableList<MutableList<MutableList<Int?>?>?>?>?>?>?>?) {\n    if (a != null) {\n        val b = <!DEBUG_INFO_SMARTCAST!>a<!>[0]\n        if (b != null) {\n            val c = <!DEBUG_INFO_SMARTCAST!>b<!>[0]\n            if (c != null) {\n                val d = <!DEBUG_INFO_SMARTCAST!>c<!>[0]\n                if (d != null) {\n                    val e = <!DEBUG_INFO_SMARTCAST!>d<!>[0]\n                    if (e != null) {\n                        val f = <!DEBUG_INFO_SMARTCAST!>e<!>[0]\n                        if (f != null) {\n                            val g = <!DEBUG_INFO_SMARTCAST!>f<!>[0]\n                            if (g != null) {\n                                val h = <!DEBUG_INFO_SMARTCAST!>g<!>[0]\n                                if (h != null) {\n                                    <!DEBUG_INFO_SMARTCAST!>h<!>.inc()\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nclass Scope\n\nfun <T> simpleAsync0(block: Scope.() -> T) {}\nfun <T> simpleAsync1(block: suspend Scope.() -> T) {}\nsuspend fun <T> simpleAsync2(block: Scope.() -> T) {}\nsuspend fun <T> simpleAsync3(block: suspend Scope.() -> T) {}\n\nfun insideJob0() = doTheJob0()\nfun insideJob1() = doTheJob1()\nsuspend fun insideJob2() = doTheJob2()\nsuspend fun insideJob3() = doTheJob3()\n\nfun doTheJob0() = simpleAsync0 { <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>insideJob0<!>()<!> }\nfun doTheJob1() = simpleAsync1 { <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>insideJob1<!>()<!> }\nsuspend fun doTheJob2() = simpleAsync2 { <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>insideJob2<!>()<!> }\nsuspend fun doTheJob3() = simpleAsync3 { <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>insideJob3<!>()<!> }\n"
        },
        {
            "code": "package n\n\n//+JDK\nimport java.util.*\n\nfun <T> expected(t: T, <!UNUSED_PARAMETER!>f<!>: () -> T) : T = t\n\nfun test(arrayList: ArrayList<Int>, list: List<Int>) {\n    val <!UNUSED_VARIABLE!>t<!> = expected(arrayList, l@ {return@l list.reverse() })\n}\n\nfun <T> List<T>.reverse() : List<T> = this"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ExpectedTypeFromCast\n\nclass X<S> {\n    fun <T : S> foo(): T = TODO()\n}\n\nfun test(x: X<Number>) {\n    val <!UNUSED_VARIABLE!>y<!> = x.foo() as Int\n}\n\nfun <S, D: S> g() {\n    fun <T : S> foo(): T = TODO()\n\n    val <!UNUSED_VARIABLE!>y<!> = <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo<!>() as Int\n\n    val <!UNUSED_VARIABLE!>y2<!> = foo() as D\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nclass TestClass {\n    companion object {\n        inline operator fun <T> invoke(task: () -> T) = task()\n    }\n}\n\nfun test(s: String): String {\n    val a = TestClass { \"K\" }\n    a checkType { _<String>() }\n\n    <!UNREACHABLE_CODE!>val b =<!> TestClass { return s }\n    <!UNREACHABLE_CODE!>b checkType { _<Nothing>() }<!>\n}"
        },
        {
            "code": "package a\n\ninterface Closeable {\n    fun close() {}\n}\n\nclass C : Closeable\n\npublic inline fun <T: Closeable, R> T.use(block: T.()-> R) : R {\n    return this.block()\n}\n\nfun test() {\n    C().use {\n        this.close()\n        <!UNRESOLVED_REFERENCE!>x<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-832 Provide better diagnostics when type inference fails for an expression that returns a function\npackage a\n\nfun <T> fooT2() : (t : T) -> T {\n    return {it}\n}\n\nfun test() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>fooT2<!>()(1) // here 1 should not be marked with an error\n}"
        },
        {
            "code": "//KT-3007 Kotlin plugin 0.4.126 does not compile KAnnotator revision ba0a93eb\npackage a\n\nenum class SomeEnum {\n    FIRST,\n    SECOND\n}\n\n// Doesn't work\nfun Iterable<Int>.some() {\n    this.fold(SomeEnum.FIRST, {res : SomeEnum, <!UNUSED_ANONYMOUS_PARAMETER!>value<!> ->\n        if (res == SomeEnum.FIRST) SomeEnum.FIRST else SomeEnum.SECOND\n    })\n}\n\nfun tempFun() : SomeEnum {\n    return SomeEnum.FIRST\n}\n\n// Doesn't work\nfun Iterable<Int>.someSimpleWithFun() {\n    this.fold(SomeEnum.FIRST, {<!UNUSED_ANONYMOUS_PARAMETER!>res<!> : SomeEnum, <!UNUSED_ANONYMOUS_PARAMETER!>value<!> ->\n        tempFun()\n    })\n}\n\n\n// Works\nfun Iterable<Int>.someSimple() {\n    this.fold(SomeEnum.FIRST, {<!UNUSED_ANONYMOUS_PARAMETER!>res<!> : SomeEnum, <!UNUSED_ANONYMOUS_PARAMETER!>value<!> ->\n        SomeEnum.FIRST\n    })\n}\n\n// Works\nfun Iterable<Int>.someInt() {\n    this.fold(0, {res : Int, <!UNUSED_ANONYMOUS_PARAMETER!>value<!> ->\n        if (res == 0) 1 else 0\n    })\n}\n\n//from standard library\nfun <T,R> Iterable<T>.fold(<!UNUSED_PARAMETER!>initial<!>: R, <!UNUSED_PARAMETER!>operation<!>: (R, T) -> R): R {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n// KT-1410 Compiler does automatically infer type argument when using variance\n//+JDK\npackage d\n\npublic fun <T> MutableCollection<out T>.filterToMy(result : MutableList<in T>, filter : (T) -> Boolean) : MutableCollection<out T> {\n    for (t in this){\n        if (filter(t)){\n            result.add(t)\n        }\n    }\n    return this\n}\n\nfun foo(result: MutableList<in String>, collection: MutableCollection<String>, prefix : String){\n    collection.filterToMy(result, {it.startsWith(prefix)})\n}\n\nfun test(result: MutableList<in Any>, collection: MutableCollection<String>, prefix : String){\n    val c = collection.filterToMy(result, {it.startsWith(prefix)})\n    checkSubtype<MutableCollection<out String>>(c)\n}\n\n//from library\nfun String.startsWith(<!UNUSED_PARAMETER!>prefix<!>: String) : Boolean {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "class B {\n    fun getA() = <!UNRESOLVED_REFERENCE!>a<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-2883 Type inference fails due to non-Unit value returned\npackage a\n\npublic fun doAction(<!UNUSED_PARAMETER!>action<!> : () -> Unit){\n}\n\nclass Y<TItem>(val itemToString: (TItem) -> String){\n}\n\nfun <TItem> bar(<!UNUSED_PARAMETER!>context<!> : Y<TItem>) : TItem{\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun foo(){\n    val stringToString : (String) -> String = { it }\n    doAction({bar(Y<String>(stringToString))})\n}\n\nfun <T> bar(t: T): T = t\n\nfun test() {\n    \n    doAction { bar(12) }\n\n    val <!UNUSED_VARIABLE!>u<!>: Unit =  <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>bar(11)<!>\n}\n\nfun testWithoutInference(col: MutableCollection<Int>) {\n    \n    doAction { col.add(2) }\n    \n    val <!UNUSED_VARIABLE!>u<!>: Unit = <!TYPE_MISMATCH!>col.add(2)<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage n\n\nimport java.util.*\n\nfun test() {\n    val foo = arrayList(\"\").map { it -> it.length }.fold(0, { x, y -> Math.max(x, y) })\n    checkSubtype<Int>(foo)\n    checkSubtype<String>(<!TYPE_MISMATCH!>foo<!>)\n}\n\n//from library\nfun <T> arrayList(vararg <!UNUSED_PARAMETER!>values<!>: T) : ArrayList<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun <T, R> Collection<T>.map(<!UNUSED_PARAMETER!>transform<!> : (T) -> R) : List<R> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun <T> Iterable<T>.fold(<!UNUSED_PARAMETER!>initial<!>: T, <!UNUSED_PARAMETER!>operation<!>: (T, T) -> T): T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-742 Stack overflow in type inference\npackage a\n\nfun <T : Any> T?.sure() : T = this!!\n\nclass List<T>(val head: T, val tail: List<T>? = null)\n\nfun <T, Q> List<T>.map1(f: (T)-> Q): List<T>? = tail!!.map1(f)\n\nfun <T, Q> List<T>.map2(f: (T)-> Q): List<T>? = tail.sure().map2(f)\n\nfun <T, Q> List<T>.map3(f: (T)-> Q): List<T>? = <!OI;TYPE_MISMATCH!>tail<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>sure<!><<!OI;UPPER_BOUND_VIOLATED!>T<!>>().<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, OI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>map3<!>(f)"
        },
        {
            "code": "//KT-2459 Type inference error\npackage b\n\nimport java.util.*\n\nclass B<T>(val x: List<T>)\nfun <T> f(x: T): B<T> = B(arrayList(x))\n\n// from standard library\nfun <T> arrayList(vararg <!UNUSED_PARAMETER!>values<!>: T) : ArrayList<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\ninterface G<T> {\n    fun build(): G<T>\n}\nclass V1<V>(val value: V)\nclass V2<V>(val value: V)\nfun <V, T : V?> G<T>.foo(vararg values: V1<V>) = build()\nfun <V, T : V?> G<T>.foo(vararg values: V2<V?>) = build()\n\nfun forReference(ref: Any?) {}\n\nfun test() {\n    forReference(G<Int?>::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>foo<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-943 Type inference failed\npackage maze\n\n//+JDK\nimport java.util.Collections.*\nimport java.util.*\n\nfun foo(lines: List<String>) {\n    val w = max(lines, comparator {o1, o2 ->\n        val l1 : Int = o1.length // Types of o1 and o2 are ERROR\n        val l2 = o2.length\n        l1 - l2\n    }).sure()\n    checkSubtype<String>(w)\n}\n\n//standard library\nfun <T : Any> T?.sure() : T = this!!\n\npublic inline fun <T> comparator(<!UNUSED_PARAMETER!>fn<!>: (T,T) -> Int): Comparator<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "//KT-702 Type inference failed\npackage a\n//+JDK\n\nfun <T> getJavaClass() : java.lang.Class<T> { <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\npublic class Throwables() {\n    companion object {\n        public fun <X : Throwable?> propagateIfInstanceOf(throwable : Throwable?, declaredType : Class<X?>?) : Unit {\n            if (((throwable != null) && declaredType?.isInstance(throwable)!!))\n            {\n                throw declaredType<!UNNECESSARY_SAFE_CALL!>?.<!>cast(throwable)!!\n            }\n        }\n        public fun propagateIfPossible(throwable : Throwable?) : Unit {\n            propagateIfInstanceOf(throwable, getJavaClass<Error?>()) // Type inference failed: Mismatch while expanding constraints\n            propagateIfInstanceOf(throwable, getJavaClass<RuntimeException?>()) // Type inference failed: Mismatch while expanding constraints\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-1127 Wrong type computed for Arrays.asList()\n\npackage d\n\nfun <T> asList(<!UNUSED_PARAMETER!>t<!>: T) : List<T>? {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun main() {\n    val <!UNUSED_VARIABLE!>list<!> : List<String> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>asList(\"\")<!>\n}"
        },
        {
            "code": "//KT-2741 Compiler can't infer a type of a function literal parameter when its body contains errors\npackage a\n\nfun <T, R: Comparable<R>> Iterable<T>._sortBy(<!UNUSED_PARAMETER!>f<!>: (T) -> R): List<T> = throw Exception()\nfun <T> _arrayList(vararg <!UNUSED_PARAMETER!>values<!>: T) : List<T> = throw Exception()\n\nclass _Pair<A>(val a: A)\n\nfun test() {\n    _arrayList(_Pair(1))._sortBy { <!UNUSED_ANONYMOUS_PARAMETER!>it<!> -> <!UNRESOLVED_REFERENCE!>xxx<!> }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-1145 removing explicit generics on a call to Iterable<T>.map(...) seems to generate an odd bytecode/runtime error\n\npackage d\n\nfun test(numbers: Iterable<Int>) {\n    val s = numbers.map{it.toString()}.fold(\"\"){it, it2 -> it + it2}\n    checkSubtype<Int>(<!TYPE_MISMATCH!>s<!>)\n}\n\n//from library\nfun <T, R> Iterable<T>.map(<!UNUSED_PARAMETER!>transform<!> : (T) -> R) : List<R> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun <T> Iterable<T>.fold(<!UNUSED_PARAMETER!>initial<!>: T, <!UNUSED_PARAMETER!>operation<!>: (T, T) -> T): T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nimport java.util.ArrayList\n\nclass F<T> {\n    fun <T, V> x (y: F<ArrayList<T>>, w: ArrayList<V>) {\n        val z: ArrayList<T> = y[\"\", w]\n    }\n}\noperator fun <V, T> Any.get(<!UNUSED_PARAMETER!>s<!>: String, <!UNUSED_PARAMETER!>w<!>: ArrayList<V>): ArrayList<T> = throw Exception()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\n//KT-948 Make type inference work with sure()/!!\n\npackage a\n\nimport java.util.*\n\nfun <T> emptyList() : List<T>? = ArrayList<T>()\n\nfun foo() {\n    // type arguments shouldn't be required\n    val <!UNUSED_VARIABLE!>l<!> : List<Int> = emptyList()!!\n    val <!UNUSED_VARIABLE!>l1<!> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>()<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>!!<!>\n\n    checkSubtype<List<Int>>(emptyList()!!)\n    checkSubtype<List<Int>?>(emptyList())\n\n    doWithList(emptyList()!!)\n}\n\nfun doWithList(list: List<Int>) = list"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNREACHABLE_CODE\n//KT-2838 Type inference failed on passing null as a nullable argument\npackage a\n\nfun <T> foo(a: T, b: Map<T, String>?) = b?.get(a)\nfun <T> bar(a: T, b: Map<T, String>) = b.get(a)\n\nfun test(a: Int) {\n    foo(a, null)\n    <!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>bar<!>(a, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n}\nfun test1(a: Int) {\n    foo(a, throw Exception())\n}\n\nfun test2(a: Int) {\n    bar(a, throw Exception())\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\n//KT-731 Missing error from type inference\npackage a\n\nclass A<T>(x: T) {\n    val p = x\n}\n\nfun <T, G> A<T>.foo(x: (T)-> G): G {\n    return x(this.p)\n}\n\nfun main() {\n    val a = A(1)\n    val t: String = <!NI;TYPE_MISMATCH!>a.<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>foo({p -> <!TYPE_MISMATCH!>p<!>})<!><!>\n    checkSubtype<String>(t)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-1718 compiler error when not using temporary variable\npackage n\n\nimport java.util.ArrayList\n\nfun test() {\n    val list = arrayList(\"foo\", \"bar\") + arrayList(\"cheese\", \"wine\")\n    checkSubtype<List<String>>(list)\n    //check it's not an error type\n    checkSubtype<Int>(<!TYPE_MISMATCH!>list<!>)\n}\n\n//from library\nfun <T> arrayList(vararg <!UNUSED_PARAMETER!>values<!>: T) : ArrayList<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\noperator fun <T> Iterable<T>.plus(<!UNUSED_PARAMETER!>elements<!>: Iterable<T>): List<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nfun foo(s: String) {}\nfun foo(i: Long) {}\n\nfun bar(f: (Boolean) -> Unit) {}\n\nfun test() {\n    bar(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>foo<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// KT-3496 Type inference bug on y[\"\"]\n\nclass B<T> {\n    fun <S> x (y: B<Iterable<S>>) {\n        val z: S = y[\"\"] // does not work with [], but works with .get()\n    }\n    operator fun <S> get(<!UNUSED_PARAMETER!>s<!> : String): S = throw Exception()\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-1031 Can't infer type of `it` with two lambdas\npackage i\n\nimport java.util.ArrayList\n\npublic infix fun<TItem> Iterable<TItem>.where(<!UNUSED_PARAMETER!>predicate<!> : (TItem)->Boolean) : ()->Iterable<TItem> {\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\npublic fun<TItem, TResult> select(<!UNUSED_PARAMETER!>yielder<!>: ()->Iterable<TItem>, <!UNUSED_PARAMETER!>selector<!> : (TItem)->TResult) : ()->Iterable<TResult> {\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun a() {\n    val x = 0..200\n    val z = x where { i: Int -> i % 2 == 0 }\n    val yielder = select(x where { it%2==0 }, { it.toString() })\n\n    checkSubtype<() -> Iterable<Int>>(z)\n    checkSubtype<() -> Iterable<String>>(yielder)\n}\n"
        },
        {
            "code": "// KT-3559 Strange inference failure error message\n\npublic inline fun <T:Any, R> let(subj: T?, body: (T) -> R): R? {\n    return if (subj != null) body(<!DEBUG_INFO_SMARTCAST!>subj<!>) else null\n}\n\n\nfun test(s: String?): String? {\n    return let(s) {s} // Reports: \"Inference failed. Expected jet.String? but found jet.String?\"\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNREACHABLE_CODE\n//KT-2445 Calling method with function with generic parameter causes compile-time exception\npackage a\n\nfun main() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>test<!> {\n\n    }\n}\n\nfun <R> test(callback: (R) -> Unit):Unit = callback(null!!)"
        },
        {
            "code": "//KT-2320 failure of complex case of type inference\npackage i\n\ninterface NotMap<B>\n\ninterface Entry<B> {\n    fun getValue(): B\n}\n\n\nfun <V, R> NotMap<V>.mapValuesOriginal(<!UNUSED_PARAMETER!>ff<!>: (Entry<V>) -> R): NotMap<R> = throw Exception()\n\nfun <B, C> NotMap<B>.mapValuesOnly(f: (B) -> C) = mapValuesOriginal { e -> f(e.getValue()) }\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-1029 Wrong type inference\npackage i\n\npublic fun<T> from(<!UNUSED_PARAMETER!>yielder<!>: ()->Iterable<T>) : Iterable<T> {\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\npublic infix fun<T> Iterable<T>.where(<!UNUSED_PARAMETER!>predicate<!> : (T)->Boolean) : ()->Iterable<T> {\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun a() {\n    val x = 0..200\n    val odd = from (x where {it%2==0}) // I believe it should infer here\n\n    checkSubtype<Iterable<Int>>(odd)\n}\n"
        },
        {
            "code": "interface In<in I>\n\ninterface B : In<B>\n\ninterface C<I, T>\n\nfun <I, T> In<I>.foo(<!UNUSED_PARAMETER!>f<!>: () -> C<I, T>) {}\nfun <I, T, Self: In<I>> Self.foo2(<!UNUSED_PARAMETER!>f<!>: () -> C<I, T>) {}\n\nclass E : B // e <: In<B> <: In<E>\n\nfun test(c: C<E, Int>, e: E) {\n    e.foo<E, Int> { c }\n    e.foo { c } // error here: expected C<B, ???> but must be C<??? : B, ???>\n    e.foo2 { c }\n    e.foo2 ({ c })\n}"
        },
        {
            "code": "//KT-3301 Inference with several supertypes fails\n\npackage arrays\n\ninterface A\ninterface B\n\nobject CAB : A, B\nobject DAB : A, B\n\nfun m(<!UNUSED_PARAMETER!>args<!> : Array<A>) {\n\n}\n\nfun test122() {\n    m(array(CAB, DAB)) // Wrong error here: Array<Any> is inferred while expected Array<A> is satisfied\n}\n\n//from library\nfun <T> array(vararg <!UNUSED_PARAMETER!>t<!>: T): Array<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "open class MyClass<T> {\n    object MyObject : MyClass<Boolean>() { }\n}\n\nval foo1 = MyClass.MyObject // it's ok\nval foo2 = <!FUNCTION_CALL_EXPECTED!>MyClass<Boolean><!>.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>MyObject<!> // here's stofl\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-2283 Bad diagnostics of failed type inference\npackage a\n\n\ninterface Foo<A>\n\nfun <A, B> Foo<A>.map(<!UNUSED_PARAMETER!>f<!>: (A) -> B): Foo<B> = object : Foo<B> {}\n\n\nfun foo() {\n    val l: Foo<String> = object : Foo<String> {}\n    val <!UNUSED_VARIABLE!>m<!>: Foo<String> = l.<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>map { <!UNUSED_ANONYMOUS_PARAMETER!>ppp<!> -> <!NI;CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> }<!>\n}\n"
        },
        {
            "code": "class Item(val name: String, val rating: Int): Comparable<Item> {\n    public override fun compareTo(other: Item): Int {\n        return compareBy(this, other, { rating }, { name })\n    }\n}\n\n// from standard library\nfun <T : Any> compareBy(<!UNUSED_PARAMETER!>a<!>: T?, <!UNUSED_PARAMETER!>b<!>: T?,\n                               vararg <!UNUSED_PARAMETER!>functions<!>: T.() -> Comparable<*>?): Int = throw Exception()"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-2179 Nested function literal breaks compiler\npackage i\n\n//+JDK\nimport java.util.*\n\nfun test() {\n    val sample1: List<List<Int?>> = arrayList(arrayList<Int?>(1, 7, null, 8))\n\n    //breaks compiler\n    val sample2 = sample1.map({it.map({it})})\n    checkSubtype<List<List<Int?>>>(sample2)\n\n    //breaks compiler\n    val sample3 = sample1.map({row -> row.map({column -> column})})\n    checkSubtype<List<List<Int?>>>(sample3)\n\n    //doesn't break compiler\n    val identity: (Int?) -> Int? = {column -> column}\n    val sample4 = sample1.map({row -> row.map(identity)})\n    checkSubtype<List<List<Int?>>>(sample4)\n}\n\n//------------\n\nfun <T> arrayList(vararg values: T) : ArrayList<T> = values.toCollection(ArrayList<T>(values.size))\n\nfun <T, R> Collection<T>.map(transform : (T) -> R) : List<R> {\n    return mapTo(java.util.ArrayList<R>(this.size), transform)\n}\n\nfun <T, R, C: MutableCollection<in R>> Collection<T>.mapTo(result: C, transform : (T) -> R) : C {\n  for (item in this)\n    result.add(transform(item))\n  return result\n}\n\nfun <T, C: MutableCollection<in T>> Array<T>.toCollection(result: C) : C {\n    for (element in this) result.add(element)\n    return result\n}\n\nval Collection<*>.<!EXTENSION_SHADOWED_BY_MEMBER!>size<!> : Int\n    get() = size\n"
        },
        {
            "code": "package c\n\ninterface A<T>\n\nfun test(a: A<Int>?) {\n    a<!UNSAFE_CALL!>.<!>foo() //no error\n}\n\nfun <R> A<R>.foo() {}\n\n//------------\nfun test(nullabilityInfoMap: Map<Int, Any>?) {\n    nullabilityInfoMap<!UNSAFE_CALL!>.<!>iterator() //no error\n}\n\n//resolves to\npublic fun <K,V> Map<K,V>.iterator(): Iterator<Map.Entry<K,V>> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n\n//-------------\nfun foo() : Boolean {\n    val nullableList = getNullableList()\n    return nullableList<!UNSAFE_CALL!>.<!>contains(\"\")\n\n}\n\nfun getNullableList(): List<String>? = null"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\n//KT-2200 array(array()) breaks compiler\npackage n\n\nfun main() {\n    val <!UNUSED_VARIABLE!>a<!> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>array<!>(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>array<!>())\n    val <!UNUSED_VARIABLE!>a0<!> : Array<Array<Int>> = array(array())\n    val a1 = array(array<Int>())\n    checkSubtype<Array<Array<Int>>>(a1)\n    val a2 = array<Array<Int>>(array())\n    checkSubtype<Array<Array<Int>>>(a2)\n}\n\n//from library\n@Suppress(\"UNCHECKED_CAST\")\nfun <T> array(vararg t : T) : Array<T> = t as Array<T>"
        },
        {
            "code": "package a\n\ninterface Closeable {\n    fun close() {}\n}\n\nclass C : Closeable\n\npublic inline fun <T: Closeable, R> use(t: T, block: T.(T)-> R) : R {\n    return t.block(t)\n}\n\nfun test() {\n    use(C()) {\n        this.close()\n        it.close()\n        <!UNRESOLVED_REFERENCE!>xx<!>\n    }\n}"
        },
        {
            "code": "//KT-3038 Wrong type inference for enum entry\npackage a\n\nenum class TestEnum {\n    FIRST,\n    SECOND\n}\n\nfun <T> inferenceTest(a: T) : T = a\n\nfun hello() {\n    var enumElemFirst = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>inferenceTest(TestEnum.FIRST)<!>\n    enumElemFirst = TestEnum.SECOND // Type mismatch: inferred type is testDebug.TestEnum.<class-object-for-TestEnum>.SECOND but testDebug.TestEnum.<class-object-for-TestEnum>.FIRST was expected\n\n    var enumElemSecond : TestEnum = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>inferenceTest(TestEnum.FIRST)<!>\n    enumElemSecond = TestEnum.SECOND // Ok\n\n    use(enumElemFirst, enumElemSecond)\n}\n\n\nfun use(vararg a: Any?) = a"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport java.util.ArrayList\n\nfun <T> foo(a : T, b : Collection<T>, c : Int) {\n}\n\nfun <T> arrayListOf(vararg values: T): ArrayList<T> = throw Exception(\"$values\")\n\nval bar = foo(\"\", arrayListOf()<!UNSUPPORTED_FEATURE!>,<!> <!NO_VALUE_FOR_PARAMETER!>)<!>\nval bar2 = foo<String>(\"\", arrayListOf()<!UNSUPPORTED_FEATURE!>,<!> <!NO_VALUE_FOR_PARAMETER!>)<!>"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-2324 Can't resolve generic by type of function result\npackage i\n\n//+JDK\nimport java.util.*\n\nfun <T, K> someFunction(list: List<T>, transform: (T) -> K): List<K> {\n    val result = arrayList<K>()\n    for (i in list) {\n        result.add(transform(i))\n    }\n    return result\n}\n\nfun testSomeFunction() {\n    val result1 = someFunction(arrayList<Int>(1, 2), {checkSubtype<Int>(it)}) //type of result1 is List<Int>\n    assertEquals(1, result1.get(0)); //OK\n\n    val result2 = someFunction(arrayList<Int>(1, 2), {it}) // type of result2 is List<DONT_CARE>\n    checkSubtype<List<Int>>(result2)\n    assertEquals(1, result2.get(0)); //resolved to error element\n}\n\n//---------------------------------\nfun assertEquals(<!UNUSED_PARAMETER!>expected<!>: Any?, <!UNUSED_PARAMETER!>actual<!>: Any?, <!UNUSED_PARAMETER!>message<!>: String = \"\") {\n}\n\nfun <T> arrayList(vararg values: T) : ArrayList<T> = values.toCollection(ArrayList<T>(values.size))\n\nfun <T, C: MutableCollection<in T>> Array<T>.toCollection(result: C) : C {\n    for (element in this) result.add(element)\n    return result\n}\n"
        },
        {
            "code": "package a\n\ninterface Closeable {}\nclass C : Closeable {}\n\npublic inline fun <T: Closeable, R> T.use1(block: (T)-> R) : R {\n    return block(this)\n}\n\nfun main() {\n    C().use1 {\n        <!UNUSED_ANONYMOUS_PARAMETER!>w<!> ->  // ERROR here\n        <!UNRESOLVED_REFERENCE!>x<!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun bar(y: (Int) -> Int) = 1\nfun foo(x: Float) = 10f\nfun foo(x: String) = \"\"\n\nfun main() {\n    bar(::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>foo<!>) // no report about unresolved callable reference for `foo`\n}\n"
        },
        {
            "code": "package aa\n\nclass Some<T>\n\nclass SomeTemplate {\n    fun <T> query(some: Class<T>) = some\n\n\n    // Uncomment this to get CANNOT_COMPLETE_RESOLVE error\n    fun <T> query1(some: Class<T>) = some\n    fun <T> query1(some: Some<T>) = some\n}\n\nfun SomeTemplate.query(f: (i: Int) -> Unit) = f\nfun SomeTemplate.query1(f: (i: Int) -> Unit) = f\n\nfun test() {\n    val mapperFunction = { <!UNUSED_ANONYMOUS_PARAMETER!>i<!>: Int -> }\n    SomeTemplate().query(mapperFunction)\n\n    // TYPE_MISMATCH: Required Class<[ERROR: CANT_INFER]>, Found (kotlin.Int) -> Unit\n    SomeTemplate().query { <!UNUSED_ANONYMOUS_PARAMETER!>i<!>: Int -> }\n    SomeTemplate().query1 { <!UNUSED_ANONYMOUS_PARAMETER!>i<!>: Int -> }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-2286 Improve error message for nullability check failure for extension methods\n\npackage n\n\nabstract class Buggy {\n\n    abstract val coll : Collection<Int>\n\n    fun getThree(): Int? {\n        return coll.find{ it > 3 }  // works fine\n    }\n\n    val anotherThree : Int\n        get() = <!NI;TYPE_MISMATCH!>coll.<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>find{ it > 3 }<!><!> // does not work here\n\n    val yetAnotherThree : Int\n        get() = <!NI;TYPE_MISMATCH!>coll.<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>find({ v:Int -> v > 3 })<!><!> // neither here\n\n    val extendedGetter : Int\n        get() {\n            return <!NI;TYPE_MISMATCH!>coll.<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>find{ it > 3 }<!><!>  // not even here!\n        }\n\n}\n\n//from library\nfun <T: Any> Iterable<T>.find(<!UNUSED_PARAMETER!>predicate<!>: (T) -> Boolean) : T? {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "package a\n\ninterface Closeable {\n    fun close() {}\n}\n\nclass C : Closeable\n\npublic inline fun <T: Closeable, R> T.use(block: (t: T)-> R) : R {\n    return block(this)\n}\n\nfun test() {\n    C().use {\n        it.close()\n        <!UNRESOLVED_REFERENCE!>x<!>\n    }\n}"
        },
        {
            "code": "fun <T, U> T.map(f: (T) -> U) = f(this)\n\nfun consume(<!UNUSED_PARAMETER!>s<!>: String) {}\n\nfun test() {\n    consume(1.map(::<!UNRESOLVED_REFERENCE!>foo<!>))\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage conflictingSubstitutions\n//+JDK\n\nimport java.util.*\n\nfun <R> elemAndList(r: R, <!UNUSED_PARAMETER!>t<!>: MutableList<R>): R = r\nfun <R> R.elemAndListWithReceiver(r: R, <!UNUSED_PARAMETER!>t<!>: MutableList<R>): R = r\n\nfun test() {\n    val <!UNUSED_VARIABLE!>s<!> = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>elemAndList<!>(11, list(\"72\"))\n\n    val <!UNUSED_VARIABLE!>u<!> = 11.<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>elemAndListWithReceiver<!>(4, list(\"7\"))\n}\n\nfun <T> list(value: T) : ArrayList<T> {\n    val list = ArrayList<T>()\n    list.add(value)\n    return list\n}\n"
        },
        {
            "code": "package n\n\n//+JDK\nimport java.util.*\n\nfun <T> expected(t: T, <!UNUSED_PARAMETER!>f<!>: () -> T) : T = t\n\nfun test(arrayList: ArrayList<Int>, list: List<Int>) {\n    val <!UNUSED_VARIABLE!>t<!> = expected(arrayList, { list.reverse() })\n}\n\nfun <T> List<T>.reverse() : List<T> = this"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ExpectedTypeFromCast\n\nfun foo() = 1\n\nfun <T> foo() = foo() <!UNCHECKED_CAST!>as T<!>\n\nfun <T> foo2(): T = TODO()\n\nval test = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo2<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>plus<!>(\"\") as String\n\nfun <T> T.bar() = this\nval barTest = \"\".bar() <!CAST_NEVER_SUCCEEDS!>as<!> Number"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass X\n\noperator fun <T> X.iterator(): Iterable<T> = TODO()\n\nfun test() {\n    for (i in <!NI;ITERATOR_MISSING, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>X()<!>) {\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <K> id2(x: K, s: String): K = x\nfun <K> ret(s: String): K = TODO()\n\nfun test() {\n    id2(<!UNRESOLVED_REFERENCE!>unresolved<!>, \"foo\")\n    id2(<!UNRESOLVED_REFERENCE!>unresolved<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>)\n\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>ret<!>(\"foo\")\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>ret<!>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>)\n}"
        },
        {
            "code": "package a\n\ninterface Closeable {}\nclass C : Closeable {}\n\nfun <T: Closeable, R> T.foo(block: (T)-> R) = block\n\nfun <T: Closeable, R> T.foo(block: (T, T)-> R) = block\n\nfun main() {\n    C().foo { // no ambiguity here\n        <!UNUSED_ANONYMOUS_PARAMETER!>www<!> ->\n        <!UNRESOLVED_REFERENCE!>xs<!>\n    }\n}\n\n"
        },
        {
            "code": "package a\n\nfun <T, R, S> foo(block: (T)-> R, <!UNUSED_PARAMETER!>second<!>: (T)-> S) = block\n\nfun main() {\n    val fff = { <!UNUSED_ANONYMOUS_PARAMETER!>x<!>: Int -> <!UNRESOLVED_REFERENCE!>aaa<!> }\n    foo(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>fff<!>, { x -> x + 1 })\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nclass X\n\noperator fun <T> X.component1(): T = TODO()\n\nfun test() {\n    val (y) = <!NI;COMPONENT_FUNCTION_MISSING, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>X()<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A\nfun A.fn(b: Int): Nothing = TODO()\n\nfun A.run() {\n    \"\".apply { fn(<!TYPE_MISMATCH!>\"\"<!>) }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//For testing error messages text see DiagnosticMessageTest.testFunctionPlaceholder\npackage a\n\nclass A<T, R>\nfun <T, R> foo(a: A<T, R>) = a\nfun <T, R> bar(f: (T) -> R) = f\n\nfun test() {\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>foo<!> <!TYPE_MISMATCH!>{ <!UNRESOLVED_REFERENCE!>it<!> }<!>\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>foo<!> <!TYPE_MISMATCH!>{ <!OI;CANNOT_INFER_PARAMETER_TYPE!>x<!> -> <!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>}<!>\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>foo<!> <!TYPE_MISMATCH!>{ x: Int -> x}<!>\n\n    <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!> { <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>it<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> 1 }\n    <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!> { <!CANNOT_INFER_PARAMETER_TYPE!>x<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> 1}\n    bar { x: Int -> x + 1}\n}"
        },
        {
            "code": "fun test() {\n    val <!UNUSED_VARIABLE!>a<!> = <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>-<!>false\n}\n\noperator fun A.unaryMinus() {}\noperator fun B.unaryMinus() {}\nclass A\nclass B"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nfun <R> foo (f: ()->R, r: MutableList<R>) = r.add(f())\nfun <R> bar (r: MutableList<R>, f: ()->R) = r.add(f())\n\nfun test() {\n    val <!UNUSED_VARIABLE!>a<!> = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>foo<!>({1}, arrayListOf(\"\")) //no type inference error on 'arrayListOf'\n    val <!UNUSED_VARIABLE!>b<!> = <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>bar<!>(arrayListOf(\"\"), {1})\n}\n\n// from standard library\nfun <T> arrayListOf(vararg <!UNUSED_PARAMETER!>values<!>: T) : MutableList<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// WITH_RUNTIME\n\nfun Runnable.test(f: Runnable.(Int) -> Unit) {\n    f(<!TYPE_MISMATCH!>\"\"<!>)\n}\n\nfun test(f: Runnable.(Int) -> Unit, runnable: Runnable) {\n    with (runnable) {\n        f(<!TYPE_MISMATCH!>\"\"<!>)\n    }\n}\n\nfun Int.test(f: String.(Int) -> Unit) {\n    f(\"\", 0)\n    f(\"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    with(\"\") {\n        f(0)\n        f(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>0.0<!>)\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage aa\n\nfun <T, R> foo(block: (T)-> R) = block\n\nfun test1() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!> {\n        <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>x<!> ->  // here we have 'cannot infer parameter type' error\n        43\n    }\n}\n\nfun bar(<!UNUSED_PARAMETER!>f<!>: (<!UNRESOLVED_REFERENCE!>A<!>)->Unit) {}\n\nfun test2() {\n    bar { <!UNUSED_ANONYMOUS_PARAMETER!>a<!> -> } // here we don't have 'cannot infer parameter type' error\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ExpectedTypeFromCast\n\nfun <T> foo(): T = TODO()\n\nclass A {\n    fun <T> fooA(): T = TODO()\n}\n\nfun <V> id(value: V) = value\n\nval asA = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>fooA<!>() as A\n\nval receiverParenthesized = (<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>()).<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>fooA<!>() as A\nval no2A = A().<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>fooA<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>fooA<!>() as A\n\nval correct1 = A().fooA() as A\nval correct2 = foo<A>().fooA() as A\nval correct3 = A().fooA<A>().fooA() as A\n\n"
        },
        {
            "code": "\n// completion order here: X, Y, WHEN_VARIABLE\nfun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList() // here type variable Y will be fixed to Nothing\n    1 -> listOf(this[0])\n    else -> this\n}\nfun <X> listOf(<!UNUSED_PARAMETER!>element<!>: X): List<X> = TODO()\nfun <Y> emptyList(): List<Y> = TODO()\n\n\nfun test(l: List<String>): List<String> {\n    val foo = l.optimizeReadOnlyList()\n    return foo\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n// !WITH_NEW_INFERENCE\n\ninterface RecursiveGeneric<T : RecursiveGeneric<T, U>, U>\n\nclass A : RecursiveGeneric<A, Int>\nclass B : RecursiveGeneric<B, Int>\nclass C : RecursiveGeneric<C, Unit>\n\nfun <K> select(x: K, y: K): K = x\n\nfun foo(a: A, b: B, c: C) {\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"RecursiveGeneric<*, kotlin.Int>\")!>select(a, b)<!>\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"RecursiveGeneric<*, out kotlin.Any>\")!>select(a, c)<!>\n}"
        },
        {
            "code": "package b\n//+JDK\n\nimport java.util.*\nimport java.util.Collections.*\n\nfun foo(list: List<String>) : String {\n    val w : String = max(list, comparator<String?> {<!UNUSED_ANONYMOUS_PARAMETER!>o1<!>, <!UNUSED_ANONYMOUS_PARAMETER!>o2<!> -> 1\n    })\n    return w\n}\n\n//from library\nfun <T> comparator(<!UNUSED_PARAMETER!>fn<!>: (T,T) -> Int): Comparator<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\nclass Obj\n\nfun foo(): String? {\n    run {\n        if (true) return@run\n\n        run {\n            if (true) {\n                Obj()\n            } else\n                <!INVALID_IF_AS_EXPRESSION!>if<!> (true) return null // Error, coercion to Unit doesn't propagate inside nested lambdas\n        }\n\n        if (true) {\n            Obj()\n        } else\n            if (true) return null // OK, no error\n    }\n\n    run {\n        if (true) return@run\n\n        run {\n            if (true) {\n                <!IMPLICIT_CAST_TO_ANY!>Obj()<!>\n            } else\n            <!INVALID_IF_AS_EXPRESSION!>if<!> (true) return null // Error, coercion to Unit doesn't propagate inside nested lambdas\n        }\n    }\n\n    run {\n        if (true) return@run\n\n        run nestedRun@{\n            if (true) return@nestedRun\n\n            if (true) {\n                Obj()\n            } else\n                if (true) return null // OK, additional empty labeled return helps\n        }\n\n        if (true) {\n            Obj()\n        } else\n            if (true) return null // OK, no error\n    }\n\n    return \"\"\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T : Number> materializeNumber(): T = TODO()\n\nfun a(): Unit = run {\n    <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>materializeNumber<!>()\n}\n\nfun b(): Unit = run {\n    run {\n        <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>materializeNumber<!>()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T> materialize(): T = TODO()\n\nfun implicitCoercion() {\n    val <!UNUSED_VARIABLE!>a<!> = {\n        // Block is implicitly Unit-coerced, so it is allowed to place statement at the end of lambda\n        if (true) <!UNUSED_EXPRESSION!>42<!>\n    }\n\n    val <!UNUSED_VARIABLE!>b<!> = l@{\n        return@l\n    }\n\n    val <!UNUSED_VARIABLE!>c<!> = l@{\n        // Error: block doesn't have an expected type, so call can't be inferred!\n        return@l <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>materialize<!>()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\nclass Obj\n\nfun foo(): String? {\n    run {\n        if (true) return@run\n\n        if (true) Obj()\n    }\n\n    run {\n        if (true) return@run\n\n        if (true) return <!TYPE_MISMATCH!>Obj()<!> // correct error, type check against return type of function \"foo\"\n    }\n\n    run {\n        if (true)\n            return@run\n        else\n            if (true) <!UNUSED_EXPRESSION!>42<!>\n    }\n\n    run {\n        if (true)\n            42\n        else\n            <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\n    }\n\n    run {\n        if (true) return@run\n\n        if (true) {\n            Obj()\n        } else\n            if (true) return null\n    }\n\n    return \"\"\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// ISSUE: KT-30242\n\nclass A\n\nfun println(s: String = \"\") {}\n\nfun foo(f: () -> Any) {}\n\nfun test1(b: Boolean) {\n    foo {\n        if (b) {\n            println(\"meh\")\n        }\n    }\n}\n\nfun test2(b: Boolean) {\n    foo {\n        when {\n            b -> println(\"meh\")\n        }\n    }\n}\n\nfun test3(b: Boolean) {\n    foo {\n        <!INVALID_IF_AS_EXPRESSION!>if<!> (b) {\n            return@foo A()\n        }\n    }\n}\n\nfun test4(b: Boolean) {\n    foo {\n        if (b) {\n            return@foo println(\"meh\")\n        }\n\n        if (b) {\n            println()\n        }\n    }\n}\n\nfun bar(block: () -> String) {}\n\nfun test_5(b: Boolean) {\n    bar {\n        <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>if (b) {\n            println(\"meh\")\n        }<!>\n    }\n}\n\nfun test_6(b: Boolean) {\n    foo {\n        if (b) {\n            return@foo Unit\n        }\n        if (b) {}\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nfun noCoercionLastExpressionUsedAsReturnArgument() {\n    val a = {\n        42\n    }\n\n    a checkType { _<() -> Int>() }\n}\n\nfun noCoercionBlockHasExplicitType() {\n    val <!UNUSED_VARIABLE!>b<!>: () -> Int = {\n        <!TYPE_MISMATCH!>if (true) <!UNUSED_EXPRESSION!>42<!><!>\n    }\n}\n\nfun noCoercionBlockHasExplicitReturn() {\n    val <!UNUSED_VARIABLE!>c<!> = l@{\n        if (true) return@l 42\n\n        <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 239\n    }\n}\n\nfun noCoercionInExpressionBody(): Unit = <!TYPE_MISMATCH!>\"hello\"<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T> materialize(): T = TODO()\n\nfun a(): Unit = run {\n    run {\n        // Ok, block is coerced, because it has (indirectly) Unit-expected type\n        <!NI;UNUSED_EXPRESSION!>\"hello\"<!>\n    }\n}\n\nfun b(): Unit = run {\n    // Ok, expected type is applied\n    materialize()\n}\n\nfun c(): Unit = run {\n    run {\n        // Attention!\n        // In OI expected type 'Unit' isn't applied here because of implementation quirks (note that OI still applies Unit in case 'e')\n        // In NI, it is applied and call is correctly inferred, which is consistent with the previous case\n        <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>materialize<!>()\n    }\n}\n\nfun d(): Unit = run outer@{\n    run inner@{\n        return@inner <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>materialize<!>()\n    }\n}\n\nfun e(): Unit = run outer@{\n    run inner@{\n        return@outer materialize()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T> materialize(): T = TODO()\n\nval a: () -> Unit = l@{\n    // Expected type 'Unit' is used here for inference\n    if (true) return@l materialize()\n\n    // Expected type here is Unit, but it also implies coercion,\n    // so we can end lambda body with statement\n    if (true) <!UNUSED_EXPRESSION!>42<!>\n}\n\nval b: () -> Unit = l@{\n    // Error, coercion can't be applied at this position!\n    if (true) return@l <!TYPE_MISMATCH!>\"hello\"<!>\n\n    // However, this is OK, because here coercion is applied\n    <!UNUSED_EXPRESSION!>\"hello\"<!>\n}\n\nval c: () -> Unit = {\n    // Interesting enough, for such expessions we use expected type Unit\n    // (compare that with the previous case, where we didn't used expected type Unit for \"hello\")\n    materialize()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\ninterface A\n\nfun <T> emptyList(): List<T> = throw Exception()\n\nfun test1() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>()\n}\n\n//--------------\n\nfun <T: A> emptyListOfA(): List<T> = throw Exception()\n\nfun test2() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyListOfA<!>()\n}\n\n//--------------\n\nfun <T: A, R: T> emptyStrangeMap(): Map<T, R> = throw Exception()\n\nfun test3() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyStrangeMap<!>()\n}\n\n//--------------\n\nfun <T, R: T> emptyStrangeMap1(t: T): Map<T, R> = throw Exception(\"$t\")\n\nfun test4() {\n    emptyStrangeMap1(1)\n}\n\n//--------------\n\nfun <T: A, R> emptyStrangeMap2(t: T): Map<T, R> where R: T = throw Exception(\"$t\")\n\nfun test5(a: A) {\n    emptyStrangeMap2(a)\n}\n\n//--------------\n\nfun <T: A, R: T> emptyStrangeMap3(r: R): Map<T, R> = throw Exception(\"$r\")\n\nfun test6(a: A) {\n    emptyStrangeMap3(a)\n}\n\n//--------------\n\nfun <T, R: T> emptyStrangeMap4(l: MutableList<T>): Map<T, R> = throw Exception(\"$l\")\n\nfun test7(list: MutableList<Int>) {\n    emptyStrangeMap4(list)\n}\n\n//--------------\n\nfun test7() : Map<A, A> = emptyStrangeMap()\n\n//--------------\n\nfun <U, V: U> foo(): U = throw Exception()\n\nfun test8(): Int = foo()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nfun <V: U, U> foo(<!UNUSED_PARAMETER!>v<!>: V, u: U) = u\nfun <U, V: U> bar(<!UNUSED_PARAMETER!>v<!>: V, u: U) = u\n\nfun test(a: Any, s: String) {\n    val b = foo(a, s)\n    checkItIsExactlyAny(a, arrayListOf(b))\n    val c = bar(a, s)\n    checkItIsExactlyAny(a, arrayListOf(c))\n}\n\nfun <T> checkItIsExactlyAny(<!UNUSED_PARAMETER!>t<!>: T, <!UNUSED_PARAMETER!>l<!>: MutableList<T>) {}\n\nfun <V : U, U> baz(<!UNUSED_PARAMETER!>v<!>: V, u: MutableSet<U>) = u\n\nfun test(a: Any, s: MutableSet<String>) {\n    <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>baz<!>(a, <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>s<!>)\n}\n\n//from standard library\nfun <T> arrayListOf(vararg <!UNUSED_PARAMETER!>t<!>: T): MutableList<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !CHECK_TYPE\n\n\n@<!INVISIBLE_MEMBER!>kotlin.internal.<!INVISIBLE_REFERENCE!>InlineOnly<!><!>\npublic inline fun <C, R> C.ifEmpty(f: () -> R): R where C : Collection<*>, C : R = if (isEmpty()) f() else this\n\npublic fun <T> listOf(<!UNUSED_PARAMETER!>t<!>: T): List<T> = TODO()\n\n\nfun usage(c: List<String>) {\n    val cn = c.ifEmpty { null }\n    cn checkType { _<List<String>?>() }\n\n    val cs = c.ifEmpty { listOf(\"x\") }\n    cs checkType { _<List<String>>() }\n}"
        },
        {
            "code": "//KT-2856 Fix the getOrElse signature to be able to return any supertype of V\npackage d\n\nimport java.util.HashMap\n\npublic inline fun <K,V1, V: V1> Map<K,V>.getOrElse1(key: K, defaultValue: ()-> V1) : V1 {\n    if (this.containsKey(key)) {\n        return this.get(key) <!UNCHECKED_CAST!>as V<!>\n    } else {\n        return defaultValue()\n    }\n}\n\nfun main() {\n    val map = HashMap<Int, Int>()\n    println(map.getOrElse1(2, { null })) // Error\n}\n\n//from standard library\nfun println(<!UNUSED_PARAMETER!>message<!> : Any?) {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage Hello\n\nopen class Base<T>\nclass StringBase : Base<String>()\n\nclass Client<T, X: Base<T>>(<!UNUSED_PARAMETER!>x<!>: X)\n\nfun test() {\n    val c = Client(StringBase()) // Type inference fails here for T.\n    val <!UNUSED_VARIABLE!>i<!> : Int = <!TYPE_MISMATCH!>c<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage s\n\ninterface In<in T>\n\ninterface A\ninterface B\ninterface C: A, B\n\nfun <T> foo(in1: In<T>, in2: In<T>): T = throw Exception(\"$in1 $in2\")\n\nfun test(inA: In<A>, inB: In<B>, inC: In<C>) {\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>foo<!>(inA, inB)\n\n    val r = foo(inA, inC)\n    checkSubtype<C>(r)\n\n    val c: C = foo(inA, inB)\n\n    use(c)\n}\n\nfun <T: C> bar(in1: In<T>): T = throw Exception(\"$in1\")\n\nfun test(inA: In<A>) {\n    val r = bar(inA)\n    checkSubtype<C>(r)\n}\n\nfun use(vararg a: Any?) = a"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <A, B> Either<A, B>.recover(f: (A) -> B): Either<A, B> = when (this) {\n    is Either.Left -> f(<!DEBUG_INFO_SMARTCAST!>this<!>.a).right()\n    is Either.Right -> <!NI;DEBUG_INFO_SMARTCAST!>this<!>\n}\n\nfun <A> A.right(): Either<Nothing, A> = Either.Right(this)\n\nsealed class Either<out A, out B> {\n    class Left<out A> constructor(val a: A) : Either<A, Nothing>()\n    class Right<out B> constructor(val b: B) : Either<Nothing, B>()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: test.kt\n\nfun <K> withLock(g: () -> K): K = g()\n\nclass Out<out P>\nclass Inv<S>\n\nfun <R> Inv<R>.asOut(): Out<R> = TODO()\n\nfun test() {\n    val o: Out<Int> = Tasks.call {\n        withLock { TODO() }\n    }.asOut()\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"(Inv<(kotlin.Nothing..kotlin.Nothing?)>..Inv<(kotlin.Nothing..kotlin.Nothing?)>?)\")!>Tasks.call {\n        withLock { TODO() }\n    }<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\ninterface LevelA\ninterface LevelB : LevelA\n\nclass BiType<out X, out Y> {\n    fun <X> pullXb(x: X): BiType<X, LevelB> = TODO()\n    fun <Y> pullYb(y: Y): BiType<LevelB, Y> = TODO()\n    fun <X> pullXn(x: X): BiType<X, Nothing> = TODO()\n    fun <Y> pullYn(y: Y): BiType<Nothing, Y> = TODO()\n}\n\nfun <X> adjustIt(fn: () -> X): X = TODO()\nfun <X> adjustIt(f1: () -> X, f2: () -> X): X = TODO()\n\nfun <X> callAdjustIt(t: BiType<*, *>, x: X, level: LevelA) {\n    val x1 = adjustIt({ t.pullXb(x) })\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"BiType<X, LevelB>\")!>x1<!>\n\n    val x2 = adjustIt({ t.pullXn(x) })\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"BiType<X, kotlin.Nothing>\")!>x2<!>\n\n    val x3 = adjustIt({ t.pullXb(x) }, { t.pullYb(level) })\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"BiType<kotlin.Any?, LevelA>\")!>x3<!>\n\n    val x4 = adjustIt({ t.pullXn(x) }, { t.pullYn(level) })\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"BiType<X, LevelA>\")!>x4<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun <K> select2(x: K, y: K): K = TODO()\nfun <K> select3(x: K, y: K, z: K): K = TODO()\n\nfun test2(f: ((String) -> Int)?) {\n    val a0: ((Int) -> Int)? = select2({ it -> it }, null)\n    val b0: ((Nothing) -> Unit)? = select2({ it -> <!UNUSED_EXPRESSION!>it<!> }, null)\n\n    select3({ it.length }, f, null)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage i\n\n//+JDK\nimport java.util.*\n\nfun <T, R> Collection<T>.map1(<!UNUSED_PARAMETER!>f<!> : (T) -> R) : List<R> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun <T, R> <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Iterable<T><!>.map1(<!UNUSED_PARAMETER!>f<!> : (T) -> R) : List<R> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun test(list: List<Int>) {\n    val res = list.map1 { it }\n    //check res is not of error type\n    checkSubtype<String>(<!TYPE_MISMATCH!>res<!>)\n}\n\nfun <T> Collection<T>.foo() {}\nfun <T> <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Iterable<T><!>.foo() {}\n\nfun test1(list: List<Int>) {\n    val res = list.foo()\n    //check res is not of error type\n    checkSubtype<String>(<!TYPE_MISMATCH!>res<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage f\n\nfun <T> g(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>a<!>: Any): List<T> {throw Exception()}\nfun <T> g(<!UNUSED_PARAMETER!>a<!>: Any, <!UNUSED_PARAMETER!>i<!>: Int): Collection<T> {throw Exception()}\n\nfun <T> test() {\n    val <!UNUSED_VARIABLE!>c<!>: List<T> = <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>g<!>(1, 1)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage typeInferenceExpectedTypeMismatch\n\nimport java.util.*\n\nfun test() {\n    val s : Set<Int> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>newList()<!>\n    use(s)\n}\n\nfun <S> newList() : ArrayList<S> {\n    return ArrayList<S>()\n}\n\ninterface Out<out T>\ninterface In<in T>\n\ninterface Two<T, R>\n\ninterface A\ninterface B: A\ninterface C: A\n\nfun <T, R> foo(o: Out<T>, i: In<R>): Two<T, R> = throw Exception(\"$o $i\")\n\nfun test1(outA: Out<A>, inB: In<B>) {\n    foo(outA, inB)\n\n    val b: Two<A, C> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>foo(outA, inB)<!>\n    use(b)\n}\n\nfun <T> bar(o: Out<T>, i: In<T>): Two<T, T> = throw Exception(\"$o $i\")\n\nfun test2(outA: Out<A>, inC: In<C>) {\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>bar<!>(outA, <!NI;TYPE_MISMATCH!>inC<!>)\n\n    val b: Two<A, B> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>bar<!>(outA, <!NI;TYPE_MISMATCH!>inC<!>)<!>\n    use(b)\n}\n\nfun use(vararg a: Any?) = a"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Outer<T> {\n    inner class Inner<I> {\n        fun getOuter(): Outer<T> = this@Outer\n        fun <R> genericFun(r: R): Outer<T> = this@Outer\n    }\n    fun useOuterParam(t: T) {}\n}\n\nfun test1() {\n    Outer<Int>().Inner<String>().getOuter().useOuterParam(22)\n    Outer<Int>().Inner<String>().getOuter().useOuterParam(<!TYPE_MISMATCH!>\"\"<!>)\n}\n\n\nclass A\nclass B\n\nfun test1(a: A, b: B) {\n    Outer<Int>().Inner<String>().genericFun(a).Inner<Double>().genericFun(b)\n}"
        },
        {
            "code": "class A<T> {\n    fun useT(t: T) = t\n\n    fun <U> newA(): A<U> = A()\n}\n\nfun test1() {\n    A<Int>().newA<String>().useT(\"\")\n    A<Int>().newA<String>().useT(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n}\n"
        },
        {
            "code": "class Test {\n    private fun <T : Any> T.self() = object {\n        fun bar(): T {\n            return this@self\n        }\n    }\n    fun test() {\n        1.self().bar() + 1\n    }\n}\n\nclass Foo<R> {\n    private fun <T> bar() = object {\n        fun baz(): Foo<R> {\n            return this@Foo\n        }\n    }\n\n    fun getR(r: R) = r\n\n    fun test() {\n        Foo<Int>().bar<String>().baz().getR(1)\n        Foo<Int>().bar<String>().baz().getR(<!TYPE_MISMATCH!>\"\"<!>)\n    }\n}"
        },
        {
            "code": "fun <S : Any> foo(x: Array<out S?>, y: Array<in S?>) {\n    val xo = outA(x)\n    val yo = inA(y)\n\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>f<!>: Array<S> = xo\n    <!UNUSED_VALUE!>f =<!> yo\n}\n\n\nfun <X : Any> outA(<!UNUSED_PARAMETER!>x<!>: Array<out X?>): Array<X> = TODO()\nfun <Y : Any> inA(<!UNUSED_PARAMETER!>x<!>: Array<in Y?>): Array<Y> = TODO()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nfun <X, Y, Z> foo(f: (Y) -> Z, g: (X) -> Y, x: X): Z = f(g(x))\n\n// TODO: Actually, this is a bug and will work when new inference is enabled\n// see ([NI] Select variable with proper non-trivial constraint first) for more details\nfun test() = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>({ it + 1 }, { it.length }, \"\")"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage a\n\n//+JDK\nimport java.util.*\n\nfun foo() {\n    val v = array(1, 2, 3)\n\n    val u = v map { it * 2 }\n\n    checkSubtype<List<Int>>(u)\n\n    val a = 1..5\n\n    val b = a.map { it * 2 }\n\n    checkSubtype<List<Int>>(b)\n\n    //check for non-error types\n    checkSubtype<String>(<!TYPE_MISMATCH!>u<!>)\n    checkSubtype<String>(<!TYPE_MISMATCH!>b<!>)\n}\n\n\n// ---------------------\n// copy from kotlin util (but with `infix` modifier on `map`)\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <T> array(vararg t : T) : Array<T> = t as Array<T>\n\ninfix fun <T, R> Array<T>.map(<!UNUSED_PARAMETER!>transform<!> : (T) -> R) : List<R> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\ninfix fun <T, R> Iterable<T>.map(<!UNUSED_PARAMETER!>transform<!> : (T) -> R) : List<R> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "package n\n\nfun <T> foo(<!UNUSED_PARAMETER!>t<!>: T, <!UNUSED_PARAMETER!>t1<!>: T) {}\n\nfun test() {\n    //no type inference error\n    foo(<!UNRESOLVED_REFERENCE!>aaab<!>, <!UNRESOLVED_REFERENCE!>bbb<!>)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage a\n//+JDK\nimport java.util.*\n\nfun <A> cons(<!UNUSED_PARAMETER!>x<!>: A, xs: List<A>): List<A> = xs\n\nfun <B> nil(): List<B> = arrayList()\n\nfun test() {\n    val xs = cons(1, nil())\n    val xs1 = cons(\"\", nil())\n    val xs2 = cons(1, nil<Any>())\n\n    checkSubtype<List<Int>>(xs)\n    checkSubtype<List<String>>(xs1)\n    checkSubtype<List<Any>>(xs2)\n}\n\n\n// ---------------------\n// copy from kotlin util\n\nfun <T> arrayList(vararg values: T) : ArrayList<T> = values.toCollection(ArrayList<T>(values.size))\n\nfun <T, C: MutableCollection<in T>> Array<T>.toCollection(result: C) : C {\n    for (element in this) result.add(element)\n    return result\n}\n"
        },
        {
            "code": "package f\n\nfun <T> f(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>t<!>: T, <!UNUSED_PARAMETER!>c<!>: MutableCollection<T>) {}\nfun <T> f(<!UNUSED_PARAMETER!>a<!>: Any, <!UNUSED_PARAMETER!>t<!>: T, <!UNUSED_PARAMETER!>l<!>: MutableList<T>) {}\n\nfun test(l: List<Int>) {\n    <!NONE_APPLICABLE!>f<!>(1, \"\", l)\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\n// FILE: test.kt\n\nfun <K> select(x: K, y: K): K = x\n\nfun <R> foo(f: () -> R): R = f()\n\nfun test(n: Number) {\n    val a = select(foo { JavaTest.createNumberArray() }, emptyArray())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"(kotlin.Array<(kotlin.Number..kotlin.Number?)>..kotlin.Array<out (kotlin.Number..kotlin.Number?)>?)\")!>a<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// Issue: KT-30300\n\nclass Inv<T>\nclass InvOut<T, out K>\n\nclass Sample\n\nfun <T> select(x: T, y: T): T = x\nfun <K1, V1> selectInvOut(a: InvOut<out K1, V1>, b: InvOut<out K1, V1>): InvOut<K1, V1> = TODO()\nfun <K2, V2> emptyInvOut(): InvOut<K2, V2> = TODO()\nfun <S> create(element: S): InvOut<Inv<S>, S> = TODO()\n\nfun test(s: Sample, b: InvOut<Inv<*>, Any?>) {\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"InvOut<Inv<*>, kotlin.Any?>\")!>selectInvOut(\n        b,\n        select(create(s), emptyInvOut())\n    )<!>\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T : Any> nullable(): T? = null\n\nval value = nullable<Int>() <!NI;TYPE_MISMATCH!>?:<!> <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>nullable()<!>"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\n// FILE: test.kt\n\nfun <K> select(x: K, y: K): K = x\n\nfun <K, T> addElementToSlice(\n    slice: Inv2<K, MutableCollection<T>>,\n    key: K,\n    element: T\n) {\n    val a = select(JavaSet.get(slice, key), JavaSet.newIdentityHashSet())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"(kotlin.collections.MutableCollection<T>..kotlin.collections.Collection<T>?)\")!>a<!>\n\n    a.add(element)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun test(condition: Boolean) {\n    val list1 =\n        if (condition) mutableListOf<Int>()\n        else emptyList()\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.collections.List<kotlin.Int>\")!>list1<!>\n\n    val list2 =\n        if (condition) mutableListOf()\n        else emptyList<Int>()\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.collections.List<kotlin.Int>\")!>list2<!>\n}\n\nfun <T> mutableListOf(): MutableList<T> = TODO()\nfun <T> emptyList(): List<T> = TODO()"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\nfun <T> select(x: T, y: T): T = x\nopen class Inv<K>\nclass SubInv<V> : Inv<V>()\n\nfun testSimple() {\n    val a0 = select(Inv<Int>(), SubInv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int>\")!>a0<!>\n\n    val a1 = select(SubInv<Int>(), Inv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int>\")!>a1<!>\n}\n\nfun testNullability() {\n    val n1 = select(Inv<Int?>(), SubInv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int?>\")!>n1<!>\n\n    val n2 = select(SubInv<Int?>(), Inv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int?>\")!>n2<!>\n}\n\nfun testNested() {\n    val n1 = select(Inv<Inv<Int>>(), SubInv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<Inv<kotlin.Int>>\")!>n1<!>\n\n    val n2 = select(SubInv<SubInv<Int>>(), Inv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<SubInv<kotlin.Int>>\")!>n2<!>\n\n    fun <K> createInvInv(): Inv<Inv<K>> = TODO()\n\n    val n3 = select(SubInv<SubInv<Int>>(), createInvInv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<out Inv<kotlin.Int>>\")!>n3<!>\n}\n\nfun testCaptured(cSub: SubInv<out Number>, cInv: Inv<out Number>) {\n    val c1 = select(cInv, SubInv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<out kotlin.Number>\")!>c1<!>\n\n    val c2 = select(cSub, Inv())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<out kotlin.Number>\")!>c2<!>\n}\n\nfun testVariableWithBound() {\n    fun <K : Number> createWithNumberBound(): Inv<K> = TODO()\n    fun <K : <!FINAL_UPPER_BOUND!>Int<!>> createWithIntBound(): Inv<K> = TODO()\n\n    val c1 = select(SubInv<Int>(), createWithNumberBound())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Int>\")!>c1<!>\n\n    val c2 = <!TYPE_MISMATCH!>select<!>(SubInv<String>(), createWithNumberBound())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.String>\")!>c2<!>\n\n    val c3 = <!TYPE_MISMATCH!>select<!>(SubInv<Double>(), createWithIntBound())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<kotlin.Double>\")!>c3<!>\n}\n\nfun testCapturedVariable() {\n    fun <K> createInvOut(): Inv<out K> = TODO()\n    fun <V> createSubInvOut(): SubInv<out V> = TODO()\n\n    fun <K> createInvIn(): Inv<in K> = TODO()\n\n    val c1 = select(SubInv<Number>(), createInvOut())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<out kotlin.Number>\")!>c1<!>\n\n    val c2 = select(createSubInvOut<Number>(), createInvOut())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<out kotlin.Number>\")!>c2<!>\n\n    val c3 = <!TYPE_MISMATCH!>select<!>(SubInv<Number>(), createInvIn())\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Inv<out kotlin.Number>\")!>c3<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A\ninterface B : A\ninterface C : A\n\n@Suppress(\"INVISIBLE_REFERENCE\")\nfun <K> select(x: K, y: K): @kotlin.internal.Exact K = x\n\nfun foo(a: Any) {}\n\nfun test(b: B, c: C) {\n    foo(\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>select(b, c)<!>\n    )\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Inv<T>\n\nclass A\nclass B\n\nfun <K> select(x: K, y: K): K = x\nfun <V> generic(x: Inv<V>) {}\n\nfun test1(a: Inv<A>, b: Inv<B>) {\n    generic(select(a, b))\n}\n\nfun test2(a: Inv<*>?, b: Inv<*>) {\n    generic(a ?: b)\n    generic(if (a != null) <!DEBUG_INFO_SMARTCAST!>a<!> else b)\n    generic(a!!)\n}\n\nfun test3(a: Inv<out Any>, b: Inv<out Any>) {\n    generic(select(a, b))\n}\n"
        },
        {
            "code": "// !LANGUAGE: -NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A\ninterface B : A\ninterface C : A\n\n@Suppress(\"INVISIBLE_REFERENCE\")\nfun <K> select(x: K, y: K): @kotlin.internal.Exact K = x\n\nfun foo(a: Any) {}\n\nfun test(b: B, c: C) {\n    foo(\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any\")!>select(b, c)<!>\n    )\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Base<out T>\n\nclass ParameterizedChild<out R> : Base<R>\nclass Child : Base<Nothing>\n\nfun <K> elvis(x: K?, y: K): K = TODO()\nfun <K> select(x: K, y: K): K = TODO()\n\nfun <V> myRun(f: () -> V): V = f()\n\nfun <S> test1(a: ParameterizedChild<S>?, b: Child): Base<S> = myRun {\n    elvis(a, b)\n}\n\nfun <S> test2(a: S?, b: S): S = myRun {\n    <!TYPE_MISMATCH, TYPE_MISMATCH!>select(a, b)<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: -NewInference\n\ninterface ISample\n\nfun <K> elvisSimple(x: K?, y: K): K = y\n\n@Suppress(\"INVISIBLE_REFERENCE\")\nfun <K> elvisExact(x: K?, y: K): @kotlin.internal.Exact K = y\n\nfun <T : Number> materialize(): T? = TODO()\n\nfun test(nullableSample: ISample, any: Any) {\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"ISample\")!>elvisSimple(\n        nullableSample,\n        <!TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>materialize<!>()\n    )<!>\n\n    elvisSimple(\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"ISample\")!>elvisSimple(nullableSample, <!TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>materialize<!>())<!>,\n        any\n    )\n\n    elvisSimple(\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any?\")!>elvisExact(nullableSample, materialize())<!>,\n        any\n    )\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface ISample\n\nfun <K> elvisSimple(x: K?, y: K): K = y\n\n@Suppress(\"INVISIBLE_REFERENCE\")\nfun <K> elvisExact(x: K?, y: K): @kotlin.internal.Exact K = y\n\nfun <T : Number> materialize(): T? = null\n\nfun test(nullableSample: ISample, any: Any) {\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"ISample\")!><!TYPE_MISMATCH!>elvisSimple<!>(\n        nullableSample,\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"{ISample & Number}?\")!>materialize()<!>\n    )<!>\n\n    elvisSimple(\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"ISample\")!><!TYPE_MISMATCH!>elvisSimple<!>(nullableSample, materialize())<!>,\n        any\n    )\n\n    elvisSimple(\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any?\")!>elvisExact(nullableSample, materialize())<!>,\n        any\n    )\n}\n"
        },
        {
            "code": "interface Inter {\n    fun foo(x: Int = <!UNINITIALIZED_PARAMETER!>y<!>, y: Int = x)\n}\n\nabstract class Abst {\n    abstract fun foo(x: Int = <!UNINITIALIZED_PARAMETER!>y<!>, y: Int = x)\n}\n\n<!NON_MEMBER_FUNCTION_NO_BODY!>fun extraDiagnostics(<!UNUSED_PARAMETER!>x<!>: Int = <!UNINITIALIZED_PARAMETER!>y<!>, y: Int)<!>\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitDataClassesOverridingCopy\n\ninterface WithCopy<T> {\n    fun copy(str: T): WithCopy<T>\n}\n\n<!DATA_CLASS_OVERRIDE_DEFAULT_VALUES_ERROR!>data<!> class <!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>Test(val str: String)<!> : WithCopy<String> {\n    <!CONFLICTING_OVERLOADS!>override fun copy(str: String)<!> = Test(str)\n}"
        },
        {
            "code": "class A(val x: Int, val y: String)\n\nfun foo(a: A) {\n    a.<!UNRESOLVED_REFERENCE!>component1<!>()\n    a.<!UNRESOLVED_REFERENCE!>component2<!>()\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ndata class A(val x: Int)\n\nfun foo(a: A) {\n    checkSubtype<Int>(a.component1())\n    a.<!UNRESOLVED_REFERENCE!>component2<!>()\n}\n"
        },
        {
            "code": "data class <!DATA_CLASS_WITHOUT_PARAMETERS!>A<!>\n\nfun foo(a: A) {\n    a.<!UNRESOLVED_REFERENCE!>component1<!>()\n    a.<!UNRESOLVED_REFERENCE!>component2<!>()\n}\n"
        },
        {
            "code": "class Outer {\n    <!INCOMPATIBLE_MODIFIERS!>inner<!> <!INCOMPATIBLE_MODIFIERS!>data<!> class Inner(val x: Int)\n}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> <!INCOMPATIBLE_MODIFIERS!>data<!> class Outer(val x: Int)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ndata class <!CONFLICTING_JVM_DECLARATIONS!>A(val x: Int, val y: String)<!> {\n    <!CONFLICTING_OVERLOADS!>fun copy(x: Int, y: String)<!> = x\n    <!CONFLICTING_OVERLOADS!>fun copy(x: Int, y: String)<!> = A(x, y)\n}"
        },
        {
            "code": "data class A1(val <!REDECLARATION, REDECLARATION, REDECLARATION!>x<!>: Int, val y: String, val <!REDECLARATION, REDECLARATION, REDECLARATION!>x<!>: Int) {\n    val z = \"\"\n}\n\ndata class A2(val <!REDECLARATION!>x<!>: Int, val y: String) {\n    val <!REDECLARATION!>x<!> = \"\"\n}\n\ndata class A3(<!REDECLARATION!>val<!SYNTAX!><!> :Int<!>, <!REDECLARATION!>val<!SYNTAX!><!> : Int<!>)\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitDataClassesOverridingCopy\n\ninterface WithCopy<T> {\n    fun copy(str: T): WithCopy<T>\n}\n\n<!DATA_CLASS_OVERRIDE_DEFAULT_VALUES_ERROR!>data<!> class Test(val str: String): WithCopy<String>"
        },
        {
            "code": "// See EA-73584\ndata class<!SYNTAX!><!> {\n\n}\n\n// See KT-9296\n<!WRONG_MODIFIER_TARGET!>data<!> interface<!SYNTAX!><!> {\n\n}"
        },
        {
            "code": "data class A(<!CONFLICTING_JVM_DECLARATIONS!>val x: Int<!>, val y: String) {\n    <!CONFLICTING_OVERLOADS!>fun component1()<!> = 1\n    <!CONFLICTING_OVERLOADS!>fun component2()<!> = 2\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\ndata class A(val i: Int, val j: <!UNRESOLVED_REFERENCE!>G<!>)\ndata class B(val i: <!UNRESOLVED_REFERENCE!>G<!>, val j: <!UNRESOLVED_REFERENCE!>G<!>)\n\n\nfun fa(a: A) {\n    val (i, j) = a\n    val i2 = a.component1()\n    val j2 = a.component2()\n}\n\nfun fb(b: B) {\n    val (i, j) = b\n    val i2 = b.component1()\n    val j2 = b.component2()\n}"
        },
        {
            "code": "<!INCOMPATIBLE_MODIFIERS!>sealed<!> <!INCOMPATIBLE_MODIFIERS!>data<!> class My(val x: Int) {\n    object Your: My(1)\n    class His(y: Int): My(y)\n}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>data<!> enum class First(val x: Int) {\n    A(1),\n    B(2)\n}\n\n<!WRONG_MODIFIER_TARGET!>data<!> object <!DATA_CLASS_WITHOUT_PARAMETERS!>Second<!>\n\n<!WRONG_MODIFIER_TARGET!>data<!> interface <!DATA_CLASS_WITHOUT_PARAMETERS!>Third<!>\n\n<!WRONG_MODIFIER_TARGET!>data<!> annotation class Fourth(val x: Int)"
        },
        {
            "code": "data class My(val x: Int, <!DATA_CLASS_VARARG_PARAMETER!>vararg val y: String<!>)\n\ndata class Your(<!DATA_CLASS_NOT_PROPERTY_PARAMETER, DATA_CLASS_VARARG_PARAMETER!>vararg <!UNUSED_PARAMETER!>z<!>: String<!>)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass Data<T>(val x: T, val y: T)\n\noperator fun <T> Data<T>.component1() = x\n\noperator fun <T> Data<T>.component2() = y\n\nfun foo(): Int {\n    val d: Data<Int>? = null\n    // An error must be here\n    val (x, y) = <!COMPONENT_FUNCTION_ON_NULLABLE, COMPONENT_FUNCTION_ON_NULLABLE!>d<!>\n    return <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>y<!>\n}\n\ndata class NormalData<T>(val x: T, val y: T)\n\nfun bar(): Int {\n    val d: NormalData<Int>? = null\n    // An error must be here\n    val (x, y) = <!COMPONENT_FUNCTION_ON_NULLABLE, COMPONENT_FUNCTION_ON_NULLABLE!>d<!>\n    return <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>y<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitDataClassesOverridingCopy\n\ninterface WithCopy<T> {\n    fun copy(str: T): WithCopy<T>\n}\n\n<!DATA_CLASS_OVERRIDE_DEFAULT_VALUES_WARNING!>data<!> class Test(val str: String): WithCopy<String>"
        },
        {
            "code": "interface SuperInterface\n\nopen class SuperClass\n\n<!INCOMPATIBLE_MODIFIERS!>abstract<!> <!INCOMPATIBLE_MODIFIERS!>data<!> class Base(val x: Int)\n\nclass Derived: Base(42)\n\n<!DATA_CLASS_OVERRIDE_CONFLICT!>data<!> class Nasty(val z: Int, val y: Int): Base(z)\n\ndata class Complex(val y: Int): SuperInterface, SuperClass()\n\n<!DATA_CLASS_OVERRIDE_CONFLICT!>data<!> class SubData(val sss: String) : <!FINAL_SUPERTYPE!>Complex<!>(42)\n"
        },
        {
            "code": "// KT-11306 ABSTRACT_MEMBER_NOT_IMPLEMENTED for data class should inheriting interfaces requiring equals(), hashCode(), or toString()\n\ninterface Foo {\n    override fun equals(other: Any?): Boolean\n    override fun hashCode(): Int\n    override fun toString(): String\n}\n\ndata class FooImpl(val num: Int) : Foo\n\ndata class FooImplSome(val num: Int) : Foo {\n    override fun hashCode() = 42\n}\n\ndata class FooImplAll(val num: Int) : Foo {\n    override fun equals(other: Any?) = false\n    override fun hashCode() = 42\n    override fun toString() = \"OK\"\n}\n\n\ndata class WrongSignatures(val num: Int) : Foo {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun equals(other: WrongSignatures) = false\n    override fun hashCode(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>Boolean<!> = true\n}\n"
        },
        {
            "code": "interface T {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> fun component1(): Int = 42\n}\n\n<!DATA_CLASS_OVERRIDE_CONFLICT!>data<!> class A(val x: Int) : T\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>data<!> object Object<!CONSTRUCTOR_IN_OBJECT!>(val x: Int, val y: Int)<!>\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitDataClassesOverridingCopy\n\ninterface WithCopy<T> {\n    fun copy(str: T): WithCopy<T>\n}\n\n<!DATA_CLASS_OVERRIDE_DEFAULT_VALUES_ERROR!>data<!> class <!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>Test(val str: String)<!> : WithCopy<String> {\n    <!CONFLICTING_OVERLOADS!>override fun copy(str: String = <!DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE!>this.str<!>)<!> = Test(str)\n}"
        },
        {
            "code": "data class A<!DATA_CLASS_WITHOUT_PARAMETERS!>()<!>\n\nfun foo(a: A) {\n    a.<!UNRESOLVED_REFERENCE!>component1<!>()\n    a.<!UNRESOLVED_REFERENCE!>component2<!>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A {\n    internal val a = A()\n    internal var v = A()\n    internal fun a() = A()\n    internal inner class B\n}\n\ninternal val a = A()\ninternal var v = A()\ninternal fun a() = A()\ninternal class B\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    val _a = <!INVISIBLE_MEMBER!>a<!>\n    val _v = <!INVISIBLE_MEMBER!>v<!>\n    <!INVISIBLE_MEMBER!>a<!>()\n    <!INVISIBLE_MEMBER!>B<!>()\n\n    val inst = A()\n    val ia = inst.<!INVISIBLE_MEMBER!>a<!>\n    val iv = inst.<!INVISIBLE_MEMBER!>v<!>\n    inst.<!INVISIBLE_MEMBER!>a<!>()\n    inst.<!INVISIBLE_MEMBER!>B<!>()\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage p1\n\n@Deprecated(\"Use p2.A instead\", level = DeprecationLevel.HIDDEN)\nclass A {\n    fun m1() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p2\n\nclass A {\n    fun m2() {}\n}\n\n// MODULE: m3(m1, m2)\n// FILE: severalStarImports.kt\nimport p1.*\nimport p2.*\n\nfun test(a: A) {\n    a.<!UNRESOLVED_REFERENCE!>m1<!>()\n    a.m2()\n}\n\n// FILE: explicitlyImportP1.kt\nimport p1.<!DEPRECATION_ERROR!>A<!>\nimport p2.*\n\nfun test(a: <!DEPRECATION_ERROR!>A<!>) {\n    a.m1()\n    a.<!UNRESOLVED_REFERENCE!>m2<!>()\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage p1\n\n@Deprecated(\"1\", level = DeprecationLevel.HIDDEN)\nclass A(val v1: Unit)\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p2\n\n@Deprecated(\"2\", level = DeprecationLevel.HIDDEN)\nclass A(val v2: Unit)\n\n// MODULE: m3\n// FILE: c.kt\n\npackage p3\n\n@Deprecated(\"3\", level = DeprecationLevel.HIDDEN)\nclass A(val v3: Unit)\n\n// MODULE: m4(m1, m2, m3)\n// FILE: oneExplicitImportOtherStars.kt\nimport p1.*\nimport p2.<!DEPRECATION_ERROR!>A<!>\nimport p3.*\n\nfun test(a: <!DEPRECATION_ERROR!>A<!>) {\n    a.<!UNRESOLVED_REFERENCE!>v1<!>\n    a.v2\n    a.<!UNRESOLVED_REFERENCE!>v3<!>\n}\n\n// FILE: severalStarImports.kt\nimport p1.*\nimport p2.*\nimport p3.*\n\nfun test(a: <!UNRESOLVED_REFERENCE!>A<!>) {\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v1<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v2<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v3<!>\n}\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n// MODULE: m1\n// FILE: a.kt\n\npackage p1\n\n@SinceKotlin(\"1.1\")\nclass A(val v1: Unit)\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p2\n\n@SinceKotlin(\"1.1\")\nclass A(val v2: Unit)\n\n// MODULE: m3\n// FILE: c.kt\n\npackage p3\n\n@SinceKotlin(\"1.1\")\nclass A(val v3: Unit)\n\n// MODULE: m4(m1, m2, m3)\n// FILE: oneExplicitImportOtherStars.kt\nimport p1.*\nimport p2.<!API_NOT_AVAILABLE!>A<!>\nimport p3.*\n\nfun test(a: <!API_NOT_AVAILABLE!>A<!>) {\n    a.<!UNRESOLVED_REFERENCE!>v1<!>\n    a.v2\n    a.<!UNRESOLVED_REFERENCE!>v3<!>\n}\n\n// FILE: severalStarImports.kt\nimport p1.*\nimport p2.*\nimport p3.*\n\nfun test(a: <!UNRESOLVED_REFERENCE!>A<!>) {\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v1<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v2<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v3<!>\n}\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n// MODULE: m1\n// FILE: a.kt\n\npackage p1\n\n@SinceKotlin(\"1.1\")\nclass A {\n    fun m1() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p2\n\nclass A {\n    fun m2() {}\n}\n\n// MODULE: m3(m1, m2)\n// FILE: severalStarImports.kt\nimport p1.*\nimport p2.*\n\nfun test(a: A) {\n    a.<!UNRESOLVED_REFERENCE!>m1<!>()\n    a.m2()\n}\n\n// FILE: explicitlyImportP1.kt\nimport p1.<!API_NOT_AVAILABLE!>A<!>\nimport p2.*\n\nfun test(a: <!API_NOT_AVAILABLE!>A<!>) {\n    a.m1()\n    a.<!UNRESOLVED_REFERENCE!>m2<!>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic fun foo(a: Int) {}\npublic fun foo(vararg values: Int) {}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic fun foo(a: Int) {}\npublic fun foo(vararg values: Int) {}\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\npackage m\n\nimport p.foo\n\nfun main() {\n    foo(12)\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage p\n\nprivate val a = 1\n\n// FILE: b.kt\n\npackage p\n\nval b = <!INVISIBLE_MEMBER(\"a\", \"private\", \"file\")!>a<!> // same package, same module\n\n// MODULE: m2(m1)\n// FILE: c.kt\n\npackage p\n\nval c = <!INVISIBLE_MEMBER(\"a\", \"private\", \"file\")!>a<!> // same package, another module\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A\npublic class B {\n    public val a: A = A()\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\npackage p\n\nclass A {\n    fun foo() {}\n}\n\nfun test() {\n    val a: A = B().a\n    a.foo()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A {\n    public fun m1() {}\n}\npublic class M1 {\n    public val a: A = A()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A {\n    public fun m2() {}\n}\n\npublic class M2 {\n    public val a: A = A()\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test(a: A) {\n    a.m1()\n\n    M1().a.m1()\n\n    M2().a.m2()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic interface A<T>\npublic interface C\npublic interface D<T>\npublic class B : A<Int>, C, D<Int>\npublic class M1 {\n    public val b: B = B()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic interface A\npublic interface C<T>\npublic interface D<T>\n\npublic fun a(a: A) {\n}\n\npublic fun c(c: C<Int>) {\n}\n\npublic fun d(d: D<Int>) {\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    a(<!TYPE_MISMATCH!>M1().b<!>) // Type arguments do not match\n    c(<!TYPE_MISMATCH!>M1().b<!>) // Type arguments do not match\n    d(M1().b) // Type arguments do match\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A\npublic class B {\n    public val a: A = A()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A {\n    val x = 1\n}\n\npublic fun foo(a: A) {\n    a.x + 1\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    foo(B().a)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A<T>\npublic class M1 {\n    public val a: A<Int> = A<Int>()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A\n\npublic fun foo(a: A) {\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    foo(<!TYPE_MISMATCH!>M1().a<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A\npublic class B {\n    public val a: A = A()\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\nimport p.*\n\nclass A\n\nfun test() {\n    val a: A = <!TYPE_MISMATCH!>B().a<!>\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A\npublic class B {\n    public val a: A = A()\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\npackage p\n\nclass A {\n    fun foo() {}\n}\n\nfun test() {\n    val a = B().a\n    a.<!UNRESOLVED_REFERENCE!>foo<!>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A<X, Y>\npublic class M1 {\n    public val a: A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!> = A<Int, Int>()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A<X, Y>\n\npublic fun foo(a: A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>) {\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    foo(M1().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>)\n    foo(1) // error type on the declaration site\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A\npublic class M1 {\n    public val a: A = A()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A<T>\n\npublic fun foo(a: A<Int>) {\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    foo(<!TYPE_MISMATCH!>M1().a<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A<T>\npublic class M1 {\n    public val a: A<Int> = A()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A<T>\n\npublic fun foo(a: A<Int>) {\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    foo(M1().a)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A {\n    public class B\n    public object C\n    companion object {\n        public class D {\n            public object E\n        }\n        public class G\n    }\n\n    public inner class F\n}\n\npublic class M1 {\n    public val a: A = A()\n    public val b: A.B = A.B()\n    public val c: A.C = A.C\n    public val d: A.Companion.D = A.Companion.D()\n    public val e: A.Companion.D.E = A.Companion.D.E\n    public val f: A.F = A().F()\n    public val g: A.Companion.G = A.Companion.G()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic class A {\n    public class B\n    public class C\n    companion object {\n        public class D {\n            public class E\n        }\n    }\n    public class G\n    public inner class F\n}\n\npublic fun a(p: A) {}\npublic fun b(p: A.B) {}\npublic fun c(p: A.C) {}\npublic fun d(p: A.Companion.D) {}\npublic fun e(p: A.Companion.D.E) {}\npublic fun f(p: A.F) {}\npublic fun g(p: A.G) {}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test(m1: M1) {\n    a(m1.a)\n    b(m1.b)\n    c(m1.c)\n    d(m1.d)\n    e(m1.e)\n    f(m1.f)\n    g(<!TYPE_MISMATCH!>m1.g<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic interface A\npublic class B : A\npublic class M1 {\n    public val b: B = B()\n}\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p\n\npublic interface A\n\npublic fun foo(a: A) {\n}\n\n// MODULE: m3(m1, m2)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    foo(M1().b)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// MODULE: m1\n// FILE: a.kt\n\npackage p\n\npublic class A {\n    @PublishedApi\n    internal val a = A()\n    @PublishedApi\n    internal var v = A()\n    @PublishedApi\n    internal fun a() = A()\n    @PublishedApi\n    internal inner class B\n}\n\n@PublishedApi\ninternal val a = A()\n@PublishedApi\ninternal var v = A()\n@PublishedApi\ninternal fun a() = A()\n@PublishedApi\ninternal class B\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\nimport p.*\n\nfun test() {\n    val _a = <!INVISIBLE_MEMBER!>a<!>\n    val _v = <!INVISIBLE_MEMBER!>v<!>\n    <!INVISIBLE_MEMBER!>a<!>()\n    <!INVISIBLE_MEMBER!>B<!>()\n\n    val inst = A()\n    val ia = inst.<!INVISIBLE_MEMBER!>a<!>\n    val iv = inst.<!INVISIBLE_MEMBER!>v<!>\n    inst.<!INVISIBLE_MEMBER!>a<!>()\n    inst.<!INVISIBLE_MEMBER!>B<!>()\n}\n\ninline fun testInline() {\n    val _a = <!INVISIBLE_MEMBER!>a<!>\n    val _v = <!INVISIBLE_MEMBER!>v<!>\n    <!INVISIBLE_MEMBER!>a<!>()\n    <!INVISIBLE_MEMBER!>B<!>()\n\n    val inst = A()\n    val ia = inst.<!INVISIBLE_MEMBER!>a<!>\n    val iv = inst.<!INVISIBLE_MEMBER!>v<!>\n    inst.<!INVISIBLE_MEMBER!>a<!>()\n    inst.<!INVISIBLE_MEMBER!>B<!>()\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: test/Foo.java\n\npackage test;\n\nclass Foo {\n    static Foo create() { return Foo(); }\n    void takeFoo(Foo f) {}\n}\n\n// MODULE: m2(m1)\n// FILE: test.kt\n\npackage test\n\nfun test() {\n    Foo()\n    val a: Foo = Foo.create()\n    Foo().takeFoo(a)\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage p\n\nfun f(s: String, t: String) = s + t\n\n// MODULE: m2\n// FILE: b.kt\npackage p\n\nfun f(s: String, t: String) = t + s\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\nimport p.f\n\nfun test() {\n    // There should be no \"none applicable\" error here\n    f(\n<!SYNTAX!><!>}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun <T> foo(a: T): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b == null) return\n    b?.foo<String>(\"\")\n}\n\nfun test1(b: B?) {\n    if (b != null) {\n        b?.foo<String>(\"\")\n    }\n}\n\nfun test2(b: B?) {\n    if (b == null) return\n    b?.foo(\"\")\n}\n\nfun test3(b: B?) {\n    if (b != null) {\n        b?.foo(\"\")\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): T\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun <T> foo(a: T): T\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): T\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b !is C)  return\n    b?.foo(\"\")\n}\n\nfun test1(b: B?) {\n    if (b !is C)  return\n    b?.foo<String>(\"\")\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun foo(a: Int, b: String): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun foo(a: Int, b: String): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun foo(a1: Int, b1: String): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b?.foo(1, \"\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun <T> foo(a: T): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b?.foo<String>(\"\")\n    }\n}\n\nfun test1(b: B?) {\n    if (b is C) {\n        b?.foo(\"\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun String.getParent(): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic class C : B {\n    override fun String.getParent(): B? = null\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun String.getParent(): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun B.test() {\n    if (this is C) {\n        \"\".getParent()\n    }\n}\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n// MODULE: m1\n// FILE: a.kt\n\npackage p1\n\n@SinceKotlin(\"1.1\")\nfun foo(s: Int): String = s.toString()\n\n// MODULE: m2\n// FILE: b.kt\n\npackage p2\n\nfun foo(s: Int): Int = s\n\n// MODULE: m3(m1, m2)\n// FILE: severalStarImports.kt\nimport p1.*\nimport p2.*\n\nfun test1(): Int {\n    val r = foo(42)\n    return r\n}\n\n// FILE: explicitlyImportP1.kt\nimport p1.foo  // TODO: consider reporting API_NOT_AVAILABLE here\nimport p2.*\n\nfun test2(): Int {\n    val r = foo(42)\n    return r\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface Foo<T>\n\npublic interface B {\n    public fun <T> foo(a: T): Foo<T>\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun <T> foo(a: T): Foo<T>\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface Foo<T>\n\npublic interface B {\n    public fun <T> foo(a: T): Foo<T>\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b !is C)  return\n    b?.foo(\"\")\n}\n\nfun test1(b: B?) {\n    if (b !is C)  return\n    b?.foo<String>(\"\")\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(a: T?)\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C<X> : B<X> {\n    override fun foo(a: X?)\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface Tr\n\npublic interface B<T: Tr?> {\n    public fun foo(a: T?)\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B<Tr>?) {\n    if (b is C) {\n        b?.foo(null)\n    }\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T, Z> {\n    public fun foo(a: T?)\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C<X, Z> : B<X, Z> {\n    override fun foo(a: X?)\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B<Z, T> {\n    public fun foo(a: T?)\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun <Y, Z> test(b: B<Y, Z>?) {\n    if (b is C<Y, Z>) {\n        b<!UNNECESSARY_SAFE_CALL!>?.<!><!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(null)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(a: T)\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C<X> : B<X> {\n    override fun foo(a: X)\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(a: T)\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B<String>?) {\n    if (b is C) {\n        b?.foo(\"\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun <T> foo(a: T): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b !is C)  return\n    b?.foo(\"\")\n}\n\nfun test1(b: B?) {\n    if (b !is C)  return\n    b?.foo<String>(\"\")\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T> {\n    public fun <R> foo(a: T, b : R)\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B<Any?> {\n    override fun <R> foo(a: Any?, b : R)\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun <T, R> foo(a: T, b: R)\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?, c: C) {\n    b?.foo(1, 1)\n    c.foo(1, 1)\n    if (b is C) {\n        b<!UNNECESSARY_SAFE_CALL!>?.<!><!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>foo<!>(1, 1)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun getParent(): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun getParent(): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun getParent(): Int\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b?.<!OVERLOAD_RESOLUTION_AMBIGUITY!>getParent<!>()\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun getParent(): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic class C : B {\n    override fun getParent(): B? = null\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun getParent(): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b?.getParent()\n    }\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun foo(a: Int, b: String): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun foo(a: Int, b: String): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun foo(a: Int, b: String, c: Int = 0): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        <!DEBUG_INFO_SMARTCAST!>b<!><!UNNECESSARY_SAFE_CALL!>?.<!>foo(1, \"\")\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(a: T)\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C<X> : B<X> {\n    override fun foo(a: X)\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B<T1> {\n    public fun foo(a: T1)\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun <Y> test(b: B<Y>?, y: Y) {\n    if (b is C) {\n        b?.foo(y)\n    }\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun getParent(): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun getParent(): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun getParent(): B?\n}\n\npublic interface D : B {\n    override fun getParent(): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C && b is D) {\n        b<!UNNECESSARY_SAFE_CALL!>?.<!>getParent()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m0\n// FILE: a.kt\npackage p\n\npublic interface G1<T>\npublic interface G2<A, B>\n\n// MODULE: m1(m0)\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun foo(a: G1<Int>, b: G2<B, String>): B?\n}\n\n// MODULE: m2(m1, m0)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun foo(a: G1<Int>, b: G2<B, String>): B?\n\n}\n\n// MODULE: m3(m0)\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun foo(a: G1<Int>, b: G2<B, String>): B?\n}\n\n// MODULE: m4(m3, m2, m0)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?, a: G1<Int>, b1: G2<B, String>) {\n    if (b is C) {\n        b?.foo(a, b1)\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun <T> foo(a: T): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun <T> foo(a: T): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface Tr\n\npublic interface B {\n    public fun <T: Tr?> foo(a: T): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        // hard to find parameters for an ambiguous call, so we rely on NONE_APPLICABLE here\n        // as opposed to diagnostics for a single unmatched candidate\n        b?.<!NONE_APPLICABLE!>foo<!>()\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m0\n// FILE: a.kt\npackage p\n\npublic interface G1<T>\npublic interface G2<A, B>\n\n// MODULE: m1(m0)\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun foo(a: G1<Int>?, b: G2<B, String>?)\n}\n\n// MODULE: m2(m1, m0)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun foo(a: G1<Int>?, b: G2<B, String>?)\n\n}\n\n// MODULE: m3(m0)\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun foo(a: G1<out Any?>?, b: G2<Int, out Any?>?)\n}\n\n// MODULE: m4(m3, m2, m0)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b?.<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>(null, null)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun foo(a: Int, b: String): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun foo(a: Int, b: String): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun foo(a: Int, b: String): B?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b?.foo(1, \"\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B {\n    public fun getParent(): B?\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B {\n    override fun getParent(): B?\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun getParent(): Any?\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        <!DEBUG_INFO_SMARTCAST!>b<!>?.getParent()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNNECESSARY_SAFE_CALL\n\n// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(): T\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C<X> : B<X> {\n    override fun foo(): X\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(): T\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B<String>?) {\n    if (b is C) {\n        b?.foo()\n    }\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage p\n\npublic interface B<T> {\n    public fun foo(a: T)\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage p\n\npublic interface C : B<String> {\n    override fun foo(a: String)\n\n}\n\n// MODULE: m3\n// FILE: b.kt\npackage p\n\npublic interface B {\n    public fun foo(a: String)\n}\n\n// MODULE: m4(m3, m2)\n// FILE: c.kt\nimport p.*\n\nfun test(b: B?) {\n    if (b is C) {\n        b<!UNNECESSARY_SAFE_CALL!>?.<!>foo(\"\")\n    }\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\n\npackage test\n\nenum class E {\n    FIRST\n}\n\nsealed class S\n\nclass Derived : S()\n\n// MODULE: m2(m1)\n// FILE: b.kt\n\npackage other\n\nimport test.*\n\nfun foo(e: E) = when (e) {\n    E.FIRST -> 42\n    else -> -42\n}\n\nfun bar(s: S?) = when (s) {\n    is Derived -> \"Derived\"\n    null -> \"\"\n    else -> TODO(\"What?!?!\")\n}\n\nfun baz(b: Boolean?) = when (b) {\n    true -> 1\n    false -> 0\n    null -> -1\n    // Still warning\n    <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> TODO()\n}\n\nfun baz(b: Boolean) = when (b) {\n    true -> 1\n    false -> 0\n    // Still warning\n    <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> TODO()\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: x.kt\npackage p\n\npublic interface Base {\n    public fun foo() {}\n}\n\npublic interface A : Base {\n    override fun foo() {}\n}\n\npublic interface C : A\n\n\n// MODULE: m2\n// FILE: x.kt\npackage p\n\npublic interface Base {\n    public fun foo() {}\n}\n\npublic interface B : Base\n\n// MODULE: m3(m1, m2)\n// FILE: x.kt\n\nimport p.*\n\nclass Foo: C, B"
        },
        {
            "code": "// MODULE: m1\n// FILE: x.kt\npackage p\n\npublic interface Base<T> {\n    public fun foo(t: T) {}\n}\n\npublic interface A<T> : Base<T>\n\n// MODULE: m2\n// FILE: x.kt\npackage p\n\npublic interface Base<T> {\n    public fun foo(t: T) {}\n}\n\npublic interface B : Base<String>\n\n// MODULE: m3(m1, m2)\n// FILE: x.kt\n\nimport p.*\n\nclass Foo: A<String>, B"
        },
        {
            "code": "// MODULE: m1\n// FILE: x.kt\npackage p\n\npublic interface Base {\n    public fun foo() {}\n}\n\npublic interface A : Base\n\n// MODULE: m2\n// FILE: x.kt\npackage p\n\npublic interface Base {\n    public fun foo() {}\n}\n\npublic interface B : Base\n\n// MODULE: m3(m1, m2)\n// FILE: x.kt\n\nimport p.*\n\nclass Foo: A, B"
        },
        {
            "code": "// MODULE: m1\n// FILE: x.kt\npackage p\n\npublic interface Base {\n    public fun <T> foo(t: Array<T>) {}\n}\n\npublic interface A : Base\n\n// MODULE: m2\n// FILE: x.kt\npackage p\n\npublic interface Base {\n    public fun <T: Base> foo(t: Array<T>) {}\n}\n\npublic interface B : Base\n\n// MODULE: m3(m1, m2)\n// FILE: x.kt\n\nimport p.*\n\nclass Foo: A, B {\n    override fun <T> foo(t: Array<T>) {}\n    override fun <T: Base> foo(t: Array<T>) {}\n}"
        },
        {
            "code": "// FILE: 1.kt\n<!FINITE_BOUNDS_VIOLATION_IN_JAVA!>class B<S: A<*>><!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UPPER_BOUND_VIOLATED\n\ninterface C0<T, S : C0<*, S>>\n\ninterface C1<T : C1<T, *>, <!FINITE_BOUNDS_VIOLATION!>S : C1<S, *><!>>   // T -> S, S -> S\ninterface C2<<!FINITE_BOUNDS_VIOLATION!>T : C2<T, *><!>, S : C2<*, S>>   // T -> S, S -> T\n\ninterface D1<<!FINITE_BOUNDS_VIOLATION!>T<!>, U> where T : U, U: D1<*, U>\ninterface D2<<!FINITE_BOUNDS_VIOLATION!>T<!>, U> where T : U?, U: D2<*, *>\ninterface D3<<!FINITE_BOUNDS_VIOLATION!>T<!>, U, V> where T : U, U : V, V: D3<*, *, V>\n\ninterface A<T, U> where T : A<U, T>, U: A<T, A<in U, T>>"
        },
        {
            "code": "interface A0<T : A0<T>>\ninterface A1<<!FINITE_BOUNDS_VIOLATION!>T : A1<*><!>>\ninterface A2<<!FINITE_BOUNDS_VIOLATION!>T : A2<out T><!>>\n// StackOverflowError\n//interface A3<T : A3<in T>>\ninterface A4<<!FINITE_BOUNDS_VIOLATION!>T : A4<*>?<!>>\n\ninterface B0<<!FINITE_BOUNDS_VIOLATION!>T : B1<*><!>>\ninterface B1<<!FINITE_BOUNDS_VIOLATION!>T : B0<*><!>>\n\ninterface AA<<!FINITE_BOUNDS_VIOLATION!>T: AA<*><!>>\ninterface BB<S : List<AA<*>>>\n\ninterface A<T: List<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><T, T, T><!>>\n\nclass X<Y>\nclass D<T : X<in X<out X<T>>>>"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)\nannotation class a\ninterface A\ninterface B\n\n<!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {}\n<!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>fun A.()<!> {}\n\n<!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>@a fun ()<!> {}\n<!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>fun @a A.()<!> {}\n\nclass Outer {\n    <!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {}\n    <!FUNCTION_DECLARATION_WITH_NO_NAME!>fun B.()<!> {}\n\n    <!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>@a fun ()<!> {}\n    <!FUNCTION_DECLARATION_WITH_NO_NAME!>fun @a A.()<!> {}\n}\n\nfun outerFun() {\n    <!UNUSED_EXPRESSION!>fun () {}<!>\n    <!UNUSED_EXPRESSION!>fun B.() {}<!>\n\n    <!UNUSED_EXPRESSION!>@a fun () {}<!>\n    <!UNUSED_EXPRESSION!>fun @a A.() {}<!>\n}"
        },
        {
            "code": "//KT-2397 Prohibit final methods in traits with no implementation\npackage a\n\ninterface T {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> fun foo()\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> val b : Int\n\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> fun bar() {}\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> val c : Int\n       get() = 42\n\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> val d = <!PROPERTY_INITIALIZER_IN_INTERFACE!>1<!>\n}\n\nclass A {\n    <!NON_ABSTRACT_FUNCTION_WITH_NO_BODY!>final fun foo()<!>\n}"
        },
        {
            "code": "fun unusedExpressions() {\n    if (1 == 1)\n        <!UNUSED_EXPRESSION!>fun(): Int {return 1}<!>\n    else\n        <!UNUSED_EXPRESSION!>fun() = 1<!>\n\n    if (1 == 1) {\n        <!UNUSED_EXPRESSION!>fun(): Int {\n            return 1\n        }<!>\n    }\n    else\n        <!UNUSED_EXPRESSION!>fun() = 1<!>\n\n    when (1) {\n        0 -> <!UNUSED_EXPRESSION!>fun(): Int {return 1}<!>\n        else -> <!UNUSED_EXPRESSION!>fun() = 1<!>\n    }\n\n    <!UNUSED_EXPRESSION!>fun() = 1<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nclass MyClass {\n    fun component1(<!UNUSED_PARAMETER!>i<!>: Int) {}\n}\n\nclass MyClass2 {}\n\n<!CONFLICTING_OVERLOADS!>fun MyClass2.component1()<!> = 1.2\n<!CONFLICTING_OVERLOADS!>fun MyClass2.component1()<!> = 1.3\n\nfun test(mc1: MyClass, mc2: MyClass2) {\n    val (<!OPERATOR_MODIFIER_REQUIRED!>a<!>, b) = <!COMPONENT_FUNCTION_MISSING, COMPONENT_FUNCTION_MISSING!>mc1<!>\n    val (c) = <!NI;COMPONENT_FUNCTION_MISSING, OI;COMPONENT_FUNCTION_AMBIGUITY!>mc2<!>\n\n    //a,b,c are error types\n    use(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>, <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b<!>, <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>c<!>)\n}\n\nfun use(vararg a: Any?) = a"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !LANGUAGE: +ProhibitTypeParametersForLocalVariables\n\nimport kotlin.reflect.KProperty\n\nfun test() {\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T><!> a0 = 0\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T : <!DEBUG_INFO_MISSING_UNRESOLVED!>__UNRESOLVED__<!>><!> a1 = \"\"\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T : <!DEBUG_INFO_MISSING_UNRESOLVED!>String<!>><!> a2 = 0\n    <!WRONG_MODIFIER_TARGET!>const<!> val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T><!> a3 = 0\n    <!INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T><!> a4 = 0\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T><!> a5 by Delegate<Int>()\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS!><T><!> a6 by Delegate<<!UNRESOLVED_REFERENCE!>T<!>>()\n}\n\nclass Delegate<F> {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String = \"\"\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {}\n}"
        },
        {
            "code": "//KT-1141 No check that object in 'object expression' implements all abstract members of supertype\n\npackage kt1141\n\npublic interface SomeTrait {\n    fun foo()\n}\n\nfun foo() {\n    val x = <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>object<!> : SomeTrait {\n    }\n    x.foo()\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>object Rr<!> : SomeTrait {}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class C<!> : SomeTrait {}\n\nfun foo2() {\n    val <!UNUSED_VARIABLE!>r<!> = <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>object<!> : Runnable {} //no error\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A {\n    operator fun component1() = 1\n    operator fun component2() = 1.0\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>: Double, <!UNUSED_VARIABLE!>y<!>: Int) in <!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH, COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>C()<!>) {\n\n    }\n}\n"
        },
        {
            "code": "fun useDeclaredVariables() {\n    val (a, b) = <!UNRESOLVED_REFERENCE!>unresolved<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNUSED_EXPRESSION!>a<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNUSED_EXPRESSION!>b<!>\n}\n\nfun checkersShouldRun() {\n    val (@A <!UNUSED_VARIABLE!>a<!>, _) = <!UNRESOLVED_REFERENCE!>unresolved<!>\n}\n\nannotation class A\n"
        },
        {
            "code": "class A {\n    operator fun component1() = 1\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>) in C()) {\n\n    }\n}\n"
        },
        {
            "code": "class A {\n    operator fun component1() = 1\n    operator fun component2() = 1.0\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>: Int, <!UNUSED_VARIABLE!>y<!>: Double) in C()) {\n\n    }\n}\n"
        },
        {
            "code": "class A {\n}\noperator fun A.component1() = 1\noperator fun A.component2() = 1\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>, <!UNUSED_VARIABLE!>y<!>) in C()) {\n\n    }\n}\n"
        },
        {
            "code": "class A {\n    operator fun component1() = 1\n    operator fun component2() = 1\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!REDECLARATION, UNUSED_VARIABLE!>x<!>, <!NAME_SHADOWING, REDECLARATION, UNUSED_VARIABLE!>x<!>) in C()) {\n\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun useDeclaredVariables() {\n    for ((a, b)<!SYNTAX!><!>) {\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNUSED_EXPRESSION!>a<!>\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNUSED_EXPRESSION!>b<!>\n    }\n}\n\nfun checkersShouldRun() {\n    for ((@A <!UNUSED_VARIABLE!>a<!>, _)<!SYNTAX!><!>) {\n\n    }\n}\n\nannotation class A\n"
        },
        {
            "code": "class A {\n    <!CONFLICTING_OVERLOADS!>operator fun component1()<!> = 1\n    <!CONFLICTING_OVERLOADS!>operator fun component1()<!> = 1\n    operator fun component2() = 1\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>, <!UNUSED_VARIABLE!>y<!>) in <!COMPONENT_FUNCTION_AMBIGUITY!>C()<!>) {\n\n    }\n}\n"
        },
        {
            "code": "class A {\n    operator fun component1() = 1\n    operator fun component2() = 1\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>, <!UNUSED_VARIABLE!>y<!>) in C()) {\n\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nclass A {\n    operator fun component1() = 1\n    operator fun component2() = \"\"\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((x, _) in C()) {\n        foo(x, <!UNRESOLVED_REFERENCE!>_<!>)\n    }\n\n    for ((_, y) in C()) {\n        foo(<!UNRESOLVED_REFERENCE!>_<!>, y)\n    }\n\n    for ((_, _) in C()) {\n        foo(<!UNRESOLVED_REFERENCE!>_<!>, <!UNRESOLVED_REFERENCE!>_<!>)\n    }\n\n    for ((_ : Int, _ : String) in C()) {\n        foo(<!UNRESOLVED_REFERENCE!>_<!>, <!UNRESOLVED_REFERENCE!>_<!>)\n    }\n\n    for ((_ : String, _ : Int) in <!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH, COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>C()<!>) {\n        foo(<!UNRESOLVED_REFERENCE!>_<!>, <!UNRESOLVED_REFERENCE!>_<!>)\n    }\n\n    val (x, _) = A()\n    val (_, y) = A()\n\n    foo(x, y)\n    foo(x, <!UNRESOLVED_REFERENCE!>_<!>)\n    foo(<!UNRESOLVED_REFERENCE!>_<!>, y)\n\n    val (<!REDECLARATION!>`_`<!>, z) = A()\n\n    foo(<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!>, z)\n\n    val (_, <!NAME_SHADOWING, REDECLARATION!>`_`<!>) = A()\n\n    foo(<!TYPE_MISMATCH, UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!>, y)\n\n    val (<!UNUSED_VARIABLE!>unused<!>, _) = A()\n}\n\nfun foo(<!UNUSED_PARAMETER!>x<!>: Int, <!UNUSED_PARAMETER!>y<!>: String) {}\n"
        },
        {
            "code": "class A {\n    operator fun component1() = 1\n}\n\nclass C {\n    operator fun iterator(): Iterator<A> = null!!\n}\n\nfun test() {\n    for ((<!UNUSED_VARIABLE!>x<!>, <!UNUSED_VARIABLE!>y<!>) in <!COMPONENT_FUNCTION_MISSING!>C()<!>) {\n\n    }\n}\n"
        },
        {
            "code": "fun useDeclaredVariables() {\n    <!INITIALIZER_REQUIRED_FOR_DESTRUCTURING_DECLARATION!>val (a, b)<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNUSED_EXPRESSION!>a<!>\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNUSED_EXPRESSION!>b<!>\n}\n\nfun checkersShouldRun() {\n    <!INITIALIZER_REQUIRED_FOR_DESTRUCTURING_DECLARATION!>val (@A <!UNUSED_VARIABLE!>a<!>, _)<!>\n}\n\nannotation class A\n"
        },
        {
            "code": "fun f(\n        <!VAL_OR_VAR_ON_FUN_PARAMETER!>val<!> a: Int,\n        <!VAL_OR_VAR_ON_FUN_PARAMETER!>var<!> b: Int,\n        c: Int,\n        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> <!VAL_OR_VAR_ON_FUN_PARAMETER!>var<!> d: Int,\n        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> <!VAL_OR_VAR_ON_FUN_PARAMETER!>val<!> e: Int,\n        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> f: Int\n) {\n    \n    \n    a + b + c + d[0] + e[0] + f[0] // to avoid 'unused parameter'\n}"
        },
        {
            "code": "interface MyTrait {\n    fun f1() {}\n}\n\nopen class MyClass {\n    fun f2() {}\n}\n\n\nclass Foo {\n\n    private val privateProperty = object : MyClass(), MyTrait {}\n\n    init {\n        privateProperty.f1()\n        privateProperty.f2()\n    }\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>protected val <!EXPOSED_PROPERTY_TYPE!>protectedProperty<!><!> = object : MyClass(), MyTrait {}\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>val <!EXPOSED_PROPERTY_TYPE!>internalProperty<!><!> = object : MyClass(), MyTrait {}\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>internal val <!EXPOSED_PROPERTY_TYPE!>internal2Property<!><!> = object : MyClass(), MyTrait {}\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>public val <!EXPOSED_PROPERTY_TYPE!>publicProperty<!><!> = object : MyClass(), MyTrait {}\n\n    val <!EXPOSED_PROPERTY_TYPE!>propertyWithGetter<!>\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>get()<!> = object: MyClass(), MyTrait {}\n\n\n    private fun privateFunction() = object : MyClass(), MyTrait {}\n\n    init {\n        privateFunction().f1()\n        privateFunction().f2()\n    }\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>protected fun <!EXPOSED_FUNCTION_RETURN_TYPE!>protectedFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>fun <!EXPOSED_FUNCTION_RETURN_TYPE!>internalFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>internal fun <!EXPOSED_FUNCTION_RETURN_TYPE!>internal2Function<!>()<!> = object : MyClass(), MyTrait {}\n\n    <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>public fun <!EXPOSED_FUNCTION_RETURN_TYPE!>publicFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n\n\n    class FooInner {\n        private val privatePropertyInner = object : MyClass(), MyTrait {}\n\n        init {\n            privatePropertyInner.f1()\n            privatePropertyInner.f2()\n        }\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>protected val <!EXPOSED_PROPERTY_TYPE!>protectedProperty<!><!> = object : MyClass(), MyTrait {}\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>val <!EXPOSED_PROPERTY_TYPE!>internalProperty<!><!> = object : MyClass(), MyTrait {}\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>internal val <!EXPOSED_PROPERTY_TYPE!>internal2Property<!><!> = object : MyClass(), MyTrait {}\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>public val <!EXPOSED_PROPERTY_TYPE!>publicProperty<!><!> = object : MyClass(), MyTrait {}\n\n\n        private fun privateFunctionInner() = object : MyClass(), MyTrait {}\n\n        init {\n            privateFunctionInner().f1()\n            privateFunctionInner().f2()\n        }\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>protected fun <!EXPOSED_FUNCTION_RETURN_TYPE!>protectedFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>fun <!EXPOSED_FUNCTION_RETURN_TYPE!>internalFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>internal fun <!EXPOSED_FUNCTION_RETURN_TYPE!>internal2Function<!>()<!> = object : MyClass(), MyTrait {}\n\n        <!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>public fun <!EXPOSED_FUNCTION_RETURN_TYPE!>publicFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n    }\n\n    fun foo() {\n        val localVar = object : MyClass(), MyTrait {}\n        localVar.f1()\n        localVar.f2()\n\n        fun foo2() = object : MyClass(), MyTrait {}\n        foo2().f1()\n        foo2().f2()\n    }\n\n}\n\nprivate val packagePrivateProperty = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!><!WRONG_MODIFIER_TARGET!>protected<!> val <!EXPOSED_PROPERTY_TYPE!>packageProtectedProperty<!><!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>val <!EXPOSED_PROPERTY_TYPE!>packageInternalProperty<!><!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>internal val <!EXPOSED_PROPERTY_TYPE!>packageInternal2Property<!><!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>public val <!EXPOSED_PROPERTY_TYPE!>packagePublicProperty<!><!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!><!WRONG_MODIFIER_TARGET!>protected<!> fun <!EXPOSED_FUNCTION_RETURN_TYPE!>packageProtectedFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>fun <!EXPOSED_FUNCTION_RETURN_TYPE!>packageInternalFunction<!>()<!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>internal fun <!EXPOSED_FUNCTION_RETURN_TYPE!>packageInternal2Function<!>()<!> = object : MyClass(), MyTrait {}\n\n<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>public fun <!EXPOSED_FUNCTION_RETURN_TYPE!>packagePublicFunction<!>()<!> = object : MyClass(), MyTrait {}\n\nfun fooPackage() {\n    val packageLocalVar = object : MyClass(), MyTrait {}\n    packageLocalVar.f1()\n    packageLocalVar.f2()\n\n    fun fooPackageLocal() = object : MyClass(), MyTrait {}\n    fooPackageLocal().f1()\n    fooPackageLocal().f2()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n// !CHECK_TYPE\nfun foo(block: () -> (() -> Int)) {}\n\nfun test() {\n    val x = fun <!ANONYMOUS_FUNCTION_WITH_NAME!>named1<!>(x: Int): Int { return 1 }\n    x checkType { _<Function1<Int, Int>>() }\n\n    foo { <!EXPECTED_TYPE_MISMATCH(\"() -> Int\")!>fun named2(): Int {return 1}<!> }\n    foo({ <!EXPECTED_TYPE_MISMATCH!>fun named3() = 1<!> })\n\n    val x1 =\n    <!INVALID_IF_AS_EXPRESSION!>if<!> (1 == 1)\n    // TODO: Diagnostic content could be better\n    <!SYNTAX!><!>fun named4(): Int {return 1}\n    <!SYNTAX!>else<!>\n    fun named5() = 1\n\n    val x2 =\n    <!INVALID_IF_AS_EXPRESSION!>if<!> (1 == 1) {\n        fun named6(): Int {\n            return 1\n        }\n    }\n    else\n    <!SYNTAX!><!>fun named7() = 1\n\n    val x3 = when (1) {\n        0 -> <!OI;EXPECTED_TYPE_MISMATCH!>fun <!NI;ANONYMOUS_FUNCTION_WITH_NAME!>named8<!>(): Int {return 1}<!>\n        else -> <!OI;EXPECTED_TYPE_MISMATCH!>fun <!NI;ANONYMOUS_FUNCTION_WITH_NAME!>named9<!>() = 1<!>\n    }\n\n    val x31 = when (1) {\n        0 -> {\n            <!OI;EXPECTED_TYPE_MISMATCH!>fun named10(): Int {return 1}<!>\n        }\n        else -> <!OI;EXPECTED_TYPE_MISMATCH!>fun <!NI;ANONYMOUS_FUNCTION_WITH_NAME!>named11<!>() = 1<!>\n    }\n\n    val x4 = {\n        y: Int -> fun named12(): Int {return 1}\n    }\n\n    x4 checkType { _<Function1<Int, Unit>>() }\n\n    <!UNUSED_LAMBDA_EXPRESSION!>{ y: Int -> fun named14(): Int {return 1} }<!>\n    val b = (fun <!ANONYMOUS_FUNCTION_WITH_NAME!>named15<!>(): Boolean { return true })()\n\n    baz(fun <!ANONYMOUS_FUNCTION_WITH_NAME!>named16<!>(){})\n}\n\nfun bar() = fun <!ANONYMOUS_FUNCTION_WITH_NAME!>named<!>() {}\n\nfun <T> run(block: () -> T): T = null!!\nfun run2(block: () -> Unit): Unit = null!!\nfun baz(obj: Any?) {}\n\nfun success() {\n    run { fun named1() = 1 }\n    run2 { fun named2() = 1 }\n\n    val x = run { fun named3() = 1 }\n    x checkType { _<Unit>() }\n\n    val y = when (1) {\n        0 -> {\n            <!OI;EXPECTED_TYPE_MISMATCH!>fun named4(): Int {return 1}<!>\n        }\n        else -> {\n            <!OI;EXPECTED_TYPE_MISMATCH!>fun named5(): Int {return 1}<!>\n        }\n    }\n    y checkType { <!OI;TYPE_MISMATCH!>_<!><Unit>() }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -MANY_COMPANION_OBJECTS -REDECLARATION -DUPLICATE_CLASS_NAMES\n\n// KT-3464 Front-end shouldn't allow override modifier in class declaration\n\n<!WRONG_MODIFIER_TARGET!>override<!> class A {\n    <!WRONG_MODIFIER_TARGET!>override<!> companion object {}\n    <!WRONG_MODIFIER_TARGET!>open<!> companion object {}\n    <!WRONG_MODIFIER_TARGET!>abstract<!> companion object {}\n    final companion object {}\n}\n\n<!WRONG_MODIFIER_TARGET!>override<!> object B1 {}\n<!WRONG_MODIFIER_TARGET!>open<!> object B2 {}\n<!WRONG_MODIFIER_TARGET!>abstract<!> object B3 {}\nfinal object B4 {}\n\n<!WRONG_MODIFIER_TARGET!>override<!> enum class C {}\n<!WRONG_MODIFIER_TARGET!>override<!> interface D {}\n<!WRONG_MODIFIER_TARGET!>override<!> annotation class E"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n// !CHECK_TYPE\nfun foo(block: () -> (() -> Int)) {}\n\nfun test() {\n    foo { fun(): Int {return 1} }\n    foo({ fun() = 1 })\n\n    val x1 =\n        if (1 == 1)\n            fun(): Int {return 1}\n        else\n            fun() = 1\n\n    val x2 =\n            if (1 == 1) {\n                fun(): Int {\n                    return 1\n                }\n            }\n            else\n                fun() = 1\n\n    val x3 = when (1) {\n        0 -> fun(): Int {return 1}\n        else -> fun() = 1\n    }\n\n    val x31 = when (1) {\n        0 -> {\n            fun(): Int {return 1}\n        }\n        else -> fun() = 1\n    }\n\n    val x4 = {\n        y: Int -> fun(): Int {return 1}\n    }\n\n    x4 checkType { _<Function1<Int, Function0<Int>>>() }\n\n    <!UNUSED_LAMBDA_EXPRESSION!>{ y: Int -> fun(): Int {return 1} }<!>\n}\n"
        },
        {
            "code": "open class MyClass {\n    fun f1() {}\n}\n\n\nclass Foo {\n\n    protected val protectedProperty = object : MyClass() {}\n\n    public val publicProperty = object : MyClass() {}\n\n    protected val protected2Property : MyClass = object : MyClass() {fun invisible() {}}\n\n    public val public2Property : MyClass = object : MyClass() {fun invisible() {}}\n\n    private val privateProperty = object : MyClass() {fun visible() {}}\n\n    internal val internalProperty = object : MyClass() { fun invisible() {}}\n\n\n    fun testProperties() {\n        privateProperty.f1()\n        internalProperty.f1()\n        protected2Property.f1()\n        public2Property.f1()\n\n        privateProperty.visible()\n        protected2Property.<!UNRESOLVED_REFERENCE!>invisible<!>()\n        public2Property.<!UNRESOLVED_REFERENCE!>invisible<!>()\n        internalProperty.<!UNRESOLVED_REFERENCE!>invisible<!>()\n    }\n\n\n    protected fun protectedFunction() = object : MyClass() {}\n\n    public fun publicFunction() = object : MyClass() {}\n\n    protected fun protected2Function(): MyClass = object : MyClass() {fun visible() {}}\n\n    public fun public2Function(): MyClass = object : MyClass() {fun visible() {}}\n\n    private fun privateFunction() = object : MyClass() {fun visible() {}}\n\n    internal fun internalFunction() = object : MyClass() {fun invisible() {}}\n\n\n    fun testFunctions() {\n        privateFunction().f1()\n        internalFunction().f1()\n        public2Function().f1()\n        protected2Function().f1()\n\n        privateFunction().visible()\n        internalFunction().<!UNRESOLVED_REFERENCE!>invisible<!>()\n        public2Function().<!UNRESOLVED_REFERENCE!>invisible<!>()\n        protected2Function().<!UNRESOLVED_REFERENCE!>invisible<!>()\n    }\n\n\n    class FooInner {\n\n        public val publicProperty = object : MyClass() {}\n\n        protected val protectedProperty = object : MyClass() {}\n\n        protected val protected2Property : MyClass = object : MyClass() {fun invisible() {}}\n\n        public val public2Property : MyClass = object : MyClass() {fun invisible() {}}\n\n        private val privateProperty = object : MyClass() {fun visible() {}}\n\n        internal val internalProperty = object : MyClass() { fun invisible() {}}\n\n\n        fun testProperties() {\n            privateProperty.f1()\n            internalProperty.f1()\n            protected2Property.f1()\n            public2Property.f1()\n\n            privateProperty.visible()\n            protected2Property.<!UNRESOLVED_REFERENCE!>invisible<!>()\n            public2Property.<!UNRESOLVED_REFERENCE!>invisible<!>()\n            internalProperty.<!UNRESOLVED_REFERENCE!>invisible<!>()\n        }\n\n\n        protected fun protectedFunction() = object : MyClass() {}\n\n        public fun publicFunction() = object : MyClass() {}\n\n        protected fun protected2Function(): MyClass = object : MyClass() {fun visible() {}}\n\n        public fun public2Function(): MyClass = object : MyClass() {fun visible() {}}\n\n        private fun privateFunction() = object : MyClass() {fun visible() {}}\n\n        internal fun internalFunction() = object : MyClass() {fun invisible() {}}\n\n\n        fun testFunctions() {\n            privateFunction().f1()\n            internalFunction().f1()\n            public2Function().f1()\n            protected2Function().f1()\n\n            privateFunction().visible()\n            internalFunction().<!UNRESOLVED_REFERENCE!>invisible<!>()\n            public2Function().<!UNRESOLVED_REFERENCE!>invisible<!>()\n            protected2Function().<!UNRESOLVED_REFERENCE!>invisible<!>()\n        }\n    }\n\n    fun foo() {\n        val localVar = object : MyClass() {}\n        localVar.f1()\n        fun foo2() = object : MyClass() {}\n        foo2().f1()\n    }\n\n}\n\n<!WRONG_MODIFIER_TARGET!>protected<!> val packageProtectedProperty = object : MyClass() {}\n\npublic val packagePublicProperty = object : MyClass() {}\n\npublic val packagePublic2Property : MyClass = object : MyClass() {fun invisible() {}}\n\nprivate val packagePrivateProperty = object : MyClass() {fun invisible() {}}\n\ninternal val packageInternalProperty = object : MyClass() {fun invisible() {}}\n\n\nfun testProperties() {\n    packagePrivateProperty.f1()\n    packageInternalProperty.f1()\n    packagePublic2Property.f1()\n\n    packagePrivateProperty.invisible()\n    packageInternalProperty.<!UNRESOLVED_REFERENCE!>invisible<!>()\n    packagePublic2Property.<!UNRESOLVED_REFERENCE!>invisible<!>()\n}\n\n\nprivate fun privateFunction() = object : MyClass() {fun invisible() {}}\n\n<!WRONG_MODIFIER_TARGET!>protected<!> fun protectedFunction() = object : MyClass() {}\n\npublic fun publicFunction() = object : MyClass() {}\n\npublic fun public2Function() : MyClass = object : MyClass() {fun invisible() {}}\n\ninternal fun internalFunction() = object : MyClass() {fun invisible() {}}\n\n\n\nfun testFunctions() {\n    privateFunction().f1()\n    internalFunction().f1()\n    public2Function().f1()\n\n    privateFunction().invisible()\n    internalFunction().<!UNRESOLVED_REFERENCE!>invisible<!>()\n    public2Function().<!UNRESOLVED_REFERENCE!>invisible<!>()\n}\n\nfun fooPackage() {\n    val packageLocalVar = object : MyClass() {fun visible() {}}\n    packageLocalVar.f1()\n    packageLocalVar.visible()\n\n    fun fooPackageLocal() = object : MyClass() {fun visible() {}}\n    fooPackageLocal().f1()\n    fooPackageLocal().visible()\n}"
        },
        {
            "code": "package d\n\nclass T {\n    fun baz() = 1\n}\n\nfun foo() {\n    <!WRONG_MODIFIER_TARGET!>public<!> val <!UNUSED_VARIABLE!>i<!> = 11\n    <!WRONG_MODIFIER_TARGET!>abstract<!> val <!UNUSED_VARIABLE, VARIABLE_WITH_NO_TYPE_NO_INITIALIZER!>j<!>\n    <!WRONG_MODIFIER_TARGET!>override<!> fun T.<!EXTENSION_SHADOWED_BY_MEMBER!>baz<!>() = 2\n    <!WRONG_MODIFIER_TARGET!>private<!> fun bar() = 2\n}"
        },
        {
            "code": "fun <<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>in<!> T> f() {\n    \n}\n\nfun <<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>out<!> T> g() {\n\n}\n\nfun <<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>out<!> T, <!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>in<!> X, Y> h() {\n\n}\n\nval <<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>out<!> T> T.x: Int\n    get() = 1\n\nval <<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>in<!> T> T.y: Int\n    get() = 1"
        },
        {
            "code": "class A {\n    operator fun component1() : Int = 1\n    operator fun component2() : Int = 2\n}\n\nfun a(aa : A?, b : Any) {\n    if (aa != null) {\n        val (<!UNUSED_VARIABLE!>a1<!>, <!UNUSED_VARIABLE!>b1<!>) = <!DEBUG_INFO_SMARTCAST!>aa<!>;\n    }\n\n    if (b is A) {\n        val (<!UNUSED_VARIABLE!>a1<!>, <!UNUSED_VARIABLE!>b1<!>) = <!DEBUG_INFO_SMARTCAST!>b<!>;\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UPPER_BOUND_VIOLATED\n\n//// FILE: 1.kt\n<!EXPANSIVE_INHERITANCE_IN_JAVA!>interface P1<YY1, YY2> : P<YY1, YY2><!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UPPER_BOUND_VIOLATED\n\n//// FILE: 1.kt\ninterface P<Y1, <!EXPANSIVE_INHERITANCE!>Y2<!>> : Q<C<Y1>, C<D<Y2>>>\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UPPER_BOUND_VIOLATED\n\ninterface A<T>\ninterface B<T> : A<A<*>>\n\ninterface N0<in T>\ninterface C0<<!EXPANSIVE_INHERITANCE!>X<!>> : N0<N0<C0<C0<X>>>>\n\ninterface N1<in T>\ninterface C1<<!EXPANSIVE_INHERITANCE!>X<!>> : N1<N1<C1<C1<X?>>>>\ninterface C2<T> : C1<C1<T>>\n\ninterface C<<!EXPANSIVE_INHERITANCE!>X<!>> : D<P<X, X>>\ninterface P<Y1, <!EXPANSIVE_INHERITANCE!>Y2<!>> : Q<C<Y1>, C<D<Y2>>>\ninterface Q<Z1, Z2>\ninterface D<W>\n\ninterface E0<T>\ninterface E1<T : E2>\ninterface E2 : E0<E1<out E2>>\n\ninterface F0<T>\ninterface F1<T : F2<*>, U : F2<*>>\ninterface F2<T> : F0<F1<out F2<*>, T>>\n\ninterface G0<T>\ninterface G1<T : U, U : G2<*>>\ninterface G2<T> : G0<G1<out G2<*>, T>>"
        },
        {
            "code": "package d\n\n<!WRONG_MODIFIER_TARGET!>override<!> val f : ()-> Int = { 12 }\n\nfun test() {\n    f()\n}\n\nvar g: Int = 1\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> set(<!UNUSED_PARAMETER!>i<!>: Int) {}"
        },
        {
            "code": "// KT-2667 Support multi-declarations in for-loops in control flow analysis\npackage d\n\nclass A {\n    operator fun component1() = 1\n    operator fun component2() = 2\n    operator fun component3() = 3\n}\n\nfun foo(list: List<A>) {\n    for (<!VAL_OR_VAR_ON_LOOP_PARAMETER!>var<!> (<!UNUSED_VARIABLE!>c1<!>, <!UNUSED_VARIABLE!>c2<!>, c3) in list) {\n        <!UNUSED_VALUE!><!VAL_REASSIGNMENT!>c1<!> =<!> 1\n        c3 + 1\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !LANGUAGE: -ProhibitTypeParametersForLocalVariables\n\nimport kotlin.reflect.KProperty\n\nfun test() {\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T><!> a0 = 0\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T : <!DEBUG_INFO_MISSING_UNRESOLVED!>__UNRESOLVED__<!>><!> a1 = \"\"\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T : <!DEBUG_INFO_MISSING_UNRESOLVED!>String<!>><!> a2 = 0\n    <!WRONG_MODIFIER_TARGET!>const<!> val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T><!> a3 = 0\n    <!INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T><!> a4 = 0\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T><!> a5 by Delegate<Int>()\n    val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><T><!> a6 by Delegate<<!UNRESOLVED_REFERENCE!>T<!>>()\n}\n\nclass Delegate<F> {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String = \"\"\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {}\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-2631 Check multiple assignment\npackage a\n\nclass MyClass {\n    operator fun component1() = 1\n    operator fun component2() = \"a\"\n}\n\nclass MyClass2 {}\n\noperator fun MyClass2.component1() = 1.2\n\nfun test(mc1: MyClass, mc2: MyClass2) {\n    val (a, b) = mc1\n    checkSubtype<Int>(a)\n    checkSubtype<String>(b)\n\n    val (c) = mc2\n    checkSubtype<Double>(c)\n\n    //check no error types\n    checkSubtype<Boolean>(<!TYPE_MISMATCH!>a<!>)\n    checkSubtype<Boolean>(<!TYPE_MISMATCH!>b<!>)\n    checkSubtype<Boolean>(<!TYPE_MISMATCH!>c<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED\nfun test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {\n    fun test2(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {\n        class LocalClass(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {\n        constructor(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int, xx: Int) {}\n    }\n        fun test3(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n    }\n}\n\nfun Any.test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x3: Int) {}\n\ninterface I {\n    fun test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int)\n}\n\nabstract class C(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int, b: Boolean) {\n    fun test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n\n    abstract fun test2(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int)\n\n    class CC(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int, b: Boolean) {\n        constructor(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n        fun test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n    }\n}\n\nobject O {\n    fun test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n\n    class CC(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int, b: Boolean) {\n        constructor(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n        fun test(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x1: Int, <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> x2: Int) {}\n    }\n}\n"
        },
        {
            "code": "interface A {\n    <!WRONG_MODIFIER_TARGET!>sealed<!> fun foo()\n    <!WRONG_MODIFIER_TARGET!>sealed<!> var bar: Unit\n}\n\ninterface B {\n    abstract fun foo()\n    abstract var bar: Unit\n}\n\ninterface C : A, B\n\nabstract class D(<!WRONG_MODIFIER_TARGET!>sealed<!> var x: Int) {\n    abstract var y: Unit\n        <!WRONG_MODIFIER_TARGET!>sealed<!> set\n}\n\nabstract class E : D(42)\n"
        },
        {
            "code": "fun test() {\n    val <!UNUSED_VARIABLE, VARIABLE_WITH_NO_TYPE_NO_INITIALIZER!>a<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// KT-5068 Add special error for scala-like syntax 'fun foo(): Int = { 1 }'\n\nfun test1(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\nfun test2(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\nval test3: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\nval test4: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\nfun test5(): Int { return <!TYPE_MISMATCH!>{ 1 }<!> }\nfun test6(): Int = <!TYPE_MISMATCH!>fun (): Int = 1<!>\n\nfun outer() {\n    fun test1(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\n    fun test2(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\n    val test3: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\n    val test4: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\n    fun test5(): Int { return <!TYPE_MISMATCH!>{ 1 }<!> }\n    fun test6(): Int = <!TYPE_MISMATCH!>fun (): Int = 1<!>\n}\n\nclass Outer {\n    fun test1(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\n    fun test2(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\n    val test3: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\n    val test4: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\n    fun test5(): Int { return <!TYPE_MISMATCH!>{ 1 }<!> }\n    fun test6(): Int = <!TYPE_MISMATCH!>fun (): Int = 1<!>\n\n    class Nested {\n        fun test1(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\n        fun test2(): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\n        val test3: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ <!RETURN_NOT_ALLOWED!>return<!> 1 }<!>\n        val test4: () -> Int = fun (): Int = <!TYPE_MISMATCH_DUE_TO_EQUALS_LAMBDA_IN_FUN!>{ 1 }<!>\n        fun test5(): Int { return <!TYPE_MISMATCH!>{ 1 }<!> }\n        fun test6(): Int = <!TYPE_MISMATCH!>fun (): Int = 1<!>\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A {\n    operator fun component1() : Int = 1\n    operator fun component2() : Int = 2\n}\n\nfun a(aa : A) {\n    val (<!UNUSED_VARIABLE!>a<!>: String, <!UNUSED_VARIABLE!>b1<!>: String) = <!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH, COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>aa<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n//KT-1193 Check enum entry supertype / initialization\n\npackage kt1193\n\nenum class MyEnum(val i: Int) {\n    A(12),\n    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>B<!>  //no error\n}\n\nopen class A(x: Int = 1)\n\nval x: MyEnum = MyEnum.A"
        },
        {
            "code": "//KT-2096 Abstract property with no type specified causes compiler to crash\n\npackage c\n\nabstract class Foo{\n    <!PROPERTY_WITH_NO_TYPE_NO_INITIALIZER!>protected abstract val prop<!>\n}"
        },
        {
            "code": "//KT-2643 Support multi-declarations in Data-Flow analysis\npackage n\n\nclass C {\n    operator fun component1() = 1\n    operator fun component2() = 2\n}\n\nfun test1(c: C) {\n    val (<!UNUSED_VARIABLE!>a<!>, <!UNUSED_VARIABLE!>b<!>) = c\n}\n\nfun test2(c: C) {\n    val (a, <!UNUSED_VARIABLE!>b<!>) = c\n    a + 3\n}\n\nfun test3(c: C) {\n    var (<!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>a<!>, <!UNUSED_VARIABLE!>b<!>) = c\n    <!UNUSED_VALUE!>a =<!> 3\n}\n\nfun test4(c: C) {\n    var (<!VARIABLE_WITH_REDUNDANT_INITIALIZER!>a<!>, <!UNUSED_VARIABLE!>b<!>) = c\n    a = 3\n    a + 1\n}\n"
        },
        {
            "code": "//KT-559 Forbid abstract method call through super\n\npackage kt559\n\nabstract class A {\n    abstract val i : Int\n\n    abstract fun foo() : Int\n\n    fun fff() {}\n}\n\nabstract class D(): A() {\n    override val i : Int = 34\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class C<!>() : D() {\n    fun test() {\n        super.i\n    }\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class B<!>() : A() {\n    override fun foo(): Int {\n        super.<!ABSTRACT_SUPER_CALL!>i<!>\n\n        super.fff() //everything is ok\n        return super.<!ABSTRACT_SUPER_CALL!>foo<!>()  //no error!!\n    }\n}"
        },
        {
            "code": "package d\n\n<!WRONG_MODIFIER_TARGET!>abstract<!> val a : Int = 1\n\n<!WRONG_MODIFIER_TARGET!>override<!> val c : Int = 1\n\n<!WRONG_MODIFIER_TARGET!>final<!> fun foo() = 2\n\n<!WRONG_MODIFIER_TARGET!>abstract<!> fun baz() = 2\n\nclass T {}\n<!WRONG_MODIFIER_TARGET!>override<!> fun T.bar() = 2"
        },
        {
            "code": "package d\n\nclass T {\n    fun baz() = 1\n}\n\n<!WRONG_MODIFIER_TARGET!>override<!> fun zzz() {}\n\nfun foo(t: T) {\n    <!WRONG_MODIFIER_TARGET!>override<!> fun T.<!EXTENSION_SHADOWED_BY_MEMBER!>baz<!>() = 2\n\n    // was \"Visibility is unknown yet exception\"\n    t.baz()\n\n    zzz()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -TYPE_PARAMETER_AS_REIFIED -TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER -UNUSED_VARIABLE -UNUSED_PARAMETER\n\nfun <T> <!KCLASS_WITH_NULLABLE_TYPE_PARAMETER_IN_SIGNATURE!>test1<!>() = T::class\nfun <T : Any> test2() = T::class\n\nval <T> <!KCLASS_WITH_NULLABLE_TYPE_PARAMETER_IN_SIGNATURE!>test3<!> = T::class\nval <T> <!KCLASS_WITH_NULLABLE_TYPE_PARAMETER_IN_SIGNATURE!>test4<!> get() = T::class\n\nfun <T> <!KCLASS_WITH_NULLABLE_TYPE_PARAMETER_IN_SIGNATURE!>test5<!>() = listOf(T::class)\n\nfun <T> test6(): kotlin.reflect.KClass<<!UPPER_BOUND_VIOLATED!>T<!>> = T::class\nfun <T> test7(): kotlin.reflect.KClass<*> = T::class\nfun test8() = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>String?::class<!>\n\nfun <T> listOf(e: T): List<T> = null!!\n\nfun <L> locals() {\n    fun <T> test1() = T::class\n    fun <T : Any> test2() = T::class\n\n    val test3 = L::class\n    fun test4() = L::class\n}\n"
        },
        {
            "code": "class A {\n    operator fun component1() : Int = 1\n    operator fun component2() : Int = 2\n}\n\nfun a() {\n    val (<!REDECLARATION, UNUSED_VARIABLE!>a<!>, <!NAME_SHADOWING, REDECLARATION, UNUSED_VARIABLE!>a<!>) = A()\n    val (<!UNUSED_VARIABLE!>x<!>, <!REDECLARATION, UNUSED_VARIABLE!>y<!>) = A();\n    val <!REDECLARATION!>b<!> = 1\n    use(b)\n    val (<!NAME_SHADOWING, REDECLARATION, UNUSED_VARIABLE!>b<!>, <!NAME_SHADOWING, REDECLARATION, UNUSED_VARIABLE!>y<!>) = A();\n}\n\n\nfun use(a: Any): Any = a\n"
        },
        {
            "code": "class In<in T>\nclass Out<out T>\nclass Inv<T>\nclass X\n\nfun f1(<!UNUSED_PARAMETER!>p<!>: In<<!REDUNDANT_PROJECTION!>in<!> X>) {}\nfun f2(<!UNUSED_PARAMETER!>p<!>: In<<!CONFLICTING_PROJECTION!>out<!> X>) {}\nfun f3(<!UNUSED_PARAMETER!>p<!>: In<X>) {}\n\nfun f4(<!UNUSED_PARAMETER!>p<!>: Out<<!REDUNDANT_PROJECTION!>out<!> X>) {}\nfun f5(<!UNUSED_PARAMETER!>p<!>: Out<<!CONFLICTING_PROJECTION!>in<!> X>) {}\nfun f6(<!UNUSED_PARAMETER!>p<!>: Out<X>) {}\n\nfun f6(<!UNUSED_PARAMETER!>p<!>: Inv<X>) {}\nfun f7(<!UNUSED_PARAMETER!>p<!>: Inv<in X>) {}\nfun f8(<!UNUSED_PARAMETER!>p<!>: Inv<out X>) {}\n\nfun f9(<!UNUSED_PARAMETER!>p<!>: In<*>) {}\nfun f10(<!UNUSED_PARAMETER!>p<!>: Out<*>) {}\nfun f11(<!UNUSED_PARAMETER!>p<!>: Inv<*>) {}\n"
        },
        {
            "code": "// FILE: File1.kt\npackage pack1\n\npublic class SomeClass {\n    private class N\n    public open class PublicNested\n}\n\n// FILE: File2.kt\npackage pack2\n\npublic open class N\n\n// FILE: Main.kt\npackage a\n\nimport pack1.SomeClass.*\nimport pack2.*\n\nclass X : N()\nclass Y : PublicNested()\n"
        },
        {
            "code": "//FILE:mainFile.kt\n//----------------------------------------------------------------------------------\npackage test\n\nimport testing.other.*\nimport testing.TestFun\n\n// Resolve shouldn't be ambiguous\nval a = TestFun()\n\n\n//FILE:testing.kt\n//----------------------------------------------------------------------------------\npackage testing\n\nclass TestFun\n\n//FILE:testingOther.kt\n//----------------------------------------------------------------------------------\npackage testing.other\n\nfun TestFun() = 12\n"
        },
        {
            "code": "// FILE: File1.kt\npackage pack1\n\nprivate class SomeClass\n\n// FILE: File2.kt\npackage pack2\n\npublic open class SomeClass\n\n// FILE: Main.kt\npackage a\n\nimport pack1.*\nimport pack2.*\n\nclass X : SomeClass()\n"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nclass X\n\n// FILE: b.kt\npackage b\n\nclass X\n\n// FILE: c.kt\npackage c\n\nimport a.<!CONFLICTING_IMPORT!>X<!>\nimport b.<!CONFLICTING_IMPORT!>X<!>\n\nclass Y : <!UNRESOLVED_REFERENCE!>X<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// FILE: 1.kt\npackage k\n\nprivate fun zero() {}\nprivate fun zero(a: Int) {}\nprivate fun zero(a: String) {}\n\nfun one() {}\nprivate fun one(a: Int) {}\nprivate fun one(a: String) {}\n\nfun two() {}\nfun two(a: Int) {}\nprivate fun two(a: String) {}\n\nfun all() {}\nfun all(a: Int) {}\nfun all(a: String) {}\n\n// FILE: 2.kt\n\nimport k.<!DEBUG_INFO_MISSING_UNRESOLVED, INVISIBLE_REFERENCE!>zero<!>\nimport k.one\nimport k.two\nimport k.all\n\nfun test() {\n    <!INVISIBLE_MEMBER!>zero<!>()\n    <!INVISIBLE_MEMBER!>zero<!>(1)\n    <!INVISIBLE_MEMBER!>zero<!>(\"\")\n\n    one()\n    one(<!TOO_MANY_ARGUMENTS!>1<!>)\n    one(<!TOO_MANY_ARGUMENTS!>\"\"<!>)\n\n    two()\n    two(1)\n    two(<!TYPE_MISMATCH!>\"\"<!>)\n\n    all()\n    all(1)\n    all(\"\")\n}"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nvar X: Int = 1\n\n// FILE: b.kt\npackage b\n\nvar X: String = \"\"\n\n// FILE: c.kt\npackage c\n\nimport a.X\nimport b.*\n\nfun foo() {\n    X = 1\n}\n"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nval x = 1\nval y = 1\n\n// FILE: b.kt\npackage b\n\nval x = \"\"\n\n// FILE: c.kt\npackage c\n\nimport a.x as AX\nimport a.*\nimport b.*\nimport a.y as AY\n\nval v1: Int = AX\nval v2: String = x\nval v3 = <!UNRESOLVED_REFERENCE!>y<!>\n"
        },
        {
            "code": "// FILE:a.kt\npackage a.b\n\n// FILE:a.kt\npackage a\n\nval foo = object {\n    fun bar() {}\n}\n\nfun bar() = object {\n    val foo = 239\n}\n\nclass B {\n    val foo = object {\n        fun bar() {}\n    }\n\n    fun bar() = object {\n        val foo = 239\n    }\n}\n\nobject C {\n    val foo = object {\n        fun bar() {}\n    }\n\n    fun bar() = object {\n        val foo = 239\n    }\n\n    class Nested\n}\n\nclass D {\n    companion object {\n        val foo = object {\n            fun bar() {}\n        }\n\n        fun bar() = object {\n            val foo = 239\n        }\n    }\n}\n\n\n// FILE:b.kt\nimport <!PACKAGE_CANNOT_BE_IMPORTED!>a<!>\nimport a.<!PACKAGE_CANNOT_BE_IMPORTED!>b<!>\n\nimport a.foo\nimport a.<!UNRESOLVED_REFERENCE!>foo<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\nimport a.bar\nimport a.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\nimport a.B.<!CANNOT_BE_IMPORTED!>foo<!>\nimport a.B.<!UNRESOLVED_REFERENCE!>foo<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\nimport a.B.<!CANNOT_BE_IMPORTED!>bar<!>\nimport a.B.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\nimport a.C.foo\nimport a.C.<!UNRESOLVED_REFERENCE!>foo<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\nimport a.C.bar\nimport a.C.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\nimport a.C.Nested\n\nimport a.D.<!UNRESOLVED_REFERENCE!>foo<!>\nimport a.D.<!UNRESOLVED_REFERENCE!>foo<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\nimport a.D.<!UNRESOLVED_REFERENCE!>bar<!>\nimport a.D.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\nimport a.D.Companion.foo\nimport a.D.Companion.<!UNRESOLVED_REFERENCE!>foo<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\nimport a.D.Companion.bar\nimport a.D.Companion.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>"
        },
        {
            "code": "// FILE: propertyClassFileDependencyRecursion.kt\npackage test\n\nimport other.prop\n\n// Note: \"prop\" is expected to be unresolved and replaced to Any\nclass PropType: <!UNRESOLVED_REFERENCE!>prop<!>\n\n// Note: this time \"prop\" should be resolved and type should be inferred for \"checkTypeProp\"\nval checkTypeProp = prop\n\n// FILE: propertyClassFileDependencyRecursionOther.kt\npackage other\n\nimport test.PropType\n\nval prop: PropType? = null\n"
        },
        {
            "code": "import java.lang.reflect.*\nimport <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.List<!>\n\nfun foo(\n        <!UNUSED_PARAMETER!>p1<!>: Array<String> /* should be resolved to kotlin.Array */,\n        <!UNUSED_PARAMETER!>p2<!>: <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>List<String><!> /* should be resolved to java.util.List */) { }"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nclass X\n\n// FILE: b.kt\npackage b\n\nclass X\n\n// FILE: c.kt\npackage c\n\nimport a.*\nimport b.*\n\nclass Y : <!UNRESOLVED_REFERENCE!>X<!>"
        },
        {
            "code": "// FILE: b.kt\n// KT-355 Resolve imports after all symbols are built\n\npackage a\n  import b.*\n  val x : X = X()\n\n// FILE: b.kt\npackage b\n  class X() {\n\n  }\n\n// FILE: b.kt\npackage c\n  import d.X\n  val x : X = X()\n\n// FILE: b.kt\npackage d\n  class X() {\n\n  }\n"
        },
        {
            "code": "// FILE:a.kt\npackage a\n\nval foo = 2\nfun bar() {}\n\nclass B {\n    val foo = 2\n    fun bar() {}\n\n    class C\n}\n\n// FILE:b.kt\npackage a.b.c\n\nclass D {\n    class E {\n\n    }\n}\n\n\n// FILE:c.kt\nimport<!SYNTAX!><!> ;\nimport <!SYNTAX!>.<!>\nimport a.<!SYNTAX!><!> ;\nimport <!SYNTAX!>.a.<!> ;\nimport <!SYNTAX!>.a.b<!> ;\nimport <!SYNTAX!>.a.B<!> ;\nimport a.B.<!SYNTAX!><!> ;\nimport a.B.C.<!SYNTAX!><!> ;\nimport a.B.<!UNRESOLVED_REFERENCE!>foo<!>.<!SYNTAX!><!> ;\nimport a.B.<!UNRESOLVED_REFERENCE!>bar<!>.<!SYNTAX!><!> ;\nimport a.b.<!SYNTAX!><!> ;\nimport a.b.c.<!SYNTAX!><!> ;\nimport a.<!SYNTAX!>%<!>.b.c.<!SYNTAX!><!> ;\nimport a.b.c.D.<!SYNTAX!><!> ;\nimport a.b.c.D.E.<!SYNTAX!><!> ;\n\n// FILE:d.kt\nimport<!SYNTAX!><!>\nimport <!SYNTAX!>.<!>\nimport <!PACKAGE_CANNOT_BE_IMPORTED!>a<!>.<!SYNTAX!><!>\nimport <!SYNTAX!>.a.<!>\nimport <!SYNTAX!>.a.b<!>\nimport <!SYNTAX!>.a.B<!>\nimport a.B.<!SYNTAX!><!> as<!SYNTAX!><!>\nimport a.B.<!SYNTAX!><!> as A\nimport a.B.<!SYNTAX!><!>\nimport a.B.C.<!SYNTAX!><!>\nimport a.B.<!CANNOT_BE_IMPORTED!>foo<!>.<!SYNTAX!><!>\nimport a.B.<!CANNOT_BE_IMPORTED!>bar<!>.<!SYNTAX!><!>\nimport a.<!PACKAGE_CANNOT_BE_IMPORTED!>b<!>.<!SYNTAX!><!>\nimport a.b.<!PACKAGE_CANNOT_BE_IMPORTED!>c<!>.<!SYNTAX!><!>\nimport a.<!SYNTAX!>%<!>.b.<!PACKAGE_CANNOT_BE_IMPORTED!>c<!>.<!SYNTAX!><!>\nimport a.b.c.D.<!SYNTAX!><!>\nimport a.b.c.D.E.<!SYNTAX!><!>\n\nimport <!PACKAGE_CANNOT_BE_IMPORTED!>a<!><!SYNTAX!>?.<!><!SYNTAX!>b<!>"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nfun X(<!UNUSED_PARAMETER!>p<!>: Int) {}\n\n// FILE: b.kt\npackage b\n\nfun X(): Int = 1\n\n// FILE: c.kt\npackage c\n\nimport b.*\nimport a.X\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>v<!>: Int = X()\n}\n"
        },
        {
            "code": "// FILE: j/JavaPackageLocal.java\npackage j;\n\npublic class JavaPackageLocal {\n    static void javaMPackage() {}\n    static int javaPPackage = 4;\n}\n\n// FILE: j/JavaProtected.java\npackage j;\n\npublic class JavaProtected {\n    protected static void javaMProtectedStatic() {}\n    protected static int javaPProtectedStatic = 4;\n    protected final int javaPProtectedPackage = 4;\n}\n\n// FILE: k.kt\npackage k\n\nimport j.JavaProtected\nimport j.JavaPackageLocal\n\nclass A {\n    val p1 = JavaPackageLocal.<!INVISIBLE_MEMBER(\"javaPPackage\", \"package-private\", \"'JavaPackageLocal'\")!>javaPPackage<!>\n    val p2 = JavaProtected.<!INVISIBLE_MEMBER(\"javaPProtectedStatic\", \"protected\", \"'JavaProtected'\")!>javaPProtectedStatic<!>\n    val p3 = JavaProtected().<!INVISIBLE_MEMBER(\"javaPProtectedPackage\", \"protected\", \"'JavaProtected'\")!>javaPProtectedPackage<!>\n\n    fun test() {\n        JavaProtected.<!INVISIBLE_MEMBER(\"javaMProtectedStatic\", \"protected\", \"'JavaProtected'\")!>javaMProtectedStatic<!>()\n        JavaPackageLocal.<!INVISIBLE_MEMBER(\"javaMPackage\", \"package-private\", \"'JavaPackageLocal'\")!>javaMPackage<!>()\n    }\n}\n\nclass B : JavaProtected() {\n    val p1 = JavaPackageLocal.<!INVISIBLE_MEMBER(\"javaPPackage\", \"package-private\", \"'JavaPackageLocal'\")!>javaPPackage<!>\n    val p2 = JavaProtected.javaPProtectedStatic\n    val p3 = javaPProtectedPackage\n\n    fun test() {\n        JavaProtected.javaMProtectedStatic()\n        JavaPackageLocal.<!INVISIBLE_MEMBER(\"javaMPackage\", \"package-private\", \"'JavaPackageLocal'\")!>javaMPackage<!>()\n    }\n}\n\n// FILE: j.kt\npackage j\n\nimport j.JavaProtected\nimport j.JavaPackageLocal\n\nclass C {\n    val p1 = JavaPackageLocal.javaPPackage\n    val p2 = JavaProtected.javaPProtectedStatic\n    val p3 = JavaProtected().javaPProtectedPackage\n\n    fun test() {\n        JavaProtected.javaMProtectedStatic()\n        JavaProtected.javaMProtectedStatic()\n        JavaPackageLocal.javaMPackage()\n    }\n}"
        },
        {
            "code": "// FILE: a.kt\npackage a.x\n\nclass X\n\n// FILE: b.kt\npackage b.x\n\nclass X\n\n// FILE: c.kt\npackage c\n\nimport a.<!PACKAGE_CANNOT_BE_IMPORTED!>x<!>\nimport b.<!PACKAGE_CANNOT_BE_IMPORTED!>x<!>\n\nclass Y : <!UNRESOLVED_REFERENCE!>x<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>X<!>"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nopen class X\n\n// FILE: b.kt\npackage b\n\nclass X\n\n// FILE: c.kt\npackage c\n\nimport a.X\nimport b.*\n\nclass Y : X()"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nopen class Y\n\n// FILE: b.kt\npackage b\n\nclass X\n\n// FILE: b1.kt\npackage b\n\nimport a.Y as X\n\nclass Y : X() // class from explicit import should take priority\n"
        },
        {
            "code": "package test\n\nimport test.TopLevelClass.NestedClass.*\nimport test.TopLevelEnum.NestedEnum.*\nimport test.TopLevelEnum.*\n\nprivate class TopLevelClass {\n    private class NestedClass {\n        class A1\n        object A2\n    }\n\n    fun test() {\n        A1()\n        A2\n    }\n}\n\nprivate enum class TopLevelEnum(private val e: NestedEnum) {\n    E1(NestedEntry);\n\n    private enum class NestedEnum {\n        NestedEntry;\n    }\n}\n\nfun testAccess() {\n    E1\n    <!INVISIBLE_MEMBER!>NestedEntry<!>\n    <!INVISIBLE_MEMBER!>A1<!>()\n    <!INVISIBLE_MEMBER!>A2<!>\n}"
        },
        {
            "code": "// FILE: a.kt\npackage p1\n\nprivate class X\nprivate class Y\n\n// FILE: b.kt\npackage p2\n\nclass X\n\n// FILE: c.kt\npackage p1\n\nimport p2.*\n\nval x: X = X()\nval <!EXPOSED_PROPERTY_TYPE!>y<!>: <!INVISIBLE_REFERENCE!>Y<!> = <!INVISIBLE_MEMBER!>Y<!>()\n"
        },
        {
            "code": "//FILE:a.kt\npackage a\n\nimport b.foo\nimport c.foo // TODO: need warning here\n\n//FILE:b.kt\npackage b\n\nfun foo() = 2\n\n//FILE:c.kt\npackage c\n\nfun foo() = 1\n"
        },
        {
            "code": "// FILE: File.kt\npackage pack\n\npublic open class InetAddressImpl\n\n// FILE: Main.kt\npackage a\n\nimport java.net.* // should not import java.net.InetAddressImpl because it's package local\nimport pack.*\n\nclass X : InetAddressImpl() // should resolve to our pack.InetAddressImpl\n"
        },
        {
            "code": "// FILE: 1.kt\n\npackage anotherpackage\n\ninterface IInterfaceInput<in T> {\n    fun doSomething(input: T)\n}\n\n// FILE: 2.kt\n\npackage anotherpackage\n\ninterface IInterfaceOutput<out T> {\n    fun doSomething(): T?\n}\n\n// FILE: 3.kt\n\npackage mypackage.nestedpackage\n\nimport mypackage.nestedpackage.Bar.<!UNRESOLVED_REFERENCE!>Baz<!>\nimport anotherpackage.IInterfaceInput\nimport anotherpackage.IInterfaceOutput\n\nclass Foo() {\n    class FooNest {\n        val bar = Bar()\n\n        fun myFun(): List<Baz> {\n            return <!UNRESOLVED_REFERENCE!>listOf<!>(bar.doSomething())\n        }\n    }\n}\n\nclass Bar() : IInterfaceInput<Baz>, IInterfaceOutput<Baz> {\n    override fun doSomething(input: Baz) {\n        throw UnsupportedOperationException(\"not implemented\")\n    }\n\n    override fun doSomething(): Baz {\n        throw UnsupportedOperationException(\"not implemented\")\n    }\n\n}\n\ndata class Baz(val myField: Int)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: a.kt\npackage a\n\ninterface A\n\noperator fun A.plus(other: A): A = this\n\n// FILE: b.kt\npackage b\n\nimport a.A\nimport a.<!OPERATOR_RENAMED_ON_IMPORT!>plus<!> as minus\n\nfun test(a1: A, a2: A) =\n        a1 - a2"
        },
        {
            "code": "// FILE: File1.kt\npackage pack1\n\npublic class SomeClass {\n    private class N\n    public open class PublicNested\n}\n\n// FILE: Main.kt\npackage a\n\nimport pack1.SomeClass.*\n\nprivate class X : <!FINAL_SUPERTYPE, INVISIBLE_MEMBER, INVISIBLE_REFERENCE!>N<!>()"
        },
        {
            "code": "package test\n\nimport <!UNRESOLVED_REFERENCE!>some<!>.<!SYNTAX!><!>\nimport <!SYNTAX!>.some<!>\nimport <!SYNTAX!>.kotlin<!>\nimport <!PACKAGE_CANNOT_BE_IMPORTED!>kotlin<!>.<!SYNTAX!><!>\nimport<!SYNTAX!><!>\nimport <!SYNTAX!>.<!>\nimport <!SYNTAX!>*<!>"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nobject O {\n    class A\n    object B\n\n    fun bar() {}\n}\n\n\nobject S {\n\n    val prop: String = \"\"\n\n    fun o(<!UNUSED_PARAMETER!>s<!>: String) = Unit\n    fun o(<!UNUSED_PARAMETER!>i<!>: Int) = Unit\n\n    fun Int.ext() = Unit\n    var String.ext: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>i<!>) {\n        }\n\n    fun A(<!UNUSED_PARAMETER!>c<!>: Int) = A()\n\n    class A()\n\n    fun <T> genericFun(t: T, <!UNUSED_PARAMETER!>t2<!>: T): T = t\n}\n\nopen class Base {\n    fun f() {\n    }\n\n    fun <T> g(<!UNUSED_PARAMETER!>t<!>: T) {\n    }\n\n    val p = 1\n    val Int.ext: Int\n        get() = 4\n}\n\ninterface BaseI<T> {\n    fun fromI(): Int = 3\n\n    fun genericFromI(t: T) = t\n}\n\nobject K: Base(), BaseI<Int> {\n    val own: String = \"\"\n}\n\n// FILE: b.kt\npackage b\n\nimport a.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>O<!>.*\n\nfun testErroneusAllUnderImportFromObject() {\n    <!UNRESOLVED_REFERENCE!>A<!>()\n    <!UNRESOLVED_REFERENCE!>B<!>\n    <!UNRESOLVED_REFERENCE!>bar<!>()\n}\n\n// FILE: c.kt\npackage c\n\nimport a.S.prop\nimport a.S.o\nimport a.S.ext\nimport a.S.A\nimport a.S.genericFun\nimport a.S.ext as extRenamed\n\nfun testImportFromObjectByName() {\n    prop\n    o(\"a\")\n    o(3)\n    3.ext()\n    \"\".ext = 3\n    val <!UNUSED_VARIABLE!>c<!>: Int = \"\".ext\n\n    3.extRenamed()\n    \"\".extRenamed = 3\n    val <!UNUSED_VARIABLE!>c2<!>: Int = \"\".extRenamed\n\n    A()\n    A(3)\n\n    val <!UNUSED_VARIABLE!>a<!>: Int = genericFun(3, 3)\n    val <!UNUSED_VARIABLE!>s<!>: String = genericFun(\"A\", \"b\")\n    val <!UNUSED_VARIABLE!>b<!>: Boolean = genericFun(true, false)\n}\n\nfun <T> t(t: T): T {\n    return genericFun(t, t)\n}\n\n// FILE: d.kt\npackage d\n\nimport a.S.prop as renamed\n\nfun testFunImportedFromObjectHasNoDispatchReceiver(l: a.S) {\n    l.<!UNRESOLVED_REFERENCE!>renamed<!>\n    l.prop\n    renamed\n}\n\n// FILE: e.kt\n\npackage e\n\nimport a.K.f\nimport a.K.g\nimport a.K.p\nimport a.K.own\nimport a.K.fromI\nimport a.K.genericFromI\nimport a.K.ext\n\nfun testMembersFromSupertypes() {\n    f()\n    g(\"\")\n    p\n    fromI()\n\n    genericFromI(3)\n    genericFromI(<!TYPE_MISMATCH!>\"a\"<!>)\n\n    own\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE:a.kt\npackage a\n\n<!SYNTAX!><<!><!SYNTAX!><<!><!SYNTAX!><<!> <!SYNTAX!>FOOO<!><!SYNTAX!><!>\nimport b.B        //class\nimport b.foo      //function\nimport b.ext      //extension function\nimport b.value    //property\nimport b.C.Companion.bar    //function from companion object\nimport b.C.Companion.cValue //property from companion object\nimport b.<!UNRESOLVED_REFERENCE!>constant<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>fff<!>     //function from val\nimport b.<!UNRESOLVED_REFERENCE!>constant<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>dValue<!>  //property from val\nimport <!UNRESOLVED_REFERENCE!>smth<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>illegal<!>\nimport b.C.<!UNRESOLVED_REFERENCE!>smth<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>illegal<!>\n\n<!SYNTAX!><<!><!SYNTAX!><<!><!SYNTAX!><<!><!SYNTAX!>HEAD<!><!SYNTAX!><!>\nimport b.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>smth<!>\nimport b.<!UNRESOLVED_REFERENCE!>bar<!>.*\nimport b.<!UNRESOLVED_REFERENCE!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>\nimport <!UNRESOLVED_REFERENCE!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>\nimport b.constant\nimport b.E.Companion.f      //val from companion object\n\nfun test(arg: B) {\n    foo(value)\n    arg.ext()\n\n    bar()\n    foo(cValue)\n\n    <!UNRESOLVED_REFERENCE!>fff<!>(<!UNRESOLVED_REFERENCE!>dValue<!>)\n\n    constant.fff(constant.dValue)\n\n    f.f()\n}\n\n// FILE:b.kt\npackage b\n\nclass B() {}\n\nfun foo(i: Int) = i\n\nfun B.ext() {}\n\nval value = 0\n\nclass C() {\n    companion object {\n        fun bar() {}\n        val cValue = 1\n    }\n}\n\nclass D() {\n    fun fff(s: String) = s\n    val dValue = \"w\"\n}\n\nval constant = D()\n\nclass E() {\n    companion object {\n        val f = F()\n    }\n}\n\nclass F() {\n    fun f() {}\n}\n\nfun bar() {}\n\n//FILE:c.kt\npackage c\n\nimport c.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>C<!>.*\n\nobject C {\n    fun f() {\n    }\n    val i = 348\n}\n\nfun foo() {\n    if (<!UNRESOLVED_REFERENCE!>i<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>==<!> 3) <!UNRESOLVED_REFERENCE!>f<!>()\n}\n\n//FILE:d.kt\npackage d\n\nimport d.A.Companion.B\nimport d.A.Companion.C\n\nval b : B = B()\nval c : B = C\n\nclass A() {\n    companion object {\n        open class B() {}\n        object C : B() {}\n    }\n}\n"
        },
        {
            "code": "package a\n\nimport a.A as ER\n\ninterface A {\n    val a: <!UNRESOLVED_REFERENCE!>A<!>\n    val b: ER\n}\n"
        },
        {
            "code": "//FILE:a.kt\npackage a\n\n// no error is reported\nimport b.a\n\nfun foo() = a\n\n//FILE:b.kt\npackage b\n\nobject a {}\n"
        },
        {
            "code": "// FILE: a.kt\n\npackage foo\n\nobject Bar {\n    fun bar() {}\n}\n\n// FILE: b.kt\n\npackage baz\n\nimport foo.Bar\n\nclass C: <!SINGLETON_IN_SUPERTYPE!>Bar<!>\n\nfun test() {\n    Bar.bar()\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a.b\n\nfun ab_fun() {}\n\nclass c {\n    fun ab_c() {}\n\n    class d {\n        fun ab_cd() {}\n    }\n}\n\n// MODULE: m2\n// FILE: b.kt\npackage a\n\nfun a_fun() {}\n\nclass b {\n    fun a_b() {}\n\n    class c {\n        fun a_bc() {}\n    }\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\nimport a.a_fun\nimport a.b\n\nimport a.b.ab_fun\nimport a.b.c\n\nfun test(a_b: b) {\n    a_b.a_b()\n\n    val a_bc: b.c = b.c()\n    a_bc.a_bc()\n\n    val a_bc2 = b.c()\n    a_bc2.a_bc()\n\n    a_fun()\n}\n\nfun test2(ab_c: c) {\n    ab_c.ab_c()\n\n    val ab_cd: c.d = c.d()\n    ab_cd.ab_cd()\n\n    val ab_cd2 = c.d()\n    ab_cd2.ab_cd()\n\n    ab_fun()\n}\n\n// FILE: d.kt\npackage a\n\nimport a.b.ab_fun\nimport a.b.c\n\nfun test(a_b: b) {\n    a_b.a_b()\n\n    val a_bc: b.c = b.c()\n    a_bc.a_bc()\n\n    val a_bc2 = b.c()\n    a_bc2.a_bc()\n\n    a_fun()\n}\n\nfun test2(ab_c: c) {\n    ab_c.ab_c()\n\n    val ab_cd: c.d = c.d()\n    ab_cd.ab_cd()\n\n    val ab_cd2 = c.d()\n    ab_cd2.ab_cd()\n\n    ab_fun()\n}\n\n//---- Changed dependence order\n// MODULE: m4(m2, m1)\n// FILE: c.kt\nimport a.a_fun\nimport a.b\n\nimport a.b.ab_fun\nimport a.b.c\n\nfun test(a_b: b) {\n    a_b.a_b()\n\n    val a_bc: b.c = b.c()\n    a_bc.a_bc()\n\n    val a_bc2 = b.c()\n    a_bc2.a_bc()\n\n    a_fun()\n}\n\nfun test2(ab_c: c) {\n    ab_c.ab_c()\n\n    val ab_cd: c.d = c.d()\n    ab_cd.ab_cd()\n\n    val ab_cd2 = c.d()\n    ab_cd2.ab_cd()\n\n    ab_fun()\n}\n\n// FILE: d.kt\npackage a\n\nimport a.b.ab_fun\nimport a.b.c\n\nfun test(a_b: b) {\n    a_b.a_b()\n\n    val a_bc: b.c = b.c()\n    a_bc.a_bc()\n\n    val a_bc2 = b.c()\n    a_bc2.a_bc()\n\n    a_fun()\n}\n\nfun test2(ab_c: c) {\n    ab_c.ab_c()\n\n    val ab_cd: c.d = c.d()\n    ab_cd.ab_cd()\n\n    val ab_cd2 = c.d()\n    ab_cd2.ab_cd()\n\n    ab_fun()\n}"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nfun X(<!UNUSED_PARAMETER!>p<!>: Int) {}\n\n// FILE: b.kt\npackage b\n\nfun X(): Int = 1\n\n// FILE: c.kt\npackage c\n\nimport b.X\nimport a.X\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>v<!>: Int = X()\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a\n\nclass B {\n    fun m1() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\npackage a\n\nclass B {\n    fun m2() {}\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\nimport a.B\n\nfun test(b: B) {\n    b.m1()\n    b.<!UNRESOLVED_REFERENCE!>m2<!>()\n\n    val b_: B = B()\n    b_.m1()\n\n    val b_1: a.B = B()\n    b_1.m1()\n\n    val b_2: B = a.B()\n    b_2.m1()\n\n    val b_3: B = B()\n    b_3.m1()\n\n    val b_4: B = a.B()\n    b_4.m1()\n}\n\n\n//----------------------------TOP LEVEL---------------------\n// MODULE: top_m1\n// FILE: top_a.kt\nclass B {\n    fun m1() {}\n}\n\n// MODULE: top_m2\n// FILE: top_b.kt\nclass B {\n    fun m2() {}\n}\n\n// MODULE: top_m3(top_m1, top_m2)\n// FILE: top_c.kt\nimport B\n\nfun test(b: B) {\n    b.m1()\n    b.<!UNRESOLVED_REFERENCE!>m2<!>()\n\n    val b_: B = B()\n    b_.m1()\n\n    val b_2 = B()\n    b_2.m1()\n}\n\n// FILE: top_d.kt\n\nfun test2(b: B) {\n    b.m1()\n    b.<!UNRESOLVED_REFERENCE!>m2<!>()\n\n    val b_: B = B()\n    b_.m1()\n\n    val b_2 = B()\n    b_2.m1()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE:a.kt\npackage a\n\nimport b.B        //class\nimport b.foo      //function\nimport b.ext      //extension function\nimport b.value    //property\nimport b.C.Companion.bar    //function from companion object\nimport b.C.Companion.cValue //property from companion object\nimport b.<!UNRESOLVED_REFERENCE!>constant<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>fff<!>     //function from val\nimport b.<!UNRESOLVED_REFERENCE!>constant<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>dValue<!>  //property from val\nimport b.constant\nimport b.E.Companion.f      //val from companion object\nimport <!UNRESOLVED_REFERENCE!>smth<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>illegal<!>\nimport b.C.<!UNRESOLVED_REFERENCE!>smth<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>illegal<!>\nimport b.<!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>smth<!>\nimport b.<!UNRESOLVED_REFERENCE!>bar<!>.*\nimport b.<!UNRESOLVED_REFERENCE!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>\nimport <!UNRESOLVED_REFERENCE!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>unr<!>\n\nfun test(arg: B) {\n    foo(value)\n    arg.ext()\n\n    bar()\n    foo(cValue)\n\n    <!UNRESOLVED_REFERENCE!>fff<!>(<!UNRESOLVED_REFERENCE!>dValue<!>)\n\n    constant.fff(constant.dValue)\n\n    f.f()\n}\n\n// FILE:b.kt\npackage b\n\nclass B() {}\n\nfun foo(i: Int) = i\n\nfun B.ext() {}\n\nval value = 0\n\nclass C() {\n    companion object {\n        fun bar() {}\n        val cValue = 1\n    }\n}\n\nclass D() {\n    fun fff(s: String) = s\n    val dValue = \"w\"\n}\n\nval constant = D()\n\nclass E() {\n    companion object {\n        val f = F()\n    }\n}\n\nclass F() {\n    fun f() {}\n}\n\nfun bar() {}\n\n//FILE:c.kt\npackage c\n\nimport c.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>C<!>.*\n\nobject C {\n    fun f() {\n    }\n    val i = 348\n}\n\nfun foo() {\n    if (<!UNRESOLVED_REFERENCE!>i<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>==<!> 3) <!UNRESOLVED_REFERENCE!>f<!>()\n}\n\n//FILE:d.kt\npackage d\n\nimport d.A.Companion.B\nimport d.A.Companion.C\n\nval b : B = B()\nval c : B = C\n\nclass A() {\n    companion object {\n        open class B() {}\n        object C : B() {}\n    }\n}"
        },
        {
            "code": "// FILE: a.kt\n\npackage weatherForecast\n\nfun weatherToday() = \"snow\"\n\n// FILE: b.kt\n\npackage myApp\n\nimport weatherForecast.weatherToday\nimport weatherForecast.weatherToday\n\nfun needUmbrella() = weatherToday() == \"rain\"\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: 1.kt\npackage a\n\nclass someFun() {}\nfun someFun(i: Int) {}\n\nclass someVal() {}\nval Int.someVal: Int get() = 3\n\nclass A\n\nclass B\n\n// FILE: 2.kt\npackage b\n\nclass someFun\nclass someVal\nclass someAll\n\nfun A() {}\n\nclass B\n\n\n// FILE: 3.kt\nimport a.<!CONFLICTING_IMPORT!>someFun<!>\nimport b.<!CONFLICTING_IMPORT!>someFun<!>\n\nimport a.<!CONFLICTING_IMPORT!>someVal<!>\nimport b.<!CONFLICTING_IMPORT!>someVal<!>\n\nimport a.A\nimport b.A\n\n// FILE: 4.kt\nimport b.*\nimport a.B\n\n// FILE: 5.kt\npackage b\n\nimport a.B\n\n// FILE: 6.kt\nimport a.<!CONFLICTING_IMPORT!>B<!>\nimport b.<!CONFLICTING_IMPORT!>B<!>"
        },
        {
            "code": "// FILE: a.kt\n\npackage weatherForecast\n\nfun weatherToday() = \"snow\"\n\n// FILE: b.kt\n\npackage myApp\n\nimport weatherForecast.*\nimport weatherForecast.*\n\nfun needUmbrella() = weatherToday() == \"rain\"\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a\n\nfun a_fun() {}\n\nclass b {\n    fun a_b() {}\n\n    class c {\n        fun a_bc() {}\n    }\n}\n\n// MODULE: m2\n// FILE: b.kt\nfun _fun() {}\n\nclass a {\n    fun _a() {}\n\n    class b {\n        fun _ab() {}\n    }\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\nimport a.a_fun\nimport a.b\n\nfun test(a_b: b) {\n    a_b.a_b()\n\n    val a_bc: b.c = b.c()\n    a_bc.a_bc()\n\n    a_fun()\n}\n\n// FILE: d.kt\nfun test2(_a: a) {\n    _a._a()\n\n    val _ab: a.b = a.b()\n    _ab._ab()\n\n    val _ab2 = a.b()\n    _ab2._ab()\n\n    _fun()\n}\n\n// FILE: e.kt\nimport a\nimport _fun\n\nfun test3(_a: a) {\n    _a._a()\n\n    val _ab: a.b = a.b()\n    _ab._ab()\n\n    val _ab2 = a.b()\n    _ab2._ab()\n\n    _fun()\n}"
        },
        {
            "code": "//FILE:a.kt\npackage a\n\nimport b.<!CONFLICTING_IMPORT!>O<!>\nimport c.<!CONFLICTING_IMPORT!>O<!>\n\n//FILE:b.kt\npackage b\n\nobject O {}\n\n//FILE:c.kt\npackage c\n\nobject O {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: a.kt\npackage a\n\nclass A {\n    class B\n}\n\n// FILE: b.kt\npackage a\n\nclass D {\n    class B\n}\n\n// FILE: c.kt\nimport a.A.<!CONFLICTING_IMPORT!>B<!>\nimport a.D.<!CONFLICTING_IMPORT!>B<!>\n\nfun test(b: <!UNRESOLVED_REFERENCE!>B<!>) {\n    <!UNRESOLVED_REFERENCE!>B<!>()\n}\n\n// FILE: d.kt\nimport a.A.*\nimport a.D.*\n\n// todo ambiguvity here\nfun test2(b: <!UNRESOLVED_REFERENCE!>B<!>) {\n    <!UNRESOLVED_REFERENCE!>B<!>()\n}"
        },
        {
            "code": "// FILE: j/JavaPublic.java\npackage j;\n\npublic class JavaPublic {\n    public static void javaM() {}\n    public static int javaP = 4;\n    static int javaPackageLocal = 5;\n}\n\n// FILE: j/JavaPackageLocal.java\npackage j;\n\nclass JavaPackageLocal {\n    static void javaMPackage() {}\n    static int javaPPackage = 4;\n}\n\n// FILE: j/JavaProtected.java\npackage j;\n\npublic class JavaProtected {\n    protected static void javaMProtected() {}\n    protected static int javaPProtected = 4;\n}\n\n// FILE: j/JavaPrivate.java\npackage j;\n\npublic class JavaPrivate {\n    private static void javaMPrivate() {}\n    private static int javaPPrivate = 4;\n}\n\n\n// FILE: k1.kt\npackage k\n\nimport j.JavaPublic\nimport j.JavaPublic.javaM\nimport j.JavaPublic.javaP\nimport j.JavaPublic.<!INVISIBLE_REFERENCE!>javaPackageLocal<!>\n\nimport j.<!INVISIBLE_REFERENCE!>JavaPackageLocal<!>\nimport j.<!INVISIBLE_REFERENCE!>JavaPackageLocal<!>.<!INVISIBLE_REFERENCE!>javaMPackage<!>\nimport j.<!INVISIBLE_REFERENCE!>JavaPackageLocal<!>.<!INVISIBLE_REFERENCE!>javaPPackage<!>\n\nimport j.JavaProtected\nimport j.JavaProtected.javaMProtected\nimport j.JavaProtected.javaPProtected\n\nimport j.JavaPrivate\nimport j.JavaPrivate.<!INVISIBLE_REFERENCE!>javaMPrivate<!>\nimport j.JavaPrivate.<!INVISIBLE_REFERENCE!>javaPPrivate<!>\n\n// FILE: k2.kt\npackage j\n\nimport j.JavaPublic\nimport j.JavaPublic.javaM\nimport j.JavaPublic.javaP\nimport j.JavaPublic.javaPackageLocal\n\nimport j.JavaPackageLocal\nimport j.JavaPackageLocal.javaMPackage\nimport j.JavaPackageLocal.javaPPackage\n\nimport j.JavaProtected\nimport j.JavaProtected.javaMProtected\nimport j.JavaProtected.javaPProtected\n\nimport j.JavaPrivate\nimport j.JavaPrivate.<!INVISIBLE_REFERENCE!>javaMPrivate<!>\nimport j.JavaPrivate.<!INVISIBLE_REFERENCE!>javaPPrivate<!>"
        },
        {
            "code": "package a\n\nimport a.A.*\nimport a.A.C\nimport a.A.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>C<!>.*\nimport a.A.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>D<!>.*\nimport a.A.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>C<!>.*\nimport a.A.C.G\nimport a.A.E.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>J<!>.*\nimport a.A.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>CO<!>.*\nimport a.A.CO\n\nimport a.B.C.*\nimport a.B.C.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>A<!>.*\nimport a.B.C.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>D<!>.*\n\nimport a.E.*\nimport a.E.E1\nimport a.E.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>E2<!>.*\n\nclass A {\n    object C {\n        object G\n    }\n    object D {\n\n    }\n\n    class E {\n        object J\n    }\n\n    companion object CO {\n        object H\n    }\n}\n\nenum class E {\n    E1, E2\n}\n\nobject B {\n    class C {\n        object A\n        object D\n    }\n}"
        },
        {
            "code": "// FILE: A.kt\n\nimport B.<!INVISIBLE_REFERENCE!>foo<!>\n\nfun test() {\n    <!INVISIBLE_MEMBER!>foo<!>\n}\n\n// FILE: B.kt\nobject B : C<String>()\n\n// FILE: C.kt\n\nopen class C<T> {\n    private var foo: String = \"abc\"\n}"
        },
        {
            "code": "// FILE: importFunctionWithAllUnderImport.kt\npackage test\n\nimport testOther.*\n\nclass B: A()\nval inferTypeFromImportedFun = testFun()\n\n// FILE: importFunctionWithAllUnderImportOther.kt\npackage testOther\n\nopen class A\nfun testFun() = 1\n"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nclass X\n\n// FILE: b.kt\npackage b\n\nopen class X\n\n// FILE: b1.kt\npackage b\n\nimport a.*\n\nclass Y : X() // class from the current package should take priority\n"
        },
        {
            "code": "// FILE: File1.kt\npackage pack1\n\nprivate open class SomeClass\n\n// FILE: Main.kt\npackage a\n\nimport pack1.*\n\nprivate class X : <!INVISIBLE_MEMBER, INVISIBLE_REFERENCE!>SomeClass<!>()"
        },
        {
            "code": "// MODULE: m1\n// FILE: k1.kt\npackage k\n\nprivate class KPrivate\ninternal class KInternal\npublic class KPublic\n\nclass A {\n    protected class KProtected\n}\n\n// FILE: k2.kt\npackage k2\n\nimport k.<!INVISIBLE_REFERENCE!>KPrivate<!>\nimport k.KInternal\nimport k.KPublic\nimport k.A.KProtected\n\n// MODULE: m2(m1)\n// FILE: k3.kt\npackage k3\n\nimport k.<!INVISIBLE_REFERENCE!>KPrivate<!>\nimport k.<!INVISIBLE_REFERENCE!>KInternal<!>\nimport k.KPublic\nimport k.A.KProtected"
        },
        {
            "code": "package p\n\nimport p.Foo.Nested\n\nopen class Foo {\n    protected class Nested\n}\n\nclass Bar: Foo() {\n    protected fun foo(): Nested? = null\n}\n\nprivate fun foo(): <!INVISIBLE_REFERENCE!>Nested<!>? = null\nprivate fun bar(): p.Foo.<!INVISIBLE_REFERENCE!>Nested<!>? = null"
        },
        {
            "code": "// FILE: a.kt\npackage a\n\nclass C1 {\n    companion object O {\n        class A\n        object B\n\n        fun bar() {}\n    }\n}\n\n\nclass C2 {\n    companion object S {\n\n        val prop: String = \"\"\n\n        fun o(<!UNUSED_PARAMETER!>s<!>: String) = Unit\n        fun o(<!UNUSED_PARAMETER!>i<!>: Int) = Unit\n\n        fun Int.ext() = Unit\n        var String.ext: Int\n            get() = 3\n            set(<!UNUSED_PARAMETER!>i<!>) {\n            }\n\n        fun A(<!UNUSED_PARAMETER!>c<!>: Int) = A()\n\n        class A()\n\n        fun <T> genericFun(t: T, <!UNUSED_PARAMETER!>t2<!>: T): T = t\n    }\n}\n\nopen class Base {\n    fun f() {\n    }\n\n    fun <T> g(<!UNUSED_PARAMETER!>t<!>: T) {\n    }\n\n    val p = 1\n    val Int.ext: Int\n        get() = 4\n}\n\ninterface BaseI<T> {\n    fun fromI(): Int = 3\n\n    fun genericFromI(t: T) = t\n}\n\nclass C3 {\n    companion object K: Base(), BaseI<Int> {\n        val own: String = \"\"\n    }\n}\n\n// FILE: b.kt\npackage b\n\nimport a.C1.<!CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON!>O<!>.*\n\nfun testErroneusAllUnderImportFromObject() {\n    <!UNRESOLVED_REFERENCE!>A<!>()\n    <!UNRESOLVED_REFERENCE!>B<!>\n    <!UNRESOLVED_REFERENCE!>bar<!>()\n}\n\n// FILE: c.kt\npackage c\n\nimport a.C2.S.prop\nimport a.C2.S.o\nimport a.C2.S.ext\nimport a.C2.S.A\nimport a.C2.S.genericFun\nimport a.C2.S.ext as extRenamed\n\nfun testImportFromObjectByName() {\n    prop\n    o(\"a\")\n    o(3)\n    3.ext()\n    \"\".ext = 3\n    val <!UNUSED_VARIABLE!>c<!>: Int = \"\".ext\n\n    3.extRenamed()\n    \"\".extRenamed = 3\n    val <!UNUSED_VARIABLE!>c2<!>: Int = \"\".extRenamed\n\n    A()\n    A(3)\n\n    val <!UNUSED_VARIABLE!>a<!>: Int = genericFun(3, 3)\n    val <!UNUSED_VARIABLE!>s<!>: String = genericFun(\"A\", \"b\")\n    val <!UNUSED_VARIABLE!>b<!>: Boolean = genericFun(true, false)\n}\n\nfun <T> t(t: T): T {\n    return genericFun(t, t)\n}\n\n// FILE: d.kt\npackage d\n\nimport a.C2.S.prop as renamed\n\nfun testFunImportedFromObjectHasNoDispatchReceiver(l: a.C2.S) {\n    l.<!UNRESOLVED_REFERENCE!>renamed<!>\n    l.prop\n    renamed\n}\n\n// FILE: e.kt\n\npackage e\n\nimport a.C3.K.f\nimport a.C3.K.g\nimport a.C3.K.p\nimport a.C3.K.own\nimport a.C3.K.fromI\nimport a.C3.K.genericFromI\nimport a.C3.K.ext\n\nfun testMembersFromSupertypes() {\n    f()\n    g(\"\")\n    p\n    fromI()\n\n    genericFromI(3)\n    genericFromI(<!TYPE_MISMATCH!>\"a\"<!>)\n\n    own\n}"
        },
        {
            "code": "// FILE: A.kt\n\nclass A {\n    private class Nested {\n        object O1\n    }\n}\n\n// FILE: C.kt\n\nimport A.<!INVISIBLE_REFERENCE!>Nested<!>.*\nimport B.<!INVISIBLE_REFERENCE!>JC<!>.JC1\n\nfun test() {\n    <!INVISIBLE_MEMBER!>O1<!>\n    <!INACCESSIBLE_TYPE!><!INVISIBLE_MEMBER!>JC1<!>()<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// MODULE: m1\n// FILE: a.kt\npackage a\n\nclass B {\n    fun m1() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\npackage a\n\nclass B {\n    fun m2() {}\n}\n\n// MODULE: m3(m2, m1)\n// FILE: b.kt\nimport a.*\n\n\nfun test(b: B) {\n    b.m2()\n    b.<!UNRESOLVED_REFERENCE!>m1<!>()\n\n    val b_: B = B()\n    b_.m2()\n\n    val b_1: a.B = B()\n    b_1.m2()\n\n    val b_2: B = a.B()\n    b_2.m2()\n\n    val b_3 = B()\n    b_3.m2()\n\n    val b_4 = a.B()\n    b_4.m2()\n}\n\n\n//----------------------------TOP LEVEL---------------------\n\n// MODULE: top_m1\n// FILE: top_a.kt\nclass B {\n    fun m1() {}\n}\n\n// MODULE: top_m2\n// FILE: top_b.kt\nclass B {\n    fun m2() {}\n}\n\n// MODULE: top_m3(top_m2, top_m1)\n// FILE: top_c.kt\n\nfun test(b: B) {\n    b.m2()\n    b.<!UNRESOLVED_REFERENCE!>m1<!>()\n\n    val b_: B = B()\n    b_.m2()\n\n    val b_2 = B()\n    b_2.m2()\n\n    val b_3 = B()\n    b_3.m2()\n\n    val b_4 = <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>B<!>()\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b_4<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>m2<!>()\n}"
        },
        {
            "code": "// FILE: rootPackage.kt\nclass Klass {\n    class Nested\n}\n\nclass NotImported\n\nfun function() = \"\"\n\nval property = \"\"\n\n// FILE: anotherFromRootPackage.kt\nfun foo(): Klass {\n    function() + property\n    return Klass()\n}\n\n// FILE: anotherFromRootPackage.kt\npackage pkg\n\nimport Klass\nimport Klass.Nested\nimport function\nimport property\n\nfun foo(): Klass {\n    function() + property\n    return Klass()\n}\n\nval v: Nested = Nested()\nval x: <!UNRESOLVED_REFERENCE!>NotImported<!> = <!UNRESOLVED_REFERENCE!>NotImported<!>()"
        },
        {
            "code": "package test\n\nimport test.TopLevelClass.NestedClass\nimport test.TopLevelClass.NestedClass.InNested\nimport test.TopLevelEnum.NestedEnum.NestedEntry\nimport test.TopLevelObject.inObject\nimport test.TopLevelEnum.E1\n\nprivate class TopLevelClass {\n    private class NestedClass {\n        class InNested\n    }\n\n    fun test() {\n        InNested()\n    }\n}\n\nprivate enum class TopLevelEnum(private val e: NestedEnum) {\n    E1(NestedEntry);\n\n    private enum class NestedEnum {\n        NestedEntry;\n    }\n}\n\nprivate object TopLevelObject {\n    fun inObject() {}\n}\n\nfun testAccess() {\n    <!INVISIBLE_MEMBER!>NestedClass<!>()\n    E1\n    <!INVISIBLE_MEMBER!>InNested<!>()\n    <!INVISIBLE_MEMBER!>NestedEntry<!>\n    inObject()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A<T> {\n    fun foo(): Int\n}\n\nclass AImpl<T>: A<T> {\n    override fun foo() = 42\n}\n\nclass B : A<Int> by AImpl()\n\nfun <T> bar(): A<T> = AImpl()\n\nclass C : A<Int> by bar()\n\nfun <T> baz(f: (T) -> T): A<T> = AImpl()\n\nclass D : A<Int> by baz({ it + 1 })\n\nfun <T> boo(t: T): A<T> = AImpl()\n\nclass E : A<Int> by <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>boo(\"\")<!>\n\nclass F : A<Int> by <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>AImpl<String>()<!>"
        },
        {
            "code": "open class Foo() {\n\n}\n\nclass Barrr() : <!DELEGATION_NOT_TO_INTERFACE!>Foo<!> by Foo() {}\n\ninterface T {}\n\nclass Br(t : T) : T by t {}\n\n<!WRONG_MODIFIER_TARGET!>open<!> enum class EN() {\n  A\n}\n\nclass Test2(e : EN) : <!DELEGATION_NOT_TO_INTERFACE!>EN<!> by e {}\n"
        },
        {
            "code": "interface IStr {\n    fun foo(): String\n}\n\nclass CStr : IStr {\n    override fun foo(): String = \"\"\n}\n\ninterface IInt {\n    fun foo(): Int\n}\n\nclass CInt : IInt {\n    override fun foo(): Int = 42\n}\n\ninterface IAny {\n    fun foo(): Any\n}\n\nclass CAny : IAny {\n    override fun foo(): Any = null!!\n}\n\ninterface IGeneric<T> {\n    fun foo(): T\n}\n\nclass CGeneric<T> : IGeneric<T> {\n    override fun foo(): T {\n        throw UnsupportedOperationException()\n    }\n}\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test1<!> : IStr by CStr(), IInt\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test2<!> : IStr, IInt by CInt()\n\nabstract <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test3<!> : IStr by CStr(), IInt by CInt()\n\nabstract class Test4 : IStr by CStr(), IGeneric<String>\n\nabstract class Test5 : IStr by CStr(), IGeneric<Any>\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test6<!> : IStr by CStr(), IGeneric<Int>\n\nabstract class Test7 : IGeneric<String> by CGeneric<String>(), IStr\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test8<!> : IGeneric<String> by CGeneric<String>(), IInt\n\n// Can't test due to https://youtrack.jetbrains.com/issue/KT-10258\n// abstract class Test9 : IGeneric<String> by CGeneric<String>(), IGeneric<Int>\n\nabstract <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test10<!> : IInt by CInt(), IStr by CStr(), IAny by CAny()\n\nabstract <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test11<!> : IInt, IStr by CStr(), IAny by CAny()\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test12<!> : IInt, IStr, IAny by CAny()\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nopen class Final {\n    fun foo() {}\n    val bar: Int = 0\n    var qux: Int = 0\n}\n\nopen class Derived : Final()\n\ninterface IFoo {\n    fun foo()\n}\n\nclass CFoo : IFoo {\n    override fun foo() {}\n}\n\ninterface IBar {\n    val bar: Int\n}\n\nclass CBar : IBar {\n    override val bar: Int get() = 0\n}\n\ninterface IQux {\n    val qux: Int\n}\n\nclass CQux : IQux {\n    override val qux: Int get() = 0\n}\n\ninterface IBarT<T> {\n    val bar: T\n}\n\nclass CBarT<T> : IBarT<T> {\n    override val bar: T get() = null!!\n}\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION!>class Test1<!> : Final(), IFoo by CFoo()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION!>class Test2<!> : Final(), IBar by CBar()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION, VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION!>class Test3<!> : Final(), IQux by CQux()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION!>class Test4<!> : Derived(), IFoo by CFoo()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION!>class Test5<!> : Derived(), IBar by CBar()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION, VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION!>class Test6<!> : Derived(), IQux by CQux()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION!>class Test7<!> : Final(), IBarT<Int> by CBarT<Int>()\n\n<!OVERRIDING_FINAL_MEMBER_BY_DELEGATION!>class Test8<!> : Final(), IBarT<Int> by <!TYPE_MISMATCH!>CBar()<!>\n"
        },
        {
            "code": "interface IStr {\n    val foo: String\n}\n\nclass CStr : IStr {\n    override val foo: String get() = \"\"\n}\n\ninterface IInt {\n    val foo: Int\n}\n\nclass CInt : IInt {\n    override val foo: Int get() = 42\n}\n\ninterface IAny {\n    val foo: Any\n}\n\nclass CAny : IAny {\n    override val foo: Any get() = null!!\n}\n\ninterface IGeneric<T> {\n    val foo: T\n}\n\nclass CGeneric<T> : IGeneric<T> {\n    override val foo: T get() = null!!\n}\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test1<!> : IStr by CStr(), IInt\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test2<!> : IStr, IInt by CInt()\n\nabstract <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test3<!> : IStr by CStr(), IInt by CInt()\n\nabstract class Test4 : IStr by CStr(), IGeneric<String>\n\nabstract class Test5 : IStr by CStr(), IGeneric<Any>\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test6<!> : IStr by CStr(), IGeneric<Int>\n\nabstract class Test7 : IGeneric<String> by CGeneric<String>(), IStr\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test8<!> : IGeneric<String> by CGeneric<String>(), IInt\n\n// Can't test right now due to https://youtrack.jetbrains.com/issue/KT-10258\n// abstract class Test9 : IGeneric<String> by CGeneric<String>(), IGeneric<Int>\n\nabstract <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test10<!> : IInt by CInt(), IStr by CStr(), IAny by CAny()\n\nabstract <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test11<!> : IInt, IStr by CStr(), IAny by CAny()\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Test12<!> : IInt, IStr, IAny by CAny()\n\n"
        },
        {
            "code": "interface IVar {\n    var foo: Int\n}\n\ninterface IDerived : IVar\n\ninterface IVal {\n    val foo: Int\n}\n\nclass CVal : IVal {\n    override val foo: Int get() = 42\n}\n\ninterface IValT<T> {\n    val foo: T\n}\n\nclass CValT<T> : IValT<T> {\n    override val foo: T get() = null!!\n}\n\nabstract <!VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION!>class Test1<!> : IVar, IVal by CVal()\n\nabstract <!VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION!>class Test2<!> : IVar, IValT<Int> by CValT<Int>()\n\nabstract <!VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION!>class Test3<!> : IDerived, IVal by CVal()\n\nabstract <!VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION!>class Test4<!> : IDerived, IValT<Int> by CValT<Int>()\n"
        },
        {
            "code": "public interface Base {\n    var test: String\n        get() = \"OK\"\n        set(<!UNUSED_PARAMETER!>s<!>: String) {\n        }\n}\n\npublic interface Base2 : Base {\n    override var test: String\n            get() = \"OK2\"\n            set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nclass Delegate : Base2 {\n\n}\n\nfun box(): String {\n    object : Base, Base2 by Delegate() {\n    }\n\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>object<!> : Base2, Base by Delegate() {\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "interface Base {\n    fun test() = \"Base\"\n}\n\nclass Delegate : Base\n\nabstract class Middle : Base {\n    override fun test() = \"MyClass\"\n}\n\nabstract class MyClass : Middle()\n\n<!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>class A<!> : MyClass(), Base by Delegate()\n"
        },
        {
            "code": "public interface Base {\n    fun test() = \"Base\"\n}\n\npublic interface Base2 : Base {\n    override fun test() = \"Base2\"\n}\n\npublic interface Base3 : Base {\n    override fun test() = \"Base3\"\n}\n\nclass Impl : Base\n\nclass Impl2 : Base2\n\nclass Impl3 : Base3\n\nclass ImplAll : Base, Base2, Base3 {\n    override fun test(): String {\n        return super<Base2>.test()\n    }\n}\n\nfun box(): String {\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : Base2, Base3, Base by Impl() {\n\n    }\n\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : Base2 by Impl2(), Base3, Base {\n\n    }\n\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : Base2, Base3 by Impl3(), Base {\n\n    }\n\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : Base2 by Impl2(), Base3 by Impl3(), Base by Impl() {\n\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "public interface Base {\n    fun getValue(): String\n\n    fun test() = getValue()\n}\n\nclass Delegate : Base {\n    override fun getValue() = \"Delegate\"\n}\n\npublic abstract class MyClass : Base {\n    override fun test(): String {\n        return \"Class\"\n    }\n}\n\n<!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>class A<!> : MyClass(), Base by Delegate() {\n    override fun getValue() = \"Delegate\"\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface Base1 {\n    fun test() = \"OK\"\n}\n\ninterface Base2 {\n    fun test2() = \"OK\"\n}\n\n\nclass Delegate1 : Base1\n\nclass Delegate2 : Base2\n\n\npublic abstract class MyClass : Base1, Base2 {\n    override fun test(): String {\n        return \"Class\"\n    }\n\n    override fun test2(): String {\n        return \"Class\"\n    }\n}\n\n<!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class A<!> : MyClass(), Base1 by Delegate1(), <!SUPERTYPE_APPEARS_TWICE!>Base1<!> by <!TYPE_MISMATCH!>Delegate2()<!> {\n\n}"
        },
        {
            "code": "public interface Base {\n    fun test() = \"Base\"\n}\n\npublic interface Derived : Base {\n    override fun test() = \"Derived\"\n}\n\n\nclass Delegate : Derived {\n    override fun test() = \"Delegate\"\n}\n\npublic open class MyClass : Base by Delegate()\n\nfun box(): String {\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : MyClass(), Derived by Delegate() {\n    }\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "public interface Base {\n    fun test() = \"Base\"\n}\n\nclass Delegate : Base {\n    override fun test() = \"Base\"\n}\n\npublic open class MyClass : Base by Delegate()\n\nfun box(): String {\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>object<!> : MyClass(), Base by Delegate() {\n    }\n    return \"OK\"\n}\n\n"
        },
        {
            "code": "public interface Base {\n    fun test() = \"OK\"\n}\n\npublic interface Base2 : Base {\n    override fun test() = \"OK2\"\n}\n\nclass Delegate : Base2\n\nfun box(): String {\n    object : Base, Base2 by Delegate() {\n    }\n\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>object<!> : Base2, Base by Delegate() {\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "public interface Base {\n    val test: String\n        get() = \"OK\"\n}\n\nopen class Delegate : Base {\n    override val test: String\n        get() = \"OK\"\n}\n\nfun box(): String {\n    <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>object<!> : Delegate(), Base by Delegate() {\n\n    }\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -CONFLICTING_JVM_DECLARATIONS\ninterface One {\n    public fun foo(): Any?\n}\ninterface Two {\n    public fun foo(): String?\n}\n\ninterface Three {\n    public fun foo(): String\n}\n\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test123<!>(val v1: One, val v2: Two, val v3: Three) : One by v1, Two by v2, Three by v3 { }\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test132<!>(val v1: One, val v2: Two, val v3: Three) : One by v1, Three by v3, Two by v2 { }\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class Test312<!>(val v1: One, val v2: Two, val v3: Three) : Three by v3, One by v1, Two by v2 { }\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class Test321<!>(val v1: One, val v2: Two, val v3: Three) : Three by v3, Two by v2, One by v1 { }\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test231<!>(val v1: One, val v2: Two, val v3: Three) : Two by v2, Three by v3, One by v1 { }\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED, MANY_IMPL_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Test213<!>(val v1: One, val v2: Two, val v3: Three) : Two by v2, One by v1, Three by v3 { }"
        },
        {
            "code": "interface IBase1 {\n    fun foo(): Any\n}\n\ninterface IDerived1 : IBase1 {\n    override fun foo(): String\n}\n\n<!RETURN_TYPE_MISMATCH_BY_DELEGATION!>class Broken1<!>(val b: IBase1) : IBase1 by b, IDerived1\n\ninterface IBase2 {\n    val foo: Any\n}\n\ninterface IDerived2 : IBase2 {\n    override val foo: String\n}\n\n<!PROPERTY_TYPE_MISMATCH_BY_DELEGATION!>class Broken2<!>(val b: IBase2) : IBase2 by b, IDerived2\n"
        },
        {
            "code": "interface IBase1 {\n    fun foo(): Any\n}\n\nopen class IDerived1 : IBase1 {\n    override fun foo(): String = \"1\"\n}\n\n<!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, RETURN_TYPE_MISMATCH_BY_DELEGATION!>class Broken1<!>(val b: IBase1) : IBase1 by b, IDerived1()\n\ninterface IBase2 {\n    val foo: Any\n}\n\nopen class IDerived2 : IBase2 {\n    override val foo: String = \"2\"\n}\n\n<!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, PROPERTY_TYPE_MISMATCH_BY_DELEGATION!>class Broken2<!>(val b: IBase2) : IBase2 by b, IDerived2()\n"
        },
        {
            "code": "interface IA {\n    fun foo(): Number\n}\n\ninterface IB : IA {\n    override fun foo(): Int\n}\n\nobject AImpl : IA {\n    override fun foo() = 42\n}\n\nopen <!RETURN_TYPE_MISMATCH_BY_DELEGATION!>class C<!> : IA by AImpl, IB\n\nclass D : C() {\n    override fun foo(): Double = 3.14\n}\n"
        },
        {
            "code": "interface IBase1 {\n    fun foo(): Any\n}\n\ninterface IDerived1 {\n    fun foo(): String\n}\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class Broken1<!>(val b: IBase1) : IBase1 by b, IDerived1\n\ninterface IBase2 {\n    val foo: Any\n}\n\ninterface IDerived2 {\n    val foo: String\n}\n\n<!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class Broken2<!>(val b: IBase2) : IBase2 by b, IDerived2\n"
        },
        {
            "code": "// !DIAGNOSTICS: -CONFLICTING_JVM_DECLARATIONS\ninterface One {\n  public <!REDUNDANT_OPEN_IN_INTERFACE!>open<!> fun foo() : Int\n  private fun boo() = 10\n}\ninterface Two {\n  public <!REDUNDANT_OPEN_IN_INTERFACE!>open<!> fun foo() : Int\n}\n\ninterface OneImpl : One {\n  public override fun foo() = 1\n}\ninterface TwoImpl : Two {\n  public override fun foo() = 2\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class Test1<!>() : TwoImpl, OneImpl {}\nclass Test2(a : One) : One by a, Two {}\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class Test3<!>(a : One, b : Two) : Two by b, One by a {}"
        },
        {
            "code": "package override\n\ninterface T {\n    fun foo()\n    val v : Int\n}\n\nopen <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Br<!>(<!UNUSED_PARAMETER!>t<!> : T) : T {\n\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class Br3<!>(t : T) : Br(t) {\n\n}\n\nopen class Br1(t : T) : T by t {\n\n}\n\nclass Br2(t : T) : Br1(t) {\n\n}\n\ninterface G<T> {\n    fun foo(t : T) : T\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class GC<!>() : G<Int> {\n\n}\n\nopen class GC1(g : G<Int>) : G<Int> by g {\n\n}\n\nopen class GC2(g : G<Int>) : GC1(g) {\n\n}"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\nclass TestIface(r : Runnable) : Runnable by r {}\n\nclass TestObject(o : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!>) : <!DELEGATION_NOT_TO_INTERFACE, PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!> by o {}"
        },
        {
            "code": "interface T {\n    val x: Int\n        get() = 1\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : T {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n}"
        },
        {
            "code": "interface B {\n    fun getX() = 1\n}\n\ninterface D {\n    val x: Int\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C(d: D)<!> : D by d, B {\n}"
        },
        {
            "code": "interface T {\n    val x: Int\n}\n\nabstract class C : T {\n    <!ACCIDENTAL_OVERRIDE!>fun getX()<!> = 1\n}"
        },
        {
            "code": "open class C {\n    val x = 1\n}\n\ninterface Tr : <!INTERFACE_WITH_SUPERCLASS!>C<!> {\n    <!ACCIDENTAL_OVERRIDE!>fun getX()<!> = 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class B {\n    fun foo(l: List<String>) {}\n}\n\nclass C : B() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo(l: List<Int>)<!> {}\n}"
        },
        {
            "code": "interface T {\n    fun getX() = 1\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : T {\n    val x: Int\n        <!CONFLICTING_JVM_DECLARATIONS!>get()<!> = 1\n}"
        },
        {
            "code": "open class B {\n    fun getX() = 1\n}\n\nclass C : B() {\n    <!ACCIDENTAL_OVERRIDE!>val x: Int<!> = 1\n}"
        },
        {
            "code": "interface T {\n    fun getX(): Int\n}\n\nabstract class C : T {\n    val x: Int\n        <!ACCIDENTAL_OVERRIDE!>get()<!> = 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class Base {\n    open fun `foo$default`(d: Derived, i: Int, mask: Int, mh: Any) {}\n}\n\nclass Derived : Base() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo(i: Int = 0)<!> {}\n}\n"
        },
        {
            "code": "open class B {\n    fun getX() = 1\n}\n\nclass C(<!ACCIDENTAL_OVERRIDE!>val x: Int<!>) : B()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\ninterface Foo<X> {\n    fun foo(x: X)\n}\n\nopen class FooImpl : Foo<String> {\n    override fun foo(x: String) {\n    }\n}\n\nopen class FooImpl2 : FooImpl() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo(x: Any)<!> {\n    }\n}\n"
        },
        {
            "code": "open class B {\n    val x: Int\n        get() = 1\n}\n\nclass C : B() {\n    <!ACCIDENTAL_OVERRIDE!>fun getX()<!> = 1\n}"
        },
        {
            "code": "interface B {\n    fun getX() = 1\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : B {\n    <!NOTHING_TO_OVERRIDE!>override<!> val x = 1\n}"
        },
        {
            "code": "open class B {\n    fun getX() = 1\n}\n\nclass C : B() {\n    val x: Int\n        <!ACCIDENTAL_OVERRIDE!>get()<!> = 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// KT-7174 Report error on members with the same signature as non-overridable methods from mapped Java types (like Object.wait/notify)\n\nclass A {\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun notify()<!> {}\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun notifyAll()<!> {}\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun wait()<!> {}\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun wait(l: Long)<!> {}\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun wait(l: Long, i: Int)<!> {}\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun getClass(): Class<Any><!> = null!!\n}\n\n<!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun notify()<!> {}\n<!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun notifyAll()<!> {}\n<!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun wait()<!> {}\n<!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun wait(l: Long)<!> {}\n<!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun wait(l: Long, i: Int)<!> {}\n<!CONFLICTING_INHERITED_JVM_DECLARATIONS!>fun getClass(): Class<Any><!> = null!!\n"
        },
        {
            "code": "enum class E {\n    ENTRY;\n\n    fun <!VIRTUAL_MEMBER_HIDDEN!>getDeclaringClass<!>() {}\n    fun <!VIRTUAL_MEMBER_HIDDEN!>finalize<!>() {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: K.kt\n\nopen class K : A() {\n    val a = 1\n    <!ACCIDENTAL_OVERRIDE!>fun foo()<!> {}\n    fun foo(i: Int) {}\n    fun baz(i: Int) {}\n\n    companion object {\n        fun foo() {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: K.kt\n\nopen class K : B() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo()<!> {}\n    fun foo(a: Any) {}\n    <!ACCIDENTAL_OVERRIDE!>fun bar(i: Int)<!> {}\n    fun bar(i: String) {}\n    fun baz(i: Int) {}\n\n    companion object {\n        fun foo() {}\n        fun bar(i: Int) {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: B.kt\n\nopen class B : A() {\n}\n\n// FILE: K.kt\n\nopen class K : C() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo()<!> {}\n    fun foo(a: Any) {}\n    <!ACCIDENTAL_OVERRIDE!>fun bar(i: Int)<!> {}\n    fun bar(i: String) {}\n    fun baz(i: Int) {}\n\n    companion object {\n        fun foo() {}\n        fun bar(i: Int) {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: foo/A.java\n\npackage foo;\n\npublic class A {\n    private static void foo(int s) {}\n    static void bar(double s) {}\n}\n\n// FILE: K.kt\nimport foo.A\n\nopen class K : A() {\n    fun foo(i: Int) {}\n    fun bar(d: Double) {}\n    fun baz(i: Int) {}\n\n    companion object {\n        fun foo(i: Int) {}\n        fun bar(d: Double) {}\n    }\n}\n"
        },
        {
            "code": "interface T {\n    <!CONFLICTING_JVM_DECLARATIONS!>val x: <!UNRESOLVED_REFERENCE!>ErrorType<!><!>\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX(): <!UNRESOLVED_REFERENCE!>ErrorType1<!><!>\n}"
        },
        {
            "code": "object C {\n    <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n}"
        },
        {
            "code": "class C(<!CONFLICTING_JVM_DECLARATIONS!>val x: Int<!>) {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n}"
        },
        {
            "code": "interface T {\n    val x: Int\n        <!CONFLICTING_JVM_DECLARATIONS!>get()<!> = 1\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n}"
        },
        {
            "code": "class C {\n    companion object {\n        <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n    }\n}"
        },
        {
            "code": "fun foo() {\n    class C {\n        <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n    }\n}"
        },
        {
            "code": "fun foo() =\n    object {\n        <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n    }"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun setX(x: Int)<!> {}\n\n    var x: Int = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>set(v)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: Any)<!> {}\n    <!CONFLICTING_JVM_DECLARATIONS!>fun Any.foo()<!> {}\n}\n"
        },
        {
            "code": "class C {\n    <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n}"
        },
        {
            "code": "<!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n<!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1"
        },
        {
            "code": "val x: Int\n    <!CONFLICTING_JVM_DECLARATIONS!>get()<!> = 1\n<!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1"
        },
        {
            "code": "class Outer {\n    fun foo() {\n        class C {\n            <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n            <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun setX(x: Int)<!> {}\n\n    <!CONFLICTING_JVM_DECLARATIONS!>var x: Int<!> = 1\n}"
        },
        {
            "code": "class Outer {\n    val x = object {\n        <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n    }\n}"
        },
        {
            "code": "class B {\n    class C {\n        <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>fun getX()<!> = 1\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun getX(t: Any)<!> = 1\n    val Any.x: Int\n        <!CONFLICTING_JVM_DECLARATIONS!>get()<!> = 1\n}\n"
        },
        {
            "code": "interface T {\n    fun getX() = 1\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : T {\n    <!CONFLICTING_JVM_DECLARATIONS!>val x<!> = 1\n}"
        },
        {
            "code": "interface T1 {\n    fun getX() = 1\n}\n\ninterface T2 {\n    val x: Int\n        get() = 1\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : T1, T2 {\n}"
        },
        {
            "code": "interface T {\n    fun getX() = 1\n}\n\ninterface <!CONFLICTING_JVM_DECLARATIONS!>C<!> : T {\n    val x: Int\n        get() = 1\n}\n"
        },
        {
            "code": "interface T {\n    val x: Int\n        get() = 1\n}\n\ninterface <!CONFLICTING_JVM_DECLARATIONS!>C<!> : T {\n    fun getX() = 1\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface B<T> {\n    fun foo(t: T) {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : B<String> {\n    override fun foo(t: String) {}\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(o: Any)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class B<T> {\n    open fun foo(t: T) {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : B<String>() {\n    override fun foo(t: String) {}\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(o: Any)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface B<T> {\n    fun foo(t: T) {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> : B<String> {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(o: Any)<!> {}\n}"
        },
        {
            "code": "class B {\n    companion object <!REDECLARATION!>A<!> {\n    }\n\n    val <!REDECLARATION!>A<!> = <!DEBUG_INFO_LEAKING_THIS!>this<!>\n}\n\nclass C {\n    companion <!CONFLICTING_JVM_DECLARATIONS!>object A<!> {\n        <!CONFLICTING_JVM_DECLARATIONS!>val A<!> = <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    }\n\n}\n"
        },
        {
            "code": "class C {\n    companion <!REDECLARATION!>object<!> {}\n\n    val <!REDECLARATION!>Companion<!> = C\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nenum class <!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>E<!> {\n    A;\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun values(): Array<E><!> = null!!\n    <!CONFLICTING_JVM_DECLARATIONS!>fun valueOf(s: String): E<!> = null!!\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ndata class <!CONFLICTING_JVM_DECLARATIONS!>C(val c: Int)<!> {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun `copy$default`(c: C, x: Int, m: Int, mh: Any)<!> = C(this.c)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\noperator fun Any.getValue(x: Any?, y: Any): Any = null!!\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C<!> {\n    val x by 1\n    <!CONFLICTING_JVM_DECLARATIONS!>val `$$delegatedProperties`: Array<KProperty<*>><!> = null!!\n}\n\nval x by 1\n<!CONFLICTING_JVM_DECLARATIONS!>val `$$delegatedProperties`: Array<KProperty<*>><!> = null!!\n"
        },
        {
            "code": "<!CONFLICTING_JVM_DECLARATIONS!>object O<!> {\n    <!CONFLICTING_JVM_DECLARATIONS!>val INSTANCE: O<!> = null!!\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    inner class <!CONFLICTING_JVM_DECLARATIONS!>D<!> {\n        <!CONFLICTING_JVM_DECLARATIONS!>val `this$0`: C?<!> = null\n    }\n}"
        },
        {
            "code": "class C {\n    companion object {\n        val X = 1\n        <!CONFLICTING_JVM_DECLARATIONS!>val `X$1`<!> = 1\n    }\n\n    <!CONFLICTING_JVM_DECLARATIONS!>val X<!> = 1\n}"
        },
        {
            "code": "interface Foo\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>Bar(f: Foo)<!> : Foo by f {\n    <!CONFLICTING_JVM_DECLARATIONS!>val `$$delegate_0`: Foo?<!> = null\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass C {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun `a$default`(c: C, x: Int, m: Int, mh: Any)<!> {}\n    <!CONFLICTING_JVM_DECLARATIONS!>fun a(x: Int = 1)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo<T> {\n    fun foo(l: List<T>) {}\n}\n\ninterface Bar<T> {\n    fun foo(l: List<T>) {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>Baz()<!>: Foo<String>, Bar<Int> {\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo<T> {\n    fun foo(l: List<T>) {}\n}\n\ninterface Bar<T> {\n    fun foo(l: List<T>) {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>Baz()<!>: Foo<String>, Bar<Int> {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(l: List<Long>)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo<T> {\n    fun foo(l: List<T>)\n}\n\ninterface Bar<T> {\n    fun foo(l: List<T>)\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>Baz(f: Foo<String>, b: Bar<Int>)<!>: Foo<String> by f, Bar<Int> by b {\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo<T> {\n    fun foo(l: List<T>)\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>Bar(f: Foo<String>)<!>: Foo<String> by f {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(l: List<Int>)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> foo(x: T): T<!> {null!!}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: Any): Any<!> {null!!}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\npublic open class A<T> {\n    fun foo(x: T) = \"O\"\n    fun foo(x: A<T>) = \"K\"\n}\n\ninterface C<E> {\n    fun foo(x: E): String\n    fun foo(x: A<E>): String\n}\n\ninterface D {\n    fun foo(x: A<String>): String\n}\n\nclass <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>B1<!> : A<A<String>>(), D\n\ninterface <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>B2<!> : C<A<String>>, D\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass G<T>\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: G<String>): G<Int><!> {null!!}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: G<Int>): G<String><!> {null!!}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo\ninterface Bar\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> foo(x: T): T<!> where T: Foo, T: Bar {null!!}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: Foo): Foo<!> {null!!}\nfun foo(x: Bar): Bar {null!!}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PLATFORM_CLASS_MAPPED_TO_KOTLIN\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(s: List<String>)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(s: java.util.List<String>)<!> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: String)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: String?)<!> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A<T> {\n    fun foo(l: List<T>)\n}\n\ninterface B {\n    fun foo(l: List<Int>) {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>C(f: A<String>)<!>: A<String> by f, B\n\n<!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE!>class D<!>(f: A<Int>): A<Int> by f, B"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo<T> {\n    fun foo(l: List<T>) {\n\n    }\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>Bar(f: Foo<String>)<!>: Foo<String> by f {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo(l: List<Int>)<!> {}\n}\n\nclass BarOther(f: Foo<String>): Foo<String> by f {\n    override fun foo(l: List<String>) {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(s: List<String>)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(s: MutableList<String>)<!> {}"
        },
        {
            "code": "class G<T>\n\nval <T> G<T>.foo: Int\n    <!CONFLICTING_JVM_DECLARATIONS!>get()<!> = 1\n\nval G<String>.foo: Int\n    <!CONFLICTING_JVM_DECLARATIONS!>get()<!> = 1"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo\ninterface Bar\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> foo(x: T): T<!> where T: Foo, T: Bar {null!!}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: Foo): Foo<!> {null!!}\nfun foo(x: Bar): Bar {null!!}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T: Foo> foo(x: T): T<!> {null!!}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(x: Foo): Foo<!> {null!!}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PLATFORM_CLASS_MAPPED_TO_KOTLIN\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(s: java.lang.String)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(s: String)<!> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -DUPLICATE_CLASS_NAMES\n<!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {\n\n}\n\n<!FUNCTION_DECLARATION_WITH_NO_NAME!>fun Outer.()<!> {\n\n}\n\n<!REDECLARATION!>val<!SYNTAX!><!> : Int = 1<!>\n\n<!REDECLARATION!>class<!SYNTAX!><!> {\n\n}<!>\n\nobject<!SYNTAX!><!> {\n\n}\n\ninterface<!SYNTAX!><!> {\n\n}\n\nenum class<!SYNTAX!><!> {\n\n}\n\nannotation class<!SYNTAX!><!> {\n\n}\n\nclass Outer {\n    <!FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {\n\n    }\n\n    <!REDECLARATION!>val<!SYNTAX!><!> : Int = 1<!>\n\n    <!REDECLARATION!>class<!SYNTAX!><!> {\n\n    }<!>\n\n    <!REDECLARATION!>object<!><!SYNTAX!><!> {\n\n    }\n\n    <!REDECLARATION!>interface<!SYNTAX!><!> {\n\n    }<!>\n\n    <!REDECLARATION!>enum class<!SYNTAX!><!> {\n\n    }<!>\n\n    <!REDECLARATION!>annotation class<!SYNTAX!><!> {\n\n    }<!>\n}\n\nfun outerFun() {\n    <!UNUSED_EXPRESSION!>fun () {\n\n    }<!>\n    <!UNUSED_EXPRESSION!>fun () {\n\n    }<!>\n}\n\n"
        },
        {
            "code": "enum class <!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>A<!> {\n    A1,\n    A2;\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun valueOf(s: String): A<!> = valueOf(s)\n\n    fun valueOf() = \"OK\"\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun values(): Array<A><!> = null!!\n\n    fun values(x: String) = x\n}\n"
        },
        {
            "code": "<!CONFLICTING_JVM_DECLARATIONS!>fun foo(vararg <!UNUSED_PARAMETER!>x<!>: Int)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(<!UNUSED_PARAMETER!>x<!>: IntArray)<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(vararg <!UNUSED_PARAMETER!>x<!>: Int?)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(<!UNUSED_PARAMETER!>x<!>: Array<Int>)<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(vararg <!UNUSED_PARAMETER!>nn<!>: Number)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun foo(<!UNUSED_PARAMETER!>nn<!>: Array<out Number>)<!> {}\n"
        },
        {
            "code": "<!CONFLICTING_JVM_DECLARATIONS!>val aa<!> = 1\n<!CONFLICTING_JVM_DECLARATIONS!>val Aa<!> = 1"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\ninterface MyTrait: <!INTERFACE_WITH_SUPERCLASS, PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!> {\n    override fun toString(): String\n    public override fun finalize()\n    <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>public <!OVERRIDING_FINAL_MEMBER!>override<!> fun wait()<!>\n}\n"
        },
        {
            "code": "class Test(foo: Any?, bar: Any?) {\n    val foo = foo ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bar = bar ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bas = bas()\n    val bas2 = bas2()\n\n    private fun bas(): Int = null!!\n    private fun bas2(): Int = null!!\n\n    fun bar() = bar(1)\n    fun bar(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n    private fun bar2() = bar2(1)\n    private fun bar2(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n}\n\n// KT-6413 Typechecker recursive problem when class have non-invariant generic parameters\nclass Test2<A, B, C>(foo: Any?, bar: Any?) {\n    val foo = foo ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bar = bar ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bas = bas()\n    val bas2 = bas2()\n\n    private fun bas(): Int = null!!\n    private fun bas2(): Int = null!!\n\n    fun bar() = bar(1)\n    fun bar(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n    private fun bar2() = bar2(1)\n    private fun bar2(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n}\n\nclass Test3<in A, B, C>(foo: Any?, bar: Any?) {\n    val foo = foo ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bar = bar ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bas = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bas<!>()<!>\n    val bas2 = bas2()\n\n    private fun bas(): Int = null!!\n    private fun bas2(): Int = null!!\n\n    fun bar() = bar(1)\n    fun bar(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n    private fun bar2() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar2<!>(1)<!>\n    private fun bar2(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n}\n\nclass Test4<A, out B, C>(foo: Any?, bar: Any?) {\n    val foo = foo ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bar = bar ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bas = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bas<!>()<!>\n    val bas2 = bas2()\n\n    private fun bas(): Int = null!!\n    private fun bas2(): Int = null!!\n\n    fun bar() = bar(1)\n    fun bar(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n    private fun bar2() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar2<!>(1)<!>\n    private fun bar2(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n}\n\nclass Test5<A, out B, C>(foo: Any?, bar: Any?) {\n    val foo = foo ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bar = bar ?: <!DEBUG_INFO_LEAKING_THIS!>this<!>\n    private val bas: Int = bas()\n    val bas2 = bas2()\n\n    private fun bas(): Int = null!!\n    private fun bas2(): Int = null!!\n\n    fun bar() = bar(1)\n    fun bar(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n    private fun bar2(): Int = bar2(1)\n    private fun bar2(<!UNUSED_PARAMETER!>i<!>: Int) = 2\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage qualified_expressions\n\nfun test(s: IntRange?) {\n   val <!UNUSED_VARIABLE!>a<!>: Int = <!TYPE_MISMATCH!>s?.start<!>\n   val b: Int? = s?.start\n   val <!UNUSED_VARIABLE!>c<!>: Int = s?.start ?: -11\n   val <!UNUSED_VARIABLE!>d<!>: Int = <!NI;TYPE_MISMATCH!>s?.start ?: <!OI;TYPE_MISMATCH!>\"empty\"<!><!>\n   val e: String = <!NI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>s?.start<!> ?: \"empty\"<!>\n   val <!UNUSED_VARIABLE!>f<!>: Int = s?.endInclusive ?: b ?: 1\n   val <!UNUSED_VARIABLE!>g<!>: Boolean? = e.startsWith(\"s\")//?.length\n}\n\nfun String.startsWith(<!UNUSED_PARAMETER!>s<!>: String): Boolean = true\n"
        },
        {
            "code": "abstract class My {\n    abstract var x: Int\n        <!REDUNDANT_MODIFIER_IN_GETTER!>public<!> get\n        <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n\n    abstract val y: Int\n        <!GETTER_VISIBILITY_DIFFERS_FROM_PROPERTY_VISIBILITY!>protected<!> get\n\n    abstract protected var z: Int\n        <!GETTER_VISIBILITY_DIFFERS_FROM_PROPERTY_VISIBILITY!>internal<!> get\n        <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n\n    abstract internal val w: Int\n        <!GETTER_VISIBILITY_DIFFERS_FROM_PROPERTY_VISIBILITY!>protected<!> get\n\n    abstract var u: Int\n        protected set\n\n    open var t: Int = 0\n        <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\nval la = { <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>a<!> -> }\nval las = { <!UNUSED_ANONYMOUS_PARAMETER!>a<!>: Int -> }\n\nval larg = { <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>a<!> -> }(123)\nval twoarg = { <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>a<!>, <!UNUSED_ANONYMOUS_PARAMETER!>b<!>: String, <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>c<!> -> }(123, \"asdf\", 123)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-7383 Assertion failed when a star-projection of function type is used\n\nfun foo() {\n    val f : Function1<*, *> = { x -> x.toString() }\n    <!OI;MEMBER_PROJECTED_OUT!>f<!>(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n}\n"
        },
        {
            "code": "fun unusedLiteral(){\n    <!UNUSED_LAMBDA_EXPRESSION!>{ ->\n        val <!UNUSED_VARIABLE!>i<!> = 1\n    }<!>\n}\n\n\nfun unusedLiteralInDoWhile(){\n    do<!UNUSED_LAMBDA_EXPRESSION!>{ ->\n            val <!UNUSED_VARIABLE!>i<!> = 1\n    }<!> while(false)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Foo\nfun (Foo.() -> Unit).invoke(b : Foo.() -> Unit)  {}\n\nobject Z {\n    infix fun add(b : Foo.() -> Unit) : Z = Z\n}\n\nval t2 = Z add <!TYPE_MISMATCH!>{ } <!TOO_MANY_ARGUMENTS!>{ }<!><!>\n"
        },
        {
            "code": "fun main() {\n    \"\".run {\n        <!UNUSED_LAMBDA_EXPRESSION!>{}<!>\n    }\n}\n\n\nfun <T> T.run(f: (T) -> Unit): Unit = f(this)\n"
        },
        {
            "code": "fun main() {\n    var list = listOf(1)\n\n    val a: Int? = 2\n\n    a?.let { list += it }\n}\n\noperator fun <T> Iterable<T>.plus(<!UNUSED_PARAMETER!>element<!>: T): List<T> = null!!\nfun <T> listOf(vararg <!UNUSED_PARAMETER!>values<!>: T): List<T> = null!!"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test(bal: Array<Int>) {\n    var bar = 4\n\n    val <!UNUSED_VARIABLE!>a<!>: () -> Unit = { bar += 4 }\n\n    val <!UNUSED_VARIABLE!>b<!>: () -> Int = { <!EXPECTED_TYPE_MISMATCH!>bar = 4<!> }\n\n    val <!UNUSED_VARIABLE!>c<!>: () -> <!UNRESOLVED_REFERENCE!>UNRESOLVED<!> = { bal[2] = 3 }\n\n    val <!UNUSED_VARIABLE!>d<!>: () -> Int = { <!ASSIGNMENT_TYPE_MISMATCH(\"Int\")!>bar += 4<!> }\n\n    val <!UNUSED_VARIABLE!>e<!>: Unit = run { bar += 4 }\n\n    val <!UNUSED_VARIABLE!>f<!>: Int = <!NI;TYPE_MISMATCH!>run { <!NI;TYPE_MISMATCH, OI;ASSIGNMENT_TYPE_MISMATCH!>bar += 4<!> }<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: -DestructuringLambdaParameters\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A(val x: Int, val y: String)\n\nfun foo(block: (A) -> Unit) { }\n\nfun bar() {\n    foo { <!UNSUPPORTED_FEATURE!>(a, b)<!> ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER\ndata class A(val x: Int, val y: String)\ndata class B(val u: Double, val w: Short)\n\nfun foo(block: (A) -> Unit) { }\nfun foobar(block: (A, B) -> Unit) { }\n\nfun bar() {\n    foo { (a, <!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>) ->\n        a checkType { _<Int>() }\n    }\n\n    foo { (<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>a<!>, b) ->\n        b checkType { _<String>() }\n    }\n\n    foo { (a: Int, <!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>: String) ->\n        a checkType { _<Int>() }\n    }\n\n    foo { (<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>a<!>: Int, b: String) ->\n        b checkType { _<String>() }\n    }\n\n    foobar { (a, <!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>), c ->\n        a checkType { _<Int>() }\n    }\n\n    foobar { a, (<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>, c) ->\n        c checkType { _<Short>() }\n    }\n\n    foobar { (a, <!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>), (<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>c<!>, d) ->\n        a checkType { _<Int>() }\n        d checkType { _<Short>() }\n    }\n\n    foobar { (<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>a<!>, b), (c, <!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>d<!>) ->\n        b checkType { _<String>() }\n        c checkType { _<Double>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A(val x: Int, val y: String)\ndata class B(val u: Double, val w: Short)\n\nfun foo(block: (A) -> Unit) { }\nfun foobar(block: (A, B) -> Unit) { }\n\nfun bar() {\n    foo { (a, b) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    foo { (a: Int, b: String) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    foo { (a, b): A ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    foobar { (a, b), c ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n        c checkType { _<B>() }\n    }\n\n    foobar { a, (b, c) ->\n        a checkType { _<A>() }\n        b checkType { _<Double>() }\n        c checkType { _<Short>() }\n    }\n\n    foobar { (a, b), (c, d) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n        c checkType { _<Double>() }\n        d checkType { _<Short>() }\n    }\n\n    foo { (<!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>a: String<!>, b) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    foo <!NI;TYPE_MISMATCH!>{ <!EXPECTED_PARAMETER_TYPE_MISMATCH!>(a, b): B<!> ->\n        a checkType { _<Double>() }\n        b checkType { _<Short>() }\n    }<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\ndata class A(val x: Int, val y: String)\n\nfun bar() {\n    val x = { (a, b): A ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    x checkType { _<(A) -> Unit>() }\n\n    val y = { (a: Int, b): A ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    y checkType { _<(A) -> Unit>() }\n\n    val y2 = { (a: Number, b): A ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    y2 checkType { _<(A) -> Unit>() }\n\n    val z = { <!CANNOT_INFER_PARAMETER_TYPE!>(a: Int, b: String)<!> ->\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><Int>() }\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><String>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A(val x: Int, val y: String)\ndata class B(val u: Double, val w: Short)\n\nfun <T> Iterable<T>.foo(x: (T) -> Unit) {}\n\nfun bar(aList: List<A>) {\n    aList.foo { (a, b) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    aList.foo { (a: Int, b: String) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    aList.foo { (a, b): A ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    aList.foo { (<!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>a: String<!>, b) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n\n    aList.<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>foo<!> { <!NI;EXPECTED_PARAMETER_TYPE_MISMATCH!>(a, b): B<!> ->\n        b checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><Int>() }\n        a checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A(val x: Int, val y: String)\ndata class B(val u: Double, val w: Short)\n\n// first parameter of the functional type of 'x' can only be inferred from a lambda parameter explicit type specification\nfun <X, Y> foo(y: Y, x: (X, Y) -> Unit) {}\n\nfun bar(aInstance: A, bInstance: B) {\n    foo(\"\") {\n        (a, b): A, c ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n        c checkType { _<String>() }\n    }\n\n    foo(aInstance) {\n        a: String, (b, c) ->\n        a checkType { _<String>() }\n        b checkType { _<Int>() }\n        c checkType { _<String>() }\n    }\n\n    foo(bInstance) {\n        (a, b): A, (c, d) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n        c checkType { _<Double>() }\n        d checkType { _<Short>() }\n    }\n\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(bInstance) {\n        <!CANNOT_INFER_PARAMETER_TYPE!>(a, b)<!>, (c, d) ->\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><Int>() }\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>b<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><String>() }\n        c checkType { _<Double>() }\n        d checkType { _<Short>() }\n    }\n\n    foo<A, B>(bInstance) {\n        (a, b), (c, d) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n        c checkType { _<Double>() }\n        d checkType { _<Short>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A(val x: Int, val y: String)\ndata class B(val u: Double, val w: Short)\n\nfun foo(block: (A) -> Unit) { }\n\nfun bar() {\n    foo { (_, b) ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n        b checkType { _<String>() }\n    }\n\n    foo { (a, _) ->\n        a checkType { _<Int>() }\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { (_, _) ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { (_: Int, b: String) ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n        b checkType { _<String>() }\n    }\n\n    foo { (a: Int, _: String) ->\n        a checkType { _<Int>() }\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { (_: Int, _: String) ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { (_, _): A ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { (`_`, _) ->\n        _ checkType { _<Int>() }\n    }\n\n    foo { (_, `_`) ->\n        _ checkType { _<String>() }\n    }\n\n    foo { (<!REDECLARATION, UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>`_`<!>, <!REDECLARATION!>`_`<!>) ->\n        _ checkType { _<String>() }\n    }\n\n    foo { (<!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>_: String<!>, b) ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n        b checkType { _<String>() }\n    }\n\n    foo <!NI;TYPE_MISMATCH!>{ <!EXPECTED_PARAMETER_TYPE_MISMATCH!>(_, b): B<!> ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n        b checkType { _<Short>() }\n    }<!>\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A(val x: Int, val y: String)\n\nfun foo(block: (A) -> Unit) { }\n\n@Target(AnnotationTarget.VALUE_PARAMETER)\nannotation class Ann\n\nfun bar() {\n    foo { (<!WRONG_MODIFIER_TARGET!>private<!> <!WRONG_MODIFIER_TARGET!>inline<!> a, <!WRONG_ANNOTATION_TARGET!>@Ann<!> b) ->\n        a checkType { _<Int>() }\n        b checkType { _<String>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER\ndata class A(val x: Int, val y: String)\ndata class B(val u: Double, val w: Short)\n\nfun foo(block: (A, B) -> Unit) { }\n\nfun bar() {\n    foo { (<!REDECLARATION, UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>a<!>, <!REDECLARATION!>a<!>), b ->\n        a checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><Int>() }\n        b checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String>() }\n    }\n\n    foo { (<!REDECLARATION, UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>a<!>, b), <!REDECLARATION!>a<!> ->\n        a checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><Int>() }\n        b checkType { _<String>() }\n    }\n\n    foo { <!REDECLARATION!>a<!>, (<!REDECLARATION!>a<!>, b) ->\n        a checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><Int>() }\n        b checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String>() }\n    }\n\n    foo { (a, <!REDECLARATION, UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>), (c, <!REDECLARATION!>b<!>) ->\n        a checkType { _<Int>() }\n        b checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String>() }\n        c checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><B>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval receiver = { Int.(<!SYNTAX!><!>) <!SYNTAX!>-><!> }\nval receiverWithParameter = { Int.<!ILLEGAL_SELECTOR!>(<!UNRESOLVED_REFERENCE!>a<!>)<!> <!SYNTAX!>-><!> }\n\nval receiverAndReturnType = { Int.(<!SYNTAX!><!>)<!SYNTAX!>: Int ->  5<!> }\nval receiverAndReturnTypeWithParameter = { Int.(<!UNRESOLVED_REFERENCE!>a<!><!SYNTAX!><!SYNTAX!><!>: Int): Int ->  5<!> }\n\nval returnType = { (<!SYNTAX!><!>): Int -> 5 }\nval returnTypeWithParameter = { (<!COMPONENT_FUNCTION_MISSING!><!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>: Int<!>): Int -> 5 }\n\nval receiverWithFunctionType = { ((Int)<!SYNTAX!><!> <!SYNTAX!>-> Int).() -><!> }\n\nval parenthesizedParameters = { <!CANNOT_INFER_PARAMETER_TYPE!>(<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>a<!>: Int)<!> -> }\nval parenthesizedParameters2 = { <!CANNOT_INFER_PARAMETER_TYPE!>(<!UNUSED_DESTRUCTURED_PARAMETER_ENTRY!>b<!>)<!> -> }\n\nval none = { -> }\n\n\nval parameterWithFunctionType = { a: ((Int) -> Int) -> <!SYNTAX!><!>} // todo fix parser\n\nval newSyntax = { <!UNUSED_ANONYMOUS_PARAMETER!>a<!>: Int -> }\nval newSyntax1 = { <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>a<!>, <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>b<!> -> }\nval newSyntax2 = { <!UNUSED_ANONYMOUS_PARAMETER!>a<!>: Int, <!UNUSED_ANONYMOUS_PARAMETER!>b<!>: Int -> }\nval newSyntax3 = { <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>a<!>, <!UNUSED_ANONYMOUS_PARAMETER!>b<!>: Int -> }\nval newSyntax4 = { <!UNUSED_ANONYMOUS_PARAMETER!>a<!>: Int, <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>b<!> -> }\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nval flag = true\n\n// type of a was checked by txt\nval a = run { // () -> Unit\n    return@run\n}\n\n// Unit\nval b = run {\n    if (flag) return@run\n    <!UNUSED_EXPRESSION!>5<!>\n}\n\n// Unit\nval c = run {\n    if (flag) return@run\n\n    return@run <!RETURN_TYPE_MISMATCH!>4<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test() {\n    run {<!RETURN_NOT_ALLOWED!>return<!>}\n    run {}\n}\n\nfun test2() {\n    run {<!RETURN_NOT_ALLOWED!>return@test2<!>}\n    run {}\n}\n\nfun test3() {\n    fun test4() {\n        run {<!RETURN_NOT_ALLOWED!>return@test3<!>}\n        run {}\n    }\n}\n\nfun <T> run(f: () -> T): T { return f() }\n"
        },
        {
            "code": "val flag = true\n\n// type of a was checked by txt\nval a/*: () -> Any*/ = l@ {\n    <!INVALID_IF_AS_EXPRESSION!>if<!> (flag) return@l 4\n}\n\nval b/*: () -> Int */ = l@ {\n    if (flag) return@l 4\n    5\n}\n\nval c/*: () -> Unit */ = l@ {\n    if (flag) <!UNUSED_EXPRESSION!>4<!>\n}"
        },
        {
            "code": "fun f() {\n    foo {\n        return@foo 1\n    }\n    foo({\n        return@foo 1\n    }\n    )\n    foo(a = {\n        return@foo 1\n    })\n\n    foo {\n        foo {\n            return<!LABEL_NAME_CLASH!>@foo<!> 1\n        }\n        return@foo 1\n    }\n}\n\nfun foo(<!UNUSED_PARAMETER!>a<!>: Any) {}\n\n"
        },
        {
            "code": "// KT-6822 Smart cast doesn't work inside local returned expression in lambda\n\nval a : (Int?) -> Int = l@ {\n    if (it != null) return@l <!DEBUG_INFO_SMARTCAST!>it<!>\n    5\n}\n\nfun <R> let(<!UNUSED_PARAMETER!>f<!>: (Int?) -> R): R = null!!\n\nval b: Int = let {\n    if (it != null) return@let <!DEBUG_INFO_SMARTCAST!>it<!>\n    5\n}\n\nval c: Int = let {\n    if (it != null) <!DEBUG_INFO_SMARTCAST!>it<!> else 5\n}\n"
        },
        {
            "code": "val flag = true\n\n// type of lambda was checked by txt\nval a = b@ { // () -> Unit\n    if (flag) return@b\n    else <!UNUSED_EXPRESSION!>54<!>\n}"
        },
        {
            "code": "val a = l@ {\n    return@l <!UNRESOLVED_REFERENCE!>r<!>\n}\n\nval b = l@ {\n    if (\"\" == \"OK\") return@l\n\n    return@l <!RETURN_TYPE_MISMATCH, UNRESOLVED_REFERENCE!>r<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun test() {\n    run f@{\n        <!UNREACHABLE_CODE!>checkSubtype<Nothing>(<!>return@f 1<!UNREACHABLE_CODE!>)<!>\n    }\n}\n"
        },
        {
            "code": "fun <T> listOf(): List<T> = null!!\nfun <T> listOf(vararg <!UNUSED_PARAMETER!>values<!>: T): List<T> = null!!\n\nval flag = true\n\nval a: () -> List<Int> = l@ {\n    if (flag) return@l listOf()\n    listOf(5)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun <T, R> Iterable<T>.map(<!UNUSED_PARAMETER!>transform<!>: (T) -> R): List<R> = null!!\nfun <T> listOf(): List<T> = null!!\nfun <T> listOf(vararg <!UNUSED_PARAMETER!>values<!>: T): List<T> = null!!\n\nfun commonSystemFailed(a: List<Int>) {\n    a.map {\n        if (it == 0) return@map listOf(it)\n        <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>listOf<!>()\n    }\n    a.map {\n        if (it == 0) return@map <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>listOf<!>()\n        listOf(it)\n    }\n    a.map {\n        if (it == 0) listOf()\n        else listOf(it)\n    }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun test2(a: Int) {\n    val x = run f@{\n      if (a > 0) <!RETURN_NOT_ALLOWED!>return<!>\n      return@f 1\n    }\n    checkSubtype<Int>(x)\n}\n\nfun <T> run(f: () -> T): T { return f() }"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test(a: Int) {\n    run f@{\n      if (a > 0) return@f\n      else return@f <!RETURN_TYPE_MISMATCH!>1<!>\n    }\n}\n"
        },
        {
            "code": "val flag = true\n\nval a = b@ {\n    if (flag) return@b <!RETURN_TYPE_MISMATCH!>4<!>\n    return@b\n}"
        },
        {
            "code": "val flag = true\n\nval a: () -> Int = l@ {\n    <!TYPE_MISMATCH!><!INVALID_IF_AS_EXPRESSION!>if<!> (flag) return@l 4<!>\n}\n\nval b: () -> Unit = l@ {\n    if (flag) return@l <!CONSTANT_EXPECTED_TYPE_MISMATCH!>4<!>\n}\n\nval c: () -> Any = l@ {\n    <!INVALID_IF_AS_EXPRESSION!>if<!> (flag) return@l 4\n}\n\nval d: () -> Int = l@ {\n    if (flag) return@l 4\n    5\n}\n\nval e: () -> Int = l@ {\n    <!TYPE_MISMATCH!>if (flag) <!UNUSED_EXPRESSION!>4<!><!>\n}"
        },
        {
            "code": "fun f() {\n    foo {\n        bar {\n            <!RETURN_NOT_ALLOWED!>return@foo<!> 1\n        }\n        return@foo 1\n    }\n}\n\nfun foo(<!UNUSED_PARAMETER!>a<!>: Any) {}\nfun bar(<!UNUSED_PARAMETER!>a<!>: Any) {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test(a: Int) {\n    run<Int>f@{\n      if (a > 0) return@f <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>\"\"<!>\n      return@f 1\n    }\n\n    run<Int>{ <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>\"\"<!> }\n    run<Int>{ 1 }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n// KT-6822 Smart cast doesn't work inside local returned expression in lambda \n\nval a /* :(Int?) -> Int? */ = l@ { it: Int? -> // but must be (Int?) -> Int\n    if (it != null) return@l it\n    5\n}\n\nfun <R> let(<!UNUSED_PARAMETER!>f<!>: (Int?) -> R): R = null!!\n\nval b /*: Int? */ = let { // but must be Int\n    if (it != null) return@let <!NI;DEBUG_INFO_SMARTCAST!>it<!>\n    5\n}\n\nval c /*: Int*/ = let {\n    if (it != null) <!DEBUG_INFO_SMARTCAST!>it<!> else 5\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\n// FILE: Main.kt\nfun process(<!UNUSED_PARAMETER!>x<!>: Predicate<String>) {}\nfun main() {\n    process(Predicate { x -> x checkType { _<String>() }\n        true\n    })\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER\npackage a\n\ninterface Super\ninterface Trait : Super\nclass Sub : Trait\n\nfun foo(f: (Trait) -> Trait) = f\n\nfun test(s: Sub) {\n    foo {\n        t: Super -> s\n    }\n    foo {\n        t: Trait -> s\n    }\n\n    foo(<!TYPE_MISMATCH!>fun(<!EXPECTED_PARAMETER_TYPE_MISMATCH!>t: Sub<!>) = s<!>)\n    foo(<!TYPE_MISMATCH!>fun(t): Super = s<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage m\n\ninterface Element\n\nfun test(handlers: Map<String, Element.()->Unit>) {\n\n    handlers.getOrElse(\"name\", l@ { return@l <!OI;NULL_FOR_NONNULL_TYPE!>null<!> })\n}\n\nfun <K,V> Map<K,V>.getOrElse(key: K, defaultValue: ()-> V) : V = throw Exception(\"$key $defaultValue\")"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nfun foo0(f: () -> String) = f\nfun foo1(f: (Int) -> String) = f\nfun foo2(f: (Int, String) -> String) = f\n\nfun test1() {\n    foo0 {\n        \"\"\n    }\n    foo0 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!UNUSED_ANONYMOUS_PARAMETER!>s<!>: String<!>-> \"\"\n    }<!>\n    foo0 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>x<!>, <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>y<!><!> -> \"\"\n    }<!>\n\n    foo1 {\n        \"\"\n    }\n    foo1 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETER_TYPE_MISMATCH!><!UNUSED_ANONYMOUS_PARAMETER!>s<!>: String<!> -> \"\"\n    }<!>\n    foo1 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!UNUSED_ANONYMOUS_PARAMETER!>x<!>, <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>y<!><!> -> \"\"\n    }<!>\n    foo1 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!>-> <!CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n    }<!>\n\n\n    foo2 <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>{<!>\n        \"\"\n    }\n    foo2 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETERS_NUMBER_MISMATCH, EXPECTED_PARAMETER_TYPE_MISMATCH!><!UNUSED_ANONYMOUS_PARAMETER!>s<!>: String<!> -> \"\"\n    }<!>\n    foo2 <!NI;TYPE_MISMATCH!>{\n        <!EXPECTED_PARAMETERS_NUMBER_MISMATCH, UNUSED_ANONYMOUS_PARAMETER!>x<!> -> \"\"\n    }<!>\n    foo2 <!NI;TYPE_MISMATCH!>{\n         <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!>-> <!CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n    }<!>\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(<!UNUSED_PARAMETER!>block<!>: (Int, String) -> Unit) { }\nfun foobar(<!UNUSED_PARAMETER!>block<!>: (Double) -> Unit) { }\n\nfun bar() {\n    foo { _, b ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n        b checkType { _<String>() }\n    }\n\n    foo { a, _ ->\n        a checkType { _<Int>() }\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { _, _ ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { _: Int, b: String ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n        b checkType { _<String>() }\n    }\n\n    foo { a: Int, _: String ->\n        a checkType { _<Int>() }\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { _: Int, _: String ->\n        <!UNRESOLVED_REFERENCE!>_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>()\n    }\n\n    foo { `_`, _ ->\n        _ checkType { _<Int>() }\n    }\n\n    foo { _, `_` ->\n        _ checkType { _<String>() }\n    }\n\n    foo { <!REDECLARATION, REDECLARATION, UNUSED_ANONYMOUS_PARAMETER!>`_`<!>, <!REDECLARATION, REDECLARATION!>`_`<!> ->\n        _ checkType { _<String>() }\n    }\n\n    foo(fun(<!UNUSED_ANONYMOUS_PARAMETER!>x<!>: Int, _: String) {})\n}\n"
        },
        {
            "code": "// See KT-7813: Call to functional parameter with missing argument: no error detected but compiler crashes\n\nfun foo(p: (Int, () -> Int) -> Unit) {\n    // Errors except last call\n    <!NO_VALUE_FOR_PARAMETER!>p<!> { 1 }\n    p(<!NO_VALUE_FOR_PARAMETER!>)<!> { 2 }\n    p(3) { 4 }\n}\n\nfun bar(p: (String, Any, () -> String) -> Unit) {\n    // Errors except last call\n    <!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>p<!> { \"\" }\n    p(<!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!> { \"x\" }\n    p(\"y\"<!NO_VALUE_FOR_PARAMETER!>)<!> { \"z\" }\n    p(\"v\", Any()) { \"w\" }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage h\n\n//traits to make ambiguity with function literal as an argument\ninterface A\ninterface B\ninterface C: A, B\n\nfun <T> foo(<!UNUSED_PARAMETER!>a<!>: A, f: () -> T): T = f()\nfun <T> foo(<!UNUSED_PARAMETER!>b<!>: B, f: () -> T): T = f()\n\nfun test(c: C) {\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>foo<!>(c) f@ {\n        c<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n}\n"
        },
        {
            "code": "// KT-3343 Type mismatch when function literal consists of try-catch with Int returning call, and Unit is expected\n\nfun main() {\n    \"hello world\".prt{\n        try{\n            print(it)\n            log(\"we are printing\")\n        }\n        catch(e : Exception){\n            log(\"Exception\")\n        }\n    }\n}\n\nfun log(str : String) : Int{\n    print(\"logging $str\")\n    return 0\n}\n\nfun print(<!UNUSED_PARAMETER!>obj<!>: Any) {}\n\n\nfun String.prt(action : (String) -> Unit){\n    action(this)\n}"
        },
        {
            "code": "class Log\n\ndata class CalculatedVariable(\n    val idString: String,\n    val presentableName: String,\n    val units: String,\n    val function: (Log) -> ((TimeIndex) -> Any?)?,\n    val converter: (Any) -> Double\n) {\n    constructor(idString: String, presentableName: String, units: String, function: (Log) -> ((TimeIndex) -> Double?)?)\n            : this(idString, presentableName, units, function, { it as Double })\n}\n\nobject CalculatedVariables {\n    val x = CalculatedVariable(\n        \"A\",\n        \"B\",\n        \"C\",\n        fun(<!UNUSED_ANONYMOUS_PARAMETER!>log<!>: Log): ((TimeIndex) -> Double?)? {\n            return { 0.0 }\n        }\n    )\n}\n\nclass TimeIndex"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface Predicate<T>\n\nfun <T> Predicate(<!UNUSED_PARAMETER!>x<!>: (T?) -> Boolean): Predicate<T> = null!!\n\nfun foo() {\n    process(Predicate {\n        x -> x checkType { _<String?>() }\n\n        true\n    })\n}\n\nfun process(<!UNUSED_PARAMETER!>x<!>: Predicate<String>) {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n// See KT-13401: SOE in VarianceChecker\n\ninterface Rec<T: Rec<T>> {\n    fun t(): T\n}\ninterface Super<out U> {\n    fun foo(p: Rec<*>) = p.t()\n}\n// Related variance errors\nclass Owner<in T> {\n    inner class Inner<U : <!TYPE_VARIANCE_CONFLICT!>T<!>>(val u: U) {\n        fun getT() = u\n    }\n\n    fun foo(arg: Inner<*>) = arg.getT()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test() {\n  if (<!UNRESOLVED_REFERENCE!>x<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>><!> 0) {\n\n  }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -DEPRECATION -TOPLEVEL_TYPEALIASES_ONLY\n\n<!UNDERSCORE_IS_RESERVED!>import kotlin.Deprecated as ___<!>\n\n@___(\"\") data class Pair(val x: Int, val y: Int)\n\nclass <!UNDERSCORE_IS_RESERVED!>_<!><<!UNDERSCORE_IS_RESERVED!>________<!>>\nval <!UNDERSCORE_IS_RESERVED!>______<!> = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!><Int>()\n\nfun <!UNDERSCORE_IS_RESERVED!>__<!>(<!UNDERSCORE_IS_RESERVED!>___<!>: Int, y: <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!><Int>?): Int {\n    val (_, <!UNUSED_VARIABLE!>z<!>) = Pair(<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>___<!> - 1, 42)\n    val (x, <!UNDERSCORE_IS_RESERVED!>__________<!>) = Pair(<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>___<!> - 1, 42)\n    val <!UNDERSCORE_IS_RESERVED!>____<!> = x\n    // in backquotes: allowed\n    val `_` = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__________<!>\n\n    val q = fun(_: Int, <!UNDERSCORE_IS_RESERVED, UNUSED_ANONYMOUS_PARAMETER!>__<!>: Int) {}\n    q(1, 2)\n\n    val <!UNDERSCORE_IS_RESERVED!>_<!> = 56\n\n    fun localFun(<!UNDERSCORE_IS_RESERVED!>_<!>: String) = 1\n\n    <!REDUNDANT_LABEL_WARNING!><!UNDERSCORE_IS_RESERVED!>__<!>@<!> return if (y != null) <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>(<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>____<!>, y) else <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>(`_`, <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>______<!>)\n}\n\n\nclass A1(val <!UNDERSCORE_IS_RESERVED, UNDERSCORE_IS_RESERVED!>_<!>: String)\nclass A2(<!UNDERSCORE_IS_RESERVED!>_<!>: String) {\n    class B {\n        typealias <!UNDERSCORE_IS_RESERVED!>_<!> = CharSequence\n    }\n    val <!UNDERSCORE_IS_RESERVED!>_<!>: Int = 1\n\n    fun <!UNDERSCORE_IS_RESERVED!>_<!>() {}\n\n    fun foo(<!UNDERSCORE_IS_RESERVED!>_<!>: Double) {}\n}\n\n// one underscore parameters for named function are still prohibited\nfun oneUnderscore(<!UNDERSCORE_IS_RESERVED!>_<!>: Int) {}\n\nfun doIt(f: (Any?) -> Any?) = f(null)\n\nval something = doIt { <!UNDERSCORE_IS_RESERVED!>__<!> -> <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!> }\nval something2 = doIt { _ -> 1 }\n"
        },
        {
            "code": "private var x = object {}\n\nfun test() {\n    x = <!TYPE_MISMATCH!>object<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: 1.kt\nclass C: B()\n\nclass D: B(), A<String>\nclass E: B(), A<String?>\n\nfun eatAString(a: A<String>) {}\nfun eatAStringN(a: A<String?>) {}\n\nfun test(b: B, c: C, d: D, e: E) {\n    eatAString(b)\n    eatAString(c)\n    eatAString(d)\n    eatAString(<!TYPE_MISMATCH!>e<!>)\n\n    eatAStringN(b)\n    eatAStringN(c)\n    eatAStringN(<!TYPE_MISMATCH!>d<!>)\n    eatAStringN(e)\n}\n\n// FILE: 3.kt\n\ninterface X : A<String>\ninterface Y: X\ninterface Z: X\n\nclass W: B(), Z\n\nfun test2(w: W) {\n    eatAString(w)\n    eatAStringN(<!TYPE_MISMATCH!>w<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER\n\npackage p\n\nprivate fun foo(a: Int) = run {\n    object {\n        inner class A\n        fun foo() = A()\n    }.foo()\n}\n\nprivate fun foo() = run {\n    object {\n        inner class A\n        fun foo() = A()\n    }.foo()\n}\n\nfun test() {\n    var x = foo(1)\n    x = <!TYPE_MISMATCH!>foo()<!>\n}"
        },
        {
            "code": "//KT-304: Resolve supertype reference to class anyway\n\nopen class Foo() : <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Bar<!>() {\n}\n\nopen class Bar<T>() {\n}"
        },
        {
            "code": "class Test {\n    private var x = object {};\n    init {\n        x = <!TYPE_MISMATCH!>object<!> {}\n    }\n}"
        },
        {
            "code": "class A : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>Double.() -> Unit<!> {\n    override fun invoke(p1: Double) {}\n}\n\nclass B : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>Int.(Double) -> Unit<!> {\n    override fun invoke(p1: Int, p2: Double) {}\n}\n\nopen class C {}\n\nabstract class A0 : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>C.() -> Int<!>\nabstract class A1 : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>C.(Int) -> Int<!>\nabstract class A2 : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>C.(Int, String) -> Int<!>\n\nopen class D<T> {}\n\nabstract class B0<T> : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>D<T>.() -> Int<!>\nabstract class B1<T> : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>D<T>.(C) -> Int<!>\nabstract class B2<T> : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>D<T>.(T, C) -> T<!>\n\ninterface E<T> {}\n\nabstract class C0: C(), <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>Int.() -> Double<!>\nabstract class C1<T>: C(), E<T>, <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>Int.(C) -> Double<!>"
        },
        {
            "code": "interface Super {\n    var v: CharSequence\n    val v2: CharSequence\n}\n\nclass Sub: Super {\n    override var v: <!VAR_TYPE_MISMATCH_ON_OVERRIDE!>String<!> = \"fail\"\n    override val v2: String = \"ok\"\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER\n\npackage p\n\nprivate fun foo(a: Int) = run {\n    class A {\n        inner class B\n    }\n    A().B()\n}\n\nprivate fun foo() = run {\n    class A {\n        inner class B\n    }\n    A().B()\n}\n\nfun test() {\n    var x = foo(1)\n    x = <!TYPE_MISMATCH!>foo()<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE\nfun test() {\n    var x = object {}\n    x = <!TYPE_MISMATCH!>object<!> {}\n}"
        },
        {
            "code": "class X : <!UNRESOLVED_REFERENCE!>S<!>\n\nfun f(<!UNUSED_PARAMETER!>l<!>: List<X>) {}\n"
        },
        {
            "code": "interface A1 : <!UNRESOLVED_REFERENCE!>B<!>\n\ninterface A2 : <!UNRESOLVED_REFERENCE!>B<!><!SUPERTYPE_INITIALIZED_IN_INTERFACE!>()<!>\n\nclass A3 : <!UNRESOLVED_REFERENCE!>B<!>, <!UNRESOLVED_REFERENCE!>B<!>\n\nenum class A4 : <!UNRESOLVED_REFERENCE!>B<!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER\n\npackage p\n\nprivate fun foo(a: Int) = run {\n    class A\n    A()\n}\n\nprivate fun foo() = run {\n    class A\n    A()\n}\n\nfun test() {\n    var x = foo(1)\n    x = <!TYPE_MISMATCH!>foo()<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninterface X<T>\ninterface A: X<String>\ninterface B : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>A, X<Int><!>\n\nfun foo(x: B) {\n    // Checks that when checking subtypes we search closes corresponding constructor (e.g. with BFS)\n    val y: X<Int> = x\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A() {\n    override fun equals(other : Any?) : Boolean = false\n}\n\nfun f(): Unit {\n    var x: Int? = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>1<!>\n    x = null\n    <!OI;DEBUG_INFO_CONSTANT!>x<!> + 1\n    <!DEBUG_INFO_CONSTANT!>x<!> <!INFIX_MODIFIER_REQUIRED!>plus<!> 1\n    <!DEBUG_INFO_CONSTANT!>x<!> <!UNSAFE_OPERATOR_CALL!><<!> 1\n    <!TYPE_MISMATCH!><!OI;DEBUG_INFO_CONSTANT!>x<!> += 1<!>\n\n    <!DEBUG_INFO_CONSTANT!>x<!> == 1\n    <!DEBUG_INFO_CONSTANT!>x<!> != 1\n\n    <!EQUALITY_NOT_APPLICABLE!>A() == 1<!>\n\n    <!EQUALITY_NOT_APPLICABLE!><!DEBUG_INFO_CONSTANT!>x<!> === \"1\"<!>\n    <!EQUALITY_NOT_APPLICABLE!><!DEBUG_INFO_CONSTANT!>x<!> !== \"1\"<!>\n\n    <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!><!DEBUG_INFO_CONSTANT!>x<!> === 1<!>\n    <!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!><!DEBUG_INFO_CONSTANT!>x<!> !== 1<!>\n\n    <!OI;DEBUG_INFO_CONSTANT!>x<!><!UNSAFE_OPERATOR_CALL!>..<!>2\n    <!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!> in 1..2\n\n    val y : Boolean? = true\n    <!UNUSED_EXPRESSION!>false || <!TYPE_MISMATCH!>y<!><!>\n    <!UNUSED_EXPRESSION!><!TYPE_MISMATCH!>y<!> && true<!>\n    <!UNUSED_EXPRESSION!><!TYPE_MISMATCH!>y<!> && <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!><!>\n}"
        },
        {
            "code": "public interface ITest {\n    public var prop : Int\n        get() = 12\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nabstract class ATest {\n    protected open var prop2 : Int\n        get() = 13\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nclass Test: ATest(), ITest {\n    override var prop : Int\n        get() = 12\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>private<!> set(<!UNUSED_PARAMETER!>value<!>) {}\n\n    override var prop2 : Int\n        get() = 14\n        <!CANNOT_CHANGE_ACCESS_PRIVILEGE, SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>internal<!> set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nfun main() {\n    val test = Test()\n    <!INVISIBLE_SETTER!>test.prop<!> = 12\n\n    val itest: ITest = test\n    itest.prop = 12 // No error here\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage variance\n\nabstract class Consumer<in T> {}\n\nabstract class Producer<out T> {}\n\nabstract class Usual<T> {}\n\nfun foo(c: Consumer<Int>, p: Producer<Int>, u: Usual<Int>) {\n    val c1: Consumer<Any> = <!TYPE_MISMATCH!>c<!>\n    val <!UNUSED_VARIABLE!>c2<!>: Consumer<Int> = c1\n\n    val p1: Producer<Any> = p\n    val <!UNUSED_VARIABLE!>p2<!>: Producer<Int> = <!TYPE_MISMATCH!>p1<!>\n\n    val u1: Usual<Any> = <!TYPE_MISMATCH!>u<!>\n    val <!UNUSED_VARIABLE!>u2<!>: Usual<Int> = <!TYPE_MISMATCH!>u1<!>\n}\n\n//Arrays copy example\nclass Array<T>(val length : Int, val t : T) {\n    fun get(<!UNUSED_PARAMETER!>index<!> : Int) : T { return t }\n    fun set(<!UNUSED_PARAMETER!>index<!> : Int, <!UNUSED_PARAMETER!>value<!> : T) { /* ... */ }\n}\n\nfun copy1(<!UNUSED_PARAMETER!>from<!> : Array<Any>, <!UNUSED_PARAMETER!>to<!> : Array<Any>) {}\n\nfun copy2(<!UNUSED_PARAMETER!>from<!> : Array<out Any>, <!UNUSED_PARAMETER!>to<!> : Array<in Any>) {}\n\nfun <T> copy3(<!UNUSED_PARAMETER!>from<!> : Array<out T>, <!UNUSED_PARAMETER!>to<!> : Array<in T>) {}\n\nfun copy4(<!UNUSED_PARAMETER!>from<!> : Array<out Number>, <!UNUSED_PARAMETER!>to<!> : Array<in Int>) {}\n\nfun f(ints: Array<Int>, any: Array<Any>, numbers: Array<Number>) {\n    copy1(<!TYPE_MISMATCH!>ints<!>, any)\n    copy2(ints, any) //ok\n    copy2(ints, <!TYPE_MISMATCH!>numbers<!>)\n    copy3<Int>(ints, numbers)\n    copy4(ints, numbers) //ok\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowBreakAndContinueInsideWhen\n\nfun breakContinueInWhen(i: Int) {\n    for (y in 0..10) {\n        when(i) {\n            0 -> continue\n            1 -> break\n            2 -> {\n                for(z in 0..10) {\n                    break\n                }\n                for(w in 0..10) {\n                    continue\n                }\n            }\n        }\n    }\n}\n\n\nfun breakContinueInWhenWithWhile(i: Int, j: Int) {\n    while (i > 0) {\n        when (i) {\n            0 -> continue\n            1 -> break\n            2 -> {\n                while (j > 0) {\n                    break\n                }\n            }\n        }\n    }\n}\n\nfun breakContinueInWhenWithDoWhile(i: Int, j: Int) {\n    do {\n        when (i) {\n            0 -> continue\n            1 -> break\n            2 -> {\n                do {\n                    if (j == 5) break\n                    if (j == 10) continue\n                } while (j > 0)\n            }\n        }\n    } while (i > 0)\n}\n\nfun labeledBreakContinue(i: Int) {\n    outer@ for (y in 0..10) {\n        when (i) {\n            0 -> continue@outer\n            1 -> break@outer\n        }\n    }\n}\n\nfun testBreakContinueInWhenInWhileCondition() {\n    var i = 0\n    while (\n        when (i) {\n            1 -> <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break<!>\n            2 -> <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>\n            else -> true\n        }\n    ) {\n        ++i\n    }\n}\n\nfun testBreakContinueInWhenInDoWhileCondition() {\n    var i = 0\n    do {\n        ++i\n    } while (\n        when (i) {\n            1 -> <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break<!>\n            2 -> <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>\n            else -> true\n        }\n    )\n}\n\nfun testBreakContinueInWhenInForIteratorExpression(xs: List<Any>, i: Int) {\n    for (x in when (i) {\n        1 -> <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break<!>\n        2 -> <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>\n        else -> xs\n    }) {\n    }\n}"
        },
        {
            "code": "fun Any.foo1() : (i : Int) -> Unit {\n    return {}\n}\n\nfun test(a : Any) {\n    a.foo1()(<!NO_VALUE_FOR_PARAMETER(\"i\")!>)<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// Fixpoint generic in Java: Enum<T extends Enum<T>>\nfun test(<!UNUSED_PARAMETER!>a<!> : java.lang.annotation.RetentionPolicy) {\n\n}\n\nfun test() {\n  java.util.Collections.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>()\n  val <!UNUSED_VARIABLE!>a<!> : Collection<String>? = java.util.Collections.emptyList()\n}\n\nfun test(<!UNUSED_PARAMETER!>a<!> : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<Int><!>) {\n\n}\n\nfun test(<!UNUSED_PARAMETER!>a<!> : java.util.ArrayList<Int>) {\n\n}\n\nfun test(<!UNUSED_PARAMETER!>a<!> : java.lang.Class<Int>) {\n\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-1897 When call cannot be resolved to any function, save information about types of arguments\n\npackage a\n\nfun bar() {}\n\nfun foo(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>s<!>: String) {}\n\nfun test() {\n\n    bar(<!TOO_MANY_ARGUMENTS, UNRESOLVED_REFERENCE!>xx<!>)\n\n    bar <!TOO_MANY_ARGUMENTS!>{ }<!>\n\n    foo(<!TYPE_MISMATCH!>\"\"<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!TOO_MANY_ARGUMENTS, UNRESOLVED_REFERENCE!>xx<!>)\n\n    foo(<!NAMED_PARAMETER_NOT_FOUND!>r<!> = <!UNRESOLVED_REFERENCE!>xx<!>, i = <!TYPE_MISMATCH!>\"\"<!>, s = \"\")\n\n    foo(i = 1, <!ARGUMENT_PASSED_TWICE!>i<!> = 1, s = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>11<!>)\n\n    foo(<!TYPE_MISMATCH!>\"\"<!>, s = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n\n    foo(i = <!TYPE_MISMATCH!>\"\"<!>, s = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>33<!>)\n\n    foo(<!TYPE_MISMATCH!>\"\"<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) <!TOO_MANY_ARGUMENTS!>{}<!>\n\n    foo(<!TYPE_MISMATCH!>\"\"<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) <!TOO_MANY_ARGUMENTS!>{}<!> <!MANY_LAMBDA_EXPRESSION_ARGUMENTS!>{}<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A {\n    operator fun get(x: Int) {}\n    operator fun set(x: String, value: Int) {}\n\n    fun d(x: Int) {\n        this[\"\", <!OI;TOO_MANY_ARGUMENTS!>1<!>] = <!NI;TOO_MANY_ARGUMENTS!>1<!>\n    }\n}\n"
        },
        {
            "code": "//KT-1940 Exception while repeating named parameters\npackage kt1940\n\nfun foo(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\nfun test() {\n    foo(1, <!ARGUMENT_PASSED_TWICE!>i<!> = 2) //exception\n    foo(i = 1, <!ARGUMENT_PASSED_TWICE!>i<!> = 2) //exception\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun foo() {}\nfun foo(s: Int) {}\n\n\nfun bar(a: Any) {}\nfun bar(a: Int) {}\n\nfun test() {\n    <!NONE_APPLICABLE!>foo<!>(1, 2)\n    foo(<!TYPE_MISMATCH!>\"\"<!>)\n\n    <!OI;NONE_APPLICABLE!>bar<!>(1, <!NI;TOO_MANY_ARGUMENTS!>2<!>)\n    <!NONE_APPLICABLE!>bar<!>()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !LANGUAGE: +ProhibitAssigningSingleElementsToVarargsInNamedForm\n\nfun <T> array1(vararg a : T) = a\n\nfun main() {\n    val a = array1(\"a\", \"b\")\n    val b = array1(1, 1)\n    join(1)\n    join(1, \"2\")\n    join(1, \"2\", \"3\")\n    join(<!NON_VARARG_SPREAD!>*<!>1, \"2\")\n    join(1, *<!TYPE_MISMATCH!>\"2\"<!>)\n    join(x = 1, a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"2\"<!>)\n    join(x = <!NON_VARARG_SPREAD!>*<!>1, a = *<!TYPE_MISMATCH!>\"2\"<!>)\n    join(x = 1, a = *a)\n    join(x = 1, a = *<!TYPE_MISMATCH!>b<!>)\n    join(1, *a)\n    join(1, *<!TYPE_MISMATCH!>b<!>)\n    join(1, *a, \"3\")\n    join(1, *<!TYPE_MISMATCH!>b<!>, \"3\")\n    join(1, \"4\", *a, \"3\")\n    join(1, \"4\", *<!TYPE_MISMATCH!>b<!>, \"3\")\n    join(1, \"4\", *a)\n    join(1, \"4\", *a, *a, \"3\")\n    join(1, \"4\", *a, *<!TYPE_MISMATCH!>b<!>, \"3\")\n    join(a = *a, x = 1)\n    join(a = *<!TYPE_MISMATCH!>b<!>, x = 1)\n    join(a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR, TYPE_MISMATCH!>a<!>, x = 1)\n\n    joinG<String>(1, \"2\")\n    joinG<String>(<!NON_VARARG_SPREAD!>*<!>1, \"2\")\n    joinG<String>(1, *<!TYPE_MISMATCH!>\"2\"<!>)\n    joinG<String>(x = 1, a = *a)\n    joinG<String>(x = 1, a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"2\"<!>)\n    joinG<String>(x = <!NON_VARARG_SPREAD!>*<!>1, a = *<!TYPE_MISMATCH!>\"2\"<!>)\n    joinG<String>(1, *a)\n    joinG<String>(1, *a, \"3\")\n    joinG<String>(1, \"4\", *a, \"3\")\n    joinG<String>(1, \"4\", *a)\n    joinG<String>(1, \"4\", *a, *a, \"3\")\n    joinG<String>(a = *a, x = 1)\n\n    joinG(1, \"2\")\n    joinG(<!NON_VARARG_SPREAD!>*<!>1, \"2\")\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>joinG<!>(1, *<!TYPE_MISMATCH!>\"2\"<!>)\n    joinG(x = 1, a = *a)\n    joinG(x = 1, a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"2\"<!>)\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>joinG<!>(x = <!NON_VARARG_SPREAD!>*<!>1, a = *<!TYPE_MISMATCH!>\"2\"<!>)\n    joinG(1, *a)\n    joinG(1, *a, \"3\")\n    joinG(1, \"4\", *a, \"3\")\n    joinG(1, \"4\", *a)\n    joinG(1, \"4\", *a, *a, \"3\")\n    joinG(a = *a, x = 1)\n\n    val x1 = joinT(1, \"2\")\n    checkSubtype<String?>(x1)\n    val x2 = joinT(<!NON_VARARG_SPREAD!>*<!>1, \"2\")\n    checkSubtype<String?>(x2)\n    val x6 = joinT(1, *a)\n    checkSubtype<String?>(x6)\n    val x7 = joinT(1, *a, \"3\")\n    checkSubtype<String?>(x7)\n    val x8 = joinT(1, \"4\", *a, \"3\")\n    checkSubtype<String?>(x8)\n    val x9 = joinT(1, \"4\", *a)\n    checkSubtype<String?>(x9)\n    val x10 = joinT(1, \"4\", *a, *a, \"3\")\n    checkSubtype<String?>(x10)\n    val x11 = joinT(a = *a, x = 1)\n    checkSubtype<String?>(x11)\n    val x12 = joinT(x = 1, a = *a)\n    checkSubtype<String?>(x12)\n}\n\nfun join(x : Int, vararg a : String) : String {\n    val b = StringBuilder(x.toString())\n    for (s in a) {\n        b.append(s)\n    }\n    return b.toString()\n}\n\nfun <T> joinG(x : Int, vararg a : T) : String {\n    val b = StringBuilder(x.toString())\n    for (s in a) {\n        b.append(s)\n    }\n    return b.toString()\n}\n\nfun <T: Any> joinT(<!UNUSED_PARAMETER!>x<!> : Int, vararg <!UNUSED_PARAMETER!>a<!> : T) : T? {\n    return null\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nfun test(x: () -> Unit, y: () -> Unit) {\n\n}\n\nfun main() {\n    <!NO_VALUE_FOR_PARAMETER!>test<!> {\n        1\n    } <!MANY_LAMBDA_EXPRESSION_ARGUMENTS!>{\n        2\n    }<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo1(b: Boolean, c: Int) {\n    if (b && <!TYPE_MISMATCH!>c<!>) {}\n    if (b || <!TYPE_MISMATCH!>c<!>) {}\n    if (<!TYPE_MISMATCH!>c<!> && b) {}\n    if (<!TYPE_MISMATCH!>c<!> || b) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject A {\n    operator fun set(x: Int, y: String = \"y\", z: Double) {\n    }\n}\n\nobject B {\n    operator fun set(x: Int, y: String = \"y\", z: Double = 3.14, w: Char = 'w', v: Boolean) {\n    }\n}\n\nobject D {\n    operator fun set(x: Int, vararg y: String, z: Double) {\n    }\n}\n\nobject Z {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun set() {\n    }\n}\n\nfun test() {\n    A[0] = <!TYPE_MISMATCH!>\"\"<!>\n    A[0] = 2.72\n\n    B[0] = <!TYPE_MISMATCH!>\"\"<!>\n    B[0] = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2.72<!>\n    B[0] = true\n\n    D[0] = <!TYPE_MISMATCH!>\"\"<!>\n    D[0] = 2.72\n\n    Z[<!TOO_MANY_ARGUMENTS!>0<!>] = <!TOO_MANY_ARGUMENTS!>\"\"<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: a.kt\npackage boundsWithSubstitutors\n    open class A<T>\n    class B<X : A<X>>()\n\n    class C : A<C>()\n\n    val a = B<C>()\n    val a1 = B<<!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>Int<!>>()\n\n    class X<A, B : A>()\n\n    val b = X<Any, X<A<C>, C>>()\n    val b0 = X<Any, <!NI;UPPER_BOUND_VIOLATED, UPPER_BOUND_VIOLATED!>Any?<!>>()\n    val b1 = X<Any, X<A<C>, <!UPPER_BOUND_VIOLATED!>String<!>>>()\n\n// FILE: b.kt\n  open class A {}\n  open class B<T : A>()\n\n  class Pair<A, B>\n\n  abstract class C<T : B<<!UPPER_BOUND_VIOLATED!>Int<!>>, X :  (B<<!UPPER_BOUND_VIOLATED!>Char<!>>) -> Pair<B<<!UPPER_BOUND_VIOLATED!>Any<!>>, B<A>>>() : B<<!UPPER_BOUND_VIOLATED!>Any<!>>() { // 2 errors\n    val a = B<<!UPPER_BOUND_VIOLATED!>Char<!>>() // error\n\n    abstract val x :  (B<<!UPPER_BOUND_VIOLATED!>Char<!>>) -> B<<!UPPER_BOUND_VIOLATED!>Any<!>>\n  }\n\n\nfun test() {\n    foo<<!UPPER_BOUND_VIOLATED!>Int?<!>>()\n    foo<Int>()\n    bar<Int?>()\n    bar<Int>()\n    bar<<!UPPER_BOUND_VIOLATED!>Double?<!>>()\n    bar<<!UPPER_BOUND_VIOLATED!>Double<!>>()\n    1.buzz<<!UPPER_BOUND_VIOLATED!>Double<!>>()\n}\n\nfun <T : Any> foo() {}\nfun <T : Int?> bar() {}\nfun <T : <!FINAL_UPPER_BOUND!>Int<!>> Int.buzz() : Unit {}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninterface A\ninterface B\n\nexpect fun <!JVM:NO_ACTUAL_FOR_EXPECT!><T><!> List<T>.foo() where T : A, T : B\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nfun <T> List<T>.foo() where T : B, T : A {}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects +LateinitTopLevelProperties\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect val justVal: String\nexpect var justVar: String\n\nexpect val String.extensionVal: Unit\nexpect var <T> T.genericExtensionVar: T\n\nexpect val valWithGet: String\n    get\nexpect var varWithGetSet: String\n    get set\n\nexpect var varWithPlatformGetSet: String\n    <!WRONG_MODIFIER_TARGET!>expect<!> get\n    <!WRONG_MODIFIER_TARGET!>expect<!> set\n\nexpect val backingFieldVal: String = <!EXPECTED_PROPERTY_INITIALIZER!>\"no\"<!>\nexpect var backingFieldVar: String = <!EXPECTED_PROPERTY_INITIALIZER!>\"no\"<!>\n\nexpect val customAccessorVal: String\n    <!EXPECTED_DECLARATION_WITH_BODY!>get()<!> = \"no\"\nexpect var customAccessorVar: String\n    <!EXPECTED_DECLARATION_WITH_BODY!>get()<!> = \"no\"\n    <!EXPECTED_DECLARATION_WITH_BODY!>set(<!UNUSED_PARAMETER!>value<!>)<!> {}\n\nexpect <!CONST_VAL_WITHOUT_INITIALIZER!>const<!> val constVal: Int\n\nexpect <!EXPECTED_LATEINIT_PROPERTY!>lateinit<!> var lateinitVar: String\n\nexpect val delegated: String <!EXPECTED_DELEGATED_PROPERTY!>by Delegate<!>\nobject Delegate { operator fun getValue(x: Any?, y: Any?): String = \"\" }\n\nfun test(): String {\n    <!WRONG_MODIFIER_TARGET!>expect<!> val localVariable: String\n    localVariable = \"no\"\n    return localVariable\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\n<!WRONG_MODIFIER_TARGET!>expect<!> typealias Foo = String\n\nclass Outer <!WRONG_MODIFIER_TARGET!>expect<!> constructor() {\n    <!WRONG_MODIFIER_TARGET!>expect<!> class Nested\n\n    <!WRONG_MODIFIER_TARGET!>expect<!> init {}\n\n    <!NON_ABSTRACT_FUNCTION_WITH_NO_BODY!><!WRONG_MODIFIER_TARGET!>expect<!> fun foo()<!>\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!><!WRONG_MODIFIER_TARGET!>expect<!> val bar: Int<!>\n}\n\nfun foo() {\n    <!NON_MEMBER_FUNCTION_NO_BODY!><!WRONG_MODIFIER_TARGET!>expect<!> fun localFun()<!>\n    <!WRONG_MODIFIER_TARGET!>expect<!> var <!UNUSED_VARIABLE!>x<!> = 42\n    <!WRONG_MODIFIER_TARGET!>expect<!> class Bar\n}\n\n// MODULE: m2-jvm\n// FILE: jvm.kt\n\nclass Outer <!ACTUAL_WITHOUT_EXPECT!>actual constructor()<!> {\n    actual class <!ACTUAL_WITHOUT_EXPECT!>Nested<!>\n\n    <!WRONG_MODIFIER_TARGET!>actual<!> init {}\n}\n\nfun foo() {\n    <!WRONG_MODIFIER_TARGET!>actual<!> fun localFun() {}\n    <!WRONG_MODIFIER_TARGET!>actual<!> var <!UNUSED_VARIABLE!>x<!> = 42\n    <!WRONG_MODIFIER_TARGET!>actual<!> class <!ACTUAL_WITHOUT_EXPECT!>Bar<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo1 {\n    val x: String\n}\n\nexpect class Foo2 {\n    val x: String\n}\n\nexpect class Foo3 {\n    val x: String\n}\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: jvm.kt\n\nopen class Open {\n    open val x = \"42\"\n}\n\nactual open class Foo1 : Open() {\n    override val <!ACTUAL_MISSING!>x<!> = super.x\n}\n\nactual open class Foo2 : Open()\n\nopen class WithFinal {\n    val x = \"42\"\n}\n\nactual open class Foo3 : WithFinal()\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect open class A\nexpect class B : A\nopen class C : <!JVM:SUPERTYPE_NOT_INITIALIZED, SUPERTYPE_NOT_INITIALIZED!>A<!>\n\n// MODULE: m1-jvm(m1-common)\n// FILE: jvm.kt\n\nactual open class A\nactual class B : A()"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect annotation class Foo1\nexpect annotation class Foo2\nexpect annotation class Foo3\nexpect annotation class Foo4\nexpect annotation class Foo5()\nexpect annotation class Foo6()\nexpect annotation class Foo7()\n\n@<!NO_CONSTRUCTOR!>Foo1<!>\nfun foo() {}\n\n@Foo5\nfun bar() {}\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: jvm.kt\n\nactual typealias Foo1 = Bar1\n\nactual typealias Foo4 = Bar2\n\nactual annotation class Foo2(val p: String = \"default\")\n\nactual annotation class Foo3(val a: String = \"a\", val b: String = \"b\")\n\nactual annotation class Foo5\n\nactual annotation class Foo6(val s: String = \"value\")\n\nactual typealias <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>Foo7<!> = Bar2"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo1\nexpect class Foo2\nexpect class Foo3\n\nexpect class Bar1()\nexpect class Bar2()\nexpect class Bar3()\nexpect class Bar4()\nexpect class Bar5()\nexpect class Bar6()\nexpect class Bar7(s: String)\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: jvm.kt\n\nactual class Foo1(val s: String)\nactual class Foo2(val p: String = \"value\", <!UNUSED_PARAMETER!>i<!>: Int)\nactual typealias Foo3 = JavaFoo\n\nactual class <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>Bar1<!>(val s: String)\nactual class <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>Bar2<!>(val p: String = \"value\", <!UNUSED_PARAMETER!>i<!>: Int)\nactual typealias <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>Bar3<!> = JavaBar\nactual class Bar4(val s: String) {\n    <!ACTUAL_MISSING!>constructor() : this(\"\")<!>\n}\n\nactual class Bar5 {\n    actual constructor()\n    constructor(<!UNUSED_PARAMETER!>s<!>: String)\n}\n\nclass <!ACTUAL_MISSING!>Bar6<!> {\n    actual constructor()\n}\n\nactual class Bar7 actual constructor(s: String) {\n    constructor() : this(\"\")\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect fun foo1(x: Int)\nexpect fun foo2<!JVM:NO_ACTUAL_FOR_EXPECT!>(x: Int)<!>\n\nexpect class NoArgConstructor()\n\nexpect fun foo3(): <!JVM:NO_ACTUAL_FOR_EXPECT!>Int<!>\nexpect fun foo4<!JVM:NO_ACTUAL_FOR_EXPECT!>()<!>: Int\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: jvm.kt\n\nactual fun foo1(x: Int) {}\n\nfun foo1(x: Int, y: Int) {}\nfun foo1(x: String) {}\n\nfun foo2(x: Int, y: Int) {}\nfun foo2(x: String) {}\n\nactual fun foo3(): <!ACTUAL_WITHOUT_EXPECT!>String<!> = \"\"\nfun foo4(x: Int): String = \"\"\n\nactual class NoArgConstructor {\n    actual constructor()\n    actual constructor<!ACTUAL_WITHOUT_EXPECT!>(x: Int)<!>\n    constructor(x: String)\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo { // also, it's important that Foo doesn't override equals\n    fun foo()\n}\n\nfun check(x1: Foo, x: Any) {\n    if (x1 == x) {\n        x.<!UNRESOLVED_REFERENCE!>foo<!>()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninterface A\n\nclass B : A\nexpect class Foo(b: B) : <!IMPLEMENTATION_BY_DELEGATION_IN_EXPECT_CLASS!>A by b<!>\n\nexpect class Bar : <!IMPLEMENTATION_BY_DELEGATION_IN_EXPECT_CLASS!>A by B()<!>"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninterface Foo {\n    fun foo()\n}\n\nexpect class ImplicitFoo : Foo\n\nexpect class ExplicitFoo : Foo {\n    override fun foo()\n}\n\nexpect class ImplicitFooCheck : Foo\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class ImplicitFoo : Foo {\n    override fun foo() {}\n}\n\nactual class ExplicitFoo : Foo {\n    actual override fun foo() {}\n}\n\nactual <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class ImplicitFooCheck<!> : Foo"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class A {\n    <!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> fun foo()\n    <!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> val bar: String\n    <!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> fun Int.memExt(): Any\n\n    <!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> class Nested\n}\n\n// MODULE: m1-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class A {\n    private fun <!ACTUAL_MISSING!>foo<!>() {}\n    private val <!ACTUAL_MISSING!>bar<!>: String = \"\"\n    actual private fun Int.memExt(): Any = 0\n\n    actual private class Nested\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\nexpect class Foo(\n        <!EXPECTED_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER!>val constructorProperty: String<!>,\n        constructorParameter: String\n) {\n    <!EXPECTED_DECLARATION_WITH_BODY!>init<!> {\n        <!UNUSED_EXPRESSION, UNUSED_EXPRESSION!>\"no\"<!>\n    }\n\n    <!EXPECTED_DECLARATION_WITH_BODY!>constructor(s: String)<!> {\n        <!UNUSED_EXPRESSION!>\"no\"<!>\n    }\n\n    constructor() : <!EXPECTED_CLASS_CONSTRUCTOR_DELEGATION_CALL!>this<!>(\"no\")\n\n    val prop: String = <!EXPECTED_PROPERTY_INITIALIZER!>\"no\"<!>\n\n    var getSet: String\n        <!EXPECTED_DECLARATION_WITH_BODY!>get()<!> = \"no\"\n        <!EXPECTED_DECLARATION_WITH_BODY!>set(<!UNUSED_PARAMETER!>value<!>)<!> {}\n\n    <!EXPECTED_DECLARATION_WITH_BODY!>fun functionWithBody(x: Int): Int<!> {\n        return x + 1\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class A {\n    fun foo()\n}\n\n// MODULE: m1-jvm(m1-common)\n// FILE: jvm.kt\n\nclass <!ACTUAL_MISSING!>A<!> {\n    actual fun foo() {}\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninterface Foo {\n    fun foo()\n}\n\nexpect class NonAbstractClass : Foo {\n    <!ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS!>abstract<!> fun bar()\n\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> val baz: Int\n\n    <!ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS!>abstract<!> override fun foo()\n}\n\nexpect abstract class AbstractClass : Foo {\n    abstract fun bar()\n\n    abstract val baz: Int\n\n    abstract override fun foo()\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect abstract class BaseA() {\n    abstract fun foo()\n}\nexpect open class BaseAImpl() : BaseA\n\nclass DerivedA1 : BaseAImpl()\nclass DerivedA2 : BaseAImpl() {\n    override fun foo() = super.foo()\n}\n\n\n\nexpect interface BaseB {\n    fun foo()\n}\nexpect open class BaseBImpl() : BaseB\n\nclass DerivedB1 : BaseBImpl()\nclass DerivedB2 : BaseBImpl() {\n    override fun foo() = super.foo()\n}\n\n\n\nexpect interface BaseC {\n    fun foo()\n}\nexpect abstract class BaseCImpl() : BaseC\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class DerivedC1<!> : BaseCImpl()\nclass DerivedC2 : BaseCImpl() {\n    override fun foo() = super.<!ABSTRACT_SUPER_CALL!>foo<!>()\n}\n\n\n\nexpect interface BaseD {\n    fun foo()\n}\nabstract class BaseDImpl() : BaseD {\n    fun bar() = super.<!ABSTRACT_SUPER_CALL!>foo<!>()\n}\n\n\n\nexpect interface BaseE {\n    fun foo()\n}\nsealed class BaseEImpl() : BaseE {\n    fun bar() = super.<!ABSTRACT_SUPER_CALL!>foo<!>()\n}\n\n\n\nexpect interface BaseF {\n    fun foo()\n}\nexpect class BaseFImpl() : BaseF\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo1\nexpect class Foo2\n\nexpect fun foo2(): Int\n\nexpect val s: String\n\nexpect open class <!JVM:AMBIGUOUS_ACTUALS, JVM:PACKAGE_OR_CLASSIFIER_REDECLARATION!>Foo3<!>\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: jvm.kt\n\n<!ACTUAL_WITHOUT_EXPECT!>interface<!> Foo1\nactual <!ACTUAL_WITHOUT_EXPECT!>interface<!> Foo2\n\nactual <!ACTUAL_WITHOUT_EXPECT!>var<!> s: String = \"value\"\n\nfun <!ACTUAL_MISSING!>foo2<!>(): Int = 0\n\nactual class <!ACTUAL_WITHOUT_EXPECT, PACKAGE_OR_CLASSIFIER_REDECLARATION!>Foo3<!>\n\nclass <!ACTUAL_WITHOUT_EXPECT, PACKAGE_OR_CLASSIFIER_REDECLARATION!>Foo3<!>\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class H {\n    <!JVM:WRONG_MODIFIER_TARGET, WRONG_MODIFIER_TARGET!>expect<!> fun foo()\n}\n\n// MODULE: m1-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class H {\n    actual fun foo() {}\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo\nexpect class Bar()\nexpect class Baz constructor()\nexpect class FooBar {\n    constructor()\n}\n\nfun test() {\n    <!RESOLUTION_TO_CLASSIFIER!>Foo<!>()\n    Bar()\n    Baz()\n    FooBar()\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class Foo\nactual class Bar\nactual class Baz\nactual class FooBar"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect open class Container {\n    internal fun internalFun()\n}\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: foo/Foo.java\n\npackage foo;\n\npublic class Foo {\n    public final void internalFun() {}    // OK: internal -> public\n}\n\n// FILE: jvm.kt\n\nactual typealias Container = foo.Foo"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\nexpect open class A {\n    constructor(s: String)\n\n    constructor(n: Number) : <!EXPECTED_CLASS_CONSTRUCTOR_DELEGATION_CALL!>this<!>(\"A\")\n}\n\nexpect class B : A {\n    constructor(i: Int)\n\n    constructor() : <!EXPECTED_CLASS_CONSTRUCTOR_DELEGATION_CALL!>super<!>(\"B\")\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninterface I\nopen class C\ninterface J\n\nexpect class Foo : I, C, J\n\nexpect class Bar : <!JS:SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR, JVM:SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR, SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR!>C<!JS:SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS, JVM:SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS, SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS!>()<!><!>\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\nactual class Foo : I, C(), J\n\nactual class <!ACTUAL_WITHOUT_EXPECT!>Bar<!>\n\n// MODULE: m3-js(m1-common)\n// FILE: js.kt\nactual class Foo : I, J, C()\n\nactual class Bar : C()\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo {\n    fun bar(): String\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class Foo {\n    fun <!ACTUAL_MISSING!>bar<!>(): String = \"bar\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect abstract class Base {\n    abstract fun foo()\n}\n\nexpect class DerivedImplicit : Base\n\nexpect class DerivedExplicit : Base {\n    override fun foo()\n}\n\nexpect class DerivedExplicitCheck : Base {\n    override fun foo()\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual abstract class Base {\n    actual abstract fun foo()\n}\n\nactual class DerivedImplicit : Base() {\n    override fun foo() {}\n}\n\nactual class DerivedExplicit : Base() {\n    actual override fun foo() {}\n}\n\nactual class DerivedExplicitCheck : Base() {\n    override fun <!ACTUAL_MISSING!>foo<!>() {}\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class B {\n    class N {\n        <!EXPECTED_DECLARATION_WITH_BODY, JVM:EXPECTED_DECLARATION_WITH_BODY!>fun body()<!> {}\n        <!JVM:WRONG_MODIFIER_TARGET, WRONG_MODIFIER_TARGET!>expect<!> fun extraHeader()\n    }\n}\n\nexpect class C {\n    <!JVM:WRONG_MODIFIER_TARGET, WRONG_MODIFIER_TARGET!>expect<!> class N\n    <!JVM:WRONG_MODIFIER_TARGET, WRONG_MODIFIER_TARGET!>expect<!> enum class E\n    <!JVM:WRONG_MODIFIER_TARGET, WRONG_MODIFIER_TARGET!>expect<!> inner class I\n}\n\nexpect class D {\n    class N\n}\n\nexpect class E {\n    class N\n}\n\n// MODULE: m1-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class B {\n    actual class N {\n        actual fun body() {}\n        actual fun extraHeader() {}\n    }\n}\n\nactual class C {\n    actual class N\n    actual enum class E\n    actual inner class I\n}\n\nactual class <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>D<!>\n\nactual class E {\n    class <!ACTUAL_MISSING!>N<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect open class Container {\n    fun publicFun()\n\n    internal fun internalFun1()\n    internal fun internalFun2()\n    internal fun internalFun3()\n\n    protected fun protectedFun1()\n    protected fun protectedFun2()\n    protected fun protectedFun3()\n\n    open internal fun openInternalFun()\n    open fun openPublicFun()\n}\n\n// MODULE: m2-jvm(m1-common)\n\n// FILE: jvm.kt\n\nactual open class Container {\n    actual fun publicFun() {}               // OK: public -> public\n\n    actual fun internalFun1() {}            // OK: internal -> public\n    actual internal fun internalFun2() {}   // OK: internal -> internal\n\n    actual fun protectedFun1() {}           // OK: protected -> public\n    actual protected fun protectedFun2() {} // OK: protected -> protected\n\n    actual <!ACTUAL_WITHOUT_EXPECT!>internal<!> fun protectedFun3() {}  // BAD: protected -> internal\n    actual <!ACTUAL_WITHOUT_EXPECT!>protected<!> fun internalFun3() {}  // BAD: internal -> protected\n\n    actual open fun <!ACTUAL_WITHOUT_EXPECT!>openInternalFun<!>() {}    // BAD: internal+open -> public\n    actual internal fun <!ACTUAL_WITHOUT_EXPECT!>openPublicFun<!>() {}  // BAD: open+public -> internal\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -ACTUAL_WITHOUT_EXPECT\n// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class C1\nexpect interface C2<A>\nexpect interface C3<B>\nexpect interface C4<D, E>\nexpect interface C5<F, G>\nexpect interface C6<H>\nexpect interface C7<I>\nexpect interface C8<J>\nexpect interface C9<K>\nexpect interface C10<L>\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual typealias C1 = String\n<!ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE!>actual typealias C2<<!UNUSED_TYPEALIAS_PARAMETER!>A<!>> = List<String><!>\n<!ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE!>actual typealias C3<B> = List<B><!>\nactual typealias C4<D, E> = MutableMap<D, E>\n<!ACTUAL_TYPE_ALIAS_WITH_COMPLEX_SUBSTITUTION!>actual typealias C5<F, G> = MutableMap<G, F><!>\nactual typealias C6<H> = MutableList<H>\n<!ACTUAL_TYPE_ALIAS_WITH_USE_SITE_VARIANCE!>actual typealias C7<I> = MutableList<out I><!>\n<!ACTUAL_TYPE_ALIAS_WITH_USE_SITE_VARIANCE!>actual typealias C8<<!UNUSED_TYPEALIAS_PARAMETER!>J<!>> = MutableList<*><!>\n<!ACTUAL_TYPE_ALIAS_WITH_USE_SITE_VARIANCE!>actual typealias C9<K> = MutableList<in K><!>\n\ntypealias Tmp<K> = MutableList<K>\n<!ACTUAL_TYPE_ALIAS_NOT_TO_CLASS!>actual typealias C10<L> = Tmp<L><!>\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo {\n    val justVal: String\n    var justVar: String\n\n    val String.extensionVal: Unit\n    var <T> T.genericExtensionVar: T\n\n    val valWithGet: String\n        get\n    var varWithGetSet: String\n        get set\n\n    val backingFieldVal: String = <!EXPECTED_PROPERTY_INITIALIZER!>\"no\"<!>\n    var backingFieldVar: String = <!EXPECTED_PROPERTY_INITIALIZER!>\"no\"<!>\n\n    val customAccessorVal: String\n    <!EXPECTED_DECLARATION_WITH_BODY!>get()<!> = \"no\"\n    var customAccessorVar: String\n    <!EXPECTED_DECLARATION_WITH_BODY!>get()<!> = \"no\"\n    <!EXPECTED_DECLARATION_WITH_BODY!>set(<!UNUSED_PARAMETER!>value<!>)<!> {}\n\n    <!EXPECTED_LATEINIT_PROPERTY!>lateinit<!> var lateinitVar: String\n\n    val delegated: String <!EXPECTED_DELEGATED_PROPERTY!>by Delegate<!>\n}\n\nobject Delegate { operator fun getValue(x: Any?, y: Any?): String = \"\" }\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Foo(zzz: Int) {\n    constructor(aaa: Boolean)\n\n    fun f1(xxx: String): String\n}\n\nexpect fun f2(xxx: Int)\n\nfun testCommon() {\n    Foo(<!OI;NAMED_ARGUMENTS_NOT_ALLOWED!>zzz<!> = 0)\n    val f = Foo(<!OI;NAMED_ARGUMENTS_NOT_ALLOWED!>aaa<!> = true)\n    f.f1(<!OI;NAMED_ARGUMENTS_NOT_ALLOWED!>xxx<!> = \"\")\n    f2(xxx = 42)\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class Foo actual constructor(val aaa: Boolean) {\n    actual constructor(zzz: Int) : this(zzz == 0)\n\n    actual fun f1(xxx: String) = xxx\n}\n\nactual fun f2(xxx: Int) {}\n\nfun testPlatform() {\n    Foo(zzz = 0)\n    val f = Foo(aaa = true)\n    f.f1(xxx = \"\")\n    f2(xxx = 42)\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nclass Foo {\n    <!JVM:NON_ABSTRACT_FUNCTION_WITH_NO_BODY, NON_ABSTRACT_FUNCTION_WITH_NO_BODY!><!JVM:WRONG_MODIFIER_TARGET, WRONG_MODIFIER_TARGET!>expect<!> fun bar(): String<!>\n}\n\n// MODULE: m1-jvm(m1-common)\n// FILE: jvm.kt\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect fun ok(x: Int, y: String = \"\")\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual fun ok(x: Int, y: String) {}\n\nfun ok(x: Int, y: Long = 1L) {}\n\nfun test() {\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>ok<!>(1)\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nimport kotlin.reflect.KClass\n\nexpect annotation class Primitives(\n    val z: Boolean = true,\n    val c: Char = 'c',\n    val b: Byte = 42.toByte(),\n    val s: Short = (-1).toShort(),\n    val i: Int = -42,\n    val f: Float = 2.72f,\n    val j: Long = 123456789123456789L,\n    val d: Double = 3.14159265358979\n)\n\nexpect annotation class PrimitiveArrays(\n    val z: BooleanArray = [true],\n    val c: CharArray = ['c'],\n    val b: ByteArray = [42.toByte()],\n    val s: ShortArray = [(-1).toShort()],\n    val i: IntArray = [-42],\n    val f: FloatArray = [2.72f],\n    val j: LongArray = [123456789123456789L],\n    val d: DoubleArray = [3.14159265358979]\n)\n\nenum class En { A, B }\n\nannotation class Anno(val value: String = \"Anno\")\n\nexpect annotation class Classes(\n    val s: String = \"OK\",\n    val e: En = En.B,\n    // TODO: this does not work at the moment because AnnotationDescriptor subclasses do not implement equals correctly\n    // val a: Anno = Anno(),\n    val k: KClass<*> = List::class\n)\n\nexpect annotation class ClassArrays(\n    val s: Array<String> = [\"OK\"],\n    val e: Array<En> = [En.B],\n    // val a: Array<Anno> = [Anno()],\n    val k: Array<KClass<*>> = [List::class],\n    vararg val v: Int = [42]\n)\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nimport kotlin.reflect.KClass\n\nactual annotation class Primitives(\n    actual val z: Boolean = true,\n    actual val c: Char = 'c',\n    actual val b: Byte = 42.toByte(),\n    actual val s: Short = (-1).toShort(),\n    actual val i: Int = -42,\n    actual val f: Float = 2.72f,\n    actual val j: Long = 123456789123456789L,\n    actual val d: Double = 3.14159265358979\n)\n\nactual annotation class PrimitiveArrays(\n    actual val z: BooleanArray = [true],\n    actual val c: CharArray = ['c'],\n    actual val b: ByteArray = [42.toByte()],\n    actual val s: ShortArray = [(-1).toShort()],\n    actual val i: IntArray = [-42],\n    actual val f: FloatArray = [2.72f],\n    actual val j: LongArray = [123456789123456789L],\n    actual val d: DoubleArray = [3.14159265358979]\n)\n\nactual annotation class Classes(\n    actual val s: String = \"OK\",\n    actual val e: En = En.B,\n    // actual val a: Anno = Anno(),\n    actual val k: KClass<*> = List::class\n)\n\nactual annotation class ClassArrays(\n    actual val s: Array<String> = [\"OK\"],\n    actual val e: Array<En> = [En.B],\n    // actual val a: Array<Anno> = [Anno()],\n    actual val k: Array<KClass<*>> = [List::class],\n    actual vararg val v: Int = [42]\n)\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect annotation class A1(val x: Int, val y: String = \"OK\")\n\nexpect annotation class A2(val x: Int = 42, val y: String = \"OK\")\n\nexpect annotation class A3(val x: Int, val y: String)\n\nexpect annotation class A4(val x: Int = 42, val y: String)\n\nexpect annotation class A5(val x: Int = 42, val y: String)\n\n@A1(0)\n@A2\n@A3(0, \"\")\n@A4(0, \"\")\n@A5(0, \"\")\nfun test() {}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual annotation class A1(actual val x: Int, actual val y: String)\n\nactual annotation class A2(actual val x: Int, actual val y: String = \"OK\")\n\nactual annotation class A3(actual val x: Int = 42, actual val y: String = \"OK\")\n\nactual annotation class A4(actual val x: Int, actual val y: String = \"OK\")\n\nactual annotation class A5(actual val x: Int = <!ACTUAL_ANNOTATION_CONFLICTING_DEFAULT_ARGUMENT_VALUE!>239<!>, actual val y: String = \"OK\")\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninterface Foo {\n    fun ok(x: Int, y: String = \"\")\n\n    fun failX(x: Int, y: String = \"\")\n\n    fun failY(x: Int, y: String = \"\")\n}\n\nexpect class Bar : Foo {\n    override fun ok(x: Int, y: String)\n\n    override fun failX(x: Int, y: String)\n\n    override fun failY(x: Int, y: String)\n}\n\nfun test(foo: Foo, bar: Bar) {\n    foo.ok(42)\n    foo.ok(42, \"OK\")\n    bar.ok(42)\n    bar.ok(42, \"OK\")\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class Bar : Foo {\n    actual override fun ok(x: Int, y: String) {}\n    \n    actual override fun failX(<!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>x: Int = <!DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE!>0<!><!>, y: String) {}\n\n    actual override fun failY(x: Int, <!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>y: String = <!DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE!>\"\"<!><!>) {}\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect annotation class A1(val x: Int, val y: String = \"OK\")\n\nexpect annotation class A2(val x: Int = 42, val y: String = \"OK\")\n\nexpect annotation class A3(val x: Int, val y: String)\n\nexpect annotation class A4(val x: Int = 42, val y: String)\n\nexpect annotation class A5(val x: Int = 42, val y: String)\n\n@A1(0)\n@A2\n@A3(0, \"\")\n@A4(0, \"\")\n@A5(0, \"\")\nfun test() {}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual typealias A1 = J1\nactual typealias A2 = J2\nactual typealias A3 = J3\nactual typealias A4 = J4\nactual typealias <!ACTUAL_ANNOTATION_CONFLICTING_DEFAULT_ARGUMENT_VALUE!>A5<!> = J5\n\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect fun ok(x: Int, y: String = \"\")\n\nexpect fun failX(x: Int, y: String = \"\")\n\nexpect fun failY(x: Int, y: String = \"\")\n\nexpect open class Foo {\n    fun ok(x: Int, y: String = \"\")\n\n    fun failX(x: Int, y: String = \"\")\n\n    fun failY(x: Int, y: String = \"\")\n}\n\nfun test(foo: Foo) {\n    ok(42)\n    ok(42, \"OK\")\n    foo.ok(42)\n    foo.ok(42, \"OK\")\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual fun ok(x: Int, y: String) {}\n\nactual fun failX(<!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>x: Int = 0<!>, y: String) {}\n\nactual fun failY(x: Int, <!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>y: String = \"\"<!>) {}\n\nactual open class Foo {\n    actual fun ok(x: Int, y: String) {}\n\n    actual fun failX(<!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>x: Int = 0<!>, y: String) {}\n\n    actual fun failY(x: Int, <!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>y: String = \"\"<!>) {}\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect class Ok(x: Int, y: String = \"\")\n\nexpect class FailX(x: Int, y: String = \"\")\n\nexpect class FailY(x: Int, y: String = \"\")\n\nfun test() {\n    Ok(42)\n    Ok(42, \"OK\")\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual class Ok actual constructor(x: Int, y: String)\n\nactual class FailX actual constructor(<!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>x: Int = 0<!>, y: String)\n\nactual class FailY actual constructor(x: Int, <!ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS!>y: String = \"\"<!>)\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\n<!DEPRECATED_MODIFIER, JVM:DEPRECATED_MODIFIER!>header<!> class My\n\n<!DEPRECATED_MODIFIER, JVM:DEPRECATED_MODIFIER!>header<!> fun foo(): Int\n\n<!DEPRECATED_MODIFIER, JVM:DEPRECATED_MODIFIER!>header<!> val x: String\n\n<!DEPRECATED_MODIFIER, JVM:DEPRECATED_MODIFIER!>header<!> object O\n\n<!DEPRECATED_MODIFIER, JVM:DEPRECATED_MODIFIER!>header<!> enum class E {\n    FIRST\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\n<!DEPRECATED_MODIFIER!>impl<!> class My\n\n<!DEPRECATED_MODIFIER!>impl<!> fun foo() = 42\n\n<!DEPRECATED_MODIFIER!>impl<!> val x get() = \"Hello\"\n\n<!DEPRECATED_MODIFIER!>impl<!> object O\n\n<!DEPRECATED_MODIFIER!>impl<!> enum class E {\n    FIRST\n}"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// !DIAGNOSTICS: -NOTHING_TO_INLINE\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect fun f1(s: () -> String)\nexpect inline fun f2(s: () -> String)\nexpect inline fun f3(noinline s: () -> String)\n\nexpect fun f4(s: () -> String)\nexpect inline fun f5(s: () -> String)\nexpect inline fun f6(crossinline s: () -> String)\n\nexpect fun f7<!JVM:NO_ACTUAL_FOR_EXPECT!>(x: Any)<!>\nexpect fun f8<!JVM:NO_ACTUAL_FOR_EXPECT!>(vararg x: Any)<!>\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual inline fun f1(noinline s: () -> String) {}\nactual inline fun f2<!ACTUAL_WITHOUT_EXPECT!>(noinline s: () -> String)<!> {}\nactual inline fun f3(s: () -> String) {}\nactual inline fun f4(crossinline s: () -> String) {}\nactual inline fun f5<!ACTUAL_WITHOUT_EXPECT!>(crossinline s: () -> String)<!> {}\nactual inline fun f6(s: () -> String) {}\nactual fun f7<!ACTUAL_WITHOUT_EXPECT!>(vararg x: Any)<!> {}\nactual fun f8<!ACTUAL_WITHOUT_EXPECT!>(x: Any)<!> {}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\n<!CONFLICTING_OVERLOADS!>expect fun foo()<!>\n\n<!CONFLICTING_OVERLOADS, EXPECTED_DECLARATION_WITH_BODY!>expect fun foo()<!> {}\n\n<!EXPECTED_DECLARATION_WITH_BODY!>expect fun bar()<!> {}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect fun <!JS:AMBIGUOUS_ACTUALS, JVM:AMBIGUOUS_ACTUALS!>foo<!>()\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\n<!CONFLICTING_OVERLOADS!>actual fun foo()<!> {}\n<!CONFLICTING_OVERLOADS!>actual fun foo()<!> {}\n\n// MODULE: m3-js(m1-common)\n// FILE: js.kt\n\n<!CONFLICTING_OVERLOADS!>actual fun foo()<!> {}\n<!CONFLICTING_OVERLOADS!>actual fun foo()<!> {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\npackage test\n\nexpect fun foo(): String\n\nfun g(f: () -> String): String = f()\n\nfun test() {\n    g(::<!OI;JVM:DEPRECATION!>foo<!>)\n}\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\npackage test\n\n@Deprecated(\"To check that ::foo is resolved to actual fun foo when compiling common+jvm\")\nactual fun foo(): String = \"\"\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\ninline expect fun inlineFun()\nexpect fun nonInlineFun()\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\n<!ACTUAL_WITHOUT_EXPECT!>actual<!> fun inlineFun() { }\nactual fun nonInlineFun() { }\n\n// MODULE: m3-js(m1-common)\n// FILE: js.kt\n\nactual <!NOTHING_TO_INLINE!>inline<!> fun inlineFun() { }\nactual <!NOTHING_TO_INLINE!>inline<!> fun nonInlineFun() { }\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\n<!CONFLICTING_OVERLOADS!>expect fun foo()<!>\n<!CONFLICTING_OVERLOADS!>expect fun foo()<!>\n\nexpect fun foo(x: Int)\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\npackage common\n\nexpect fun <!JS:NO_ACTUAL_FOR_EXPECT, JVM:NO_ACTUAL_FOR_EXPECT!>foo<!>()\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\npackage jvm\n\nactual fun <!ACTUAL_WITHOUT_EXPECT!>foo<!>() {}\n\n// MODULE: m3-js(m1-common)\n// FILE: js.kt\npackage js\n\nactual fun <!ACTUAL_WITHOUT_EXPECT!>foo<!>() {}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-jvm\n// FILE: jvm.kt\n\nactual fun <!ACTUAL_WITHOUT_EXPECT!>foo<!>() { }\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect fun foo()\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\n<!NON_MEMBER_FUNCTION_NO_BODY!>actual fun foo()<!>\n\n<!NON_MEMBER_FUNCTION_NO_BODY!>actual fun <!ACTUAL_WITHOUT_EXPECT!>bar<!>()<!>\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect enum class En<!EXPECTED_ENUM_CONSTRUCTOR!>(x: Int)<!> {\n    E1,\n    E2<!SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS!>(42)<!>,\n    ;\n\n    <!EXPECTED_ENUM_CONSTRUCTOR!>constructor(s: String)<!>\n}\n\nexpect enum class En2 {\n    E1<!NO_CONSTRUCTOR, SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS!>()<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect enum class En {\n    E1,\n    <!EXPECTED_ENUM_ENTRY_WITH_BODY!>E2 {\n        <!EXPECTED_DECLARATION_WITH_BODY!>fun foo()<!> = \"\"\n    },<!>\n    <!EXPECTED_ENUM_ENTRY_WITH_BODY!>E3 { };<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n// MODULE: m1-common\n// FILE: common.kt\n\n<!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> expect fun foo()\n<!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> expect val bar: String\n<!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> expect fun Int.memExt(): Any\n\n<!EXPECTED_PRIVATE_DECLARATION, JVM:EXPECTED_PRIVATE_DECLARATION!>private<!> expect class Foo\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nprivate actual fun foo() {}\nprivate actual val bar: String = \"\"\nprivate actual fun Int.memExt(): Any = 0\n\nprivate actual class Foo\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects, +InlineClasses\n// MODULE: m1-common\n// FILE: common.kt\n\nexpect inline class Foo1(val x: Int) {\n    fun bar(): String\n}\n\nexpect inline class Foo2(val x: Int)\n\nexpect <!ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_INLINE_CLASS, JVM:ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_INLINE_CLASS!>inline<!> class Foo3\n\nexpect class NonInlineExpect\n\nexpect inline class NonInlineActual(val x: Int)\n\n// MODULE: m2-jvm(m1-common)\n// FILE: jvm.kt\n\nactual inline class Foo1(val x: Int) {\n    actual fun bar(): String = \"Hello\"\n}\nactual inline class <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>Foo2<!>(val x: String)\nactual <!ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_INLINE_CLASS!>inline<!> class Foo3\n\n<!ACTUAL_WITHOUT_EXPECT!>actual inline<!> class NonInlineExpect(val x: Int)\n\n<!ACTUAL_WITHOUT_EXPECT!>actual<!> class NonInlineActual actual constructor(actual val x: Int)\n"
        },
        {
            "code": "// !LANGUAGE: +MultiPlatformProjects\n\n<!DEPRECATED_MODIFIER, INCOMPATIBLE_MODIFIERS!>header<!> <!INCOMPATIBLE_MODIFIERS!>impl<!> class <!NO_ACTUAL_FOR_EXPECT!>First<!>\n\n<!DEPRECATED_MODIFIER, INCOMPATIBLE_MODIFIERS!>header<!> <!INCOMPATIBLE_MODIFIERS!>expect<!> class <!NO_ACTUAL_FOR_EXPECT!>Second<!>\n\n<!DEPRECATED_MODIFIER, INCOMPATIBLE_MODIFIERS!>header<!> <!INCOMPATIBLE_MODIFIERS!>actual<!> class <!NO_ACTUAL_FOR_EXPECT!>Third<!>\n\n<!DEPRECATED_MODIFIER, INCOMPATIBLE_MODIFIERS!>impl<!> <!INCOMPATIBLE_MODIFIERS!>expect<!> class <!NO_ACTUAL_FOR_EXPECT!>Fourth<!>\n\n<!DEPRECATED_MODIFIER, INCOMPATIBLE_MODIFIERS!>impl<!> <!INCOMPATIBLE_MODIFIERS!>actual<!> class <!ACTUAL_WITHOUT_EXPECT!>Fifth<!>\n\n<!INCOMPATIBLE_MODIFIERS!>expect<!> <!INCOMPATIBLE_MODIFIERS!>actual<!> class <!NO_ACTUAL_FOR_EXPECT!>Sixth<!>"
        },
        {
            "code": "class C {\n    fun foo(@Suppress(\"REDUNDANT_NULLABLE\") p: String?? = null <!USELESS_CAST!>as Nothing??<!>) = p\n}"
        },
        {
            "code": "@Suppress(\"REDUNDANT_NULLABLE\")\nobject C {\n    fun foo(): String?? = null <!USELESS_CAST!>as Nothing??<!>\n}"
        },
        {
            "code": "class C {\n    @Suppress(\"REDUNDANT_NULLABLE\")\n    companion object {\n        val foo: String?? = null <!USELESS_CAST!>as Nothing??<!>\n    }\n}"
        },
        {
            "code": "fun <T : CharSequence> foo(x: Array<Any>, y: IntArray, block: (T, Int) -> Int) {\n    var r: Any?\n\n    @Suppress(\"UNCHECKED_CAST\")\n    // comment\n    /* comment */\n    r = block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int)\n\n    // to prevent unused assignment diagnostic for the above statement\n    <!DEBUG_INFO_SMARTCAST!>r<!>.hashCode()\n\n    var i = 1\n\n    if (i != 1) {\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n    }\n\n    if (i != 1)\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n\n    if (i != 2)\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n    else\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[1] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n\n    while (i != 1)\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n\n    do\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n    while (i != 1)\n\n    for (j in 1..100)\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n\n    when (i) {\n        1 ->\n            @Suppress(\"UNCHECKED_CAST\")\n            i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n    }\n\n    val l: () -> Unit = {\n        @Suppress(\"UNCHECKED_CAST\")\n        i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n    }\n    l()\n\n    // many empty new lines\n    @Suppress(\"UNCHECKED_CAST\")\n\n\n    y[i] += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n}\n"
        },
        {
            "code": "class C {\n    @Suppress(\"REDUNDANT_NULLABLE\")\n    val foo: String?? = null <!USELESS_CAST!>as Nothing?<!>\n}"
        },
        {
            "code": "class C {\n    @Suppress(\"REDUNDANT_NULLABLE\")\n    fun foo(): String?? = null <!USELESS_CAST!>as Nothing??<!>\n}"
        },
        {
            "code": "@Suppress(\"REDUNDANT_NULLABLE\")\nclass C {\n    fun foo(): String?? = null <!USELESS_CAST!>as Nothing??<!>\n}"
        },
        {
            "code": "fun foo(): Any? {\n    @Suppress(\"REDUNDANT_NULLABLE\")\n    return null <!USELESS_CAST!>as Nothing??<!>\n}"
        },
        {
            "code": "class C {\n    fun foo(): Any? {\n        @Suppress(\"REDUNDANT_NULLABLE\")\n        val v: String?? = null <!USELESS_CAST!>as Nothing??<!>\n        return v\n    }\n}"
        },
        {
            "code": "class C {\n    val foo: String?\n        @Suppress(\"REDUNDANT_NULLABLE\")\n        get(): String?? = null <!USELESS_CAST!>as Nothing??<!>\n}"
        },
        {
            "code": "fun <T : CharSequence> foo(x: Array<Any>, block: (T, Int) -> Int) {\n    var r: Any?\n\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Suppress(\"UNCHECKED_CAST\") r<!> = block(x[0] <!UNCHECKED_CAST!>as T<!>, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int)\n\n    // to prevent unused assignment diagnostic for the above statement\n    <!DEBUG_INFO_SMARTCAST!>r<!>.hashCode()\n\n    var i = 1\n\n    if (i != 1) {\n        <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Suppress(\"UNCHECKED_CAST\") i<!> += block(x[0] <!UNCHECKED_CAST!>as T<!>, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n    }\n\n    if (i != 1) @Suppress(\"UNCHECKED_CAST\")\n    i += block(x[0] as T, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n\n    if (i != 1) <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Suppress(\"UNCHECKED_CAST\") i<!> += block(x[0] <!UNCHECKED_CAST!>as T<!>, \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Int).toInt()\n}\n"
        },
        {
            "code": "@Suppress(\"warnings\")\nclass C {\n    fun foo(p: String??) {\n        // Make sure errors are not suppressed:\n        <!VAL_REASSIGNMENT!>p<!> = \"\"\n    }\n}"
        },
        {
            "code": "class C {\n    fun foo(@Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\") p: String?? = \"\"!! <!USELESS_CAST!>as String??<!>) = p\n}"
        },
        {
            "code": "@Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\nobject C {\n    fun foo(): String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "class C {\n    @Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\n    companion object {\n        val foo: String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n    }\n}"
        },
        {
            "code": "class C {\n    @Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\n    val foo: String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "class C {\n    @Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\n    fun foo(): String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "@Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\nclass C {\n    fun foo(): String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "fun foo(): Any? {\n    @Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\n    return \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "@Suppress(\"REDUNDANT_NULLABLE\")\nclass C {\n    @Suppress(\"UNNECESSARY_NOT_NULL_ASSERTION\")\n    fun foo(): String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "class C {\n    val foo: String?\n        @Suppress(\"REDUNDANT_NULLABLE\", \"UNNECESSARY_NOT_NULL_ASSERTION\")\n        get(): String?? = \"\"!! <!USELESS_CAST!>as String??<!>\n}"
        },
        {
            "code": "class My {\n    val x: String\n\n    constructor() {\n        val y = bar(<!DEBUG_INFO_LEAKING_THIS!>this<!>)\n        val z = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n        x = \"$y$z\"\n    }\n\n    fun foo() = x\n}\n\nfun bar(arg: My) = arg.x\n"
        },
        {
            "code": "val instance = My()\n\nclass My {\n    val equalsInstance = (<!DEBUG_INFO_LEAKING_THIS!>this<!> == instance)\n\n    val isInstance = if (this === instance) \"true\" else \"false\"\n\n    override fun equals(other: Any?) =\n            other is My && isInstance.hashCode() == <!DEBUG_INFO_SMARTCAST!>other<!>.isInstance.hashCode()\n}\n"
        },
        {
            "code": "class My {\n\n    val x = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n\n    val w = bar()\n\n    fun foo() = 0\n\n    companion object {\n        \n        val y = <!UNRESOLVED_REFERENCE!>foo<!>()\n\n        val u = <!DEBUG_INFO_LEAKING_THIS!>bar<!>()\n\n        val z: String? = bar()\n\n        fun bar() = \"1\"\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Context\nclass Point\n\nclass Example {\n    constructor(context: Context?)\n    constructor(context: Context?, arg1: Int)\n    constructor(context: Context?, arg1: Int, arg2: Int)\n    constructor(context: Context?, arg1: Int, arg2: Int, arg3: Int)\n\n    var condition: Boolean = false\n    private var index = <!DEBUG_INFO_LEAKING_THIS!>newIndex<!>(condition)\n    private fun newIndex(zero: Boolean) = if (zero) 0 else 1\n\n    private lateinit var latePoint1: Point\n    private lateinit var latePoint2: Point\n\n    private val point1 = Point()\n    private val point2 = Point()\n    private val point3 = Point()\n    private val point4 = Point()\n    private var nullPoint: Point? = null\n}\n"
        },
        {
            "code": "open class Base {\n    init {\n        register(<!DEBUG_INFO_LEAKING_THIS!>this<!>)\n        <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n    }\n\n    open fun foo() {}\n}\n\nfun register(arg: Base) {\n    arg.foo()\n}\n\nclass Derived(val x: Int) : Base() {\n    override fun foo() {\n        x.hashCode() // NPE in Base constructor\n    }\n}\n\nenum class MyEnum {\n    FIRST() {\n        val x: Int = 42\n\n        override fun foo() {\n            x.hashCode() // NPE in MyEnum constructor\n        }\n    };\n\n    init {\n        <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n    }\n\n    abstract fun foo()\n}\n"
        },
        {
            "code": "fun foo() = 42\n\nclass Your {\n    fun bar() = 13\n}\n\nclass My {\n    val your = Your()\n\n    val x = foo()\n\n    val y = Your().bar()\n\n    val z = your.bar()\n\n    // This extension function also can use our properties,\n    // so the call is also dangerous\n    val w = your.<!DEBUG_INFO_LEAKING_THIS!>gav<!>()\n\n    val v = Your().<!DEBUG_INFO_LEAKING_THIS!>gav<!>()\n\n    val t = your.other()\n\n    val r = Your().other()\n\n    fun Your.gav() = if (your.bar() == 0) t else r\n}\n\nfun Your.other() = \"3\""
        },
        {
            "code": "class My {\n    val x: String\n\n    constructor() {\n        val temp = <!DEBUG_INFO_LEAKING_THIS!>this<!>\n        x = bar(temp)\n    }\n\n}\n\nfun bar(arg: My) = arg.x\n"
        },
        {
            "code": "class My(var x: String) {\n\n    var y: String\n        get() = if (x != \"\") x else z\n        set(arg) {\n            if (arg != \"\") x = arg\n        }\n\n    val z: String\n\n    var d: String = \"\"\n        get\n        set\n\n    val z1: String\n\n    init {\n        <!DEBUG_INFO_LEAKING_THIS!>d<!> = \"d\"\n        if (<!DEBUG_INFO_LEAKING_THIS!>d<!> != \"\") z1 = this.<!DEBUG_INFO_LEAKING_THIS!>d<!> else z1 = <!DEBUG_INFO_LEAKING_THIS!>d<!>\n\n        // Dangerous: setter!\n        <!DEBUG_INFO_LEAKING_THIS!>y<!> = \"x\"\n        // Dangerous: getter!\n        if (<!DEBUG_INFO_LEAKING_THIS!>y<!> != \"\") z = this.<!DEBUG_INFO_LEAKING_THIS!>y<!> else z = <!DEBUG_INFO_LEAKING_THIS!>y<!>\n    }\n}\n"
        },
        {
            "code": "class First {\n    val x: String\n\n    init {\n        use(<!DEBUG_INFO_LEAKING_THIS!>this<!>) // NPE! Leaking this\n        x = <!DEBUG_INFO_LEAKING_THIS!>foo<!>() // NPE! Own function\n    }\n\n    fun foo() = x\n}\n\nfun use(first: First) = first.x.hashCode()\n\nabstract class Second {\n    val x: String\n\n    init {\n        use(<!DEBUG_INFO_LEAKING_THIS!>this<!>) // Leaking this in non-final\n        x = <!DEBUG_INFO_LEAKING_THIS!>bar<!>() // Own function in non-final\n        <!DEBUG_INFO_LEAKING_THIS!>foo<!>()     // Non-final function call\n    }\n\n    private fun bar() = foo()\n\n    abstract fun foo(): String\n}\n\nfun use(second: Second) = second.x\n\nclass SecondDerived : Second() {\n    val y = x // null!\n\n    override fun foo() = y\n}\n\nopen class Third {\n    open var x: String\n\n    constructor() {\n        <!DEBUG_INFO_LEAKING_THIS!>x<!> = \"X\" // Non-final property access\n    }\n}\n\nclass ThirdDerived : Third() {\n    override var x: String = \"Y\"\n        set(arg) { field = \"$arg$y\" }\n\n    val y = \"\"\n}\n\nclass Fourth {\n    val x: String\n        get() = y\n\n    val y = <!DEBUG_INFO_LEAKING_THIS!>x<!> // null!\n}\n"
        },
        {
            "code": "class My(x: String) {\n    val y: String = <!DEBUG_INFO_LEAKING_THIS!>foo<!>(x)\n\n    fun foo(x: String) = \"$x$y\"\n}"
        },
        {
            "code": "class My {\n    var x = 1\n        set(value) {\n            field = value\n        }\n\n    var y: Int = 1\n        set(value) {\n            field = value + if (w == \"\") 0 else 1\n        }\n\n    var z: Int = 2\n        set(value) {\n            field = value + if (w == \"\") 1 else 0\n        }\n\n    var m: Int = 2\n        set\n\n    init {\n        <!DEBUG_INFO_LEAKING_THIS!>x<!> = 3\n        <!DEBUG_INFO_LEAKING_THIS!>m<!> = 6\n\n        // Writing properties using setters is dangerous\n        <!DEBUG_INFO_LEAKING_THIS!>y<!> = 4\n        this.<!DEBUG_INFO_LEAKING_THIS!>z<!> = 5\n    }\n\n    val w = \"6\"\n}"
        },
        {
            "code": "open class Base(val x: String) {\n    fun foo() = bar()\n\n    open fun bar() = -1\n}\n\nclass Derived(x: String): Base(x) {\n    // It's still dangerous: we're not sure that foo() does not call some open function inside\n    val y = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n    val z = x\n}\n"
        },
        {
            "code": "class My {\n    val x: String\n\n    init {\n        x = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n    }\n\n    fun foo(): String = x\n}"
        },
        {
            "code": "fun use(x: Any?) = x\n\nclass Eap {\n    private val foo = <!DEBUG_INFO_LEAKING_THIS!>toString<!>()\n\n    constructor(foo: Int) {\n        use(foo)\n    }\n    constructor(foo: String) {\n        use(foo)\n    }\n}"
        },
        {
            "code": "interface Base {\n    val x: Int\n}\n\nopen class Impl(override val x: Int) : Base {\n    init {\n        if (this.<!DEBUG_INFO_LEAKING_THIS!>x<!> != 0) foo()\n    }\n}\n\nfun foo() {}\n"
        },
        {
            "code": "class My {\n    val x: Int\n        get() = field + if (z != \"\") 1 else 0\n\n    val y: Int\n        get() = field - if (z == \"\") 0 else 1\n\n    val w: Int\n\n    init {\n        // Safe, val never has a setter\n        x = 0\n        this.y = 0\n        // Unsafe\n        w = this.<!DEBUG_INFO_LEAKING_THIS!>x<!> + <!DEBUG_INFO_LEAKING_THIS!>y<!>\n    }\n\n    val z = \"1\"\n}\n"
        },
        {
            "code": "open class Base {\n    open var x: Int\n\n    open var y: Int\n\n    constructor() {\n        <!DEBUG_INFO_LEAKING_THIS!>x<!> = 42\n        this.<!DEBUG_INFO_LEAKING_THIS!>y<!> = 24\n        val temp = this.<!DEBUG_INFO_LEAKING_THIS!>x<!>\n        this.<!DEBUG_INFO_LEAKING_THIS!>x<!> = <!DEBUG_INFO_LEAKING_THIS!>y<!>\n        <!DEBUG_INFO_LEAKING_THIS!>y<!> = temp\n\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n//FILE:file1.kt\npackage a\n\nprivate open class A {\n    fun bar() {}\n}\n\nprivate var x: Int = 10\n\nvar xx: Int = 20\n  private set(<!UNUSED_PARAMETER!>value<!>: Int) {}\n\nprivate fun foo() {}\n\nprivate fun bar() {\n    val y = x\n    x = 20\n    xx = 30\n}\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>makeA<!>() = A()\n\nprivate object PO {}\n\n//FILE:file2.kt\npackage a\n\nfun test() {\n    val y = makeA()\n    y.<!INVISIBLE_MEMBER(\"A\", \"private\", \"file\")!>bar<!>()\n    <!INVISIBLE_MEMBER(\"foo\", \"private\", \"file\")!>foo<!>()\n\n    val u : <!INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!> = <!INVISIBLE_MEMBER(\"A\", \"private\", \"file\")!>A<!>()\n\n    val z = <!INVISIBLE_MEMBER(\"x\", \"private\", \"file\")!>x<!>\n    <!INVISIBLE_MEMBER(\"x\", \"private\", \"file\")!>x<!> = 30\n\n    val po = <!INVISIBLE_MEMBER(\"PO\", \"private\", \"file\")!>PO<!>\n\n    val v = xx\n    <!INVISIBLE_SETTER(\"xx\", \"private\", \"file\")!>xx<!> = 40\n}\n\nclass B : <!EXPOSED_SUPER_CLASS!><!INVISIBLE_MEMBER(\"A\", \"private\", \"file\"), INVISIBLE_REFERENCE(\"A\", \"private\", \"file\")!>A<!>()<!> {}\n\nclass Q {\n    class W {\n        fun foo() {\n            val y = makeA() //assure that 'makeA' is visible\n        }\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\npackage pp\n\nprivate annotation class A(val s: String)\nprivate const val foo = \"O\"\n\n@A(foo)\nfun f1() {}\n\n@A(foo)\nval p1 = \"\"\n\n@A(foo)\nclass C1\n\n\n// FILE: 2.kt\npackage pp\n\n@<!INVISIBLE_MEMBER, INVISIBLE_REFERENCE!>A<!>(<!INVISIBLE_MEMBER!>foo<!>)\nfun f2() {}\n\n@<!INVISIBLE_MEMBER, INVISIBLE_REFERENCE!>A<!>(<!INVISIBLE_MEMBER!>foo<!>)\nval p2 = \"\"\n\n@<!INVISIBLE_MEMBER, INVISIBLE_REFERENCE!>A<!>(<!INVISIBLE_MEMBER!>foo<!>)\nclass C2\n"
        },
        {
            "code": "object A1<!CONSTRUCTOR_IN_OBJECT!>()<!> {\n    <!CONSTRUCTOR_IN_OBJECT!>constructor(x: Int = <!TYPE_MISMATCH!>\"\"<!>, y: Int)<!> : this() {\n        x + y\n    }\n}\n\nobject A2 public <!CONSTRUCTOR_IN_OBJECT!>constructor(private val prop: Int)<!> {\n    <!CONSTRUCTOR_IN_OBJECT!>constructor(x: Int = <!TYPE_MISMATCH!>\"\"<!>, y: Int)<!> : this(x * y) {\n        x + y\n    }\n}\n\nval x = object <!CONSTRUCTOR_IN_OBJECT!>(val prop: Int)<!> {\n    <!CONSTRUCTOR_IN_OBJECT!>constructor()<!> : this(1) {\n        val x = 1\n        x * x\n    }\n}\n\nclass A3 {\n    companion object B<!CONSTRUCTOR_IN_OBJECT!>(val prop: Int)<!> {\n        public <!CONSTRUCTOR_IN_OBJECT!>constructor()<!> : this(2)\n    }\n}"
        },
        {
            "code": "object Host {\n    val `____` = { -> }\n    fun testFunTypeVal() {\n        <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>____<!>()\n    }\n}\n"
        },
        {
            "code": "// FILE: a.kt\npackage outer\n\nprivate fun a() {}\nprivate class B\n\n// FILE: b.kt\npackage outer.p1\n\nimport outer.<!INVISIBLE_REFERENCE!>a<!>\n\nfun use() {\n    <!INVISIBLE_MEMBER!>a<!>()\n    outer.<!INVISIBLE_MEMBER!>B<!>()\n}\n\n// FILE: c.kt\npackage outer.p1.p2\n\nimport outer.<!INVISIBLE_REFERENCE!>a<!>\n\nfun use() {\n    <!INVISIBLE_MEMBER!>a<!>()\n    outer.<!INVISIBLE_MEMBER!>B<!>()\n}"
        },
        {
            "code": "// See KT-13997\n\nclass Foo {\n    var bar: Int // Ok\n        external get\n        external set\n}\n\nclass Bar {\n    val foo: Int // Ok\n        external get\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var baz: Int<!>\n        external get\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var gav: Int<!>\n        external set\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(f: Boolean): Int {\n    val i: Int\n    if (f) {\n        i = 1\n    }\n    <!VAL_REASSIGNMENT!>i<!> = 3\n    return i\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(k: Int): Int {\n    val i: Int\n    for (j in 1..k) {\n        <!VAL_REASSIGNMENT!>i<!> = j\n    }\n    i = 6\n    return i\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(f: Boolean): Int {\n    val i: Int\n    when (f) {\n        true -> i = 1\n    }\n    <!VAL_REASSIGNMENT!>i<!> = 3\n    return i\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(): Int {\n    val i: Int\n    var j = 0\n    do {\n        <!VAL_REASSIGNMENT!>i<!> = ++j\n    } while (j < 5)\n    return i\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(k: Int): Int {\n    val i: Int\n    for (j in 1..k) {\n        <!VAL_REASSIGNMENT!>i<!> = j\n    }\n    return <!UNINITIALIZED_VARIABLE!>i<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(f: Boolean): Int {\n    val i: Int\n    if (f) {\n        i = 1\n    }\n    else {\n        i = 2\n    }\n    <!VAL_REASSIGNMENT!>i<!> = 3\n    return i\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(): Int {\n    val i: Int\n    var j = 0\n    while (true) {\n        <!VAL_REASSIGNMENT!>i<!> = ++j\n        if (j > 5) break\n    } \n    return i\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE\n\nfun foo(f: Boolean): Int {\n    val i: Int\n    if (f) {}\n    else {\n        i = 2\n    }\n    <!VAL_REASSIGNMENT!>i<!> = 3\n    return i\n}"
        },
        {
            "code": "// FILE: anotherTest.kt\npackage foo\n\nval s: String = \"test\"\n\n// FILE: test.kt\nfun ff() {\n    val a = <!NO_COMPANION_OBJECT!>Test<!><!UNEXPECTED_SAFE_CALL!>?.<!>FOO\n    val b = <!EXPRESSION_EXPECTED_PACKAGE_FOUND!>foo<!><!UNEXPECTED_SAFE_CALL!>?.<!>s\n    <!NO_COMPANION_OBJECT!>System<!><!UNEXPECTED_SAFE_CALL!>?.<!>out.println(a + b)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// NI_EXPECTED_FILE\n\ninterface In<in E>\nopen class A : In<A>\nopen class B : In<B>\n\nfun <T> select(x: T, y: T) = x\n\nfun <!OI;IMPLICIT_INTERSECTION_TYPE!>foo2<!>() = select(A(), B()) // Type \"In<A & B>\" is prohibited in return position\n\n\n\nopen class C : In<C>\nopen class D : In<D>\nopen class E : In<E>\nopen class F : In<F>\nopen class G : In<G>\nopen class H : In<H>\n\nfun <S> select8(a: S, b: S, c: S, d: S, e: S, f: S, g: S, h: S) = a\n\nfun <!OI;IMPLICIT_INTERSECTION_TYPE!>foo8<!>() = select8(A(), B(), C(), D(), E(), F(), G(), H())\n"
        },
        {
            "code": "class `___` {\n    class `____`\n}\n\nval testCallableRefLHSType = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>___<!>::toString\nval testCallableRefLHSType2 = `___`::toString\n\nval testClassLiteralLHSType = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>___<!>::class\nval testClassLiteralLHSType2 = `___`::class\n\nval tesLHSTypeFQN = `___`.<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>____<!>::class"
        },
        {
            "code": "package abstract\n\nabstract class MyAbstractClass() {\n    //properties\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val a: Int<!>\n    val a1: Int = 1\n    abstract val a2: Int\n    abstract val a3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>1<!>\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var b: Int<!>                private set\n    var b1: Int = 0;                         private set\n    abstract var b2: Int      <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    abstract var b3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n\n    <!MUST_BE_INITIALIZED!>var c: Int<!>                set(v: Int) { field = v }\n    var c1: Int = 0;                         set(v: Int) { field = v }\n    abstract var c2: Int                     <!ABSTRACT_PROPERTY_WITH_SETTER!>set(v: Int) { field = v }<!>\n    abstract var c3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!ABSTRACT_PROPERTY_WITH_SETTER!>set(v: Int) { field = v }<!>\n\n    val e: Int                               get() = a\n    val e1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;          get() = a\n    abstract val e2: Int                     <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = a<!>\n    abstract val e3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = a<!>\n\n    //methods\n    <!NON_ABSTRACT_FUNCTION_WITH_NO_BODY!>fun f()<!>\n    fun g() {}\n    abstract fun h()\n    <!ABSTRACT_FUNCTION_WITH_BODY!>abstract<!> fun j() {}\n\n    //property accessors\n    var i: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var i1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var j: Int                       get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var j1: Int                      get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var k: Int<!>        <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var k1: Int = 0;                 <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var l: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var l1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var n: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get <!WRONG_MODIFIER_TARGET!>abstract<!> set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n// See KT-10244: no intersection types in signatures\n\nopen class B\ninterface A\ninterface C\n\n// Error!\nfun <!OI;IMPLICIT_INTERSECTION_TYPE!>foo<!>(b: B) = if (b is A && b is C) b else null\n\n// Ok: given explicitly\nfun gav(b: B): A? = if (b is A && b is C) <!OI;DEBUG_INFO_SMARTCAST!>b<!> else null\n\nclass My(b: B) {\n    // Error!\n    val <!OI;IMPLICIT_INTERSECTION_TYPE!>x<!> = if (b is A && b is C) b else null\n    // Ok: given explicitly\n    val y: C? = if (b is A && b is C) <!OI;DEBUG_INFO_SMARTCAST!>b<!> else null\n    // Error!\n    fun <!OI;IMPLICIT_INTERSECTION_TYPE!>foo<!>(b: B) = if (b is A && b is C) b else null\n}\n\nfun bar(b: B): String {\n    // Ok: local variable\n    val tmp = if (b is A && b is C) b else null\n    // Error: local function\n    fun <!OI;IMPLICIT_INTERSECTION_TYPE!>foo<!>(b: B) = if (b is A && b is C) b else null\n    return tmp.toString()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -DEPRECATION -TOPLEVEL_TYPEALIASES_ONLY\n\nfun test(`_`: Int) {\n    <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!> + 1\n    `_` + 1\n}\n\nfun `__`() {}\n\nfun testCall() {\n    <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>()\n    `__`()\n}\n\nval testCallableRef = ::<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>\nval testCallableRef2 = ::`__`\n\n\nobject Host {\n    val `_` = 42\n    object `__` {\n        val bar = 4\n    }\n}\n\nval testQualified = Host.<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!>\nval testQualified2 = Host.`_`\n\nobject `___` {\n    val test = 42\n}\n\nval testQualifier = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>___<!>.test\nval testQualifier2 = `___`.test\nval testQualifier3 = Host.<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>.bar\nval testQualifier4 = Host.`__`.bar\n\nfun testCallableRefLHSValue(`_`: Any) = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!>::toString\nfun testCallableRefLHSValue2(`_`: Any) = `_`::toString\n\nval testCallableRefLHSObject = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>___<!>::toString\nval testCallableRefLHSObject2 = `___`::toString\n"
        },
        {
            "code": "class IncDec() {\n  operator fun inc() : IncDec = this\n  operator fun dec() : IncDec = this\n}\n\nfun testIncDec() {\n  var x = IncDec()\n  x++\n  ++x\n  x--\n  --x\n  x = <!UNUSED_CHANGED_VALUE!>x++<!>\n  x = <!UNUSED_CHANGED_VALUE!>x--<!>\n  x = ++x\n  <!UNUSED_VALUE!>x =<!> --x\n}\n\nclass WrongIncDec() {\n  <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun inc() : Int = 1\n  <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun dec() : Int = 1\n}\n\nfun testWrongIncDec() {\n  var x = WrongIncDec()\n  x<!RESULT_TYPE_MISMATCH!>++<!>\n  <!RESULT_TYPE_MISMATCH!>++<!>x\n  x<!RESULT_TYPE_MISMATCH!>--<!>\n  <!RESULT_TYPE_MISMATCH!>--<!>x\n}\n\nclass UnitIncDec() {\n  <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun inc() : Unit {}\n  <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun dec() : Unit {}\n}\n\nfun testUnitIncDec() {\n  var x = UnitIncDec()\n  x<!INC_DEC_SHOULD_NOT_RETURN_UNIT!>++<!>\n  <!INC_DEC_SHOULD_NOT_RETURN_UNIT!>++<!>x\n  x<!INC_DEC_SHOULD_NOT_RETURN_UNIT!>--<!>\n  <!INC_DEC_SHOULD_NOT_RETURN_UNIT!>--<!>x\n  x = <!UNUSED_CHANGED_VALUE!>x<!INC_DEC_SHOULD_NOT_RETURN_UNIT!>++<!><!>\n  x = <!UNUSED_CHANGED_VALUE!>x<!INC_DEC_SHOULD_NOT_RETURN_UNIT!>--<!><!>\n  x = <!INC_DEC_SHOULD_NOT_RETURN_UNIT!>++<!>x\n  <!UNUSED_VALUE!>x =<!> <!INC_DEC_SHOULD_NOT_RETURN_UNIT!>--<!>x\n}"
        },
        {
            "code": "// dummy test of syntax error highlighting in tests\n\nfun get() {\n    1 + 2 <!SYNTAX!>2 3 4<!>\n}\n"
        },
        {
            "code": "package b\n\nfun main() {\n    var ints : Array<Int?> = arrayOfNulls<Int>(31)\n\n    ints[0] = 4; ints[11] = 5; ints[2] =7\n    for(i in 0..ints.size)\n        ints[i<!SYNTAX!><!>\n}"
        },
        {
            "code": "fun test1() {\n    try {\n\n    } catch (<!SYNTAX!><!>)<!SYNTAX!><!>\n}\n\nfun test2() {\n    try { }<!SYNTAX!><!>\n}\n\nfun test3() {\n    try {\n    } catch (<!SYNTAX!><!>{}<!SYNTAX!>)<!> <!UNUSED_LAMBDA_EXPRESSION!>{}<!>\n}"
        },
        {
            "code": "package sum\n\nimport java.util.*\nfun sum(a : IntArray) : Int {\n    // Write your solution here\n    <!UNRESOLVED_REFERENCE!>res<!> = 0\n    for (e in a)\n        <!UNRESOLVED_REFERENCE!>res<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>+=<!><!SYNTAX!><!>\n}\nfun main() {\n    test(0)\n    test(1, 1)\n    test(-1, -1, 0)\n    test(6, 1, 2, 3)\n    test(6, 1, 1, 1, 1, 1, 1)\n}\n// HELPER FUNCTIONS\nfun test(expectedSum : Int, vararg data : Int) {\n    val actualSum = sum(data)\n    assertEquals(actualSum, expectedSum, \"\\ndata = ${Arrays.toString(data)}\\n\" +\n    \"sum(data) = ${actualSum}, but must be $expectedSum \")\n}\nfun <T: Any> assertEquals(actual : T?, expected : T?, message : Any? = null) {\n    if (actual != expected) {\n        if (message == null)\n            throw AssertionError()\n        else\n            throw AssertionError(message)\n    }\n}"
        },
        {
            "code": "package b\n\nfun foo() {\n    for (i in <!UNRESOLVED_REFERENCE!>collection<!>) {\n        <!UNUSED_LAMBDA_EXPRESSION!>{\n         <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n    }<!>\n}<!SYNTAX!><!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//EA-35646\npackage a\n\nclass MyClass1 {\n    public operator fun unaryPlus() {}\n}\n\nfun main(arg: MyClass1) {\n    arg<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>+<!><!SYNTAX!><!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\npackage d\n\nfun foo(a : IntArray) {\n    if (<!SENSELESS_COMPARISON!>null == <!FUNCTION_EXPECTED!>a<!>()<!><!SYNTAX!><!>\n<!SYNTAX!><!>}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\npackage d\n\ninterface A<T>\n\nfun <T> infer(<!UNUSED_PARAMETER!>a<!>: A<T>) : T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun test(nothing: Nothing?) {\n    val <!UNUSED_VARIABLE!>i<!> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_INCORPORATION_ERROR!>infer<!>(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>nothing<!>)\n}\n\nfun sum(<!UNUSED_PARAMETER!>a<!> : IntArray) : Int {\nfor (n\n<!SYNTAX!>return<!><!SYNTAX!><!> \"?\"\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nfun foo() {\n    val a = <!UNRESOLVED_REFERENCE!>getErrorType<!>()\n    if (<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>==<!> null) { //no senseless comparison\n\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\npackage a\n\nimport java.util.Date\nimport java.util.Comparator\n\nfun foo() {\n\n    val <!UNUSED_VARIABLE!>c<!>: Comparator<Date?> = comparator { date1, date2 ->\n        if (date1 != null && date2 != null) {\n            date1.compareTo(date2) * -11\n        } else {\n            11\n        }\n    }\n}\n\nfun bar(i: Int, a: <!UNRESOLVED_REFERENCE!>U<!>) {\n    val r = if (true) i else <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>\n    val <!UNUSED_VARIABLE!>b<!>: Any = r\n}\n\n//from standard library\npublic inline fun <T> comparator(<!UNUSED_PARAMETER!>fn<!>: (T,T) -> Int): Comparator<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "package l\n\nfun test(a: Int) {\n    if (a in<!SYNTAX!><!> ) {} //a is not unresolved\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//!DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <T> foo(i: Int, t: T) {}\nfun <T> foo(s: String, t: T) {}\n\nfun bar(i: Int) {}\nfun bar(s: String) {}\n\nfun test() {\n    foo(<!UNRESOLVED_REFERENCE!>rrr<!>, 1)\n    bar(<!UNRESOLVED_REFERENCE!>rrr<!>)\n}\n"
        },
        {
            "code": "fun foo() =<!SYNTAX!><!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage bar\n\nfun main() {\n    class Some\n\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!><!NO_COMPANION_OBJECT!>Some<!>[<!SYNTAX!><!>]<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>names<!> <!DEBUG_INFO_MISSING_UNRESOLVED!><!SYNTAX!>=<!> [\"ads\"]<!>\n}"
        },
        {
            "code": "package h\n\nclass Square() {\n  var size : Double =\n  <!UNRESOLVED_REFERENCE!>set<!>(<!UNRESOLVED_REFERENCE!>value<!>) {\n    <!SYNTAX!>$area<!> <!SYNTAX!>= size * size<!>\n  }\n\n  <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var area : Double<!>\n  private set\n}\n\nfun main() {\n  val s = Square()\n\n  s.size = 2.0\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\nfun foo(x: Any?) {\n    x ?:<!SYNTAX!><!>\n    val foo = 1\n\n    x ?:<!SYNTAX!><!>\n    fun bar() = 2\n\n    val res: String.() -> Int = null ?:\n    fun String.() = 3\n}\n\nclass A {\n    val z = null ?:<!SYNTAX!><!>\n    val x = 4\n\n    val y = null ?:<!SYNTAX!><!>\n    fun baz() = 5\n\n    val q = null ?:\n    fun String.() = 6\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun println(x: String) {\n}\n\nfun run(block: () -> Unit) {}\n\nval propertyNameOnTheNextLine = 1\n\nfun foo() {\n    val<!SYNTAX!><!>\n    println(\"abc\")\n\n    val<!SYNTAX!><!>\n    run {\n        println(\"abc\")\n    }\n\n    val<!SYNTAX!><!>\n    if (1 == 1) {\n\n    }\n\n    val<!SYNTAX!><!>\n    (1 + 2)\n\n    // `propertyNameOnTheNextLine` parsed as simple name expression\n    val<!SYNTAX!><!>\n    propertyNameOnTheNextLine\n\n    val<!SYNTAX!><!>\n    // comment\n    propertyNameOnTheNextLine\n\n    val<!SYNTAX!><!> /* comment */\n    propertyNameOnTheNextLine\n\n    // Correct properties\n    val\n    property1 = 1\n\n    val\n    propertyWithBy by <!UNRESOLVED_REFERENCE!>lazy<!> { 1 }\n\n    val\n    propertyWithType: Int\n\n    val\n    (a, b) = <!COMPONENT_FUNCTION_MISSING, COMPONENT_FUNCTION_MISSING!>1<!>\n}\n"
        },
        {
            "code": "package typeReferenceError\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Pair<!><<!SYNTAX!><!>:(<!UNSUPPORTED!>val<!> <!UNSUPPORTED!>c<!>: <!SYNTAX!><!SYNTAX!><!>fun<!><!SYNTAX!><!> <!UNRESOLVED_REFERENCE!>main<!>()"
        },
        {
            "code": "// VAL\nclass A(\n        val<!SYNTAX!><!>\n        val x: Int,\n        val\n        private<!SYNTAX!><!> val z: Int,\n        val<!SYNTAX!><!>\n)\n\nval<!SYNTAX!><!>\nfun foo() {}\n\nclass B {\n    val<!SYNTAX!><!>\n    fun foo() {}\n\n    fun bar() {\n        val<!SYNTAX!><!>\n        fun foo() {}\n    }\n}\n\n// VAR\nclass C(\n        var<!SYNTAX!><!>\n        val x: Int,\n        var\n        private<!SYNTAX!><!> val z: Int,\n        var<!SYNTAX!><!>\n)\n\nvar<!SYNTAX!><!>\nfun baz() {}\n\nclass D {\n    var<!SYNTAX!><!>\n    fun foo() {}\n\n    fun bar() {\n        var<!SYNTAX!><!>\n        fun foo() {}\n    }\n}\n"
        },
        {
            "code": "class A : (<!UNSUPPORTED!>categoryName<!>: <!SYNTAX!><!>)<!SYNTAX!><!> <!SYNTAX!><!>{<!SYNTAX!><!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage b\n\nfun <T, R> foo(<!UNUSED_PARAMETER!>map<!>: Map<T, R>) : R = throw Exception()\n\nfun <F, G> getMap() : Map<F, G> = throw Exception()\n\nfun bar123() {\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getMap<!>(\n<!SYNTAX!><!>}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun foo(x: Any) {\n    x.<!SYNTAX!><!>\n    val foo = 1\n\n    x.<!SYNTAX!><!>\n    fun bar() = 2\n\n    x.\n    <!ILLEGAL_SELECTOR!>fun String.() = 3<!>\n\n    var a = 24.<!SYNTAX!><!>\n    var b = 42.0\n}\n\nclass A {\n    val z = \"a\".<!SYNTAX!><!>\n    val x = 4\n\n    val y = \"b\".<!SYNTAX!><!>\n    fun baz() = 5\n\n    val q = \"c\".\n    <!ILLEGAL_SELECTOR!>fun String.() = 6<!>\n\n    var a = 24.<!SYNTAX!><!>\n    var b = 42.0\n}\n"
        },
        {
            "code": "enum class E {\n    A,\n    B,\n    C\n}\n\nfun foo() {\n    val e = E.<!SYNTAX!><!>\n}\n\n\n"
        },
        {
            "code": "fun test(a: Any) {\n    when (<!UNUSED_EXPRESSION!>a<!>)<!SYNTAX!><!>\n}"
        },
        {
            "code": "<!NON_MEMBER_FUNCTION_NO_BODY!>fun bar()<!>\n"
        },
        {
            "code": "fun<!SYNTAX, SYNTAX!><!>"
        },
        {
            "code": "package c\n\nval i =<!SYNTAX!><!>\n"
        },
        {
            "code": "abstract class A {\n    private val<!SYNTAX!><!>\n    // private is parsed as val's identifier\n    private fun foo1() {\n    }\n\n    private val<!SYNTAX!><!>\n    protected abstract fun foo2()\n\n    private val<!SYNTAX!><!>\n    fun foo3() {\n    }\n\n    private val private<!SYNTAX!><!> fun foo() {}\n}\n"
        },
        {
            "code": "package c\n\nval i : String get() =<!SYNTAX!><!>"
        },
        {
            "code": "package c\n\nfun demo() {\n    val bar = 51\n    fun map(f : <!SYNTAX!><!SYNTAX!><!>fun<!>\n    val foo = 3;\n    bar <!NONE_APPLICABLE!>+<!> map { foo }\n}"
        },
        {
            "code": "fun foo(s: String) {\n    s.<!SYNTAX!><!>\n    val <!UNUSED_VARIABLE!>b<!> = 42\n}\n"
        },
        {
            "code": "package a\n\nfun foo(a: Any) = a <!DEBUG_INFO_MISSING_UNRESOLVED!>==<!SYNTAX!><!><!>"
        },
        {
            "code": "//KT-1955 Half a file is red on incomplete code\n\npackage b\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>a<!> = 1<!SYNTAX!><!>\n\n\n"
        },
        {
            "code": "package bar\n\nclass S<T> {\n    fun foo() {\n        <!TYPE_PARAMETER_IS_NOT_AN_EXPRESSION!>T<!>\n        <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>create<!>()\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun test() {\n    \"a\".<!ILLEGAL_SELECTOR!>\"b\"<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    \"a\".<!ILLEGAL_SELECTOR!>\"b\"<!>::class\n    \"a\".<!ILLEGAL_SELECTOR!>\"b\"<!>.<!ILLEGAL_SELECTOR!>\"c\"<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    \"a\".<!ILLEGAL_SELECTOR!>\"b\"<!>.<!ILLEGAL_SELECTOR!>\"c\"<!>::class\n}\n"
        },
        {
            "code": "fun test1() {\n    if (<!UNRESOLVED_REFERENCE!>rr<!>) {\n        if (<!UNRESOLVED_REFERENCE!>l<!>) {\n            <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>q<!>()\n        }\n        else {\n            <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>w<!>()\n        }\n    }\n    else {\n        if (<!UNRESOLVED_REFERENCE!>n<!>) {\n            <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>t<!>()\n        }\n        else {\n            <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>u<!>()\n        }\n    }\n}\n\nfun test2(l: List<<!UNRESOLVED_REFERENCE!>AA<!>>) {\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>l<!>.<!UNRESOLVED_REFERENCE!>map<!> {\n        <!UNRESOLVED_REFERENCE!>it<!>!!\n    }\n}"
        },
        {
            "code": "//KT-4866 Resolve does not work inside brackets with unresolved reference before\n\nfun test(i: Int, j: Int) {\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!><!UNRESOLVED_REFERENCE!>foo<!>[i, j]<!>\n}"
        },
        {
            "code": "fun foo(a: Int) {\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>!<!><!UNRESOLVED_REFERENCE!>bbb<!>\n    <!UNRESOLVED_REFERENCE!>bbb<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> a\n}"
        },
        {
            "code": "//KT-2014 Better diagnostic when using property syntax to call a method\npackage c\n\nclass Foo {\n    fun prop() : Int = 1\n    fun bar(i: Int) : Int = i\n\n    val a : Int = 1\n}\n\nfun x(f : Foo) {\n    f.<!FUNCTION_CALL_EXPECTED!>prop<!>\n    f.<!FUNCTION_CALL_EXPECTED, NO_VALUE_FOR_PARAMETER!>bar<!>\n\n    f.<!FUNCTION_EXPECTED!>a<!>()\n    <!UNRESOLVED_REFERENCE!>c<!>()\n    <!FUNCTION_EXPECTED!>R<!>()\n}\n\nobject R {}"
        },
        {
            "code": "typealias TString = String\nfun f1() = TString::class\n\ntypealias TNullableString = String?\nfun f2() = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>TNullableString::class<!>\n\ntypealias TNullableTString = TString?\ntypealias TTNullableTString = TNullableTString\nfun f3() = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>TTNullableTString::class<!>\n\ninline fun <reified T> f4(b: Boolean): Any {\n    <!TOPLEVEL_TYPEALIASES_ONLY!>typealias X = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>T<!><!>\n    <!TOPLEVEL_TYPEALIASES_ONLY!>typealias Y = <!TYPEALIAS_SHOULD_EXPAND_TO_CLASS!>T?<!><!>\n    return if (b) X::class else Y::class\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitTypeParametersInClassLiteralsInAnnotationArguments\n\nimport kotlin.reflect.KClass\n\nannotation class Ann(val k: KClass<*>)\nannotation class AnnArray(val kk: Array<KClass<*>>)\n\nobject AnObject\n\nclass C {\n    companion object\n}\n\nfun foo() = \"foo\"\n\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>\"foo\"::class<!>)\nfun test1() {}\n\n@Ann(String::class)\nfun test2() {}\n\n@Ann(AnObject::class)\nfun test4() {}\n\n@Ann(C::class)\nfun test5() {}\n\n@Ann(C.Companion::class)\nfun test6() {}\n\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>foo()::class<!>)\nfun test7() {}\n\n@AnnArray(arrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>\"\"::class<!>, String::class, AnObject::class))\nfun test8() {}\n\ninline val <reified T> T.test9\n    get() = @AnnArray(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>arrayOf(\n        <!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER_ERROR!>T::class<!>,\n        <!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER_ERROR!>Array<T>::class<!>,\n        <!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER_ERROR!>Array<Array<Array<T>>>::class<!>\n    )<!>) object {}\n\ninline val <reified T> T.test10\n    get() = @AnnArray(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>[<!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER_ERROR!>T::class<!>]<!>) object {}\n"
        },
        {
            "code": "// KT-16291 Smart cast doesn't work when getting class of instance\n\nimport kotlin.reflect.KClass\n\nclass Foo {\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other === null || other::class != this::class) return false\n\n        return true\n    }\n}\n\nfun test(f: Foo?): KClass<out Foo>? = if (f != null) f::class else null\n\nfun test2(): KClass<out Foo>? {\n    var f: Foo? = null\n    if (f != null) {\n        run { f = null }\n        return <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>f<!>::class\n    }\n    return null\n}\n"
        },
        {
            "code": "val u = <!UNRESOLVED_REFERENCE!>Unresolved<!>::class\nval g = <!UNRESOLVED_REFERENCE!>UnresolvedGeneric<!><<!UNRESOLVED_REFERENCE!>UnresolvedTypeArg<!>>::class\n"
        },
        {
            "code": "val a01 = <!ARRAY_CLASS_LITERAL_REQUIRES_ARGUMENT!>Array::class<!>\nval a02 = Array<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Array<!>>::class\nval a03 = Array<Any?>::class\nval a04 = Array<Array<Any?>?>::class\nval a05 = Array<IntArray?>::class\nval a06 = <!ARRAY_CLASS_LITERAL_REQUIRES_ARGUMENT!>kotlin.Array::class<!>\nval a07 = kotlin.Array<IntArray?>::class\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nclass A\nclass B\n\nval listOfString: List<String> = null!!\nval arrayOfString: Array<String> = null!!\n\nval a1 : KClass<*> = A::class\nval a2 : KClass<A> = A::class\nval a3 : KClass<B> = <!TYPE_MISMATCH!>A::class<!>\nval a4 : B = <!TYPE_MISMATCH!>A::class<!>\n\nval a5 : KClass<out List<String>> = listOfString::class\nval a6 : KClass<out Array<String>> = arrayOfString::class\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nclass A<T> {\n    class Nested<N>\n\n    inner class Inner<I>\n}\n\nval a1 = A::class\nval a2 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>A<*>::class<!>\nval a3 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>A<String>::class<!>\nval a4 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>A<out String?>::class<!>\n\nval n1 = A.Nested::class\nval n2 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>A.Nested<*>::class<!>\n\nval i1 = A.Inner::class\nval i2 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>A<*>.Inner<*>::class<!>\nval i3 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>A<Int>.Inner<CharSequence>::class<!>\n\nval m1 = Map::class\nval m2 = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Map<Int, *>::class<!>\nval m3 = Map.Entry::class\n\nval b1 = Int::class\nval b2 = Nothing::class"
        },
        {
            "code": "// !LANGUAGE: -ProhibitTypeParametersInClassLiteralsInAnnotationArguments\n\nimport kotlin.reflect.KClass\n\nannotation class Ann(vararg val k: KClass<*>)\n\ninline val <reified T> T.test\n    get() = @Ann(\n        <!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER!>T::class<!>,\n        <!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER!>Array<T>::class<!>,\n        <!ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER!>Array<Array<Array<T>>>::class<!>\n    ) object {}\n"
        },
        {
            "code": "// KT-13110 Strange type mismatch error on class literal with integer receiver expression\n\nimport kotlin.reflect.KClass\n\nfun f(<!UNUSED_PARAMETER!>x<!>: KClass<out Int>) {}\n\nfun test() {\n    f(42::class)\n    f((40 + 2)::class)\n    <!UNUSED_EXPRESSION!>42::toInt<!>\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun f1(x: Int?): Any = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>x<!>::class\nfun <T> f2(t: T): Any = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>t<!>::class\nfun <S : String?> f3(s: S): Any = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>s<!>::class\nfun <U : Any> f4(u: U?): Any = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>u<!>::class\nfun f5(c: List<*>): Any = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>c[0]<!>::class\n\nfun f6(j: J): Any = j.platformString()::class\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nclass A\n\nval a1 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>A?::class<!>\nval a2 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>A??::class<!>\n\nval l1 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>List<String>?::class<!>\nval l2 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>List?::class<!>\n\nfun <T : Any> foo() {\n    val t1 = <!TYPE_PARAMETER_AS_REIFIED!>T::class<!>\n    val t2 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>T?::class<!>\n}\n\ninline fun <reified T : Any> bar() {\n    val t3 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>T?::class<!>\n}\n\nval m = Map<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><String><!>::class\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nfun <T> f1(): KClass<Array<T>> = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<T>::class<!>\nfun <T> f2(): KClass<Array<Array<T>>> = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<Array<T>>::class<!>\ninline fun <reified T> f3() = Array<T>::class\ninline fun <reified T> f4() = Array<Array<T>>::class\nfun f5(): KClass<Array<Any>> = <!CLASS_LITERAL_LHS_NOT_A_CLASS, TYPE_MISMATCH!>Array<*>::class<!>\nfun f6(): KClass<Array<Int?>> = Array<Int?>::class\nfun f7() = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<List<String>>::class<!>\nfun f8() = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<List<String>?>::class<!>\nfun f9() = <!CLASS_LITERAL_LHS_NOT_A_CLASS!>Array<List<*>?>::class<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A\n\nclass B {\n  val b: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate<A>()<!>\n}\n\nval bTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate<A>()<!>\n\nclass C {\n  val c: Int by Delegate<C>()\n}\n\nval cTopLevel: Int by Delegate<Nothing?>()\n\nclass Delegate<T> {\n  operator fun getValue(t: T, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A {\n  var a: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nvar aTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n  operator fun setValue(t: Any?, p: KProperty<*>, i: String) {}\n}\n"
        },
        {
            "code": "// KT-11809 Assertion error when delegated property has getter\n\nclass A {\n    val p1 by this\n        get\n\n    var p2 by this\n        <!ACCESSOR_FOR_DELEGATED_PROPERTY!>get() = \"\"<!>\n\n    operator fun getValue(a: Any?, p: Any?) = \"\"\n    operator fun setValue(a: Any?, p: Any?, v: Any?) {}\n}\n"
        },
        {
            "code": "//KT-4640 \"Trace is erased after resolution completion\" exception\n\nclass ValueWrapper()\n{\n    var backingValue: Int = 0\n\n    fun getValue() = backingValue\n    fun setValue(v: Int) { backingValue = v }\n}\n\nval foo by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>ValueWrapper()<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A {\n  val a: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nval aTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n\nclass Delegate {\n  fun getValue(t: Any?, p: KProperty<*>, a: Int): Int {\n    return a\n  }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nval c: Int by <!DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH!>Delegate()<!>\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): String {\n    return \"\"\n  }\n}\n"
        },
        {
            "code": "val a: Int by <!DELEGATE_SPECIAL_FUNCTION_MISSING(\"getValue(Nothing?, KProperty<*>)\", \"A\", \"delegate\")!>A()<!>\n\nclass A\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage baz\n\nimport kotlin.reflect.KProperty\n\nclass A(outer: Outer) {\n    var i: String by  + getMyConcreteProperty()\n    var d: String by  getMyConcreteProperty() - 1\n    var c: String by  O.getMyProperty()\n    var g: String by  outer.getContainer().getMyProperty()\n\n\n    var b: String by  foo(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getMyProperty<!>())\n    var r: String by  foo(outer.getContainer().<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getMyProperty<!>())\n    var e: String by  <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getMyProperty<!>())\n    var f: String by  <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getMyProperty<!>()) <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>-<!> 1\n}\n\nfun <A, B> foo(<!UNUSED_PARAMETER!>a<!>: Any?) = MyProperty<A, B>()\n\nfun <A, B> getMyProperty() = MyProperty<A, B>()\n\nfun getMyConcreteProperty() = MyProperty<Any?, String>()\n\nclass MyProperty<R, T> {\n\n    operator fun getValue(thisRef: R, desc: KProperty<*>): T {\n        println(\"get $thisRef ${desc.name}\")\n        return null <!UNCHECKED_CAST!>as T<!>\n    }\n\n    operator fun setValue(thisRef: R, desc: KProperty<*>, value: T) {\n        println(\"set $thisRef ${desc.name} $value\")\n    }\n}\n\noperator fun <R, T> MyProperty<R, T>.unaryPlus() = MyProperty<R, T>()\noperator fun <R, T> MyProperty<R, T>.minus(<!UNUSED_PARAMETER!>i<!>: Int) = MyProperty<R, T>()\n\nobject O {\n    fun <A, B> getMyProperty() = MyProperty<A, B>()\n}\n\ninterface MyPropertyContainer {\n    fun <R, T> getMyProperty(): MyProperty<R, T>\n}\n\ninterface Outer {\n    fun getContainer(): MyPropertyContainer\n}\n\n// -----------------\nfun println(a: Any?) = a\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: main.kt\npackage test\n\nimport first.*\nimport second.*\n\nval a12 by <!NI;DELEGATE_SPECIAL_FUNCTION_AMBIGUITY, OI;DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>A()<!>\n\n// FILE: first.kt\npackage first\n\nimport kotlin.reflect.KProperty\n\nclass A\n\npublic operator fun <T> A.getValue(thisRef: Any?, property: KProperty<*>): T = null!!\n\n\n// FILE: second.kt\npackage second\n\nimport first.A\nimport kotlin.reflect.KProperty\n\npublic operator fun <T> A.getValue(thisRef: Any?, property: KProperty<*>): T = null!!"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A<R>() {\n    operator fun <T> getValue(t: Any?, p: KProperty<*>): T = null!!\n    operator fun <T> setValue(t: Any?, p: KProperty<*>, x: T) = Unit\n}\n\nvar a1: Int by <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>A<!>()\nvar a2: Int by A<String>()\n\nclass B<R>() {\n    operator fun <T> getValue(t: Any?, p: KProperty<*>): T = null!!\n    operator fun setValue(t: Any?, p: KProperty<*>, x: R) = Unit\n}\n\nvar b1: Int by B()\nvar b2: Int by B<Number>()\n\nclass C<R>() {\n    operator fun getValue(t: Any?, p: KProperty<*>): R = null!!\n    operator fun <T> setValue(t: Any?, p: KProperty<*>, x: T) = Unit\n}\n\nvar c1: Int by C()\nvar c2: Int by <!DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH!>C<Number>()<!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage foo\n\nimport kotlin.reflect.KProperty\n\nclass A {\n    var a5: String by <!NI;DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!><!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>MyProperty1<!>()<!>\n    var b5: String by <!NI;DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!><!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>getMyProperty1<!>()<!>\n}\n\nfun <A, B> getMyProperty1() = MyProperty1<A, B>()\n\nclass MyProperty1<T, R> {\n\n    operator fun getValue(thisRef: R, desc: KProperty<*>): T {\n        throw Exception()\n    }\n\n    operator fun setValue(i: Int, j: Any, k: Int) {\n        println(\"set\")\n    }\n}\n\n// -----------------\n\nclass B {\n    var a5: String by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>MyProperty2()<!>\n    var b5: String by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>getMyProperty2()<!>\n}\n\nfun <A, B> getMyProperty2() = MyProperty2<A, B>()\n\nclass MyProperty2<T, R> {\n\n    operator fun getValue(thisRef: R, desc: KProperty<*>): T {\n        throw Exception()\n    }\n\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun setValue(i: Int) {\n        println(\"set\")\n    }\n}\n\n// -----------------\nfun println(a: Any?) = a\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nimport kotlin.reflect.KProperty\n\nclass A {\n    var a by <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>MyProperty<!>()\n}\n\nclass MyProperty<T, R> {\n\n    operator fun getValue(thisRef: R, desc: KProperty<*>): T {\n        throw Exception(\"$thisRef $desc\")\n    }\n\n    operator fun setValue(thisRef: R, desc: KProperty<*>, t: T) {\n        throw Exception(\"$thisRef $desc $t\")\n    }\n}\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nclass A3 {\n    val a: String by <!REDUNDANT_LABEL_WARNING!>l@<!> MyProperty()\n\n    class MyProperty<T> {}\n\n    operator fun <T> MyProperty<T>.getValue(thisRef: Any?, desc: KProperty<*>): T {\n        throw Exception(\"$thisRef $desc\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nimport kotlin.reflect.KProperty\n\nvar a: Int by A()\nvar a1 by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE, DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>A()<!>\n\nvar b: Int by B()\n\nval cObj = C()\nvar c: String by cObj\n\nclass A {\n  operator fun <T> getValue(t: Any?, p: KProperty<*>): T = null!!\n  operator fun <T> setValue(t: Any?, p: KProperty<*>, x: T) = Unit\n}\n\nclass B\n\noperator fun <T> B.getValue(t: Any?, p: KProperty<*>): T = null!!\noperator fun <T> B.setValue(t: Any?, p: KProperty<*>, x: T) = Unit\n\nclass C\n\noperator inline fun <reified T> C.getValue(t: Any?, p: KProperty<*>): T = null!!\noperator inline fun <reified T> C.setValue(t: Any?, p: KProperty<*>, x: T) = Unit\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage foo\n\nimport kotlin.reflect.KProperty\n\nopen class A {\n    val B.w: Int by <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>MyProperty<!>()<!>\n}\n\nval B.r: Int by <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!><!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>MyProperty<!>()<!>\n\nval A.e: Int by MyProperty()\n\nclass B {\n    val A.f: Int by MyProperty()\n}\n\nclass MyProperty<R : A, T> {\n    operator fun getValue(thisRef: R, desc: KProperty<*>): T {\n        throw Exception(\"$thisRef $desc\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A {\n  var a: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nvar aTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n\n  operator fun setValue(t: Any?, p: KProperty<*>, a: Int, c: Int) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nval Int.a by Delegate(<!NO_THIS!>this<!>)\n\nclass A {\n  val Int.a by Delegate(<!TYPE_MISMATCH!>this<!>)\n}\n\nclass Delegate(i: Int) {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A {\n    val c: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nclass Delegate {\n    fun getValue(t: Int, p: KProperty<*>): Int {\n        return 1\n    }\n\n    fun getValue(t: String, p: KProperty<*>): Int {\n        return 1\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nabstract class A {\n    abstract val a: Int <!ABSTRACT_DELEGATED_PROPERTY!>by Delegate()<!>\n}\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nvar a: Int by Delegate()\n  <!ACCESSOR_FOR_DELEGATED_PROPERTY!>get() = 1<!>\n  <!ACCESSOR_FOR_DELEGATED_PROPERTY!>set(i) {}<!>\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n\n  operator fun setValue(t: Any?, p: KProperty<*>, i: Int) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.reflect.KProperty\n\nclass A {\n  var a: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE, DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nvar aTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE, DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n\nclass Delegate {\n  fun getValue(t: Nothing, p: KProperty<*>): Int {\n    return 1\n  }\n  fun setValue(t: Nothing, p: KProperty<*>, a: Int) {\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass B {\n    val a: Int by Delegate()\n\n    fun foo() =<!SYNTAX!><!> <!SYNTAX!>$a<!>\n}\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass A\n\nclass D {\n    val c: Int by <!DELEGATE_SPECIAL_FUNCTION_MISSING!>IncorrectThis<A>()<!>\n}\n\nval cTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_MISSING!>IncorrectThis<A>()<!>\n\nclass IncorrectThis<T> {\n    fun <R> get(t: Any?, p: KProperty<*>): Int {\n        return 1\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nval a: Int by Delegate()\n  <!ACCESSOR_FOR_DELEGATED_PROPERTY!>get() = 1<!>\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nvar a: Int by <!DELEGATE_SPECIAL_FUNCTION_MISSING(\"setValue(Nothing?, KProperty<*>, Int)\", \"A\", \"delegate for var (read-write property)\")!>A()<!>\n\nclass A {\n    operator fun getValue(t: Any?, p: KProperty<*>): Int {\n      return 1\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject Inference2 {\n    interface Foo<T>\n\n    fun <T> delegate(): Foo<T> = TODO()\n\n    operator fun <T> Foo<T>.provideDelegate(host: T, p: Any?): Foo<T> = TODO()\n    operator fun <T> Foo<T>.getValue(receiver: Inference2, p: Any?): String = TODO()\n\n    val test1: String by <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>delegate<!>() // same story like in Inference1\n    val test2: String by delegate<Inference2>()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject Inference1 {\n    interface Foo<T>\n\n    fun <T> delegate(): Foo<T> = TODO()\n\n    operator fun <T> Foo<T>.getValue(receiver: T, p: Any?): String = TODO()\n\n    // not working because resulting descriptor for getValue contains type `???` instead of `T`\n    val test1: String by <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>delegate<!>()\n\n    val test2: String by delegate<Inference1>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun provideDelegate(x: Any?, p: KProperty<*>) {}\n\noperator fun Any.provideDelegate(x: Any?, p: KProperty<*>) {}\n\noperator fun Any.provideDelegate(x: Any?, p: Any) {}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun Any.provideDelegate(x: Any?, p: Int) {}\n\nclass Host1 {\n    operator fun provideDelegate(x: Any?, p: KProperty<*>) {}\n}\n\nclass Host2 {\n    operator fun Any.provideDelegate(x: Any?, p: KProperty<*>) {}\n}\n\nclass Host3 {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun provideDelegate(x: Any?, p: KProperty<*>, foo: Int) {}\n}\n\nclass Host4 {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun provideDelegate(x: Any?, p: KProperty<*>, foo: Int = 0) {}\n}\n\nclass Host5 {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun provideDelegate(x: Any?, p: KProperty<*>, vararg foo: Int) {}\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject T2 {\n    interface Foo<T>\n\n    fun <T> delegate(): Foo<T> = TODO()\n\n    operator fun <T> Foo<T>.provideDelegate(host: T2, p: Any?): Foo<T> = TODO()\n    operator fun <T> Foo<T>.getValue(receiver: String, p: Any?): T = TODO()\n\n    val String.test1: String by delegate()\n    val test2: String by <!NI;DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!><!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>delegate<!>()<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Delegate<T>\n\noperator fun Delegate<*>.getValue(receiver: Any?, p: Any): String = \"\"\noperator fun <T> Delegate<T>.setValue(receiver: Any?, p: Any, value: T) {}\n\noperator fun <T> String.provideDelegate(receiver: Any?, p: Any) = Delegate<T>()\n\nvar test1: String by <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>Delegate<!>()\nvar test2: String by Delegate<String>()\n\nvar test3: String by <!DELEGATE_SPECIAL_FUNCTION_MISSING, DELEGATE_SPECIAL_FUNCTION_MISSING, DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>\"OK\"<!>\n\nvar test4: String by \"OK\".<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>provideDelegate<!>(null, \"\")\nvar test5: String by \"OK\".provideDelegate<String>(null, \"\")"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject T1 {\n    operator fun Int.provideDelegate(host: T1, p: Any): Long = 2\n    operator fun Long.getValue(receiver: String, p: Any): Double = 1.0\n\n    val String.test1 by 1\n    val test2 by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>1<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject CommonCase {\n    interface Fas<D, E, R>\n\n    fun <D, E, R> delegate() : Fas<D, E, R> = TODO()\n\n    operator fun <D, E, R> Fas<D, E, R>.provideDelegate(host: D, p: Any?): Fas<D, E, R> = TODO()\n    operator fun <D, E, R> Fas<D, E, R>.getValue(receiver: E, p: Any?): R = TODO()\n\n    val Long.test1: String by <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>delegate<!>() // common test, not working because of Inference1\n    val Long.test2: String by delegate<CommonCase, Long, String>() // should work\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass StringDelegate(val s: String) {\n    operator fun getValue(a: Any?, p: KProperty<*>): Int = 42\n}\n\n// NB no operator\nfun String.provideDelegate(a: Any?, p: KProperty<*>) = StringDelegate(this)\n\noperator fun String.getValue(a: Any?, p: KProperty<*>) = this\n\nval test1: String by \"OK\"\nval test2: Int by <!DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH!>\"OK\"<!>\nval test3 by \"OK\"\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: -OperatorProvideDelegate\n\nclass WrongDelegate(val x: Int) {\n    operator fun getValue(thisRef: Any?, prop: Any): Int = x\n}\n\n<!UNSUPPORTED_FEATURE!>operator<!> fun String.provideDelegate(thisRef: Any?, prop: Any) = WrongDelegate(this.length)\n\noperator fun String.getValue(thisRef: Any?, prop: Any) = this\n\nval test1: String by \"OK\"\nval test2: Int by <!DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH!>\"OK\"<!>\nval test3 by \"OK\""
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.reflect.KProperty\n\nclass A {\n  var a: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE, DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nvar aTopLevel: Int by Delegate()\n\nclass Delegate {\n  operator fun getValue(t: Nothing?, p: KProperty<*>): Int {\n    return 1\n  }\n  operator fun setValue(t: Nothing?, p: KProperty<*>, a: Int) {\n  }\n}\n"
        },
        {
            "code": "import kotlin.reflect.KProperty0\n\nval a: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>A()<!>\n\nclass A {\n    fun getValue(<!UNUSED_PARAMETER!>t<!>: Any?, <!UNUSED_PARAMETER!>p<!>: KProperty0<*>): Int = 1\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.reflect.KProperty\n\nclass B {\n  val b: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nval bTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n\nclass A\n\nclass Delegate {\n  fun getValue(t: A, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\ninterface A {\n    val prop: Int\n}\n\nclass AImpl: A  {\n    override val <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE!>prop<!> by Delegate()\n}\n\nfun foo() {\n    AImpl().prop\n}\n\nclass Delegate {\n    operator fun getValue(t: Any?, p: KProperty<*>): String {\n        return \"\"\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass D {\n  var c: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n}\n\nvar cTopLevel: Int by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>Delegate()<!>\n\nclass A\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n  operator fun setValue(t: A, p: KProperty<*>, i: Int) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\ninterface T {\n  val a: Int <!DELEGATED_PROPERTY_IN_INTERFACE!>by Delegate()<!>\n}\n\nclass Delegate {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// NI_EXPECTED_FILE\n\nimport kotlin.reflect.KProperty\n\nval a by <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, OI;TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>a<!>\n\nval b by Delegate(<!OI;TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>b<!>)\n\nval c by <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNINITIALIZED_VARIABLE!>d<!>\nval d by <!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, OI;TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>c<!>\n\nclass Delegate(i: Int) {\n  operator fun getValue(t: Any?, p: KProperty<*>): Int {\n    return 1\n  }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// NI_EXPECTED_FILE\n\nimport kotlin.reflect.KProperty\n\nclass B {\n    val c by Delegate(<!UNRESOLVED_REFERENCE!>ag<!>)\n}\n\nclass Delegate<T: Any>(val init: T) {\n    operator fun getValue(t: Any?, p: KProperty<*>): Int = null!!\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninterface A {\n    operator fun getValue(x: Any?, y: Any?): Any?\n}\n\ninterface B : A {\n    override fun getValue(x: Any?, y: Any?): Int\n}\n\nfun test(a: A) {\n    if (a is B) {\n        val x: Int by <!DEBUG_INFO_SMARTCAST!>a<!>\n    }\n}\n"
        },
        {
            "code": "fun foo(a: Any?): Int {\n    <!SYNTAX!>@<!>{ ->\n        return<!SYNTAX!>@<!>\n    }\n\n    <!SYNTAX!>@<!> while(a == null) {\n        if (true) {\n            break<!SYNTAX!>@<!>\n        }\n        else {\n            continue<!SYNTAX!>@<!>\n        }\n    }\n\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>b<!> = 1\n\n    <!UNUSED_VALUE!>(<!SYNTAX!>@<!> b) =<!> 2\n\n    return<!SYNTAX!>@<!> 1\n}\n\nopen class A {\n    fun foo() {}\n}\n\nclass B : A() {\n    fun bar() {\n        this<!SYNTAX!>@<!>.foo()\n        super<!SYNTAX!>@<!>.foo()\n    }\n}\n\nfun bar(f: () -> Unit) = f\nfun test() {\n    bar <!SYNTAX!>@<!>{}\n}"
        },
        {
            "code": "fun nonlocals(b : Boolean) {\n    a@<!UNUSED_LAMBDA_EXPRESSION!>{\n        fun foo() {\n            if (b) {\n                <!RETURN_NOT_ALLOWED!>return@a<!> 1 // The label must be resolved, but an error should be reported for a non-local return\n            }\n        }\n\n        return@a 5\n    }<!>\n}"
        },
        {
            "code": "interface A {\n    fun foo()\n}\n\ninterface B {\n    fun bar()\n}\n\nfun B.b() {\n    object : A {\n        override fun foo() {\n            this@b.bar()\n        }\n    }\n}\n\n\nfun test() {\n    fun <T> without(f: T.() -> Unit): Unit = (null!!).f<!UNREACHABLE_CODE!>()<!>\n    without<B>() b@ {\n        object : A {\n            override fun foo() {\n                this@b.bar()\n            }\n        }\n    }\n}"
        },
        {
            "code": "//KT-1703 Reference to label is unresolved\n\nfun test() {\n    val ints = Array<Int?>(2, { null })\n    ints.forEach lit@ {\n        if (it == null) return@lit\n        use(<!DEBUG_INFO_SMARTCAST!>it<!> + 5)\n    }\n}\n\nfun <T> Array<out T>.forEach(operation: (T) -> Unit) {\n    for (element in this) operation(element)\n}\n\nfun use(a: Any?) = a"
        },
        {
            "code": "fun test(x: List<Int>): Int {\n    x myMap {\n        return@myMap\n    }\n\n    return 0\n}\n\nfun myMap(x: List<Int>): Int {\n    x myMap {\n        return<!LABEL_NAME_CLASH!>@myMap<!>\n    }\n\n    return 0\n}\n\ninfix fun List<Int>.myMap(<!UNUSED_PARAMETER!>x<!>: () -> Unit) {}"
        },
        {
            "code": "//KT-591 Unresolved label in valid code\n\nfun test() {\n    val <!UNUSED_VARIABLE!>a<!>: (Int?).() -> Unit = a@{\n        if (this != null) {\n            val <!UNUSED_VARIABLE!>b<!>: String.() -> Unit = {\n                <!DEBUG_INFO_SMARTCAST!>this@a<!>.times(5) // a@ Unresolved\n            }\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nval funLit = lambda@ fun String.() {\n    val d1 = this@lambda\n}\n\nfun test() {\n    val funLit = lambda@ fun String.(): String {\n        return this@lambda\n    }\n}\n\nfun lambda() {\n    val funLit = lambda@ fun String.(): String {\n        return <!NO_THIS!>this@lambda<!>\n    }\n}"
        },
        {
            "code": "//KT-3988 This@label for outer function not resolved\n\nclass Comment() {\n    var article = \"\"\n\n}\nclass Comment2() {\n    var article2 = \"\"\n}\n\nfun new(body: Comment.() -> Unit) = body\n\nfun new2(body: Comment2.() -> Unit) = body\n\nfun main() {\n    new {\n        new2 {\n            <!UNUSED_EXPRESSION!>this@new<!> //UNRESOLVED REFERENCE\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Pair<A, B>(val a: A, val b: B)\ninfix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n// OK\ninfix fun String.ok1(o: String) {}\nclass OkTest {\n    infix fun ok2(o: String) {}\n    infix fun String.ok3(o: String) {}\n}\n\n// Errors\n<!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun String.e1(o: String, o2: String? = null) = o\n<!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun String.e2(o: String = \"\", o2: String? = null) = o\n\n<!INAPPLICABLE_INFIX_MODIFIER(\"must be a member or an extension function\")!>infix<!> fun e3() {}\n<!INAPPLICABLE_INFIX_MODIFIER(\"must be a member or an extension function\")!>infix<!> fun e4(s: String) {}\n<!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun String.e5() {}\n<!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun String.e6(a: Int, b: Int) {}\n<!INAPPLICABLE_INFIX_MODIFIER(\"must be a member or an extension function\")!>infix<!> fun e7(a: Int, b: Int) {}\n\nclass Example {\n    <!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun e8(s: String, a: Int = 0) {}\n    <!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun e9(s: String, a: Int) {}\n    <!INAPPLICABLE_INFIX_MODIFIER(\"must have a single value parameter\")!>infix<!> fun e10() {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun println() {}\nfun foo(x: Any) {}\nfun <T> fooGeneric(x: T) {}\n\nfun testMixedIfAndWhen() =\n        if (true)\n            when {\n                true -> if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n                else <!IMPLICIT_CAST_TO_ANY!>1<!>\n                    true -> if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n                else <!IMPLICIT_CAST_TO_ANY!>println()<!>\n                else -> <!INVALID_IF_AS_EXPRESSION!>if<!> (true) <!IMPLICIT_CAST_TO_ANY!>println()<!>\n            }\n        else <!IMPLICIT_CAST_TO_ANY!>println()<!>\n\nfun testWrappedExpressions() =\n        if (true) {\n            println()\n            <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {\n                println()\n                if (true) {\n                    <!IMPLICIT_CAST_TO_ANY!>println()<!>\n                }\n                else <!IMPLICIT_CAST_TO_ANY!>{}<!>\n            }\n        }\n        else {\n            (((<!IMPLICIT_CAST_TO_ANY!>((42)) + 1<!>)))\n        }"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval test1 = { when (true) { true -> <!OI;IMPLICIT_CAST_TO_ANY!>1<!>; else -> <!OI;IMPLICIT_CAST_TO_ANY!>\"\"<!> } }\n\nval test2 = { { when (true) { true -> <!OI;IMPLICIT_CAST_TO_ANY!>1<!>; else -> <!OI;IMPLICIT_CAST_TO_ANY!>\"\"<!> } } }\n\nval test3: (Boolean) -> Any = { when (true) { true -> 1; else -> \"\" } }\n\nval test4: (Boolean) -> Any? = { when (true) { true -> 1; else -> \"\" } }\n\nfun println() {}\n\nval test5 = {\n    when (true) {\n        true -> println()\n        else -> println()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +RestrictReturnStatementTarget\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann\n\nfun testFunctionName() {\n    return@testFunctionName\n}\n\nfun testHighOrderFunctionName() {\n    run {\n        return@run\n    }\n}\n\nfun testLambdaLabel() =\n    lambda@ {\n        return@lambda\n    }\n\nfun testParenthesizedLambdaLabel() =\n    lambda@ ( {\n        return@lambda\n    } )\n\nfun testAnnotatedLambdaLabel() =\n    lambda@ @Ann {\n        return@lambda\n    }\n\nfun testLambdaMultipleLabels1() =\n    lambda1@ lambda2@ {\n        return@lambda1\n    }\n\nfun testLambdaMultipleLabels2() =\n    lambda1@ lambda2@ {\n        return@lambda2\n    }\n\nfun testAnonymousFunctionLabel() =\n    anonFun@ fun() {\n        return@anonFun\n    }\n\nfun testLoopLabelInReturn(xs: List<Int>) {\n    L@ for (x in xs) {\n        if (x > 0) <!NOT_A_FUNCTION_LABEL!>return@L<!>\n    }\n}\n\nfun testValLabelInReturn() {\n    <!REDUNDANT_LABEL_WARNING!>L@<!> val fn = { <!NOT_A_FUNCTION_LABEL!>return@L<!> }\n    fn()\n}\n\nfun testHighOrderFunctionCallLabelInReturn() {\n    <!REDUNDANT_LABEL_WARNING!>L@<!> run {\n        <!NOT_A_FUNCTION_LABEL!>return@L<!>\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNREACHABLE_CODE -UNUSED_PARAMETER -RETURN_NOT_ALLOWED\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>test1<!>() = run {\n    return <!TYPE_MISMATCH(\"String\", \"Nothing\")!>\"OK\"<!>\n}\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>test2<!>() = run {\n    fun local(): String {\n        return \"\"\n    }\n    return <!TYPE_MISMATCH(\"String\", \"Nothing\")!>\"\"<!>\n}\n\ninline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> = null!!\nfun test3(a: List<String>, b: List<Int>) = a.map {\n    if (it.length == 3) return <!TYPE_MISMATCH(\"Nothing?\", \"List<Int>\")!>null<!>\n    if (it.length == 4) return <!TYPE_MISMATCH(\"String\", \"List<Int>\")!>\"\"<!>\n    if (it.length == 4) return <!TYPE_MISMATCH(\"Int\", \"List<Int>\")!>5<!>\n    if (it.length == 4) return b\n    1\n}\n\nfun test4() = run {\n    fun test5() {\n        return\n\n        <!RETURN_TYPE_MISMATCH!>return@test4<!>\n\n        return <!RETURN_TYPE_MISMATCH!>return@test4<!>\n\n        return <!TYPE_MISMATCH!>fun() { return; return@test4 <!TYPE_MISMATCH!>\"\"<!> }<!>\n    }\n\n    <!RETURN_TYPE_MISMATCH!>return<!>\n    3\n}\n\nval foo: Int\n    get() = run {\n        if (true) return <!TYPE_MISMATCH!>\"\"<!>\n\n        <!RETURN_TYPE_MISMATCH!>return<!>\n    }\n\nfun test(): Int = run {\n    return <!TYPE_MISMATCH!>\"\"<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// See also KT-10896: Wrong inference of if / else result type\n\ninterface Option<T>\nclass Some<T> : Option<T>\nclass None<T> : Option<T>\n\nfun <T> bind(r: Option<T>): Option<T> {\n    return if (r is Some) {\n        // Ideally we should infer Option<T> here (see KT-10896)\n        (<!OI;TYPE_INFERENCE_FAILED_ON_SPECIAL_CONSTRUCT!>if<!> (true) <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>None()<!> else <!OI;DEBUG_INFO_SMARTCAST!>r<!>) checkType { <!OI;TYPE_MISMATCH!>_<!><Option<T>>() }\n        // Works correctly\n        if (true) None() else r\n    }\n    else r\n}\n\nfun <T> bind2(r: Option<T>): Option<T> {\n    return if (r is Some) {\n        // Works correctly\n        if (true) None<T>() else r\n    }\n    else r\n}\n\nfun <T, R> bind3(r: Option<T>): Option<T> {\n    return <!NI;TYPE_MISMATCH!>if (r is Some) {\n        // Diagnoses an error correctly\n        if (true) <!OI;TYPE_MISMATCH!>None<R>()<!> else r\n    }\n    else r<!>\n}\n\nfun <T> bindWhen(r: Option<T>): Option<T> {\n    return when (r) {\n        is Some -> {\n            // Works correctly\n            if (true) None() else r\n        }\n        else -> r\n    }\n}\n\ninterface SimpleOption\nclass SimpleSome : SimpleOption\nclass SimpleNone : SimpleOption\n\nfun bindNoGeneric(r: SimpleOption): SimpleOption {\n    return if (r is SimpleSome) {\n        (if (true) SimpleNone() else r) checkType { _<SimpleOption>() }\n        if (true) SimpleNone() else r\n    }\n    else r\n}"
        },
        {
            "code": "package kt786\n\n//KT-786 Exception on incomplete code with 'when'\nfun foo() : Int {\n    val d = 2\n    var z = 0\n    when(d) {\n        5, 3 -> <!UNUSED_CHANGED_VALUE!>z++<!>\n        <!ELSE_MISPLACED_IN_WHEN!>else<!> -> { <!UNUSED_VALUE!>z =<!> -1000 }\n        <!UNREACHABLE_CODE!>return z -> 34<!>\n    }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n//test unreachable code\nfun fff(): Int {\n    var d = 3\n    when(d) {\n        4 -> <!UNUSED_EXPRESSION!>21<!>\n        return 2<!UNREACHABLE_CODE!><!> -> <!UNREACHABLE_CODE!>return 47<!>\n        <!UNREACHABLE_CODE!>bar() -> 45<!>\n        <!UNREACHABLE_CODE!>444 -> true<!>\n    }\n    return 34\n}\n\nfun bar(): Int = 8"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun use(a: Any?) = a\n\nfun test() {\n    { }<!NOT_NULL_ASSERTION_ON_LAMBDA_EXPRESSION!>!!<!>\n    use({ }<!NOT_NULL_ASSERTION_ON_LAMBDA_EXPRESSION!>!!<!>);\n\n    // KT-KT-9070\n    <!TYPE_MISMATCH!>{ }<!> <!USELESS_ELVIS!>?: 1<!>\n    use({ 2 } <!USELESS_ELVIS!>?: 1<!>);\n\n    1 <!USELESS_ELVIS!>?: <!TYPE_MISMATCH, UNUSED_LAMBDA_EXPRESSION!>{ }<!><!>\n    use(1 <!USELESS_ELVIS!>?: { }<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitInnerClassesOfGenericClassExtendingThrowable\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// JAVAC_EXPECTED_FILE\n\nclass OuterGeneric<T> {\n    inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class ErrorInnerExn<!> : Exception()\n\n    inner class InnerA {\n        inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class ErrorInnerExn2<!> : Exception()\n    }\n\n    class OkNestedExn : Exception()\n\n    val errorAnonymousObjectExn = <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>object<!> : Exception() {}\n\n    fun foo() {\n        <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class OkLocalExn<!> : Exception()\n\n        val errorAnonymousObjectExn = <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>object<!> : Exception() {}\n    }\n\n    fun <X> genericFoo() {\n        <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class OkLocalExn<!> : Exception()\n\n        class LocalGeneric<Y> {\n            inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class ErrorInnerExnOfLocalGeneric<!> : Exception()\n        }\n    }\n}\n\nclass Outer {\n    inner class InnerGeneric<T> {\n        inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class ErrorInnerExn<!> : Exception()\n    }\n}\n\nfun <T> genericFoo() {\n    <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>class ErrorLocalExnInGenericFun<!> : Exception()\n\n    val errorkAnonymousObjectExnInGenericFun = <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS_WARNING!>object<!> : Exception() {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// FILE: b.kt\nfun <T: Any> exclExcl(t: T?): T = t!!\n\nfun test11() {\n    // not 'String!'\n    exclExcl(A.foo()) checkType { _<String>() }\n    exclExcl(A.foo()) checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n\n    // not 'String!'\n    A.foo()!! checkType { _<String>() }\n    A.foo()!! checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><String?>() }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See also KT-7428\nclass Container<K>(val k: K)\n// iterator() must be an extension, otherwise code will not compile\noperator fun <K> Container<K>.iterator(): Iterator<K> = null!!\n\nfun test() {\n    val container: Container<String>? = null\n    // Error\n    container<!UNSAFE_CALL!>.<!>iterator()\n    // for extension iterator, this code compiles, but should not\n    for (s in <!ITERATOR_ON_NULLABLE!>container<!>) {}\n}\nclass OtherContainer<K>(val k: K) {\n    operator fun iterator(): Iterator<K> = null!!\n}\n\nfun test2() {\n    val other: OtherContainer<String>? = null\n    // Error\n    for (s in <!ITERATOR_ON_NULLABLE!>other<!>) {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun example() {\n    val a = if (true) true else false\n    val b = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) else false\n    val c = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) true\n    val d = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) true else;\n    val e = if (true) <!IMPLICIT_CAST_TO_ANY!>{}<!> else <!IMPLICIT_CAST_TO_ANY!>false<!>\n    val f = if (true) <!IMPLICIT_CAST_TO_ANY!>true<!> else <!IMPLICIT_CAST_TO_ANY!>{}<!>\n\n    {\n        if (true) <!UNUSED_EXPRESSION!>true<!>\n    }();\n\n    {\n        if (true) true else false\n    }();\n\n    {\n        if (true) {} else false\n    }();\n\n\n    {\n        if (true) true else {}\n    }()\n\n    fun t(): Boolean {\n        return <!TYPE_MISMATCH!><!INVALID_IF_AS_EXPRESSION!>if<!> (true) true<!>\n    }\n\n    return <!NI;TYPE_MISMATCH!>if (true) <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!> else {}<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun println() {}\nfun foo(x: Any) {}\nfun <T> fooGeneric(x: T) {}\n\nfun testResultOfLambda1() =\n        run {\n            when {\n                true -> 42\n                else -> println()\n            }\n        }\n\nfun testResultOfLambda2() =\n        run {\n            when {\n                true -> 42\n                else ->\n                    when {\n                        true -> 42\n                        else -> println()\n                    }\n            }\n        }\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>testReturn1<!>() =\n        run {\n            return <!TYPE_MISMATCH!>when {\n                true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n                else -> <!IMPLICIT_CAST_TO_ANY!>println()<!>\n            }<!>\n        }\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>testReturn2<!>() =\n        run {\n            return <!TYPE_MISMATCH!>when {\n                true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n                else ->\n                    when {\n                        true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n                        else -> <!IMPLICIT_CAST_TO_ANY!>println()<!>\n                    }\n            }<!>\n        }\n\nfun testUsage1() =\n        when {\n            true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n            else -> <!IMPLICIT_CAST_TO_ANY!>println()<!>\n        }\n\nfun testUsage2() =\n        foo(when {\n                true -> 42\n                else -> println()\n            })\n\nfun testUsage2Generic() =\n        fooGeneric(when {\n                       true -> 42\n                       else -> println()\n                   })\n\nval testUsage3 =\n        when {\n            true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n            else -> <!IMPLICIT_CAST_TO_ANY!>println()<!>\n        }\n\nval testUsage4 =\n        when {\n            true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n            true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n            true -> <!IMPLICIT_CAST_TO_ANY!>42<!>\n            else -> <!IMPLICIT_CAST_TO_ANY!>println()<!>\n        }\n\nval testUsage5: Any get() =\n        when {\n            true -> 42\n            else -> println()\n        }"
        },
        {
            "code": "//KT-657 Semantic checks for when without condition\npackage kt657\n\nclass Pair<A, B>(<!UNUSED_PARAMETER!>a<!>: A, <!UNUSED_PARAMETER!>b<!>: B)\n\nfun foo() =\n    when {\n        cond1() -> 12\n        cond2() -> 2\n        <!CONSTANT_EXPECTED_TYPE_MISMATCH!>4<!> -> 34\n        <!TYPE_MISMATCH!>Pair(1, 2)<!> -> 3\n        <!EXPECTED_CONDITION!>in 1..10<!> -> 34\n        <!CONSTANT_EXPECTED_TYPE_MISMATCH!>4<!> -> 38\n        <!EXPECTED_CONDITION!>is Int<!> -> 33\n        else -> 34\n    }\n\nfun cond1() = false\n\nfun cond2() = true\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nfun foo() : Int {\n    try {\n        doSmth()\n    }\n    catch (e: Exception) {\n        <!UNREACHABLE_CODE!>return<!> <!TYPE_MISMATCH!>\"\"<!>\n    }\n    finally {\n        return <!TYPE_MISMATCH!>\"\"<!>\n    }\n}\n\nfun bar() : Int =\n    <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>try {\n        <!OI;TYPE_MISMATCH!>doSmth()<!>\n    }\n    catch (e: Exception) {\n        <!OI;TYPE_MISMATCH!>\"\"<!>\n    }\n    finally {\n        <!UNUSED_EXPRESSION!>\"\"<!>\n    }<!>\n\n\nfun doSmth() {}\n"
        },
        {
            "code": "class Pair {\n    operator fun component1(): Int = null!!\n    operator fun component2(): Int = null!!\n}\n\nclass Coll {\n    operator fun iterator(): It = It()\n}\n\nclass It {\n    operator fun next() = Pair()\n    operator fun hasNext() = false\n}\n\n\nfun f() {\n    for (<!VAL_OR_VAR_ON_LOOP_PARAMETER!>val<!> i in 1..4) {\n\n    }\n\n    for (<!VAL_OR_VAR_ON_LOOP_PARAMETER!>var<!> i in 1..4) {\n\n    }\n\n    for (<!VAL_OR_VAR_ON_LOOP_PARAMETER!>val<!> (<!UNUSED_VARIABLE!>i<!>,<!UNUSED_VARIABLE!>j<!>) in Coll()) {\n\n    }\n\n    for (<!VAL_OR_VAR_ON_LOOP_PARAMETER!>var<!> (<!UNUSED_VARIABLE!>i<!>,<!UNUSED_VARIABLE!>j<!>) in Coll()) {\n\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage kt1075\n\n//KT-1075 No type check for 'in range' condition in 'when' expression\n\nfun foo(b: String) {\n    if (<!TYPE_MISMATCH!>b<!> in 1..10) {} //type mismatch\n    when (<!NI;TYPE_MISMATCH!>b<!>) {\n        <!TYPE_MISMATCH_IN_RANGE!>in<!> 1..10 -> <!UNUSED_EXPRESSION!>1<!> //no type mismatch, but it should be here\n        else -> <!UNUSED_EXPRESSION!>2<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun idAny(x: Any) = x\nfun <T> id(x: T) = x\nfun idUnit(x: Unit) = x\n\nclass MList {\n    // MutableCollection<T>.add returns Boolean, but nobody cares\n    fun add(): Boolean = true\n}\nval mlist = MList()\n\nfun work() {}\n\nval xx1 = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\nval xx2: Unit = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\nval xx3 = idAny(<!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42)\nval xx4 = id(<!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42)\nval xx5 = idUnit(<!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42)\nval xx6 = null ?: <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\nval xx7 = \"\" + <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\n\nval wxx1 = <!NO_ELSE_IN_WHEN!>when<!> { true -> 42 }\nval wxx2: Unit = <!NI;TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!> { true -> <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!> }<!>\nval wxx3 = idAny(<!NO_ELSE_IN_WHEN!>when<!> { true -> 42 })\nval wxx4 = id(<!NO_ELSE_IN_WHEN!>when<!> { true -> 42 })\nval wxx5 = idUnit(<!NI;TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!> { true -> <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!> }<!>)\nval wxx6 = null ?: <!NO_ELSE_IN_WHEN!>when<!> { true -> 42 }\nval wxx7 = \"\" + <!NO_ELSE_IN_WHEN!>when<!> { true -> 42 }\n\nval fn1 = { if (true) <!UNUSED_EXPRESSION!>42<!> }\nval fn2 = { if (true) mlist.add() }\nval fn3 = { if (true) work() }\nval fn4 = { <!NO_ELSE_IN_WHEN!>when<!> { true -> 42 } }\nval fn5 = { <!NO_ELSE_IN_WHEN!>when<!> { true -> mlist.add() } }\nval fn6 = { when { true -> work() } }\n\nval ufn1: () -> Unit = { if (true) <!UNUSED_EXPRESSION!>42<!> }\nval ufn2: () -> Unit = { if (true) mlist.add() }\nval ufn3: () -> Unit = { if (true) work() }\nval ufn4: () -> Unit = { when { true -> <!UNUSED_EXPRESSION!>42<!> } }\nval ufn5: () -> Unit = { when { true -> mlist.add() } }\nval ufn6: () -> Unit = { when { true -> work() } }\n\nfun f1() = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) work()\nfun f2() = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) mlist.add()\nfun f3() = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\nfun f4(): Unit = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) work()\nfun f5(): Unit = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) mlist.add()\nfun f6(): Unit = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\nfun g1() = <!NO_ELSE_IN_WHEN!>when<!> { true -> work() }\nfun g2() = <!NO_ELSE_IN_WHEN!>when<!> { true -> mlist.add() }\nfun g3() = <!NO_ELSE_IN_WHEN!>when<!> { true -> 42 }\nfun g4(): Unit = <!NO_ELSE_IN_WHEN!>when<!> { true -> work() }\nfun g5(): Unit = <!NI;TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!> { true -> <!OI;TYPE_MISMATCH!>mlist.add()<!> }<!>\nfun g6(): Unit = <!NI;TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!> { true -> <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!> }<!>\n\nfun foo1(x: String?) {\n    \"\" + <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 42\n    w@while (true) {\n        x ?: if (true) break\n        x ?: when { true -> break@w }\n    }\n}\n\nfun foo2() {\n    if (true) {\n        mlist.add()\n    }\n    else if (true) {\n        mlist.add()\n    }\n    else if (true) {\n        mlist.add()\n    }\n\n    when {\n        true -> mlist.add()\n        else -> when {\n            true -> mlist.add()\n            else -> when {\n                true -> mlist.add()\n            }\n        }\n    }\n}\n\n"
        },
        {
            "code": "interface ClassData\n\nfun f() = object : ClassData {\n    val someInt: Int\n        get() {\n            return 5\n        }\n}\n\nfun g() = object : ClassData {\n    init {\n        if (true) {\n            <!RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY, RETURN_NOT_ALLOWED!>return<!> 0\n        }\n    }\n\n    fun some(): Int {\n        return 6\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNREACHABLE_CODE\npackage kt770_351_735\n\n\n//KT-770 Reference is not resolved to anything, but is not marked unresolved\nfun main() {\n    var i = 0\n    when (i) {\n        1 -> i--\n        2 -> i = 2  // i is surrounded by a black border\n        else -> <!UNRESOLVED_REFERENCE!>j<!> = 2\n    }\n    System.out.println(i)\n}\n\n//KT-351 Distinguish statement and expression positions\nval w = <!EXPRESSION_EXPECTED!>while (true) {}<!>\n\nfun foo() {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>z<!> = 2\n    val r = {  // type fun(): Any is inferred\n        if (true) {\n            2\n        }\n        else {\n            z = 34\n        }\n    }\n    val <!UNUSED_VARIABLE!>f<!>: ()-> Int = <!TYPE_MISMATCH!>r<!>\n    val <!UNUSED_VARIABLE!>g<!>: ()-> Any = r\n}\n\n//KT-735 Statements without braces are prohibited on the right side of when entries.\nfun box() : Int {\n    val d = 2\n    var z = 0\n    when(d) {\n        5, 3 -> z++\n        else -> z = -1000\n    }\n    return z\n}\n\n//More tests\n\nfun test1() { while(true) {} }\nfun test2(): Unit { while(true) {} }\n\nfun testCoercionToUnit() {\n    val <!UNUSED_VARIABLE!>simple<!>: ()-> Unit = {\n        <!UNUSED_EXPRESSION!>41<!>\n    }\n    val <!UNUSED_VARIABLE!>withIf<!>: ()-> Unit = {\n        if (true) {\n            <!UNUSED_EXPRESSION!>3<!>\n        } else {\n            <!UNUSED_EXPRESSION!>45<!>\n        }\n    }\n    val i = 34\n    val <!UNUSED_VARIABLE!>withWhen<!> : () -> Unit = {\n        when(i) {\n            1 -> {\n                val d = 34\n                <!UNUSED_EXPRESSION!>\"1\"<!>\n                doSmth(d)\n\n            }\n            2 -> <!UNUSED_EXPRESSION!>'4'<!>\n            else -> <!UNUSED_EXPRESSION!>true<!>\n        }\n    }\n\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>x<!> = 43\n    val checkType = {\n        if (true) {\n            x = 4\n        } else {\n            45\n        }\n    }\n    val <!UNUSED_VARIABLE!>f<!> : () -> String = <!TYPE_MISMATCH!>checkType<!>\n}\n\nfun doSmth(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\nfun testImplicitCoercion() {\n    val d = 21\n    var z = 0\n    var <!UNUSED_VARIABLE!>i<!> = when(d) {\n        3 -> null\n        4 -> { val <!NAME_SHADOWING, UNUSED_VARIABLE!>z<!> = 23 }\n        else -> z = 20\n    }\n\n    var <!UNUSED_VARIABLE!>u<!> = when(d) {\n        3 -> {\n        <!IMPLICIT_CAST_TO_ANY!><!UNUSED_VALUE!>z =<!> 34<!>\n    }\n        else -> <!IMPLICIT_CAST_TO_ANY, UNUSED_CHANGED_VALUE!>z--<!>\n    }\n\n    var <!UNUSED_VARIABLE!>iff<!> = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {\n        <!UNUSED_VALUE!>z =<!> 34\n    }\n    val <!UNUSED_VARIABLE!>g<!> = <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 4\n    val <!UNUSED_VARIABLE!>h<!> = if (false) <!IMPLICIT_CAST_TO_ANY!>4<!> else <!IMPLICIT_CAST_TO_ANY!>{}<!>\n\n    bar(<!NI;TYPE_MISMATCH!>if (true) {\n        <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>4<!>\n    }\n        else {\n        <!UNUSED_VALUE!>z =<!> 342\n    }<!>)\n}\n\nfun fooWithAnyArg(<!UNUSED_PARAMETER!>arg<!>: Any) {}\nfun fooWithAnyNullableArg(<!UNUSED_PARAMETER!>arg<!>: Any?) {}\n\nfun testCoercionToAny() {\n    val d = 21\n    val <!UNUSED_VARIABLE!>x1<!>: Any = if (1>2) 1 else 2.0\n    val <!UNUSED_VARIABLE!>x2<!>: Any? = if (1>2) 1 else 2.0\n    val <!UNUSED_VARIABLE!>x3<!>: Any? = if (1>2) 1 else (if (1>2) null else 2.0)\n\n    fooWithAnyArg(if (1>2) 1 else 2.0)\n    fooWithAnyNullableArg(if (1>2) 1 else 2.0)\n    fooWithAnyNullableArg(if (1>2) 1 else (if (1>2) null else 2.0))\n\n    val <!UNUSED_VARIABLE!>y1<!>: Any = when(d) { 1 -> 1.0 else -> 2.0 }\n    val <!UNUSED_VARIABLE!>y2<!>: Any? = when(d) { 1 -> 1.0 else -> 2.0 }\n    val <!UNUSED_VARIABLE!>y3<!>: Any? = when(d) { 1 -> 1.0; 2 -> null; else -> 2.0 }\n\n    fooWithAnyArg(when(d) { 1 -> 1.0 else -> 2.0 })\n    fooWithAnyNullableArg(when(d) { 1 -> 1.0 else -> 2.0 })\n    fooWithAnyNullableArg(when(d) { 1 -> 1.0; 2 -> null; else -> 2.0 })\n}\n\nfun fooWithAnuNullableResult(s: String?, name: String, optional: Boolean): Any? {\n    return if (s == null) {\n        if (!optional) {\n            throw java.lang.IllegalArgumentException(\"Parameter '$name' was not found in the request\")\n        }\n        null\n    } else {\n        name\n    }\n}\n\nfun bar(<!UNUSED_PARAMETER!>a<!>: Unit) {}\n\nfun testStatementInExpressionContext() {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>z<!> = 34\n    val <!UNUSED_VARIABLE!>a1<!>: Unit = <!ASSIGNMENT_IN_EXPRESSION_CONTEXT!><!UNUSED_VALUE!>z =<!> 334<!>\n    val <!UNUSED_VARIABLE!>f<!> = <!EXPRESSION_EXPECTED!>for (i in 1..10) {}<!>\n    if (true) return <!ASSIGNMENT_IN_EXPRESSION_CONTEXT!><!UNUSED_VALUE!>z =<!> 34<!>\n    return <!EXPRESSION_EXPECTED!>while (true) {}<!>\n}\n\nfun testStatementInExpressionContext2() {\n    val <!UNUSED_VARIABLE!>a2<!>: Unit = <!EXPRESSION_EXPECTED!>while(true) {}<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitInnerClassesOfGenericClassExtendingThrowable\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// JAVAC_EXPECTED_FILE\n\nclass OuterGeneric<T> {\n    inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class ErrorInnerExn<!> : Exception()\n\n    inner class InnerA {\n        inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class ErrorInnerExn2<!> : Exception()\n    }\n\n    class OkNestedExn : Exception()\n\n    val errorAnonymousObjectExn = <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>object<!> : Exception() {}\n\n    fun foo() {\n        <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class OkLocalExn<!> : Exception()\n\n        val errorAnonymousObjectExn = <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>object<!> : Exception() {}\n    }\n\n    fun <X> genericFoo() {\n        <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class OkLocalExn<!> : Exception()\n\n        class LocalGeneric<Y> {\n            inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class ErrorInnerExnOfLocalGeneric<!> : Exception()\n        }\n    }\n}\n\nclass Outer {\n    inner class InnerGeneric<T> {\n        inner <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class ErrorInnerExn<!> : Exception()\n    }\n}\n\nfun <T> genericFoo() {\n    <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class ErrorLocalExnInGenericFun<!> : Exception()\n\n    val errorkAnonymousObjectExnInGenericFun = <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>object<!> : Exception() {}\n}\n"
        },
        {
            "code": "\nfun foo1() = <!EXPRESSION_EXPECTED!>while (b()) {}<!>\n\nfun foo2() = <!EXPRESSION_EXPECTED!>for (<!UNUSED_PARAMETER!>i<!> in <!ITERATOR_MISSING!>10<!>) {}<!>\n\nfun foo3() = when (b()) {\n    true -> 1\n    else -> 0\n}\n\nfun b(): Boolean = true"
        },
        {
            "code": "class Coll {\n  operator fun iterator(): It? = null\n}\n\nclass It {\n  operator fun next() = 1\n  operator fun hasNext() = false\n}\n\nfun test() {\n  for (x in <!HAS_NEXT_FUNCTION_NONE_APPLICABLE, NEXT_NONE_APPLICABLE!>Coll()<!>) {}\n}"
        },
        {
            "code": "fun f() {\n    try {\n    } catch (<!VAL_OR_VAR_ON_CATCH_PARAMETER!>val<!> e: Exception) {\n    }\n\n    try {\n    } catch (<!VAL_OR_VAR_ON_CATCH_PARAMETER!>var<!> e: Exception) {\n    }\n\n    try {\n    } catch (e: Exception) {\n    }\n}"
        },
        {
            "code": "fun fn(c: Char?): Any? =\n        if (c == null) TODO()\n        else when (<!DEBUG_INFO_SMARTCAST!>c<!>) {\n            'a' -> when (<!DEBUG_INFO_SMARTCAST!>c<!>) {\n                'B' -> 1\n                'C' -> \"sdf\"\n                else -> TODO()\n            }\n            else -> TODO()\n        }"
        },
        {
            "code": "fun test1() {\n    test1@ for(i in 1..2) {\n        continue<!LABEL_NAME_CLASH!>@test1<!>\n    }\n}\n\nfun test2() {\n    test2@ while (true) {\n        break<!LABEL_NAME_CLASH!>@test2<!>\n    }\n}\n\nclass Test3 {\n    fun Test3() {\n        Test3@ while (true) {\n            break<!LABEL_NAME_CLASH!>@Test3<!>\n        }\n    }\n}\n\nfun test4() {\n    <!NOT_A_LOOP_LABEL!>break@test4<!>\n}\n\nclass Test5 {\n    fun Test5<!SYNTAX!><!> {\n        return@Test5\n    }\n}\n\nclass Test6 {\n    fun Test6() {\n        Test6@ while (true) {\n            break<!LABEL_NAME_CLASH!>@Test6<!>\n        }\n\n        Test6@ while (true) {\n            break<!LABEL_NAME_CLASH!>@Test6<!>\n        }\n    }\n}\n\nclass Test7 {\n    fun Test7() {\n        Test8@ while (true) {\n            <!NOT_A_LOOP_LABEL!>break@Test7<!>\n        }\n\n        <!UNREACHABLE_CODE!>Test7@ while (true) {\n            <!NOT_A_LOOP_LABEL!>break<!UNRESOLVED_REFERENCE!>@Test8<!><!>\n        }<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun println() {}\nfun foo(x: Any) {}\nfun <T> fooGeneric(x: T) {}\n\nfun testResultOfLambda1() =\n        run {\n            if (true) 42 else println()\n        }\n\nfun testResultOfLambda2() =\n        run {\n            if (true) 42 else if (true) 42 else println()\n        }\n\nfun testResultOfAnonFun1() =\n        run(fun () =\n                if (true) <!OI;IMPLICIT_CAST_TO_ANY!>42<!>\n                else <!OI;IMPLICIT_CAST_TO_ANY!>println()<!>\n        )\n\nfun testResultOfAnonFun2() =\n        run(fun () {\n            if (true) <!UNUSED_EXPRESSION!>42<!> else println()\n        })\n\nfun testReturnFromAnonFun() =\n        run(fun () {\n            return <!NI;TYPE_MISMATCH!>if (true) <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!> else println()<!>\n        })\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>testReturn1<!>() =\n        run {\n            return <!TYPE_MISMATCH!>if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n                   else <!IMPLICIT_CAST_TO_ANY!>println()<!><!>\n        }\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>testReturn2<!>() =\n        run {\n            return <!TYPE_MISMATCH!>if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n                   else if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n                   else <!IMPLICIT_CAST_TO_ANY!>println()<!><!>\n        }\n\nfun testUsage1() =\n        if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n        else <!IMPLICIT_CAST_TO_ANY!>println()<!>\n\nfun testUsage2() =\n        foo(if (true) 42 else println())\n\nfun testUsage2Generic() =\n        fooGeneric(if (true) 42 else println())\n\nval testUsage3 =\n        if (true) <!IMPLICIT_CAST_TO_ANY!>42<!>\n        else <!IMPLICIT_CAST_TO_ANY!>println()<!>\n\nval testUsage4: Any get() =\n        if (true) 42 else println()"
        },
        {
            "code": "fun test1() {\n    run {\n        if (true) {\n            <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {}\n        }\n        else {\n            1\n        }\n    }\n}\n"
        },
        {
            "code": "//KT-799 Allow 'return' expressions in conditionals assigned to variables\n\npackage kt799\n\nfun test() {\n    val <!UNUSED_VARIABLE!>a<!> : Int = if (true) 6 else return // should be allowed\n\n    val <!UNUSED_VARIABLE!>b<!> = if (true) 6 else return // should be allowed\n\n    doSmth(if (true) 3 else return)\n\n    doSmth(if (true) 3 else return, <!TOO_MANY_ARGUMENTS!>1<!>)\n}\n\nval a : Nothing = <!RETURN_NOT_ALLOWED!>return<!> 1\n\nval b = <!RETURN_NOT_ALLOWED!>return<!> 1\n\nval c = doSmth(if (true) 3 else <!RETURN_NOT_ALLOWED!>return<!>)\n\n\nfun f(<!UNUSED_PARAMETER!>mi<!>: Int = if (true) 0 else <!RETURN_NOT_ALLOWED!>return<!>) {}\n\nfun doSmth(<!UNUSED_PARAMETER!>i<!>: Int) {\n}\n"
        },
        {
            "code": "fun foo(x: Unit) = x\n\nfun test() {\n    if (false);\n    if (true);\n\n    val x = <!INVALID_IF_AS_EXPRESSION!>if<!> (false);\n    foo(x)\n\n    val y: Unit = <!INVALID_IF_AS_EXPRESSION!>if<!> (false);\n    foo(y)\n\n    foo({if (1==1);}())\n\n    return <!INVALID_IF_AS_EXPRESSION!>if<!> (true);\n}"
        },
        {
            "code": "@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann\n\nfun testLambdaLabel() = l@ { 42 }\n\nfun testAnonymousFunctionLabel() = l@ fun() {}\n\nfun testAnnotatedLambdaLabel() = lambda@ @Ann {}\n\nfun testParenthesizedLambdaLabel() = lambda@ ( {} )\n\nfun testLabelBoundToInvokeOperatorExpression() = <!REDUNDANT_LABEL_WARNING!>l@<!> { 42 }()\n\nfun testLabelBoundToLambda() = (l@ { 42 })()\n\nfun testWhileLoopLabel() {\n    L@ while (true) {}\n}\n\nfun testDoWhileLoopLabel() {\n    L@ do {} while (true)\n}\n\nfun testForLoopLabel(xs: List<Any>) {\n    L@ for (x in xs) {}\n}\n\nfun testValLabel() {\n    <!REDUNDANT_LABEL_WARNING!>L@<!> val fn = {}\n    fn()\n}\n\nfun testHighOrderFunctionCallLabel() {\n    <!REDUNDANT_LABEL_WARNING!>L@<!> run {}\n}\n\nfun testAnonymousObjectLabel() =\n    <!REDUNDANT_LABEL_WARNING!>L@<!> object {}"
        },
        {
            "code": "//KT-234 Force when() expressions to have an 'else' branch\n//KT-973 Unreachable code\n\npackage kt234_kt973\n\nclass Pair<A, B>(<!UNUSED_PARAMETER!>a<!>: A, <!UNUSED_PARAMETER!>b<!>: B)\n\nfun test(t : Pair<Int, Int>) : Int {\n    when (t) {\n        Pair(10, 10) -> return 1\n    }\n    return 0 // unreachable code\n}\n\nfun test1(t : Pair<Int, Int>) : Int {\n    when (t) {\n        Pair(10, 10) -> return 1\n        else -> return 2\n    }\n    <!UNREACHABLE_CODE!>return 0<!> // unreachable code\n}\n\n//more tests\nfun t1(x: Int) = when(<!UNUSED_EXPRESSION!>x<!>) {\n    else -> 1\n}\n\nfun t5(x: Int) = <!NO_ELSE_IN_WHEN!>when<!> (x) {\n    <!USELESS_IS_CHECK!>is Int<!> -> 1\n    2 -> 2\n}\n\nfun foo3(x: Int) = when(x) {\n    <!ELSE_MISPLACED_IN_WHEN!>else<!> -> 1\n    <!UNREACHABLE_CODE!>2 -> 2<!>\n}\n\nfun foo4(x: Int) = when(x) {\n    2 -> x\n    else -> 3\n}"
        },
        {
            "code": "// !LANGUAGE: -RestrictReturnStatementTarget\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann\n\nfun testFunctionName() {\n    return@testFunctionName\n}\n\nfun testHighOrderFunctionName() {\n    run {\n        return@run\n    }\n}\n\nfun testLambdaLabel() =\n    lambda@ {\n        return@lambda\n    }\n\nfun testParenthesizedLambdaLabel() =\n    lambda@ ( {\n        return@lambda\n    } )\n\nfun testAnnotatedLambdaLabel() =\n    lambda@ @Ann {\n        return@lambda\n    }\n\nfun testLambdaMultipleLabels1() =\n    lambda1@ lambda2@ {\n        return@lambda1\n    }\n\nfun testLambdaMultipleLabels2() =\n    lambda1@ lambda2@ {\n        return@lambda2\n    }\n\nfun testAnonymousFunctionLabel() =\n    anonFun@ fun() {\n        return@anonFun\n    }\n\nfun testLoopLabelInReturn(xs: List<Int>) {\n    L@ for (x in xs) {\n        if (x > 0) <!NOT_A_FUNCTION_LABEL_WARNING!>return@L<!>\n    }\n}\n\nfun testValLabelInReturn() {\n    <!REDUNDANT_LABEL_WARNING!>L@<!> val fn = { <!NOT_A_FUNCTION_LABEL_WARNING!>return@L<!> }\n    fn()\n}\n\nfun testHighOrderFunctionCallLabelInReturn() {\n    <!REDUNDANT_LABEL_WARNING!>L@<!> run {\n        <!NOT_A_FUNCTION_LABEL_WARNING!>return@L<!>\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// !CHECK_TYPE\n// Issue: KT-30406\n\ninterface Option<out T> {\n    val s: String\n}\nclass Some<T>(override val s: String) : Option<T>\nclass None(override val s: String = \"None\") : Option<Int>\n\nfun test(a: Int): Option<Any> =\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Option<kotlin.Any>\")!>if (a == 239)\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"Some<kotlin.Any>\")!>Some(\"239\")<!>\n    else\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"None\")!>None()<!><!>"
        },
        {
            "code": "fun call(f: () -> Unit) = f()\n\nfun f1() {\n    outer@ while (true) {\n        call {\n            <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break@outer<!>\n        }\n    }\n}\n\nfun f2() {\n    do {\n        fun inner() {\n            <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>continue<!>\n        }\n    } while (true)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage f\n\nfun test(a: Boolean, b: Boolean): Int {\n    return <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if(a) {\n        1\n    } else {\n        <!OI;TYPE_MISMATCH!><!INVALID_IF_AS_EXPRESSION!>if<!> (b) {\n            3\n        }<!>\n    }<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval test1 = { if (true) <!OI;IMPLICIT_CAST_TO_ANY!>1<!> else <!OI;IMPLICIT_CAST_TO_ANY!>\"\"<!> }\n\nval test2 = { { if (true) <!OI;IMPLICIT_CAST_TO_ANY!>1<!> else <!OI;IMPLICIT_CAST_TO_ANY!>\"\"<!> } }\n\nval test3: (Boolean) -> Any = { if (it) 1 else \"\" }\n\nval test4: (Boolean) -> Any? = { if (it) 1 else \"\" }\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitInnerClassesOfGenericClassExtendingThrowable\npackage test\n\nvar global: Throwable? = null\n\nfun <T> foo(x: Throwable, z: T, b: (T) -> Unit) {\n    <!INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS!>class A<!>(val y : T) : Exception()\n\n    try {\n        throw x\n    } catch (a: A) {\n        b(a.y)\n    } catch (e: Throwable) {\n        global = A(z)\n    }\n}\n\nfun main() {\n    foo(RuntimeException(), 1) { throw IllegalStateException() }\n    foo(global!!, \"\") { it.length } // (*)\n}\n\n// (*):\n//Exception in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n//  at test.TestKt$main$2.invoke(test.kt)\n//  at test.TestKt.foo(test.kt:12)\n//  at test.TestKt.main(test.kt:21)"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// See KT-9816, KT-9742\n\n// Not allowed in Java\nclass ZException<!GENERIC_THROWABLE_SUBCLASS!><T><!>(val p: T) : Exception()\n\nclass YException<!GENERIC_THROWABLE_SUBCLASS!><T><!>(val p: T): java.lang.RuntimeException()\n\nclass XException<!GENERIC_THROWABLE_SUBCLASS!><T><!>(val p: T): Throwable()\n\nfun bar() {\n    try {\n        throw ZException(11)\n    } catch (e: ZException<*>) {}    \n}\n\ninline fun <reified E : Exception, R> tryCatch(lazy: () -> R, failure: (E) -> R): R =\n    try {\n        lazy()\n    } catch (<!REIFIED_TYPE_IN_CATCH_CLAUSE!>e: E<!>) {\n        failure(e)\n    }\n\nfun <T : Throwable> tryCatch() {\n    try { } catch (<!TYPE_PARAMETER_IN_CATCH_CLAUSE!>e: T<!>) { }\n}"
        },
        {
            "code": "fun test() {\n    try { } catch (<!CATCH_PARAMETER_WITH_DEFAULT_VALUE!>e: Exception = <!DEBUG_INFO_MISSING_UNRESOLVED!>Exception<!>()<!>) { }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nval testImplicitExclExcl1: String = J.s\nval testImplicitExclExcl2: String? = J.s\n\nval testImplicitExclExcl3: String = <!TYPE_MISMATCH!>J.m[\"\"]<!>\nval testImplicitExclExcl4: String? = J.m[\"\"]\n\nval testExclExcl1: String = J.s!!\nval testExclExcl2: String? = J.s!!\n\nval testExclExcl3: String = J.m[\"\"]!!\nval testExclExcl4: String? = J.m[\"\"]!!\n\nval testSafeCall1: String = <!TYPE_MISMATCH!>J.s?.let { it }<!>\nval testSafeCall2: String? = J.s?.let { it }\n\nval testSafeCall3: String = <!TYPE_MISMATCH!>J.m[\"\"]?.let { it }<!>\nval testSafeCall4: String? = J.m[\"\"]?.let { it.toString() }\n\nval testIf1: String = if (true) J.s else J.s\nval testIf2: String? = if (true) J.s else J.s\n\nval testIf3: String = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (true) <!OI;TYPE_MISMATCH!>J.m[\"\"]<!> else <!OI;TYPE_MISMATCH!>J.m[\"\"]<!><!>\nval testIf4: String? = if (true) J.m[\"\"] else J.m[\"\"]\n\nval testWhen1: String = when { else -> J.s }\nval testWhen2: String? = when { else -> J.s }\n\nval testWhen3: String = <!NI;TYPE_MISMATCH!>when { else -> <!OI;TYPE_MISMATCH!>J.m[\"\"]<!> }<!>\nval testWhen4: String? = when { else -> J.m[\"\"] }\n"
        },
        {
            "code": "class Coll {\n  operator fun iterator(): It = It()\n}\n\nclass It {\n  operator fun next() = 1\n  operator fun hasNext() = false\n}\n\nfun test(c: Coll?) {\n  for (x in <!ITERATOR_ON_NULLABLE!>c<!>) {}\n\n  if (c != null) {\n    for(x in <!DEBUG_INFO_SMARTCAST!>c<!>) {}\n  }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass Rule(val apply:() -> Unit)\n\nfun bar() {}\n\nfun foo() {\n    val rule: Rule? = Rule { bar() }\n\n    // this compiles and works\n    val apply = rule?.apply\n    if (apply != null) <!DEBUG_INFO_SMARTCAST!>apply<!>()\n\n    // this compiles and works\n    rule?.apply?.invoke()\n\n    // this should be an error\n    rule?.<!OI;UNSAFE_IMPLICIT_INVOKE_CALL!>apply<!>()\n\n    // these both also ok (with smart cast / unnecessary safe call)\n    if (rule != null) {\n        <!DEBUG_INFO_SMARTCAST!>rule<!>.apply()\n        rule<!UNNECESSARY_SAFE_CALL!>?.<!>apply()\n    }\n}"
        },
        {
            "code": "fun v(<!UNUSED_PARAMETER!>x<!> : Int, <!UNUSED_PARAMETER!>y<!> : String, vararg <!UNUSED_PARAMETER!>f<!> : Long) {}\nfun v1(vararg <!UNUSED_PARAMETER!>f<!> :  (Int) -> Unit) {}\n\nfun test() {\n    v(1, \"\")\n    v(1, \"\", 1)\n    v(1, \"\", 1, 1, 1)\n    v(1, \"\", 1, 1, 1)\n\n    v1()\n    v1({})\n    v1({}, {})\n    v1({}, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, {})\n    v1({}, {}, {<!UNUSED_EXPRESSION!>it<!>})\n    v1({}) <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n    v1 <!VARARG_OUTSIDE_PARENTHESES!>{}<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage foo\n\nfun Any.foo() : () -> Unit {\n  return {}\n}\n\nfun Any.foo1() : (i : Int) -> Unit {\n  return {}\n}\n\nfun foo2() : (i : () -> Unit) -> Unit {\n  return {}\n}\n\nfun <T> fooT1(t : T) : () -> T {\n  return {t}\n}\n\nfun <T> fooT2() : (t : T) -> T {\n  return {it}\n}\n\nfun main(args : Array<String>) {\n    args.foo()()\n    args.foo1()(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo1<!>()()\n    <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo1<!>()(<!UNRESOLVED_REFERENCE!>a<!>)\n\n    args.foo1()(1)\n    args.foo1()(<!TYPE_MISMATCH!>\"1\"<!>)\n    <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo1<!>()(\"1\")\n    <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo1<!>()(<!UNRESOLVED_REFERENCE!>a<!>)\n\n    foo2()({})\n    foo2()<!TOO_MANY_ARGUMENTS!>{}<!>\n    (foo2()){}\n    (foo2())<!NI;TYPE_MISMATCH!>{<!CANNOT_INFER_PARAMETER_TYPE, EXPECTED_PARAMETERS_NUMBER_MISMATCH, UNUSED_ANONYMOUS_PARAMETER!>x<!> -> }<!>\n    foo2()(<!NI;TYPE_MISMATCH!>{<!CANNOT_INFER_PARAMETER_TYPE, EXPECTED_PARAMETERS_NUMBER_MISMATCH, UNUSED_ANONYMOUS_PARAMETER!>x<!> -> }<!>)\n\n    val a = fooT1(1)()\n    checkSubtype<Int>(a)\n\n    val b = fooT2<Int>()(1)\n    checkSubtype<Int>(b)\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>fooT2<!>()(1) // : Any?\n\n    <!FUNCTION_EXPECTED!>1<!>()\n    <!FUNCTION_EXPECTED!>1<!>{}\n    <!FUNCTION_EXPECTED!>1<!>(){}\n}\n\nfun f() :  Int.() -> Unit = {}\n\nfun main1() {\n    1.(fun Int.() = 1)();\n    {1}();\n    (fun (x : Int) = x)(1)\n    1.(fun Int.(x : Int) = x)(1);\n    <!REDUNDANT_LABEL_WARNING!>l@<!>{1}()\n    1.((fun Int.() = 1))()\n    1.(f())()\n    1.if(true){f()}else{f()}()\n    1.if(true)(fun Int.() {})else{f()}()\n\n    1.<!FUNCTION_EXPECTED!>\"sdf\"<!>()\n\n    1.<!ILLEGAL_SELECTOR!>\"sdf\"<!>\n    1.<!ILLEGAL_SELECTOR!>{}<!>\n    1.<!ILLEGAL_SELECTOR!>if (true) {}<!>\n}\n\nfun test() {\n    {<!UNUSED_ANONYMOUS_PARAMETER!>x<!> : Int -> 1}(<!NO_VALUE_FOR_PARAMETER!>)<!>;\n    (fun Int.() = 1)(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    <!OI;TYPE_MISMATCH!>\"sd\"<!>.<!NI;FUNCTION_EXPECTED!>(fun Int.() = 1)<!>()\n    val i : Int? = null\n    i<!UNSAFE_CALL!>.<!>(fun Int.() = 1)();\n    {}<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!>()\n    1<!UNNECESSARY_SAFE_CALL!>?.<!>(fun Int.() = 1)()\n    1.<!NO_RECEIVER_ALLOWED!>{}<!>()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass C<T>() {\n  fun foo() : T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\nfun foo(<!UNUSED_PARAMETER!>c<!>: C<Int>) {}\nfun <T> bar() : C<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun main() {\n  val <!UNUSED_VARIABLE!>a<!> : C<Int> = C();\n  val <!UNUSED_VARIABLE!>x<!> : C<in String> = C()\n  val <!UNUSED_VARIABLE!>y<!> : C<out String> = C()\n  val <!UNUSED_VARIABLE!>z<!> : C<*> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>C<!>()\n\n  val <!UNUSED_VARIABLE!>ba<!> : C<Int> = bar();\n  val <!UNUSED_VARIABLE!>bx<!> : C<in String> = bar()\n  val <!UNUSED_VARIABLE!>by<!> : C<out String> = bar()\n  val <!UNUSED_VARIABLE!>bz<!> : C<*> = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>()\n}"
        },
        {
            "code": "package <!SYNTAX!>return<!>\n\nclass A {\n    fun outer() {\n        fun inner() {\n            if (1 < 2)\n                return@inner\n            else\n            <!RETURN_NOT_ALLOWED!>return@outer<!>\n        }\n        if (1 < 2)\n            return<!UNRESOLVED_REFERENCE!>@A<!>\n        else if (2 < 3)\n            return<!UNRESOLVED_REFERENCE!>@inner<!>\n        return@outer\n    }\n}\n"
        },
        {
            "code": "abstract class A : Function1<Any, Unit>\n\nabstract class B : (Int)->Unit\n\n// Named parameter is prohibited because of possible inconsistency between\n// type declaration and actual override\nclass C : (<!UNSUPPORTED!>x<!>: Int)->Unit {\n    override fun invoke(p1: Int): Unit {}\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A {\n    companion object {\n        operator fun A.rem(x: Int) = 0\n    }\n\n    fun test() {\n        <!DEPRECATED_BINARY_MOD!>operator<!> fun A.mod(x: Int) = \"\"\n\n        takeInt(A() % 123)\n    }\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !API_VERSION: 1.2\n\nfun test() {\n    1.<!DEPRECATION!>mod<!>(3)\n}"
        },
        {
            "code": "// !API_VERSION: 1.1\n\nfun test() {\n    1.<!DEPRECATION!>mod<!>(3)\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun Int.mod(s: String) = 4\n}\n\nclass B {\n    operator fun Int.rem(s: String) = \"\"\n}\n\nfun test() {\n    with(B()) {\n        with(A()) {\n            takeString(1 % \"\")\n        }\n    }\n}\n\nfun takeString(s: String) {}"
        },
        {
            "code": "// !LANGUAGE: -OperatorRem\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject ModAndRem {\n    operator fun mod(x: Int) {}\n    <!UNSUPPORTED_FEATURE!>operator<!> fun rem(x: Int) {}\n}\n\nobject OldMod {\n    operator fun mod(x: Int) {}\n}\n\nobject ModAndRemExtension\noperator fun ModAndRemExtension.mod(x: Int) {}\n<!UNSUPPORTED_FEATURE!>operator<!> fun ModAndRemExtension.rem(x: Int) {}\n\nobject ModExtension\noperator fun ModExtension.mod(x: Int) {}\n\nobject ModMemberAndRemExtension {\n    operator fun mod(x: Int) {}\n}\n\n<!UNSUPPORTED_FEATURE!>operator<!> fun ModMemberAndRemExtension.rem(x: Int) {}\n\nfun foo() {\n    ModAndRem % 1\n    OldMod % 1\n\n    ModAndRemExtension % 1\n\n    ModExtension % 1\n\n    ModMemberAndRemExtension % 1\n\n    OldMod.mod(1)\n    ModExtension.mod(1)\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int): Foo = Foo()\n    operator fun rem(x: Int): Int = 0\n}\n\nfun foo() {\n    takeInt(Foo() % 1)\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass OldAndNew {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n    operator fun rem(x: Int) {}\n}\n\nclass OnlyOld {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n}\n\nclass OnlyNew {\n    operator fun rem(x: Int) {}\n}\n\nclass Sample\n\n<!DEPRECATED_BINARY_MOD!>operator<!> fun Sample.mod(x: Int) {}\noperator fun Sample.rem(x: Int) {}\n\nclass IntAndUnit {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) = 0\n    operator fun rem(x: Int): Int = 0\n}\n\nfun test() {\n    OldAndNew() % 1\n    OnlyOld() <!OI;DEPRECATED_BINARY_MOD_AS_REM!>%<!> 1\n    OnlyNew() % 1\n    Sample() % 1\n\n    takeInt(IntAndUnit() % 1)\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -EXTENSION_SHADOWED_BY_MEMBER\n\nclass ModAndRemAssign {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) = ModAndRemAssign()\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: String) = ModAndRemAssign()\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun modAssign(x: String) {}\n    operator fun rem(x: Int) = ModAndRemAssign()\n}\n\n<!DEPRECATED_BINARY_MOD!>operator<!> fun ModAndRemAssign.mod(x: String) = ModAndRemAssign()\n<!DEPRECATED_BINARY_MOD!>operator<!> fun ModAndRemAssign.modAssign(x: String) {}\n\nfun test() {\n    var modAndRemAssign = ModAndRemAssign()\n    modAndRemAssign %= 1\n}"
        },
        {
            "code": "// !LANGUAGE: -OperatorRem\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject ModAndRem {\n    operator fun mod(x: Int) = 0\n    <!UNSUPPORTED_FEATURE!>operator<!> fun rem(x: Int) = \"\"\n}\n\nobject ModAssignAndRemAssign {\n    operator fun modAssign(x: String) {}\n    <!UNSUPPORTED_FEATURE!>operator<!> fun remAssign(x: Int) {}\n}\n\nobject RemAndModAssign {\n    operator fun modAssign(x: Int) {}\n    <!UNSUPPORTED_FEATURE!>operator<!> fun rem(x: Int) = RemAndModAssign\n}\n\nobject OnlyRem {\n    <!UNSUPPORTED_FEATURE!>operator<!> fun rem(x: Int) {}\n    <!UNSUPPORTED_FEATURE!>operator<!> fun remAssign(x: Int) {}\n}\n\nfun test() {\n    takeInt(ModAndRem % 1)\n\n    val c = ModAssignAndRemAssign\n    c %= \"\"\n\n    var c1 = RemAndModAssign\n    c1 %= 1\n\n    OnlyRem <!UNRESOLVED_REFERENCE!>%<!> 1\n\n    val c2 = OnlyRem\n    c2 <!UNRESOLVED_REFERENCE!>%=<!> 1\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject A {\n    @Deprecated(\"Use mod instead\", ReplaceWith(\"mod\"), DeprecationLevel.HIDDEN)\n    operator fun rem(x: Int) = 0\n\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) = \"\"\n}\n\nfun test() {\n    takeString(A <!DEPRECATED_BINARY_MOD_AS_REM!>%<!> 123)\n}\n\nfun takeString(s: String) {}"
        },
        {
            "code": "// !LANGUAGE: -OperatorRem\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE, -EXTENSION_SHADOWED_BY_MEMBER\n\nclass Foo {\n    <!UNSUPPORTED_FEATURE!>operator<!> fun rem(x: Int): Foo = Foo()\n}\n\nclass Bar {\n    <!UNSUPPORTED_FEATURE!>operator<!> fun remAssign(x: Int) {}\n}\n\nclass Baz {\n    companion object {\n        <!UNSUPPORTED_FEATURE!>operator<!> fun rem(x: Int) {}\n        <!UNSUPPORTED_FEATURE!>operator<!> fun Int.rem(x: Int) {}\n    }\n}\n\n<!UNSUPPORTED_FEATURE!>operator<!> fun Baz.rem(x: Int) {}\n\nfun local() {\n    <!UNSUPPORTED_FEATURE!>operator<!> fun Int.rem(x: Int) {}\n    <!UNSUPPORTED_FEATURE!>operator<!> fun String.remAssign(x: Int) {}\n}\n\nfun noOverflow() {\n    (-1).mod(5)\n}\n\nfun builtIns(b: Byte, s: Short) {\n    var a = 1 % 2\n    a %= 3\n    1.mod(2)\n    b % s\n    1.0 % 2.0\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitOperatorMod\n// !WITH_NEW_INFERENCE\n// !API_VERSION: 1.0\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE, -EXTENSION_SHADOWED_BY_MEMBER\n\nclass Foo {\n    operator fun rem(x: Int): Foo = Foo()\n}\n\nclass Bar {\n    operator fun remAssign(x: Int) {}\n}\n\nclass Baz {\n    companion object {\n        operator fun rem(x: Int) {}\n        operator fun Int.rem(x: Int) {}\n    }\n}\n\noperator fun Baz.rem(x: Int) {}\n\nfun local() {\n    operator fun Int.rem(x: Int) {}\n    operator fun String.remAssign(x: Int) {}\n}\n\nclass WithMod {\n    <!FORBIDDEN_BINARY_MOD!>operator<!> fun mod(other: WithMod) = this\n\n    fun test() {\n        val a = this <!OI;FORBIDDEN_BINARY_MOD_AS_REM!>%<!> <!NI;TYPE_MISMATCH!>this<!>\n        var b = this.mod(this)\n        <!NI;TYPE_MISMATCH!>b <!OI;FORBIDDEN_BINARY_MOD_AS_REM!>%=<!> <!NI;TYPE_MISMATCH!>this<!><!>\n    }\n}\n\nfun noOverflow() {\n    (-1).mod(5)\n}\n\nfun builtIns(b: Byte, s: Short) {\n    var a = 1 % 2\n    a <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE!>%=<!> 3\n    1.mod(2)\n    b % <!NI;TYPE_MISMATCH!>s<!>\n    1.0 % <!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>2.0<!>\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int): Foo = Foo()\n}\n\noperator fun Foo.rem(x: Int): Int = 0\n\n\nfun foo() {\n    takeInt(Foo() % 1)\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject RemAndModAssign {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun modAssign(x: String) {}\n    operator fun rem(x: Int) = RemAndModAssign\n}\n\nfun test2() {\n    var c = RemAndModAssign\n    c %= 123\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject B\n\nclass A {\n    operator fun B.rem(x: Int) = 0\n}\n\nfun test1() {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun B.mod(x: Int) = \"\"\n\n    with(A()) {\n        takeInt(B % 10)\n    }\n}\n\nclass C {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun B.mod(x: Int) = \"\"\n}\n\nfun test2() {\n    operator fun B.rem(x: Int) = 0\n\n    with(C()) {\n        takeInt(B % 10)\n    }\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject ModAndRem {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n    operator fun rem(x: Int) {}\n}\n\nobject OldMod {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n}\n\nobject ModAndRemExtension\n<!DEPRECATED_BINARY_MOD!>operator<!> fun ModAndRemExtension.mod(x: Int) {}\noperator fun ModAndRemExtension.rem(x: Int) {}\n\nobject ModExtension\n<!DEPRECATED_BINARY_MOD!>operator<!> fun ModExtension.mod(x: Int) {}\n\nobject ModMemberAndRemExtension {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n}\n\noperator fun ModMemberAndRemExtension.rem(x: Int) {}\n\nfun foo() {\n    ModAndRem % 1\n    OldMod <!DEPRECATED_BINARY_MOD_AS_REM!>%<!> 1\n\n    ModAndRemExtension % 1\n\n    ModExtension <!DEPRECATED_BINARY_MOD_AS_REM!>%<!> 1\n\n    ModMemberAndRemExtension % 1\n\n    OldMod.mod(1)\n    ModExtension.mod(1)\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject ModAndRem {\n    <!FORBIDDEN_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n    operator fun rem(x: Int) {}\n\n    <!FORBIDDEN_BINARY_MOD!>operator<!> fun modAssign(x: Int) {}\n    operator fun remAssign(x: Int) {}\n}\n\nobject JustMod {\n    <!FORBIDDEN_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n    <!FORBIDDEN_BINARY_MOD!>operator<!> fun modAssign(x: Int) {}\n}\n\nfun foo() {\n    ModAndRem % 1\n    ModAndRem.mod(1)\n    ModAndRem.rem(1)\n\n    JustMod <!FORBIDDEN_BINARY_MOD_AS_REM!>%<!> 1\n    JustMod.mod(1)\n\n    val r = ModAndRem\n    r %= 1\n    r.remAssign(1)\n\n    val m = JustMod\n    m <!FORBIDDEN_BINARY_MOD_AS_REM!>%=<!> 1\n    m.modAssign(1)\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass OldAndNew {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun modAssign(x: Int) {}\n    operator fun remAssign(x: Int) {}\n}\n\nclass OnlyOld {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun modAssign(x: Int) {}\n}\n\nclass OnlyNew {\n    operator fun remAssign(x: Int) {}\n}\n\nclass Sample\n\n<!DEPRECATED_BINARY_MOD!>operator<!> fun Sample.modAssign(x: Int) {}\noperator fun Sample.remAssign(x: Int) {}\n\nclass ModAndRemAssign {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int): ModAndRemAssign = ModAndRemAssign()\n    operator fun remAssign(x: Int) {}\n}\n\nfun test() {\n    val oldAndNew = OldAndNew()\n    oldAndNew %= 1\n\n    val onlyOld = OnlyOld()\n    onlyOld <!OI;DEPRECATED_BINARY_MOD_AS_REM!>%=<!> 1\n\n    val onlyNew = OnlyNew()\n    onlyNew %= 1\n\n    val sample = Sample()\n    sample %= 1\n\n    var modAndRemAssign = ModAndRemAssign()\n    modAndRemAssign %= 1\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject OldMod {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) {}\n}\n\nobject RemExtension\noperator fun RemExtension.rem(x: Int) {}\n\nfun foo() {\n    OldMod <!OI;DEPRECATED_BINARY_MOD_AS_REM!>%<!> 123\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n}\n<!DEPRECATED_BINARY_MOD!>operator<!> fun Foo.mod(x: Int): Foo = Foo()\noperator fun Foo.rem(x: Int): Int = 0\n\nfun foo() {\n    takeInt(Foo() % 1)\n}\n\nfun takeInt(x: Int) {}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !WITH_NEW_INFERENCE\n// !API_VERSION: 1.0\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE, -EXTENSION_SHADOWED_BY_MEMBER\n\nclass Foo {\n    operator fun rem(x: Int): Foo = Foo()\n}\n\nclass Bar {\n    operator fun remAssign(x: Int) {}\n}\n\nclass Baz {\n    companion object {\n        operator fun rem(x: Int) {}\n        operator fun Int.rem(x: Int) {}\n    }\n}\n\noperator fun Baz.rem(x: Int) {}\n\nfun local() {\n    operator fun Int.rem(x: Int) {}\n    operator fun String.remAssign(x: Int) {}\n}\n\nclass WithMod {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(other: WithMod) = this\n\n    fun test() {\n        val a = this <!OI;DEPRECATED_BINARY_MOD_AS_REM!>%<!> <!NI;TYPE_MISMATCH!>this<!>\n        var b = this.mod(this)\n        <!NI;TYPE_MISMATCH!>b <!OI;DEPRECATED_BINARY_MOD_AS_REM!>%=<!> <!NI;TYPE_MISMATCH!>this<!><!>\n    }\n}\n\nfun noOverflow() {\n    (-1).mod(5)\n}\n\nfun builtIns(b: Byte, s: Short) {\n    var a = 1 % 2\n    a <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE!>%=<!> 3\n    1.mod(2)\n    b % <!NI;TYPE_MISMATCH!>s<!>\n    1.0 % <!NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>2.0<!>\n}"
        },
        {
            "code": "fun test() {\n    1.<!DEPRECATION_ERROR!>mod<!>(3)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nobject RemAndRemAssign {\n    operator fun rem(x: Int) = RemAndRemAssign\n}\n\noperator fun RemAndRemAssign.remAssign(x: Int) {}\n\nfun test() {\n    var c = RemAndRemAssign\n    c <!ASSIGN_OPERATOR_AMBIGUITY!>%=<!> 1\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitOperatorMod\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -EXTENSION_SHADOWED_BY_MEMBER\n\nclass ModAndRemAssign {\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: Int) = ModAndRemAssign()\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun mod(x: String) = ModAndRemAssign()\n    <!DEPRECATED_BINARY_MOD!>operator<!> fun modAssign(x: String) {}\n    operator fun remAssign(x: Int) {}\n}\n\n<!DEPRECATED_BINARY_MOD!>operator<!> fun ModAndRemAssign.mod(x: String) = ModAndRemAssign()\n<!DEPRECATED_BINARY_MOD!>operator<!> fun ModAndRemAssign.modAssign(x: String) {}\n\nfun test() {\n    val modAndRemAssign = ModAndRemAssign()\n    modAndRemAssign %= 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(1 % 1)\n    fooByte(1 % 1)\n    fooLong(1 % 1)\n    fooShort(1 % 1)\n}\n\npublic operator fun Int.<!EXTENSION_SHADOWED_BY_MEMBER!>rem<!>(other: Int): Int = 0"
        },
        {
            "code": "fun f(vararg <!UNUSED_PARAMETER!>t<!> : Int, <!UNUSED_PARAMETER!>f<!> : ()->Unit) {\n}\n\nfun test() {\n    f {}\n    f() {}\n    f(1) {\n\n    }\n    f(1, 2) {\n\n    }\n}"
        },
        {
            "code": "class A(vararg t : Int) {\n    init {\n        val <!UNUSED_VARIABLE!>t1<!> : IntArray = t\n    }\n}\n"
        },
        {
            "code": "fun foo1(<!UNUSED_PARAMETER!>a<!> : Int) : String = \"noarg\"\n\nfun foo1(<!UNUSED_PARAMETER!>a<!> : Int, vararg <!UNUSED_PARAMETER!>t<!> : Int) : String = \"vararg\"\n\nfun test1() {\n    foo1(1)\n    val a = IntArray(0)\n    foo1(1, *a)\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitNonConstValuesAsVarargsInAnnotations, -ProhibitAssigningSingleElementsToVarargsInNamedForm\n\nval nonConstArray = longArrayOf(0)\nfun nonConstFun(): LongArray = TODO()\n\nfun nonConstLong(): Long = TODO()\n\nannotation class Anno(vararg val value: Long)\n\n@Anno(value = <!ANNOTATION_ARGUMENT_IS_NON_CONST!>nonConstArray<!>)\nfun foo1() {}\n\n@Anno(value = <!ANNOTATION_ARGUMENT_IS_NON_CONST!>nonConstFun()<!>)\nfun foo2() {}\n\n@Anno(value = <!ANNOTATION_ARGUMENT_IS_NON_CONST!>longArrayOf(<!ANNOTATION_ARGUMENT_IS_NON_CONST!>nonConstLong()<!>)<!>)\nfun foo3() {}\n\n@Anno(value = <!ANNOTATION_ARGUMENT_IS_NON_CONST!>[<!ANNOTATION_ARGUMENT_IS_NON_CONST!>nonConstLong()<!>]<!>)\nfun foo4() {}\n\n@Anno(value = *<!ANNOTATION_ARGUMENT_MUST_BE_CONST, REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>nonConstArray<!>)\nfun bar1() {}\n\n@Anno(*<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>nonConstArray<!>)\nfun bar2() {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun testVarargOfNothing(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: Nothing) {}\n\nfun testVarargOfNNothing(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: Nothing?) {}\n\nfun <T : Nothing?> testVarargOfT(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: T) {}\n\nfun outer() {\n    fun testVarargOfNothing(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: Nothing) {}\n\n    fun testVarargOfNNothing(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: Nothing?) {}\n\n    fun <T : Nothing?> testVarargOfT(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: T) {}\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitNonConstValuesAsVarargsInAnnotations, +ProhibitAssigningSingleElementsToVarargsInNamedForm\n\nval nonConstArray = longArrayOf(0)\nfun nonConstFun(): LongArray = TODO()\n\nfun nonConstLong(): Long = TODO()\n\nannotation class Anno(vararg val value: Long)\n\n@Anno(value = <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>nonConstArray<!>)\nfun foo1() {}\n\n@Anno(value = <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>nonConstFun()<!>)\nfun foo2() {}\n\n@Anno(value = <!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>longArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>nonConstLong()<!>)<!>)\nfun foo3() {}\n\n@Anno(value = <!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>[<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>nonConstLong()<!>]<!>)\nfun foo4() {}\n\n@Anno(value = *<!ANNOTATION_ARGUMENT_MUST_BE_CONST, REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>nonConstArray<!>)\nfun bar1() {}\n\n@Anno(*<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>nonConstArray<!>)\nfun bar2() {}\n"
        },
        {
            "code": "fun foo0() : String = \"noarg\"\n\nfun foo0(vararg <!UNUSED_PARAMETER!>t<!> : Int) : String = \"vararg\"\n\nfun test0() {\n    foo0()\n    foo0(1)\n    val a = IntArray(0)\n    foo0(*a)\n}"
        },
        {
            "code": "// !LANGUAGE: +ArrayLiteralsInAnnotations, +AssigningArraysToVarargsInNamedFormInAnnotations, +ProhibitAssigningSingleElementsToVarargsInNamedForm\n\n// FILE: test.kt\n\nannotation class Ann(vararg val s: String)\n\n@Ann(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION_ERROR!>\"value\"<!>)\nfun test1() {}\n\n@Ann(s = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>arrayOf(\"value\")<!>)\nfun test2() {}\n\n@Ann(s = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>[\"value\"]<!>)\nfun test3() {}\n\n@JavaAnn(value = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION_ERROR!>\"value\"<!>)\nfun test4() {}\n\n@JavaAnn(\"value\", path = arrayOf(\"path\"))\nfun test5() {}\n\n@JavaAnn(\"value\", path = [\"path\"])\nfun test6() {}"
        },
        {
            "code": "class A(vararg val t : Int) {\n    init {\n        val <!UNUSED_VARIABLE!>t1<!> : IntArray = t\n    }\n}\n"
        },
        {
            "code": "class My {\n    var x: String = \"\"\n        set(<!WRONG_MODIFIER_CONTAINING_DECLARATION!>vararg<!> value) {\n            x = value\n        }\n}"
        },
        {
            "code": "// !LANGUAGE: +ArrayLiteralsInAnnotations, +AssigningArraysToVarargsInNamedFormInAnnotations, -ProhibitAssigningSingleElementsToVarargsInNamedForm\n\n// FILE: test.kt\n\nannotation class Ann(vararg val s: String)\n\n@Ann(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION!>\"value\"<!>)\nfun test1() {}\n\n@Ann(s = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>arrayOf(\"value\")<!>)\nfun test2() {}\n\n@Ann(s = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>[\"value\"]<!>)\nfun test3() {}\n\n@JavaAnn(value = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION!>\"value\"<!>)\nfun test4() {}\n\n@JavaAnn(\"value\", path = arrayOf(\"path\"))\nfun test5() {}\n\n@JavaAnn(\"value\", path = [\"path\"])\nfun test6() {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS:-UNUSED_PARAMETER\n\n// KT-9883 prohibit using spread operator for nullable value\n\n// FILE: 1.kt\nval args: Array<String>? = null\n\nfun bar(x: Int, vararg s: String) {}\n\nfun baz(s: String) {}\n\nfun getArr(): Array<String>? = null\n\nfun f() {\n    A().foo(1, <!SPREAD_OF_NULLABLE!>*<!>args)\n    bar(2, <!SPREAD_OF_NULLABLE!>*<!><!TYPE_MISMATCH!>args<!>)\n    baz(<!NON_VARARG_SPREAD, SPREAD_OF_NULLABLE!>*<!><!NI;TYPE_MISMATCH!>args<!>)\n}\n\nfun g(args: Array<String>?) {\n\n    if (args != null) {\n        A().foo(1, *<!OI;DEBUG_INFO_SMARTCAST!>args<!>)\n    }\n    A().foo(1, *A.ar)\n}\n\nclass B {\n    var args: Array<String>? = null\n}\n\nfun h(b: B) {\n    if (b.args != null) {\n        A().foo(1, <!SPREAD_OF_NULLABLE!>*<!><!OI;SMARTCAST_IMPOSSIBLE!>b.args<!>)\n    }\n}\n\nfun k() {\n    A().foo(1, <!SPREAD_OF_NULLABLE!>*<!>getArr())\n    bar(2, <!SPREAD_OF_NULLABLE!>*<!><!TYPE_MISMATCH!>getArr()<!>)\n    baz(<!NON_VARARG_SPREAD, SPREAD_OF_NULLABLE!>*<!><!NI;TYPE_MISMATCH!>getArr()<!>)\n}\n\nfun invokeTest(goodArgs: Array<String>) {\n    J.staticFun(*goodArgs)\n    J.staticFun(<!SPREAD_OF_NULLABLE!>*<!>args)\n    J.staticFun(<!SPREAD_OF_NULLABLE!>*<!>args <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ArrayLiteralsInAnnotations, -AssigningArraysToVarargsInNamedFormInAnnotations\n\n// FILE: test.kt\n\nannotation class Ann(vararg val s: String)\n\n@Ann(s = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf()<!>)\nfun test1() {}\n\n@Ann(s = <!TYPE_MISMATCH!>intArrayOf()<!>)\nfun test2() {}\n\n@Ann(s = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(1)<!>)\nfun test3() {}\n\n@Ann(s = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH, TYPE_MISMATCH!>[\"value\"]<!>)\nfun test5() {}\n\n@JavaAnn(value = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(\"value\")<!>)\nfun jTest1() {}\n\n@JavaAnn(value = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH, TYPE_MISMATCH!>[\"value\"]<!>)\nfun jTest2() {}\n\n@JavaAnn(value = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH, TYPE_MISMATCH!>[\"value\"]<!>, path = [\"path\"])\nfun jTest3() {}\n\nannotation class IntAnn(vararg val i: Int)\n\n@IntAnn(i = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH, TYPE_MISMATCH!>[1, 2]<!>)\nfun foo1() {}\n\n@IntAnn(i = <!TYPE_MISMATCH!>intArrayOf(0)<!>)\nfun foo2() {}\n\nfun foo(vararg <!UNUSED_PARAMETER!>i<!>: Int) {}\n\n@Ann(s = \"value\")\nfun dep1() {\n    foo(i = 1)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun <T: Any> foo(vararg <!UNUSED_PARAMETER!>ts<!>: T): T? = null\n\nclass Pair<A>(<!UNUSED_PARAMETER!>a<!>: A)\n\nfun test() {\n    val v = foo(Pair(1))\n    checkSubtype<Int>(<!TYPE_MISMATCH!>v<!>) // check that it is not error type\n}"
        },
        {
            "code": "fun main(d : D) {\n    d.from(\"\")\n    d.from(1)\n}\n\nclass D {\n    fun from(vararg <!UNUSED_PARAMETER!>a<!> : Any){}\n    fun from(vararg <!UNUSED_PARAMETER!>a<!> : String){}\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitAssigningSingleElementsToVarargsInNamedForm\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nannotation class Anno1(vararg val s: String)\nannotation class Anno2(vararg val i: Int)\n\n@Anno1(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION_ERROR!>\"foo\"<!>)\n@Anno2(i = *<!REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION!>intArrayOf(1)<!>)\nfun f1() {}\n\n@Anno1(s = [\"foo\"])\n@Anno2(i = intArrayOf(1))\nfun f2() {}\n\nfun foo(vararg ints: Int) {}\n\nfun test() {\n    foo(ints = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>)\n    foo(ints = *intArrayOf(1))\n}\n"
        },
        {
            "code": "// FILE: kotlin.kt\nfun main(j : C, s : Array<String?>) {\n    j.from()\n    j.from(\"\")\n    j.from(\"\", \"\")\n    j.<!OVERLOAD_RESOLUTION_AMBIGUITY!>from<!>(\"\", \"\", \"\")\n\n    j.<!OVERLOAD_RESOLUTION_AMBIGUITY!>from<!>(\"\", *s) // This should not be an ambiguity, see KT-1842\n    j.from(*s)\n}\n\n"
        },
        {
            "code": "package test\n\nclass CompositeIterator<T>(vararg iterators: <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.Iterator<T><!>){\n    val iteratorsIter = iterators.iterator()\n}"
        },
        {
            "code": "// !LANGUAGE: +AssigningArraysToVarargsInNamedFormInAnnotations, +ProhibitAssigningSingleElementsToVarargsInNamedForm\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\nfun foo(vararg s: Int) {}\n\nopen class Cls(vararg p: Long)\n\nfun test(i: IntArray) {\n    foo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>)\n    foo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR, TYPE_MISMATCH!>i<!>)\n    foo(s = *i)\n    foo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR, TYPE_MISMATCH!>intArrayOf(1)<!>)\n    foo(s = *intArrayOf(1))\n    foo(1)\n\n    Cls(p = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>)\n\n    class Sub : Cls(p = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>)\n\n    val c = object : Cls(p = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>) {}\n\n    foo(s = *intArrayOf(elements = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>))\n}\n\n\nfun anyFoo(vararg a: Any) {}\n\nfun testAny() {\n    anyFoo(a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>)\n    anyFoo(a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>arrayOf(\"\")<!>)\n    anyFoo(a = *arrayOf(\"\"))\n}\n\nfun <T> genFoo(vararg t: T) {}\n\nfun testGen() {\n    genFoo<Int>(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>)\n    genFoo<Int?>(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>null<!>)\n    genFoo<Array<Int>>(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>arrayOf()<!>)\n    genFoo<Array<Int>>(t = *arrayOf(arrayOf()))\n\n    genFoo(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>)\n    genFoo(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>arrayOf(\"\")<!>)\n    genFoo(t = *arrayOf(\"\"))\n}\n\nfun manyFoo(vararg v: Int) {}\nfun manyFoo(vararg s: String) {}\n\nfun testMany(a: Any) {\n    manyFoo(v = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>1<!>)\n    manyFoo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>\"\"<!>)\n\n    <!NONE_APPLICABLE!>manyFoo<!>(a)\n    <!NI;NONE_APPLICABLE!>manyFoo<!>(<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>v<!> = <!OI;ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR, OI;TYPE_MISMATCH!>a<!>)\n    <!NI;NONE_APPLICABLE!>manyFoo<!>(<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>s<!> = <!OI;ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR, OI;TYPE_MISMATCH!>a<!>)\n    manyFoo(v = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>a as Int<!>)\n    manyFoo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION_ERROR!>a as String<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +ArrayLiteralsInAnnotations, +AssigningArraysToVarargsInNamedFormInAnnotations\n\n// FILE: test.kt\n\nannotation class Ann(vararg val s: String)\n\n@Ann(s = arrayOf())\nfun test1() {}\n\n@Ann(s = <!TYPE_MISMATCH!>intArrayOf()<!>)\nfun test2() {}\n\n@Ann(s = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(1)<!>)\nfun test3() {}\n\n@Ann(\"value1\", \"value2\")\nfun test4() {}\n\n@Ann(s = [\"value\"])\nfun test5() {}\n\n@JavaAnn(value = arrayOf(\"value\"))\nfun jTest1() {}\n\n@JavaAnn(value = [\"value\"])\nfun jTest2() {}\n\n@JavaAnn(value = [\"value\"], path = [\"path\"])\nfun jTest3() {}\n\n\nannotation class IntAnn(vararg val i: Int)\n\n@IntAnn(i = [1, 2])\nfun foo1() {}\n\n@IntAnn(i = intArrayOf(0))\nfun foo2() {}"
        },
        {
            "code": "// !LANGUAGE: +AssigningArraysToVarargsInNamedFormInAnnotations, -ProhibitAssigningSingleElementsToVarargsInNamedForm\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\nfun foo(vararg s: Int) {}\n\nopen class Cls(vararg p: Long)\n\nfun test(i: IntArray) {\n    foo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>)\n    foo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION, TYPE_MISMATCH!>i<!>)\n    foo(s = *i)\n    foo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION, TYPE_MISMATCH!>intArrayOf(1)<!>)\n    foo(s = *intArrayOf(1))\n    foo(1)\n\n    Cls(p = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>)\n\n    class Sub : Cls(p = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>)\n\n    val c = object : Cls(p = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>) {}\n\n    foo(s = *intArrayOf(elements = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>))\n}\n\n\nfun anyFoo(vararg a: Any) {}\n\nfun testAny() {\n    anyFoo(a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>\"\"<!>)\n    anyFoo(a = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>arrayOf(\"\")<!>)\n    anyFoo(a = *arrayOf(\"\"))\n}\n\nfun <T> genFoo(vararg t: T) {}\n\nfun testGen() {\n    genFoo<Int>(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>)\n    genFoo<Int?>(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>null<!>)\n    genFoo<Array<Int>>(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>arrayOf()<!>)\n    genFoo<Array<Int>>(t = *arrayOf(arrayOf()))\n\n    genFoo(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>\"\"<!>)\n    genFoo(t = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>arrayOf(\"\")<!>)\n    genFoo(t = *arrayOf(\"\"))\n}\n\nfun manyFoo(vararg v: Int) {}\nfun manyFoo(vararg s: String) {}\n\nfun testMany(a: Any) {\n    manyFoo(v = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>1<!>)\n    manyFoo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>\"\"<!>)\n\n    <!NONE_APPLICABLE!>manyFoo<!>(a)\n    <!NI;NONE_APPLICABLE!>manyFoo<!>(<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>v<!> = <!OI;ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION, OI;TYPE_MISMATCH!>a<!>)\n    <!NI;NONE_APPLICABLE!>manyFoo<!>(<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>s<!> = <!OI;ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION, OI;TYPE_MISMATCH!>a<!>)\n    manyFoo(v = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>a as Int<!>)\n    manyFoo(s = <!ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION!>a as String<!>)\n}"
        },
        {
            "code": "fun foo(vararg <!UNUSED_PARAMETER!>t<!> : String) = \"\"\nfun foo(vararg <!UNUSED_PARAMETER!>t<!> : Int) = \"\"\n\nfun test() {\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>()\n}"
        },
        {
            "code": "// FILE: 1.kt\n\nval test = A(<!NAMED_ARGUMENTS_NOT_ALLOWED!>x<!> = 1, <!NAMED_ARGUMENTS_NOT_ALLOWED!>y<!> = \"2\")\n"
        },
        {
            "code": "interface A {\n    fun foo(x : Int)\n}\n\ninterface B {\n    fun foo(y : Int)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface C<!> : A, B\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface D<!> : B, A\n\nfun foo(x : C, y : D){\n    x.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>x<!> = 0)\n    x.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>y<!> = 0)\n    y.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>x<!> = 0)\n    y.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>y<!> = 0)\n}\n\nabstract <!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>class C1<!> : A, B\nabstract <!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>class D1<!> : A, B\n\nfun bar(x : C1, y : D1){\n    x.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>x<!> = 0)\n    x.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>y<!> = 0)\n    y.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>x<!> = 0)\n    y.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>y<!> = 0)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: test/J.java\n\npackage test;\n\npublic class J {\n    public J(String s, Runnable r, Boolean z) {\n    }\n}\n\n// FILE: usage.kt\n\npackage test\n\nfun test() {\n    J(\"\", <!NAMED_ARGUMENTS_NOT_ALLOWED!>r<!> = <!NI;TYPE_MISMATCH!>{ }<!>, <!NAMED_ARGUMENTS_NOT_ALLOWED!>z<!> = false)\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\nfun directInvocation() = JavaSuperClass().foo(<!NAMED_ARGUMENTS_NOT_ALLOWED!>javaName<!> = 1)\n\nopen class KotlinSubClass : JavaSuperClass()\n\nfun viaFakeOverride() = KotlinSubClass().foo(<!NAMED_ARGUMENTS_NOT_ALLOWED!>javaName<!> = 2)\n\nclass KotlinSubSubClass : KotlinSubClass() {\n    override fun foo(kotlinName: Int) {}\n}\n\nfun viaRealOverride() = KotlinSubSubClass().foo(kotlinName = 3)\n\n\nfun unresolvedParameter() = JavaSuperClass().foo(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>nonexistentName<!> = 4<!NO_VALUE_FOR_PARAMETER!>)<!>\n\n\nfun multipleParameters() = JavaSuperClass().multipleParameters(<!NAMED_ARGUMENTS_NOT_ALLOWED!>first<!> = 1, <!NAMED_ARGUMENTS_NOT_ALLOWED!>second<!> = 2L, <!NAMED_ARGUMENTS_NOT_ALLOWED!>third<!> = \"3\")\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: test/J.java\n\npackage test;\n\npublic class J {\n    public static void foo(String s, Runnable r, Boolean z) {\n    }\n}\n\n// FILE: usage.kt\n\npackage test\n\nfun test() {\n    J.foo(\"\", <!NAMED_ARGUMENTS_NOT_ALLOWED!>r<!> = <!NI;TYPE_MISMATCH!>{ }<!>, <!NAMED_ARGUMENTS_NOT_ALLOWED!>z<!> = false)\n}\n"
        },
        {
            "code": "interface A<T> {\n    fun foo(a: T)\n}\n\ninterface B {\n    fun foo(b: Int)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface C<!> : A<Int>, B { // Warning here, this is correct\n}\n\nfun test(c: C) {\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>a<!> = 1)\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>b<!> = 1)\n}"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>a<!> : Int = 1, <!UNUSED_PARAMETER!>b<!> : String = \"abc\") {\n}\n\nfun bar(<!UNUSED_PARAMETER!>x<!> : Int = 1, <!UNUSED_PARAMETER!>y<!> : Int = 1, <!UNUSED_PARAMETER!>z<!> : String) {\n}\n\nfun test() {\n    foo()\n    foo(2)\n    foo(<!TYPE_MISMATCH!>\"\"<!>)\n    foo(b = \"\")\n    foo(1, \"\")\n    foo(a = 2)\n    foo(1, \"\", <!TOO_MANY_ARGUMENTS!>\"\"<!>)\n\n    bar(z = \"\")\n    bar(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    bar(<!TYPE_MISMATCH!>\"\"<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    bar(1, 1, \"\")\n    bar(1, 1, \"\")\n    bar(1, z = \"\")\n    bar(1, z = \"\", y = 2)\n    bar(z = \"\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>1<!>)\n    bar(1, <!NAMED_PARAMETER_NOT_FOUND!>zz<!> = \"\",\n           <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!><!UNRESOLVED_REFERENCE!>zz<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!><!>\n           <!NO_VALUE_FOR_PARAMETER!>)<!>\n}"
        },
        {
            "code": "interface A {\n    fun foo(a1: Int, a2: Double)\n}\n\ninterface B {\n    fun foo(b1: Int, b2: Double)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES, DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface C<!> : A, B { // Warning here, this is correct, C.foo has no named parameters\n}\n\ninterface D : C {\n    override fun foo(<!PARAMETER_NAME_CHANGED_ON_OVERRIDE!>d1<!>: Int, <!PARAMETER_NAME_CHANGED_ON_OVERRIDE!>d2<!>: Double)\n}\n\nfun test1(d: D) {\n    d.foo(d1 = 1, d2 = 1.0)\n}\n\nfun test2(c: C) {\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>b1<!> = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>b2<!> = 1.0)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference -MixedNamedArgumentsInTheirOwnPosition\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nfun foo(\n    p1: Int,\n    p2: String,\n    p3: Double\n) {}\n\nfun main() {\n    foo(p1 = 1, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"2\"<!>, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, p2 = \"2\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, \"2\", p3 = 3.0)\n\n    foo(p1 = 1, p2 = \"2\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"\"<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference +MixedNamedArgumentsInTheirOwnPosition\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nfun foo(\n    p1: Int,\n    p2: String,\n    p3: Double\n) {}\n\nfun main() {\n    foo(p1 = 1, \"2\", 3.0)\n    foo(1, p2 = \"2\", 3.0)\n    foo(1, \"2\", p3 = 3.0)\n\n    foo(p1 = 1, p2 = \"2\", 3.0)\n\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"\"<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: -NewInference +MixedNamedArgumentsInTheirOwnPosition\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nfun foo(\n    p1: Int,\n    p2: String,\n    p3: Double\n) {}\n\nfun main() {\n    foo(p1 = 1, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"2\"<!>, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, p2 = \"2\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, \"2\", p3 = 3.0)\n\n    foo(p1 = 1, p2 = \"2\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"\"<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference +MixedNamedArgumentsInTheirOwnPosition\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nfun foo(\n    p1: Int = 1,\n    p2: String = \"\",\n    p3: Double = 3.0,\n    p4: Char = '4'\n) {}\n\nfun main() {\n    foo(p1 = 1, \"2\", 3.0)\n    foo(1, p2 = \"2\", 3.0)\n    foo(1, \"2\", p3 = 3.0)\n\n    foo(p1 = 1)\n    foo(1, p2 = \"2\")\n\n    foo(p1 = 1, p2 = \"2\", 3.0)\n\n    foo()\n    foo(1, p2 = \"\")\n    foo(p3 = 4.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>'4'<!>)\n\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"\"<!>)\n    foo(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>3.0<!>)\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference +MixedNamedArgumentsInTheirOwnPosition\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nfun foo1(\n    vararg p1: Int,\n    p2: String,\n    p3: Double\n) {}\n\nfun foo2(\n    p1: Int,\n    vararg p2: String,\n    p3: Double\n) {}\n\nfun foo3(\n    p1: Int,\n    p2: String,\n    vararg p3: Double\n) {}\n\nfun foo4(\n    p1: Int,\n    vararg p2: String,\n    p3: Double,\n    p4: Int\n) {}\n\nfun main() {\n    foo1(1, 2, p2 = \"3\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>4.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo1(p1 = *intArrayOf(1, 2), \"3\", p3 = 4.0)\n\n    foo1(p2 = \"3\", <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>4.0<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    foo2(p1 = 1, \"2\", \"3\", p3 = 4.0)\n    foo2(1, p2 = *arrayOf(\"2\", \"3\"), 4.0)\n    foo2(1, p3 = 3.0)\n\n    foo3(p1 = 1, \"2\", 3.0, 4.0)\n    foo3(p1 = 1, \"2\", p3 = *doubleArrayOf(3.0, 4.0))\n\n    foo4(p1 = 1, \"2\", \"3\", p3 = 4.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>5<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo4(1, \"2\", \"3\", p3 = 4.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>5<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo4(1, p3 = 4.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>5<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n\n    foo1(1, 2, p3 = 3.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"4\"<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo1(1, 2, p3 = 3.0, p2 = \"4\")\n    foo1(*intArrayOf(1, 2), p3 = 3.0, p2 = \"4\")\n\n    foo2(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"4\"<!>)\n    foo2(1, p3 = 2.0, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>*arrayOf(\"3\", \"4\")<!>)\n    foo2(1, p3 = 2.0, p2 = *arrayOf(\"3\", \"4\"))\n\n    foo3(1, p3 = *doubleArrayOf(2.0, 3.0), <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"4\"<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n    foo3(1, p3 = *doubleArrayOf(2.0, 3.0), p2 = \"4\")\n}\n"
        },
        {
            "code": "interface A {\n    fun foo(a1: Int, a2: Double)\n    fun bar(a1: Int, a2: Double, a3: String)\n    fun baz(a1: Int, a2: Double, a3: String, a4: Int, a5: String)\n}\n\ninterface B {\n    fun foo(b1: Int, b2: Double)\n    fun bar(a1: Int, a2: Double, b3: String)\n    fun baz(a1: Int, b2: Double, a3: String, b4: Int, a5: String)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES, DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES, DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES, DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES, DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface C<!> : A, B { // Warning here, this is correct\n}\n\nfun test(c: C) {\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>b1<!> = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>b2<!> = 1.0)\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>a1<!> = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>b2<!> = 1.0)\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>a1<!> = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>a2<!> = 1.0)\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>a1<!> = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>a2<!> = 1.0)\n    c.bar(a1 = 1, a2 = 1.0, <!NAME_FOR_AMBIGUOUS_PARAMETER!>b3<!>= \"\")\n    c.baz(a1 = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>b2<!> = 1.0, a3 = \"\", <!NAME_FOR_AMBIGUOUS_PARAMETER!>b4<!> = 2, a5 = \"\")\n    c.baz(a1 = 1, <!NAME_FOR_AMBIGUOUS_PARAMETER!>a2<!> = 1.0, a3 = \"\", <!NAME_FOR_AMBIGUOUS_PARAMETER!>b4<!> = 2, a5 = \"\")\n}"
        },
        {
            "code": "interface A<T> {\n    fun foo(a: T)\n}\n\ninterface B<E> {\n    fun foo(b: E)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface C<!><U> : A<U>, B<U> { // Warning here, this is correct\n}\n\nfun test(c: C<Int>) {\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>a<!> = 1)\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>b<!> = 1)\n}"
        },
        {
            "code": "interface A {\n    fun <E> foo(a: E)\n}\n\ninterface B {\n    fun <T> foo(b: T)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface C<!> : A, B { // Warning here, this is correct\n}\n\nfun test(c: C) {\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>a<!> = 1)\n    c.foo(<!NAME_FOR_AMBIGUOUS_PARAMETER!>b<!> = 1)\n}"
        },
        {
            "code": "interface A {\n    fun visit(a:Int, b:String=\"\") : String = b + a\n}\n\nclass B : A {\n    override fun visit(a:Int, b:String) : String = b + a\n}\n\nclass C : A {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun visit(a:Int) : String = \"\" + a\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -ABSTRACT_SUPER_CALL\n\nabstract class A {\n    open fun foo(a: String = \"default\") {\n    }\n\n    final fun foo2(a: String = \"default\") {\n    }\n\n    abstract fun foo3(a: String = \"default\")\n}\n\nopen class B : A() {\n    fun test() {\n        super.foo(\"123\")\n        super.<!SUPER_CALL_WITH_DEFAULT_PARAMETERS!>foo<!>()\n\n        super.foo2(\"123\")\n        super.<!SUPER_CALL_WITH_DEFAULT_PARAMETERS!>foo2<!>()\n\n        super.foo3(\"123\")\n        super.<!SUPER_CALL_WITH_DEFAULT_PARAMETERS!>foo3<!>()\n    }\n\n    override fun foo3(a: String) {\n        throw UnsupportedOperationException()\n    }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun f1(s: String?) {\n    if (s!! == \"\");\n    checkSubtype<String>(<!DEBUG_INFO_SMARTCAST!>s<!>)\n}\n\nfun f2(s: Number?) {\n    if (s is Int);\n    checkSubtype<Int>(<!TYPE_MISMATCH!>s<!>)\n    if (s as Int == 42);\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>s<!>)\n}\n\nfun f3(s: Number?) {\n    if (s is Int && s <!USELESS_CAST!>as Int<!> == 42);\n    checkSubtype<Int>(<!TYPE_MISMATCH!>s<!>)\n}\n\nfun f4(s: Int?) {\n    var u = <!INVALID_IF_AS_EXPRESSION!>if<!> (s!! == 42);\n    if (u == Unit) u = <!INVALID_IF_AS_EXPRESSION!>if<!> (s == 239);\n    return u\n}"
        },
        {
            "code": "class C(val f : () -> Unit)\n\nfun test(e : Any) {\n    if (e is C) {\n        (<!DEBUG_INFO_SMARTCAST!>e<!>.f)()\n    }\n}\n"
        },
        {
            "code": "fun test(a: Any?, flag: Boolean, x: Any?) {\n    if (a == null) return\n    <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n\n    val b: Any?\n\n    if (flag) {\n        b = a\n        <!DEBUG_INFO_SMARTCAST!>b<!>.hashCode()\n    }\n    else {\n        b = x\n        b<!UNSAFE_CALL!>.<!>hashCode()\n    }\n}"
        },
        {
            "code": "fun test(a: Any?) {\n    when (a) {\n        is String -> {\n            val s = a\n            <!DEBUG_INFO_SMARTCAST!>s<!>.length\n        }\n        \"\" -> {\n            val s = a\n            <!DEBUG_INFO_SMARTCAST!>s<!>.hashCode()\n        }\n    }\n}"
        },
        {
            "code": "// KT-6118 Redundant type cast can be not redundant?\n\nfun foo(o: Any) {\n    if (o is String) {\n        val s = o <!USELESS_CAST!>as String<!>\n        s.length\n    }\n}\n\nfun foo1(o: Any) {\n    if (o is String) {\n        <!DEBUG_INFO_SMARTCAST!>o<!>.length\n        val s = o\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n}"
        },
        {
            "code": "fun test(a: Any?, flag: Boolean, x: Any?) {\n    if (a !is String) return\n    <!DEBUG_INFO_SMARTCAST!>a<!>.length\n\n    val b: Any?\n\n    if (flag) {\n        b = a\n        <!DEBUG_INFO_SMARTCAST!>b<!>.length\n    }\n    else {\n        b = x\n        b.<!UNRESOLVED_REFERENCE!>length<!>()\n    }\n}"
        },
        {
            "code": "fun test(a: Any?) {\n    if (a == null) return\n    <!DEBUG_INFO_SMARTCAST!>a<!>.hashCode()\n\n    val b = a\n    <!DEBUG_INFO_SMARTCAST!>b<!>.hashCode()\n\n    val c: Any? = a\n    c<!UNSAFE_CALL!>.<!>hashCode()\n}"
        },
        {
            "code": "// KT-338 Support.smartcasts in nested declarations\n\nfun f(a: Any?) {\n  if (a is B) {\n    class C : X(<!DEBUG_INFO_SMARTCAST!>a<!>) {\n      init {\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n      }\n    }\n  }\n}\n\ninterface B {\n  fun foo() {}\n}\nopen class X(<!UNUSED_PARAMETER!>b<!>: B)"
        },
        {
            "code": "open class Base(<!UNUSED_PARAMETER!>x<!>: String, <!UNUSED_PARAMETER!>y<!>: Int)\n\nfun test(x: Any, y: Int?) {\n  if (x !is String) return\n  if (y == null) return\n\n  class Local: Base(<!DEBUG_INFO_SMARTCAST!>x<!>, <!DEBUG_INFO_SMARTCAST!>y<!>) {\n  }\n}\n\n"
        },
        {
            "code": "fun test(x: Any) {\n  if (x !is String) return\n\n  class Local(<!UNUSED_PARAMETER!>s<!>: String = <!DEBUG_INFO_SMARTCAST!>x<!>) {\n    fun foo(s: String = <!DEBUG_INFO_SMARTCAST!>x<!>): String = s\n  }\n}\n\n"
        },
        {
            "code": "interface D {\n  fun foo() {}\n}\n\nfun test(d: Any?) {\n  if (d !is D) return\n\n  class Local : D by <!DEBUG_INFO_SMARTCAST!>d<!> {\n  }\n}\n\n"
        },
        {
            "code": "fun test(x: Any) {\n  if (x !is String) return\n\n  class LocalOuter {\n    inner class Local {\n      init {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n      }\n    }\n  }\n}\n"
        },
        {
            "code": "open class X(val s: String)\n\nfun f(a: String?) {\n    if (a != null) {\n        object : X(<!DEBUG_INFO_SMARTCAST!>a<!>) { // Type mismatch: inferred type is kotlin.String? but kotlin.String was expected\n        }\n    }\n}\n"
        },
        {
            "code": "// KT-2225 Object expression delegation parameter should be checked with data flow info\n\ninterface A {\n    fun foo() : Int\n}\n\nclass B : A {\n    override fun foo() = 10\n}\nfun foo(b: B?) : Int {\n    if (b == null) return 0\n    val o = object : A by <!DEBUG_INFO_SMARTCAST!>b<!> { //no info about b not null check\n    }\n    return o.foo()\n}"
        },
        {
            "code": "interface D {\n  fun foo(): String = \"\"\n}\n\nfun test(d: Any?) {\n  if (d !is D) return\n\n  class Local {\n    fun f() {\n      <!DEBUG_INFO_SMARTCAST!>d<!>.foo()\n    }\n\n    fun f1() = <!DEBUG_INFO_SMARTCAST!>d<!>.foo()\n\n    fun f2(): String = <!DEBUG_INFO_SMARTCAST!>d<!>.foo()\n  }\n}\n\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nclass Del {\n  operator fun getValue(_this: Any?, p: KProperty<*>): Int = 0\n}\n\nfun df(del: Del): Del = del\n\n\nfun test(del: Any?) {\n  if (del !is Del) return\n\n  class Local {\n    val delegatedVal by df(<!DEBUG_INFO_SMARTCAST!>del<!>)\n    val delegatedVal1: Int by df(<!DEBUG_INFO_SMARTCAST!>del<!>)\n  }\n}\n"
        },
        {
            "code": "fun test(x: Any) {\n  if (x !is String) return\n\n  class LocalOuter {\n    fun foo(y: Any) {\n      if (y !is String) return\n      class Local {\n        init {\n          <!DEBUG_INFO_SMARTCAST!>x<!>.length\n          <!DEBUG_INFO_SMARTCAST!>y<!>.length\n        }\n      }\n    }\n  }\n}\n"
        },
        {
            "code": "fun test(x: Any?) {\n  if (x !is String) return\n\n  class C {\n    val v = <!DEBUG_INFO_SMARTCAST!>x<!>.length\n\n    val vGet: Int\n      get() = <!DEBUG_INFO_SMARTCAST!>x<!>.length\n\n    val s: String = <!DEBUG_INFO_SMARTCAST!>x<!>\n  }\n}\n"
        },
        {
            "code": "fun foo(x: Any?) {\n    if (x is String) {\n        object : Base(<!DEBUG_INFO_SMARTCAST!>x<!>) {\n            fun bar() = <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        }\n    }\n}\n\nopen class Base(<!UNUSED_PARAMETER!>s<!>: String)"
        },
        {
            "code": "interface Expr\nclass BinOp(val operator : String) : Expr\n\nfun test(e : Expr) {\n    if (e is BinOp) {\n        when (<!DEBUG_INFO_SMARTCAST!>e<!>.operator) {\n            else -> <!UNUSED_EXPRESSION!>0<!>\n        }\n    }\n}"
        },
        {
            "code": "fun f(<!UNUSED_PARAMETER!>a<!>: Boolean, <!UNUSED_PARAMETER!>b<!>: Int) {}\n\nfun foo(a: Any) {\n    f(a is Int, <!TYPE_MISMATCH!>a<!>)\n    1 <!NONE_APPLICABLE!>+<!> a\n}"
        },
        {
            "code": "class C {\n\n    fun f (<!UNUSED_PARAMETER!>a<!> : Boolean, <!UNUSED_PARAMETER!>b<!> : Boolean) {\n        b@ while (true)\n          <!REDUNDANT_LABEL_WARNING!>a@<!> {\n            <!NOT_A_LOOP_LABEL!>break@f<!>\n            break\n            <!UNREACHABLE_CODE!>break@b<!>\n            <!NOT_A_LOOP_LABEL!>break@a<!>\n          }\n\n        <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>\n\n        b@ while (true)\n          <!REDUNDANT_LABEL_WARNING!>a@<!> {\n            <!NOT_A_LOOP_LABEL!>continue@f<!>\n            continue\n            <!UNREACHABLE_CODE!>continue@b<!>\n            <!NOT_A_LOOP_LABEL!>continue@a<!>\n          }\n\n        <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break<!>\n\n        <!NOT_A_LOOP_LABEL!>continue@f<!>\n        <!NOT_A_LOOP_LABEL!>break@f<!>\n    }\n\n    fun containsBreak(a: String?, <!UNUSED_PARAMETER!>b<!>: String?) {\n        while (a == null) {\n            break;\n        }\n        a<!UNSAFE_CALL!>.<!>compareTo(\"2\")\n    }\n\n    fun notContainsBreak(a: String?, b: String?) {\n        while (a == null) {\n            while (b == null) {\n                break;\n            }\n        }\n        <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"2\")\n    }\n\n    fun containsBreakWithLabel(a: String?) {\n        loop@ while(a == null) {\n            break@loop\n        }\n        a?.compareTo(\"2\")\n    }\n\n    fun containsIllegalBreak(a: String?) {\n        loop@ while(a == null) {\n            <!NOT_A_LOOP_LABEL!>break<!UNRESOLVED_REFERENCE!>@label<!><!>\n        }\n        <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"2\")\n    }\n\n    fun containsBreakToOuterLoop(a: String?, b: String?) {\n        loop@ while(b == null) {\n            while(a == null) {\n                break@loop\n            }\n            <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"2\")\n        }\n    }\n\n    fun containsBreakInsideLoopWithLabel(a: String?, array: Array<Int>) {\n        l@ while(a == null) {\n            for (el in array) {\n                break@l\n            }\n        }\n        a<!UNSAFE_CALL!>.<!>compareTo(\"2\")\n    }\n\n    fun unresolvedBreak(a: String?, array: Array<Int>) {\n        while(a == null) {\n            l@ for (el in array) {\n                break\n            }\n            if (true) break else <!NOT_A_LOOP_LABEL!>break<!UNRESOLVED_REFERENCE!>@l<!><!>\n        }\n        a<!UNSAFE_CALL!>.<!>compareTo(\"2\")\n    }\n\n    fun twoLabelsOnLoop() {\n        label1@ label2@ for (i in 1..100) {\n            if (i > 0) {\n                break@label1\n            }\n            else {\n                break@label2\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// FULL_JDK\n\nimport java.lang.annotation.Repeatable\n\n<!DEPRECATED_JAVA_ANNOTATION!>@java.lang.annotation.Repeatable(Annotations::class)<!> annotation class RepAnn\n\n<!DEPRECATED_JAVA_ANNOTATION!>@Repeatable(OtherAnnotations::class)<!> annotation class OtherAnn\n\nannotation class Annotations(vararg val value: RepAnn)\n\nannotation class OtherAnnotations(vararg val value: OtherAnn)\n"
        },
        {
            "code": "annotation class Ann\n\ndata class Pair(val x: Int, val y: Int)\n\nfun foo(): Int {\n    <!WRONG_ANNOTATION_TARGET!>@Ann<!> val (a, b) = Pair(12, 34)\n    @<!UNRESOLVED_REFERENCE!>Err<!> val (c, d) = Pair(56, 78)\n    return a + b + c + d\n}"
        },
        {
            "code": "val a = object: T {}\nopen class C\ninterface T\n\nannotation class Ann: <!SUPERTYPES_FOR_ANNOTATION_CLASS!>C()<!>\nannotation class Ann2: <!SUPERTYPES_FOR_ANNOTATION_CLASS!>T<!>\nannotation class Ann3: <!SUPERTYPES_FOR_ANNOTATION_CLASS!>T by a<!>\nannotation class Ann4: <!SUPERTYPES_FOR_ANNOTATION_CLASS!>C(), T<!>"
        },
        {
            "code": "package bar\n\n<!MUST_BE_INITIALIZED!><!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@<!INAPPLICABLE_FILE_TARGET!>file<!>:foo<!>\nval prop<!>\n\n@<!INAPPLICABLE_FILE_TARGET!>file<!>:[<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>bar<!> <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>baz<!>]\nfun func() {}\n\n@<!INAPPLICABLE_FILE_TARGET!>file<!>:[<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>baz<!>]\nclass C\n\n<!SYNTAX!>@file:<!>\ninterface T\n\n@file:[<!SYNTAX!><!>]\ninterface T\n\nannotation class foo\nannotation class bar\nannotation class baz"
        },
        {
            "code": "// !LANGUAGE: -RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun test1(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@<!INAPPLICABLE_FILE_TARGET!>file<!><!SYNTAX!><!> Suppress(\"\")<!> x: Int) {}\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@<!INAPPLICABLE_FILE_TARGET!>file<!> <!SYNTAX!>@<!>Suppress(\"\")<!>\nfun test2() {}\n\nclass OnType(x: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@file<!SYNTAX!><!> Suppress(\"\")<!> Int)\n\nfun <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@file : Suppress(\"\")<!> Int.test3() {}"
        },
        {
            "code": "// !LANGUAGE: +RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun test1(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) {}\nfun test2(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Suppress<!> Int) {}\nfun test3(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Suppress<!> Int) {}\n\nfun test4(): <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int = TODO()\nfun test5(i: (<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) -> Unit) {}\n\nfun ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) -> Unit).test6() {}\n\nfun test7(): ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) -> Unit) = TODO()"
        },
        {
            "code": "// FILE: annotations.kt\n@Target(AnnotationTarget.CLASS)\npublic annotation class ClassAnn\n\n@Target(AnnotationTarget.FILE)\npublic annotation class FileAnn\n\n// FILE: 1.kt\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:ClassAnn<!>\n\n// FILE: 2.kt\n@file:FileAnn"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nannotation class Ann\nannotation class Second\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@property:Ann<!>\nclass SomeClass {\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@property:Ann<!>\n    constructor(<!UNUSED_PARAMETER!>s<!>: String)\n\n    @property:Ann\n    protected val p1: String = \"\"\n\n    @property:[Ann Second]\n    protected val p2: String = \"\"\n\n    @property:Ann\n    protected var p3: String = \"\"\n\n    @property:Ann\n    protected val p4: String by CustomDelegate()\n\n    @property:Ann\n    var propertyWithCustomSetter: Int\n        get() = 5\n        set(<!UNUSED_PARAMETER!>v<!>) {}\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@property:Ann<!>\n    fun anotherFun() {\n        <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@property:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n}\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nannotation class Ann\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@field:Ann<!>\nclass SomeClass {\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@field:Ann<!>\n    constructor()\n\n    @field:Ann\n    protected val simpleProperty: String = \"text\"\n\n    @field:[Ann]\n    protected val simplePropertyWithAnnotationList: String = \"text\"\n\n    <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_BACKING_FIELD!>@field:Ann<!>\n    protected val delegatedProperty: String by CustomDelegate()\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@field:Ann<!>\n    val propertyWithCustomGetter: Int\n        get() = 5\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@field:Ann<!>\n    fun anotherFun(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@field:Ann<!> <!UNUSED_PARAMETER!>s<!>: String) {\n        <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@field:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n}\n\nclass WithPrimaryConstructor(@field:Ann val a: String)\n"
        },
        {
            "code": "// !LANGUAGE: +RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n\n@Target(AnnotationTarget.VALUE_PARAMETER)\nannotation class Fancy\n\nfun @receiver:Fancy String.myExtension() { }\nval @receiver:Fancy Int.asVal get() = 0\n\nfun ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Fancy<!> Int) -> Unit).complexReceiver1() {}\nfun ((Int) -> <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Fancy<!> Unit).complexReceiver2() {}"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nannotation class Ann\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@get:Ann<!>\nclass SomeClass {\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@get:Ann<!>\n    constructor()\n\n    @get:Ann\n    protected val simpleProperty: String = \"text\"\n\n    @get:Ann\n    protected var mutableProperty: String = \"text\"\n\n    @get:[Ann]\n    protected val simplePropertyWithAnnotationList: String = \"text\"\n\n    @get:Ann\n    protected val delegatedProperty: String by CustomDelegate()\n\n    @get:Ann\n    val propertyWithCustomGetter: Int\n        get() = 5\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@get:Ann<!>\n    fun annotationOnFunction(a: Int) = a + 5\n\n    fun anotherFun() {\n        <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@get:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n}\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nannotation class Ann\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\n<!INAPPLICABLE_TARGET_ON_PROPERTY, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Ann<!>\nclass SomeClass {\n\n    <!INAPPLICABLE_TARGET_ON_PROPERTY, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Ann<!>\n    constructor()\n\n    <!INAPPLICABLE_TARGET_PROPERTY_IMMUTABLE!>@setparam:Ann<!>\n    protected val simpleProperty: String = \"text\"\n\n    @setparam:Ann\n    protected var mutableProperty: String = \"text\"\n\n    @setparam:[Ann]\n    protected var mutablePropertyWithAnnotationList: String = \"text\"\n\n    @setparam:Ann\n    protected var delegatedProperty: String by CustomDelegate()\n\n    @setparam:Ann\n    var propertyWithCustomSetter: Int\n        get() = 5\n        set(<!UNUSED_PARAMETER!>v<!>) {}\n\n    <!INAPPLICABLE_TARGET_ON_PROPERTY!>@setparam:Ann<!>\n    fun anotherFun() {\n        <!INAPPLICABLE_TARGET_ON_PROPERTY!>@setparam:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n}\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\n@Target(AnnotationTarget.FIELD) annotation class Field\n\n@Target(AnnotationTarget.PROPERTY) annotation class Prop\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!>\nclass SomeClass {\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!>\n    constructor()\n\n    <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE!>@delegate:Field<!> <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!>\n    protected val simpleProperty: String = \"text\"\n\n    @delegate:Field <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!>\n    protected val delegatedProperty: String by CustomDelegate()\n\n    <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!> <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!>\n    val propertyWithCustomGetter: Int\n        get() = 5\n\n}\n\nclass WithPrimaryConstructor(<!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE!>@delegate:Field<!> <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!> val a: String,\n                             <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Field<!> <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Prop<!> val b: String)\n\nfun foo(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!> <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!> x: Int) = x\n\n"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class RepeatableAnn\nannotation class Ann\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\npublic class A(@param:Ann <!REPEATED_ANNOTATION!>@Ann<!> val x: Int, @param: RepeatableAnn @Ann val y: Int) {\n\n    @field:Ann @property:Ann @RepeatableAnn @property:RepeatableAnn\n    val a: Int = 0\n\n    @Ann @field:Ann <!REPEATED_ANNOTATION!>@property:Ann<!>\n    val b: Int = 0\n\n    @field:RepeatableAnn @field:RepeatableAnn\n    val c: Int = 0\n\n    @property:RepeatableAnn @RepeatableAnn\n    val d: Int = 0\n\n    @property:RepeatableAnn @RepeatableAnn @delegate:RepeatableAnn\n    val e: String by CustomDelegate()\n\n    @property:Ann @delegate:Ann\n    val f: String by CustomDelegate()\n\n    @Ann @delegate:Ann\n    val g: String by CustomDelegate()\n\n    @Ann @field:Ann\n    val h: String = \"\"\n\n    @property:Ann @field:Ann\n    val i: String = \"\"\n}\n\n@Target(AnnotationTarget.FIELD, AnnotationTarget.PROPERTY)\nannotation class fieldOrPropAnn\n\n@Target(AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.VALUE_PARAMETER)\nannotation class getSetAndParamAnn\n\npublic class B(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:fieldOrPropAnn<!> @fieldOrPropAnn val x: Int,\n               @property:fieldOrPropAnn <!REPEATED_ANNOTATION!>@fieldOrPropAnn<!> val y: Int) {\n    @fieldOrPropAnn @field:fieldOrPropAnn\n    val z: Int = 42\n\n    <!WRONG_ANNOTATION_TARGET!>@getSetAndParamAnn<!>\n    <!REPEATED_ANNOTATION!>@setparam:getSetAndParamAnn<!>\n    var w: Int\n        @getSetAndParamAnn <!REPEATED_ANNOTATION!>@get:getSetAndParamAnn<!> get() = 0\n        // See KT-15470: fake INAPPLICABLE_TARGET_ON_PROPERTY\n        @getSetAndParamAnn <!INAPPLICABLE_TARGET_ON_PROPERTY, REPEATED_ANNOTATION!>@set:getSetAndParamAnn<!> set(<!UNUSED_PARAMETER!>arg<!>) {}\n}"
        },
        {
            "code": "// !LANGUAGE: -RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n\n@Target(AnnotationTarget.VALUE_PARAMETER)\nannotation class Fancy\n\nfun @receiver:Fancy String.myExtension() { }\nval @receiver:Fancy Int.asVal get() = 0\n\nfun ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@receiver:Fancy<!> Int) -> Unit).complexReceiver1() {}\nfun ((Int) -> <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@receiver:Fancy<!> Unit).complexReceiver2() {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: -ProhibitRepeatedUseSiteTargetAnnotations\n\n// Ann is not repeatable\nannotation class Ann(val x: Int)\n\n<!REPEATED_ANNOTATION_WARNING!>@get:Ann(10)<!>\nval a: String\n    @Ann(20) get() = \"foo\"\n\n<!REPEATED_ANNOTATION_WARNING!>@set:Ann(10)<!>\nvar b: String = \"\"\n    @Ann(20) set(value) { field = value }\n\n<!REPEATED_ANNOTATION_WARNING!>@setparam:Ann(10)<!>\nvar c = \" \"\n    set(@Ann(20) x) {}\n\n<!REPEATED_ANNOTATION_WARNING!>@get:Ann(10)<!>\n<!REPEATED_ANNOTATION, REPEATED_ANNOTATION_WARNING!>@get:Ann(20)<!>\nval d: String\n    @Ann(30) <!REPEATED_ANNOTATION!>@Ann(40)<!> get() = \"foo\""
        },
        {
            "code": "annotation class Ann\nannotation class Second\n\n<!INAPPLICABLE_PARAM_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Ann<!>\nclass SomeClass {\n\n    <!INAPPLICABLE_PARAM_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Ann<!>\n    constructor(<!INAPPLICABLE_PARAM_TARGET!>@param:Ann<!> <!UNUSED_PARAMETER!>a<!>: String)\n\n    <!INAPPLICABLE_PARAM_TARGET!>@param:Ann<!>\n    protected val simpleProperty: String = \"text\"\n\n    <!INAPPLICABLE_PARAM_TARGET!>@param:Ann<!>\n    fun anotherFun() {\n        <!INAPPLICABLE_PARAM_TARGET!>@param:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n}\n\nclass PrimaryConstructorClass(\n        <!REDUNDANT_ANNOTATION_TARGET!>@param:Ann<!> <!UNUSED_PARAMETER!>a<!>: String,\n@param:[<!REDUNDANT_ANNOTATION_TARGET!>Ann<!> <!REDUNDANT_ANNOTATION_TARGET!>Second<!>] <!UNUSED_PARAMETER!>b<!>: String,\n@param:Ann val c: String)"
        },
        {
            "code": "// !LANGUAGE: -RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun test1(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@setparam:Suppress<!> Int) {}\nfun test2(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@param:Suppress<!> Int) {}\nfun test3(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@receiver:Suppress<!> Int) {}\n\nfun test4(): <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@setparam:Suppress<!> Int = TODO()\nfun test5(i: (<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@setparam:Suppress<!> Int) -> Unit) {}\n\nfun ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@setparam:Suppress<!> Int) -> Unit).test6() {}\n\nfun test7(): ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET_ON_TYPE!>@setparam:Suppress<!> Int) -> Unit) = TODO()"
        },
        {
            "code": "// !LANGUAGE: +RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun test1(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@<!INAPPLICABLE_FILE_TARGET!>file<!><!SYNTAX!><!> Suppress(\"\")<!> x: Int) {}\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@<!INAPPLICABLE_FILE_TARGET!>file<!> <!SYNTAX!>@<!>Suppress(\"\")<!>\nfun test2() {}\n\nclass OnType(x: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file<!SYNTAX!><!> Suppress(\"\")<!> Int)\n\nfun <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file : Suppress(\"\")<!> Int.test3() {}"
        },
        {
            "code": "annotation class Ann\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Ann<!>\nclass SomeClass {\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Ann<!>\n    constructor(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Ann<!> <!UNUSED_PARAMETER!>a<!>: String)\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Ann<!>\n    protected val simpleProperty: String = \"text\"\n\n    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Ann<!>\n    fun anotherFun() {\n        <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n    val @receiver:Ann String.extensionProperty2: String\n        get() = \"A\"\n}\n\nfun @receiver:Ann String.length2() = length\n\nval @receiver:Ann String.extensionProperty: String\n    get() = \"A\""
        },
        {
            "code": "<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:foo<!>\n@foo @bar\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@<!INAPPLICABLE_FILE_TARGET!>file<!>: baz<!>\nfun test() {}\n\nannotation class foo\nannotation class bar\nannotation class baz"
        },
        {
            "code": "// !LANGUAGE: -ProhibitUseSiteTargetAnnotationsOnSuperTypes\n\ninterface Foo\n\nannotation class Ann\n\nclass E : <!ANNOTATION_ON_SUPERCLASS_WARNING!>@field:Ann<!> <!ANNOTATION_ON_SUPERCLASS_WARNING!>@get:Ann<!> <!ANNOTATION_ON_SUPERCLASS_WARNING!>@set:Ann<!> <!ANNOTATION_ON_SUPERCLASS_WARNING!>@setparam:Ann<!> Foo\n\ninterface G : @Ann Foo"
        },
        {
            "code": "// !LANGUAGE: +ProhibitUseSiteTargetAnnotationsOnSuperTypes\n\ninterface Foo\n\nannotation class Ann\n\nclass E : <!ANNOTATION_ON_SUPERCLASS!>@field:Ann<!> <!ANNOTATION_ON_SUPERCLASS!>@get:Ann<!> <!ANNOTATION_ON_SUPERCLASS!>@set:Ann<!> <!ANNOTATION_ON_SUPERCLASS!>@setparam:Ann<!> Foo\n\ninterface G : @Ann Foo"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\nannotation class Ann\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\n<!INAPPLICABLE_TARGET_ON_PROPERTY, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@set:Ann<!>\nclass SomeClass {\n\n    <!INAPPLICABLE_TARGET_PROPERTY_IMMUTABLE!>@set:Ann<!>\n    protected val simpleProperty: String = \"text\"\n\n    @set:Ann\n    protected var mutableProperty: String = \"text\"\n\n    @set:[Ann]\n    protected var mutablePropertyWithAnnotationList: String = \"text\"\n\n    @set:Ann\n    protected var delegatedProperty: String by CustomDelegate()\n\n    @set:Ann\n    var propertyWithCustomSetter: Int\n        get() = 5\n        set(<!UNUSED_PARAMETER!>v<!>) {}\n\n    <!INAPPLICABLE_TARGET_ON_PROPERTY, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@set:Ann<!>\n    fun annotationOnFunction(a: Int) = a + 5\n\n    fun anotherFun() {\n        <!INAPPLICABLE_TARGET_ON_PROPERTY!>@set:Ann<!>\n        val <!UNUSED_VARIABLE!>localVariable<!> = 5\n    }\n\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: +ProhibitRepeatedUseSiteTargetAnnotations\n\n// Ann is not repeatable\nannotation class Ann(val x: Int)\n\n<!REPEATED_ANNOTATION!>@get:Ann(10)<!>\nval a: String\n    @Ann(20) get() = \"foo\"\n\n<!REPEATED_ANNOTATION!>@set:Ann(10)<!>\nvar b: String = \"\"\n    @Ann(20) set(value) { field = value }\n\n<!REPEATED_ANNOTATION!>@setparam:Ann(10)<!>\nvar c = \" \"\n    set(@Ann(20) x) {}\n\n<!REPEATED_ANNOTATION!>@get:Ann(10)<!>\n<!REPEATED_ANNOTATION!>@get:Ann(20)<!>\nval d: String\n    @Ann(30) <!REPEATED_ANNOTATION!>@Ann(40)<!> get() = \"foo\""
        },
        {
            "code": "<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:foo<!>\n@foo @bar\n@<!INAPPLICABLE_FILE_TARGET!>file<!>:[<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>baz<!>]\nfun test() {}\n\nannotation class foo\nannotation class bar\nannotation class baz"
        },
        {
            "code": "// !LANGUAGE: +RestrictionOfWrongAnnotationsWithUseSiteTargetsOnTypes\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun test1(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) {}\nfun test2(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Suppress<!> Int) {}\nfun test3(i: <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Suppress<!> Int) {}\n\nfun test4(): <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int = TODO()\nfun test5(i: (<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) -> Unit) {}\n\nfun ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) -> Unit).test6() {}\n\nfun test7(): ((<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@setparam:Suppress<!> Int) -> Unit) = TODO()"
        },
        {
            "code": "// FILE: a.kt\n\nannotation class annotation\n\n// FILE: test/b.kt\n\npackage test\n\n<!NOT_AN_ANNOTATION_CLASS!>@test.annotation<!> class annotation\n\n// FILE: other/c.kt\n\npackage other\n\nannotation class My\n\n<!NOT_AN_ANNOTATION_CLASS!>@test.annotation<!> class Your\n\n@My class Our"
        },
        {
            "code": "annotation class Ann(val x: Int)\n\ndata class A(val x: Int, val y: Int)\n\nfun bar(): Array<A> = null!!\n\nfun foo() {\n    for (@Ann(1) i in 1..100) {}\n    for (@Ann(2) i in 1..100) {}\n\n    for (<!WRONG_ANNOTATION_TARGET!>@Ann(3)<!> (<!UNUSED_VARIABLE!>x<!>, @Ann(4) <!UNUSED_VARIABLE!>y<!>) in bar()) {}\n\n    for (@<!UNRESOLVED_REFERENCE!>Err<!>() (<!UNUSED_VARIABLE!>x<!>,<!UNUSED_VARIABLE!>y<!>) in bar()) {}\n}\n"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_PARAMETER\n\n@Target(AnnotationTarget.TYPE)\nannotation class a\n\n@Target(AnnotationTarget.TYPE)\nannotation class b(val i: Int)\n\nannotation class c\n\nfun foo(i: @a Int?) {}\n\nfun foo(l: List<@a Int?>) {}\n\nfun @a Int?.bar() {}\n\nval baz: @a Int? = 1\n\n\nfun foo1(i: @b(1) Int?) {}\n\nfun foo1(l: List<@b(1) Int?>) {}\n\nfun @b(1) Int?.bar1() {}\n\nval baz1: @b(1) Int? = 1\n\n\nfun foo2(i: @[a b(1)] Int?) {}\n\nfun foo2(l: List<@[a b(1)] Int?>) {}\n\nfun @[a b(1)] Int?.bar2() {}\n\nval baz2: @[a b(1)] Int? = 1\n\n\nfun foo3(i: <!WRONG_ANNOTATION_TARGET!>@c<!> Int?) {}\n\nfun foo3(l: List<<!WRONG_ANNOTATION_TARGET!>@c<!> Int?>) {}\n\nfun <!WRONG_ANNOTATION_TARGET!>@c<!> Int?.bar3() {}\n\nval baz3: <!WRONG_ANNOTATION_TARGET!>@c<!> Int? = 1"
        },
        {
            "code": "// !LANGUAGE: -RestrictRetentionForExpressionAnnotations\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class TestRetentionSource\n\n@Target(AnnotationTarget.EXPRESSION)\n<!RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_WARNING!>@Retention(AnnotationRetention.BINARY)<!>\nannotation class TestRetentionBinary\n\n@Target(AnnotationTarget.EXPRESSION)\n<!RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_WARNING!>@Retention(AnnotationRetention.RUNTIME)<!>\nannotation class TestRetentionRuntime"
        },
        {
            "code": "import java.lang.Deprecated as deprecated\n\n<!DEPRECATED_JAVA_ANNOTATION!>@java.lang.Deprecated<!> fun foo() {}\n\n<!DEPRECATED_JAVA_ANNOTATION!>@deprecated<!> fun foo1() {}"
        },
        {
            "code": "annotation class A1\nannotation class A2(val some: Int = 12)\n\nfun <<!WRONG_ANNOTATION_TARGET!>@A1<!> <!WRONG_ANNOTATION_TARGET!>@A2(3)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A1(<!TOO_MANY_ARGUMENTS!>12<!>)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2(<!TYPE_MISMATCH!>\"Test\"<!>)<!>  T> topFun() = 12\n\nclass SomeClass {\n    fun <<!WRONG_ANNOTATION_TARGET!>@A1<!> <!WRONG_ANNOTATION_TARGET!>@A2(3)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A1(<!TOO_MANY_ARGUMENTS!>12<!>)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2(<!TYPE_MISMATCH!>\"Test\"<!>)<!> T> method() = 12\n\n    fun foo() {\n        fun <<!WRONG_ANNOTATION_TARGET!>@A1<!> <!WRONG_ANNOTATION_TARGET!>@A2(3)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A1(<!TOO_MANY_ARGUMENTS!>12<!>)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2(<!TYPE_MISMATCH!>\"Test\"<!>)<!>  T> innerFun() = 12\n    }\n}"
        },
        {
            "code": "fun test(): Any? {\n    <!WRONG_ANNOTATION_TARGET!>@ann<!> val (a, b) = P(1, 1)\n    return a + b\n}\n\nannotation class ann\ndata class P(val a: Int, val b: Int)"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInAnnotations\n\nannotation class Foo {\n    class Nested\n\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>inner<!> class Inner\n\n    enum class E { A, B }\n    object O\n    interface I\n    annotation class Anno(val e: E)\n\n    companion object {\n        val x = 1\n        const val y = \"\"\n    }\n\n\n    <!ANNOTATION_CLASS_MEMBER!>constructor(<!UNUSED_PARAMETER!>s<!>: Int) {}<!>\n    <!ANNOTATION_CLASS_MEMBER!>init {}<!>\n    <!ANNOTATION_CLASS_MEMBER!>fun function() {}<!>\n    <!ANNOTATION_CLASS_MEMBER!>val property get() = Unit<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann1\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann2(val x: String)\n\nfun bar() {}\nfun bar(block: () -> Unit) {}\n\nfun foo(y: IntArray) {\n    @Ann1 bar()\n    @Ann1 bar() { }\n    @Ann1 bar { }\n\n    @Ann2(\"\") bar()\n    @Ann2(\"\") bar() { }\n    @Ann2(\"\") bar { }\n\n    @Ann1 @Ann2(\"\") bar()\n\n    var x = 1\n\n    @Ann1 ++x\n    @Ann1 x++\n    @Ann2(\"\") ++x\n    @Ann2(\"\") x++\n    @Ann1 @Ann2(\"\") ++x\n    @Ann1 @Ann2(\"\") x++\n\n    @Ann1 y[0]\n\n    @Ann1 <!UNUSED_LAMBDA_EXPRESSION!>{ <!NAME_SHADOWING!>x<!>: Int -> x }<!>\n    @Ann1 { <!NAME_SHADOWING!>x<!>: Int -> x }(1)\n    @Ann1 object { fun foo() = 1 }\n    @Ann1 object { fun foo() = 1 }.foo()\n\n    @Ann1() (x * x)\n    var z = 1\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 x<!> + z\n\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 x<!> = x + 2\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 x<!> += z + 2\n\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 x<!> + 6 * 2 > 0\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 x<!> * 6 + 2 > 0\n\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 object { operator fun plus(x: Int) = 1 }<!> + 1\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 object { operator fun plus(x: Int) = 1 }<!> + 1 * 4 > 0\n\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@Ann1 x<!> foo z + 8\n\n    1 + @Ann1 x\n    1 + @Ann1 x * z + 8\n\n    x foo @Ann1 z + 8\n}\n\ninfix fun Int.foo(other: Int) = 1\n"
        },
        {
            "code": "// Functions can be recursively annotated\nannotation class ann(val x: Int)\n@ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>bar()<!>) fun foo() = 1\n@ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>foo()<!>) fun bar() = 2"
        },
        {
            "code": "package test\n\nimport java.lang.annotation.RetentionPolicy\n\n// CORRECT\nannotation class Ann1(val p1: Int,\n                      val p2: Byte,\n                      val p3: Short,\n                      val p4: Long,\n                      val p5: Double,\n                      val p6: Float,\n                      val p7: Char,\n                      val p8: Boolean)\n\nannotation class Ann2(val p1: String)\nannotation class Ann3(val p1: Ann1)\nannotation class Ann4(val p1: IntArray,\n                      val p2: ByteArray,\n                      val p3: ShortArray,\n                      val p4: LongArray,\n                      val p5: DoubleArray,\n                      val p6: FloatArray,\n                      val p7: CharArray,\n                      val p8: BooleanArray)\n\nannotation class Ann5(val p1: MyEnum)\n\nannotation class Ann6(val p: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Class<*><!>)\nannotation class Ann7(val p: RetentionPolicy)\n\nannotation class Ann8(val p1: Array<String>,\n                      val p2: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<Class<*>><!>,\n                      val p3: Array<MyEnum>,\n                      val p4: Array<Ann1>)\n\nannotation class Ann9(\n        val error: <!UNRESOLVED_REFERENCE!>Unresolved<!> = <!UNRESOLVED_REFERENCE!>Unresolved<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>VALUE<!>\n)\n\n\n// INCORRECT\nannotation class InAnn1(val p1: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Int?<!>,\n                        val p3: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Short?<!>,\n                        val p4: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Long?<!>,\n                        val p5: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Double?<!>,\n                        val p6: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Float?<!>,\n                        val p7: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Char?<!>,\n                        val p8: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Boolean?<!>)\n\nannotation class InAnn4(val p1: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<Int><!>,\n                        val p2: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Array<Int>?<!>)\n\nannotation class InAnn6(val p:  <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Class<*>?<!>)\nannotation class InAnn7(val p:  <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>RetentionPolicy?<!>)\nannotation class InAnn8(val p1: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<Int><!>,\n                        val p2: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<Int?><!>,\n                        val p3: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<MyClass><!>,\n                        val p4: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<IntArray><!>)\n\nannotation class InAnn9(val p: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>MyClass<!>)\n\nannotation class InAnn10(val p1: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>String?<!>)\nannotation class InAnn11(val p1: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>Ann1?<!>)\nannotation class InAnn12(val p1: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>MyEnum?<!>)\n\nannotation class InAnn13(<!MULTIPLE_VARARG_PARAMETERS!>vararg<!> val p1: String,\n                        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> val p2: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Class<*><!>,\n                        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> val p3: MyEnum,\n                        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> val p4: Ann1,\n                        <!MULTIPLE_VARARG_PARAMETERS!>vararg<!> val p5: Int)\n\nenum class MyEnum {\n    A\n}\n\nclass MyClass\n"
        },
        {
            "code": "class Foo<T> {\n    @<!NOT_A_CLASS!>T<!>\n    fun foo() = 0\n}\n\nclass Bar<T : Annotation> {\n    @<!NOT_A_CLASS!>T<!>\n    fun foo() = 0\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -CAST_NEVER_SUCCEEDS -CANNOT_CHECK_FOR_ERASED -UNCHECKED_CAST -UNUSED_ANONYMOUS_PARAMETER\n// SKIP_TXT\n// Issue: KT-31734\n\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Foo\n\nfun foo1(x: @Foo() () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo2() = null as @Foo() () -> Unit\n\nfun foo3(x: Any?) {\n    if (x is (@<!DEBUG_INFO_MISSING_UNRESOLVED!>Foo<!>() () -> Unit)?) {\n\n    }\n}\n\nfun foo4(x: Any) = x is @Foo() () -> (() -> Unit?)\n\nfun foo5(x: Any): @Foo() () -> Unit = x as @Foo () @[Foo Foo ()] @Foo() () -> Unit\n\nfun foo6() {\n    val x: @Foo() @[Foo Foo()] @Foo() () -> Unit = {}\n}\n\nfun foo7() {\n    val x: @Foo() (@Foo() () -> Unit) -> Unit = { x: @Foo() () -> Unit -> }\n}\n\nfun foo8(x: @[Foo() ] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo9(x: @[Foo()] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo10() {\n    val x: @Foo () @Foo () () -> Unit = {}\n}\n\nfun foo11() {\n    val x: @Foo @Foo () () -> Unit = {}\n}\n\nfun foo12() {\n    val x: @Foo() @Foo () () -> Unit = {}\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NonParenthesizedAnnotationsOnFunctionalTypes\n// !DIAGNOSTICS: -UNUSED_VARIABLE -CAST_NEVER_SUCCEEDS -CANNOT_CHECK_FOR_ERASED -UNCHECKED_CAST -UNUSED_ANONYMOUS_PARAMETER\n// SKIP_TXT\n// Issue: KT-31734\n\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Foo\n\nclass MyClass\n\nfun foo1(x: @Foo () -> Unit) = x as Iterable<@Foo () -> Unit>?\n\nfun foo2() = null as @Foo () -> Unit\n\nfun foo3(x: Any?) {\n    if (x is (@<!DEBUG_INFO_MISSING_UNRESOLVED!>Foo<!> () -> Unit)?) {\n\n    }\n}\n\nfun foo4(x: Any) = x is @Foo () -> (() -> Unit?)\n\nfun foo5(x: Any): @Foo () -> Unit = x as @Foo() @[Foo Foo()] @Foo () -> Unit\n\nfun foo6() {\n    val x: @Foo() @[Foo Foo()] @Foo () -> Unit = {}\n}\n\nfun foo7() {\n    val x: @Foo (@Foo () -> Unit) -> Unit = { x: @Foo () -> Unit -> }\n}\n\nfun foo10(x: @[Foo()] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo11(x: @[Foo] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo12(x: @[Foo ] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo13(x: @[Foo/**/] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nval foo14: @Foo (x: @Foo () -> Unit) -> Unit get() = {}\n\nval foo15: @Foo () @Foo () -> Unit get() = {}\n\nval foo16: @Foo @Foo () @Foo () -> Unit get() = {}\n\nval foo17: @Foo() @Foo () @Foo () -> Unit get() = {}\n\nval foo18: @Foo()@Foo () @Foo () -> Unit get() = {}\n\nval foo19: @Foo@Foo () @Foo () -> Unit get() = {}\n\nval foo20: @Foo@Foo () -> Unit get() = {}\n\nval foo21: @Foo()@Foo () -> Unit get() = {}\n\nval foo22: @Foo (x: @Foo () -> Unit) -> Unit get() = {}\n\nval foo23: @Foo (@Foo () -> Unit) -> Unit get() = {}\n\nval foo24: @Foo (@Foo () -> Unit, @Foo () -> Unit) -> Unit get() = {x, y -> }\n\nval foo25: @Foo (x: @Foo Any, @Foo Any) -> Unit get() = {x, y -> }\n\nval foo26: @Foo suspend () -> Unit = {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -CAST_NEVER_SUCCEEDS -CANNOT_CHECK_FOR_ERASED -UNCHECKED_CAST -UNUSED_ANONYMOUS_PARAMETER\n// SKIP_TXT\n// Issue: KT-31734\n\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Foo\n\nfun foo1(x: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit) = x as Iterable<<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit>?\n\nfun foo2() = null as <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit\n\nfun foo3(x: Any?) {\n    if (x is (<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@<!DEBUG_INFO_MISSING_UNRESOLVED!>Foo<!><!> () -> Unit)?) {\n\n    }\n}\n\nfun foo4(x: Any) = x is <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> (() -> Unit?)\n\nfun foo5(x: Any): <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit = x as @Foo() @[Foo Foo()] <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit\n\nfun foo6() {\n    val x: @Foo() @[Foo Foo()] <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit = {}\n}\n\nfun foo7() {\n    val x: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit) -> Unit = { x: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit -> }\n}\n\nfun foo8(<!UNUSED_PARAMETER!>x<!>: Any?) {\n    val <!NAME_SHADOWING!>x<!>: (<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit)? = {}\n}\n\nfun foo9(x: (<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit)?) = x as Iterable<(<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit?)?>?\n\nfun foo10(x: @[Foo] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo11(x: @[Foo ] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nfun foo12(x: @[Foo/**/] () -> Unit) = x as Iterable<@Foo() () -> Unit>?\n\nval foo13: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (x: @Foo Any) -> Unit get() = {}\n\nval foo14: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (x: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit) -> Unit get() = {}\n\nval foo15: @Foo () <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo16: @Foo @Foo () <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo17: @Foo() @Foo () <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo18: @Foo()@Foo () <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo19: @Foo@Foo () <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo20: @Foo<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo21: @Foo()<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit get() = {}\n\nval foo22: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (x: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit) -> Unit get() = {}\n\nval foo23: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit) -> Unit get() = {}\n\nval foo24: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (<!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit, <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> () -> Unit) -> Unit get() = {x, y -> }\n\nval foo25: <!NON_PARENTHESIZED_ANNOTATIONS_ON_FUNCTIONAL_TYPES!>@Foo<!> (x: @Foo Any, @Foo Any) -> Unit get() = {x, y -> }\n\nval foo26: @Foo suspend () -> Unit = {}\n"
        },
        {
            "code": "annotation class Ann(val x: Int, val<!SYNTAX!><!> )"
        },
        {
            "code": "class Foo\n\n<!NOT_AN_ANNOTATION_CLASS!>@Foo<!> class Bar"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nimport java.util.ArrayList\n\n<!NI;NOT_AN_ANNOTATION_CLASS!>@<!OI;NONE_APPLICABLE!>ArrayList<!><Int>(<!NI;TOO_MANY_ARGUMENTS!>1<!>, <!NI;TOO_MANY_ARGUMENTS!>1<!>)<!> fun b() {}\n@<!UNRESOLVED_REFERENCE!>Xoo<!>(<!UNRESOLVED_REFERENCE!>x<!>) fun c() {}\n<!DEPRECATED_JAVA_ANNOTATION!>@java.lang.Deprecated(<!TOO_MANY_ARGUMENTS, UNRESOLVED_REFERENCE!>x<!>)<!> fun a() {}"
        },
        {
            "code": "annotation class Ann\nannotation class Ann1(val a: Int)\nannotation class Ann2(val a: Ann1)\n\nannotation class Ann3(val a: Ann1 = Ann1(1))\n\nannotation class Ann4(val value: String)\n\n@Ann2(Ann1(1)) val a = 1\n\n@Ann2(a = Ann1(1)) val c = 2\n\n@Ann4(\"a\") class MyClass\n\nfun foo() {\n    <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann()<!>\n    val <!UNUSED_VARIABLE!>a<!> = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann()<!>\n\n    <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann1(<!NO_VALUE_FOR_PARAMETER!>)<!><!>\n    <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann1(1)<!>\n    bar(<!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann()<!>)\n    bar(a = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann()<!>)\n\n    val ann = javaClass<MyClass>().getAnnotation(javaClass<Ann4>())\n    ann!!.value()\n}\n\nfun bar(a: Ann = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann()<!>) {\n    if (<!USELESS_IS_CHECK!>a is Ann<!>) {}\n}\n\noperator fun String.invoke() {}\n\n// from stdlib\nfun <T> javaClass() : Class<T> = null <!CAST_NEVER_SUCCEEDS!>as<!> Class<T>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS,\n        AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION,\n        AnnotationTarget.EXPRESSION, AnnotationTarget.PROPERTY)\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Ann(val x: Int = 6)\n\n@Ann(1) @Ann(2) @Ann(3) private class A @Ann constructor() {\n    @Ann(x = 5) fun foo() {\n        1 + @Ann(1) 1 * @Ann(<!TYPE_MISMATCH!>\"\"<!>) 6\n\n        @Ann fun local() {}\n    }\n\n    @Ann val x = 1\n\n    fun bar(x: @Ann(1) @Ann(2) @Ann(3) Int) {}\n}\n"
        },
        {
            "code": "annotation class Ann(\n        val a: Int,\n        <!VAR_ANNOTATION_PARAMETER!>var<!> b: Int,\n        <!MISSING_VAL_ON_ANNOTATION_PARAMETER!>c: String<!>\n        )\n"
        },
        {
            "code": "package test\n\n@BadAnnotation(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\nobject SomeObject\n\nval some = SomeObject\n\nannotation class BadAnnotation(val s: String)"
        },
        {
            "code": "// !LANGUAGE: +RestrictRetentionForExpressionAnnotations\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class TestRetentionSource\n\n@Target(AnnotationTarget.EXPRESSION)\n<!RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION!>@Retention(AnnotationRetention.BINARY)<!>\nannotation class TestRetentionBinary\n\n@Target(AnnotationTarget.EXPRESSION)\n<!RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION!>@Retention(AnnotationRetention.RUNTIME)<!>\nannotation class TestRetentionRuntime"
        },
        {
            "code": "// FULL_JDK\n// FILE: RepeatableUse.kt\n\n// Error should be gone when Java 8 Target will be available\n@RepeatableAnnotation <!NON_SOURCE_REPEATED_ANNOTATION!>@RepeatableAnnotation<!> class My\n"
        },
        {
            "code": "@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npackage test\n\nimport kotlin.internal.RequireKotlin\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"\")<!>\nfun f01() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"x\")<!>\nfun f02() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"1\")<!>\nfun f03() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"1.0-beta\")<!>\nfun f04() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"1.1.0-dev-1111\")<!>\nfun f05() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"1.5.3.7\")<!>\nfun f06() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\"1..0\")<!>\nfun f07() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@RequireKotlin(\" 1.0\")<!>\nfun f08() {}\n\n\n@RequireKotlin(\"1.1\")\nfun ok1() {}\n\n@RequireKotlin(\"1.1.0\")\nfun ok2() {}\n\n@RequireKotlin(\"0.0.0\")\nfun ok3() {}\n"
        },
        {
            "code": "package test\n\n// Checks that there is no rewrite error at ANNOTATION slice because of resolving annotations for object in lazy resolve and resolving\n// object as property (method tries to resolve annotations too).\n\n@<!UNRESOLVED_REFERENCE!>BadAnnotation<!>\nobject SomeObject\n\nval some = SomeObject"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(@<!UNRESOLVED_REFERENCE!>varargs<!> <!UNUSED_PARAMETER!>f<!> : Int) {}\n\nvar bar : Int = 1\n  set(@<!UNRESOLVED_REFERENCE!>varargs<!> <!UNUSED_PARAMETER!>v<!>) {}\n\nval x : (Int) -> Int = {@<!UNRESOLVED_REFERENCE!>varargs<!> <!TYPE_MISMATCH, UNINITIALIZED_VARIABLE!>x<!> <!SYNTAX!>: Int -> x<!>}\n\nclass Hello(@<!UNRESOLVED_REFERENCE!>varargs<!> <!UNUSED_PARAMETER!>args<!>: Any) {\n}"
        },
        {
            "code": "annotation class my\nannotation class my1(val i : Int)\nannotation class my2(val i : Int = 0)\n\n@my fun foo() {}\n@<!NO_VALUE_FOR_PARAMETER!>my1<!> fun foo2() {}\n@my1(2) fun foo3() {}\n@my2() fun foo4() {}\n@my2 fun foo41() {}\n@my2(2) fun foo42() {}\n"
        },
        {
            "code": "annotation class Ann\nannotation class Ann2\n\nclass C {\n    fun foo() {\n        class Local {\n            @<!UNRESOLVED_REFERENCE!>Ann0<!>\n            @Ann @<!UNRESOLVED_REFERENCE!>Ann3<!>\n            @Ann2(<!TOO_MANY_ARGUMENTS!>1<!>)\n            @<!UNRESOLVED_REFERENCE!>Ann4<!><!SYNTAX!><!>\n        }\n    }\n    @<!UNRESOLVED_REFERENCE!>Ann0<!>\n    @Ann @<!UNRESOLVED_REFERENCE!>Ann3<!>\n    @Ann2(<!TOO_MANY_ARGUMENTS!>1<!>)\n    @<!UNRESOLVED_REFERENCE!>Ann4<!><!SYNTAX!><!>\n}\n\n@<!UNRESOLVED_REFERENCE!>Ann0<!>\n@Ann @<!UNRESOLVED_REFERENCE!>Ann3<!>\n@Ann2(<!TOO_MANY_ARGUMENTS!>1<!>)\n@<!UNRESOLVED_REFERENCE!>Ann4<!SYNTAX!><!><!>"
        },
        {
            "code": "// FULL_JDK\n// FILE: RepeatableUse.kt\n\n// Error should be gone when Java 8 Target will be available\n@RepeatableAnnotation <!NON_SOURCE_REPEATED_ANNOTATION!>@RepeatableAnnotation<!> class My\n"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNUSED_ANONYMOUS_PARAMETER\n// !WITH_NEW_INFERENCE\n\nfun f1(x: String) {}\nfun f2(f: () -> Unit) {}\nfun test1() = f2(<!TYPE_MISMATCH(\"() -> Unit\", \"KFunction1<String, Unit>\")!>::f1<!>)\n\n\n@Target(AnnotationTarget.TYPE_PARAMETER,  AnnotationTarget.TYPE)\nannotation class Ann\n\nfun <@Ann R : @Ann Any> f3(a: Array<@Ann R>): Array<@Ann R?> =  null!!\n\nfun test2(a: @Ann Array<in @Ann Int>) {\n    val r: Array<in Int?> = <!OI;TYPE_INFERENCE_CANNOT_CAPTURE_TYPES(\"'R' cannot capture 'in Int'. Type parameter has an upper bound 'Any' that cannot be satisfied capturing 'in' projection\")!>f3<!>(<!NI;TYPE_MISMATCH(\"Any\", \"Int\")!>a<!>)\n}\n\n\nvar test3: Int = 0\n    set(s: <!WRONG_SETTER_PARAMETER_TYPE(\"Int\", \"String\")!>@Ann String<!>) {}\n\n\nfun f4(fn: (@Ann Int, @Ann Int) -> Unit) {}\n\nval test4 = f4 <!NI;TYPE_MISMATCH(\"(Int, Int) -> Unit\", \"(Int) -> Unit\")!>{ <!EXPECTED_PARAMETERS_NUMBER_MISMATCH(\"2\", \"Int, Int\")!>single<!> -> }<!>\n"
        },
        {
            "code": "annotation class A1\nannotation class A2(val some: Int = 12)\n\nclass TopLevelClass<<!UNSUPPORTED!>@A1<!> <!UNSUPPORTED!>@A2(3)<!> <!UNSUPPORTED!>@A2<!> <!UNSUPPORTED!>@A1(12)<!> <!UNSUPPORTED!>@A2(\"Test\")<!> T> {\n    class InnerClass<<!UNSUPPORTED!>@A1<!> <!UNSUPPORTED!>@A2(3)<!> <!UNSUPPORTED!>@A2<!> <!UNSUPPORTED!>@A1(12)<!> <!UNSUPPORTED!>@A2(\"Test\")<!> T> {\n        fun test() {\n            class InFun<<!UNSUPPORTED!>@A1<!> <!UNSUPPORTED!>@A2(3)<!> <!UNSUPPORTED!>@A2<!> <!UNSUPPORTED!>@A1(12)<!> <!UNSUPPORTED!>@A2(\"Test\")<!> T>\n        }\n    }\n}"
        },
        {
            "code": "package a\n\nimport java.lang.Deprecated as deprecated\nimport java.lang.SuppressWarnings as suppresswarnings\n\n\n<!DEPRECATED_JAVA_ANNOTATION!>@deprecated<!> @suppresswarnings val s: String = \"\";\n\n<!DEPRECATED_JAVA_ANNOTATION!>@deprecated<!> @suppresswarnings fun main() {\n    System.out.println(\"Hello, world!\")\n}\n\nclass Test(<!DEPRECATED_JAVA_ANNOTATION!>@deprecated<!> val s: String,\n           @suppresswarnings val x : Int) {}\n\n"
        },
        {
            "code": "fun test() {\n    @ann\n    while (2 > 1) {}\n\n    @ann\n    <!UNREACHABLE_CODE!>do {} while (2 > 1)<!>\n\n    @ann\n    <!UNREACHABLE_CODE!>for (i in 1..2) {}<!>\n}\n\nannotation class ann"
        },
        {
            "code": "import java.lang.annotation.Retention\nimport java.lang.annotation.Target\nimport java.lang.annotation.*\n\n<!DEPRECATED_JAVA_ANNOTATION!>@java.lang.annotation.Retention(RetentionPolicy.CLASS)<!>\nannotation class my\n\n<!DEPRECATED_JAVA_ANNOTATION!>@Retention(RetentionPolicy.RUNTIME)<!>\n<!DEPRECATED_JAVA_ANNOTATION!>@Target(ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR)<!>\nannotation class my1"
        },
        {
            "code": "annotation class A1\nannotation class A2(val some: Int = 12)\n\nval <<!WRONG_ANNOTATION_TARGET!>@A1<!> <!WRONG_ANNOTATION_TARGET!>@A2(3)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A1(<!TOO_MANY_ARGUMENTS!>12<!>)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2(<!TYPE_MISMATCH!>\"Test\"<!>)<!>  T> T.topProp: Int get() = 12\n\nclass SomeClass {\n    val <<!WRONG_ANNOTATION_TARGET!>@A1<!> <!WRONG_ANNOTATION_TARGET!>@A2(3)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A1(<!TOO_MANY_ARGUMENTS!>12<!>)<!> <!REPEATED_ANNOTATION, WRONG_ANNOTATION_TARGET!>@A2(<!TYPE_MISMATCH!>\"Test\"<!>)<!> T> T.field: Int get() = 12\n\n    fun foo() {\n        val <!LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING!><<!WRONG_ANNOTATION_TARGET!>@<!DEBUG_INFO_MISSING_UNRESOLVED!>A1<!><!> <!WRONG_ANNOTATION_TARGET!>@<!DEBUG_INFO_MISSING_UNRESOLVED!>A2<!>(3)<!> <!WRONG_ANNOTATION_TARGET!>@<!DEBUG_INFO_MISSING_UNRESOLVED!>A2<!><!> <!WRONG_ANNOTATION_TARGET!>@<!DEBUG_INFO_MISSING_UNRESOLVED!>A1<!>(12)<!> <!WRONG_ANNOTATION_TARGET!>@<!DEBUG_INFO_MISSING_UNRESOLVED!>A2<!>(\"Test\")<!> T><!> <!UNUSED_VARIABLE!>localVal<!> = 12\n    }\n}"
        },
        {
            "code": "// Functions can be recursively annotated\nannotation class ann(val x: Int)\n@ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>foo()<!>) fun foo() = 1"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInAnnotations\n\nannotation class Annotation2() {\n    <!ANNOTATION_CLASS_MEMBER!>public val s: String = \"\"<!>\n}\n\nannotation class Annotation3() {\n    <!ANNOTATION_CLASS_MEMBER!>public fun foo() {}<!>\n}\n\nannotation class Annotation4() {\n    class Foo() {}\n}\n\nannotation class Annotation5() {\n    companion object {}\n}\n\nannotation class Annotation6() {\n    <!ANNOTATION_CLASS_MEMBER!>init {}<!>\n}\n\nannotation class Annotation1() {}\n\nannotation class Annotation7(val name: String) {}\n\nannotation class Annotation8(<!VAR_ANNOTATION_PARAMETER!>var<!> name: String = \"\") {}\n\nannotation class Annotation9(val name: String)\n\nannotation class Annotation10\n"
        },
        {
            "code": "// Function parameter CAN be recursively annotated\nannotation class ann(val x: Int)\nfun foo(@ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>foo(1)<!>) x: Int): Int = x"
        },
        {
            "code": "@<!UNRESOLVED_REFERENCE!>Ann<!> class A\n@<!UNRESOLVED_REFERENCE!>Ann<!> class B\n@<!UNRESOLVED_REFERENCE!>Ann<!>(1) class C\n@kotlin.<!UNRESOLVED_REFERENCE!>Ann<!>(1) class D\n@kotlin.annotation.<!UNRESOLVED_REFERENCE!>Ann<!>(1) class E"
        },
        {
            "code": "<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"\")<!>\nfun f01() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"x\")<!>\nfun f02() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1\")<!>\nfun f03() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1,0\")<!>\nfun f04() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1,0,1\")<!>\nfun f05() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"a.b\")<!>\nfun f06() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.a\")<!>\nfun f07() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.0.a\")<!>\nfun f08() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.0-beta\")<!>\nfun f09() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.1.0-dev-1111\")<!>\nfun f10() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.1.0+rc\")<!>\nfun f11() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.5.3.7\")<!>\nfun f12() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"01.1\")<!>\nfun f13() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.01\")<!>\nfun f14() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"-1.0\")<!>\nfun f15() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.-1.0\")<!>\nfun f16() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"0.00.1\")<!>\nfun f17() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1..0\")<!>\nfun f18() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\" 1.0\")<!>\nfun f19() {}\n\n<!ILLEGAL_KOTLIN_VERSION_STRING_VALUE!>@SinceKotlin(\"1.0 \")<!>\nfun f20() {}\n\n\n\n\n@SinceKotlin(\"1.1\")\nfun ok1() {}\n\n@SinceKotlin(\"1.1.0\")\nfun ok2() {}\n\n@SinceKotlin(\"0.0.0\")\nfun ok3() {}\n\n<!NEWER_VERSION_IN_SINCE_KOTLIN!>@SinceKotlin(\"123456789012345678901234567890.123456789012345678901234567890.123456789012345678901234567890\")<!>\nfun ok4() {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nannotation class Ann\n\nfun f(@Ann x: Int) {}\n\nval inVal: (<!UNSUPPORTED!>@Ann<!> x: Int)->Unit = {}\n\nfun inParam(fn: (<!UNSUPPORTED!>@Ann<!> x: Int)->Unit) {}\n\nfun inParamNested(fn1: (fn2: (<!UNSUPPORTED!>@Ann<!> n: Int)->Unit)->Unit) {}\n\nfun inReturn(): (<!UNSUPPORTED!>@Ann<!> x: Int)->Unit = {}\n\nclass A : (@Ann Int)->Unit {\n    override fun invoke(p1: Int) {\n        var lambda: (<!UNSUPPORTED!>@Ann<!> x: Int)->Unit = {}\n    }\n\n    val prop: (<!UNSUPPORTED!>@Ann<!> x: Int)->Unit\n        get(): (<!UNSUPPORTED!>@Ann<!> x: Int)->Unit = {}\n}\n\n@Target(AnnotationTarget.TYPE)\nannotation class TypeAnn\n\nval onType: (@TypeAnn A).(<!UNSUPPORTED!>@Ann<!> a: @TypeAnn A, @TypeAnn A)->@TypeAnn A? = <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!>{<!> null }\n\nfun (@TypeAnn A).extFun(@Ann a: @TypeAnn A): @TypeAnn A? = null"
        },
        {
            "code": "// Properties can be recursively annotated\nannotation class ann(val x: Int)\nclass My {\n    @ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>x<!>) val x: Int = 1\n}"
        },
        {
            "code": "annotation class B\n\nclass A {\n   <!WRONG_MODIFIER_TARGET!>annotation<!> companion object {}\n}\n\n<!WRONG_MODIFIER_TARGET!>annotation<!> object O {}\n\n<!WRONG_MODIFIER_TARGET!>annotation<!> interface T {}\n\n<!WRONG_MODIFIER_TARGET!>annotation<!> fun f() = 0\n\n<!WRONG_MODIFIER_TARGET!>annotation<!> val x = 0\n\n<!WRONG_MODIFIER_TARGET!>annotation<!> var y = 0"
        },
        {
            "code": "annotation class ann\n\nfun test(@ann <!UNUSED_PARAMETER!>p<!>: Int) {\n\n}\n\nval bar = fun(@ann <!UNUSED_ANONYMOUS_PARAMETER!>g<!>: Int) {}\n"
        },
        {
            "code": "annotation class Ann(vararg val i: Boolean)\nfun foo() {\n    val bool1 = true\n\n    @Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>bool1<!>) val <!UNUSED_VARIABLE!>a<!> = bool1\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitNonConstValuesAsVarargsInAnnotations\n\nannotation class AnnE(val i: MyEnum)\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_ENUM_CONST!>e<!>)\nclass Test\n\nval e: MyEnum = MyEnum.A\n\nenum class MyEnum {\n    A\n}\n\n@AnnE(<!TYPE_MISMATCH!>Test()<!>)\nclass Test2"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\nannotation class Ann(vararg val i: Boolean)\nfun foo() {\n    val a1 = 1 > 2\n    val a2 = 1 == 2\n    val a3 = a1 == a2\n    val a4 = a1 > a2\n\n    @Ann(\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a1<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a2<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a3<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a1 > a2<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a1 == a2<!>\n    ) val b = 1\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitNonConstValuesAsVarargsInAnnotations\n\nannotation class AnnE(val i: MyEnum)\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_ENUM_CONST!>e<!>)\nclass Test\n\nval e: MyEnum = MyEnum.A\n\nenum class MyEnum {\n    A\n}\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_CONST, TYPE_MISMATCH!>Test()<!>)\nclass Test2"
        },
        {
            "code": "annotation class Ann(vararg val i: Int)\n\n@Ann(\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i1<!>,\n        i2,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>,\n        i4,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i5<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i6<!>\n)\nclass Test\n\nvar i1 = 1  // var\nconst val i2 = 1  // val\nval i3 = i1 // val with var in initializer\nconst val i4 = i2 // val with val in initializer\nvar i5 = i1 // var with var in initializer\nvar i6 = i2 // var with val in initializer\n"
        },
        {
            "code": "annotation class AnnE(val i: String)\n\nenum class MyEnum {\n    A\n}\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"1\" + MyEnum.A<!>)\nclass Test\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"1\" + MyEnum::class<!>)\nclass Test2\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"1\" + AnnE(\"23\")<!>)\nclass Test3\n\n@AnnE(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"1\" + arrayOf(\"23\", \"34\")<!>)\nclass Test4\n\n"
        },
        {
            "code": "const val iConst = 42\nval iVal = 42\nfun iFun() = 42\n\nannotation class Ann(val x: Int)\nannotation class Test1(val x: Int = 42)\nannotation class Test2(val x: Int = iConst)\nannotation class Test3(val x: Int = 1 + iConst + 1)\nannotation class Test4(val x: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>iVal<!>)\nannotation class Test5(val x: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>1 + iVal + 1<!>)\nannotation class Test6(val x: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>iFun()<!>)\nannotation class Test7(val x: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>1 + iFun() + 1<!>)\n"
        },
        {
            "code": "// FILE: a.kt\nannotation class Ann(vararg val i: Int)\n\n@Ann(\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>Test.i1<!>,\n        Test.i2,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>Test.i3<!>,\n        Test.i4,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>Test.i5<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>Test.i6<!>,\n        <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>Test().i7<!>\n)\nclass A\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\nannotation class Ann(vararg val i: String)\n\nconst val topLevel = \"topLevel\"\n\nfun foo() {\n    val a1 = \"a\"\n    val a2 = \"b\"\n    val a3 = a1 + a2\n\n    val a4 = 1\n    val a5 = 1.0\n\n    @Ann(\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a1<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a2<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a3<!>,\n            \"$topLevel\",\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"$a1\"<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"$a1 $topLevel\"<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"$a4\"<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"$a5\"<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>a1 + a2<!>,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"a\" + a2<!>,\n            \"a\" + topLevel,\n            <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>\"a\" + a4<!>\n    ) val b = 1\n}"
        },
        {
            "code": "// FILE: UnrepeatableUse.kt\n\n@UnrepeatableAnnotation <!REPEATED_ANNOTATION!>@UnrepeatableAnnotation<!> class My"
        },
        {
            "code": "// !LANGUAGE: -NestedClassesInAnnotations\n\nannotation class Annotation2() {\n    <!ANNOTATION_CLASS_MEMBER!>public val s: String = \"\"<!>\n}\n\nannotation class Annotation3() {\n    <!ANNOTATION_CLASS_MEMBER!>public fun foo() {}<!>\n}\n\nannotation class Annotation4() {\n    <!ANNOTATION_CLASS_MEMBER!>class Foo() {}<!>\n}\n\nannotation class Annotation5() {\n    companion <!ANNOTATION_CLASS_MEMBER!>object<!> {}\n}\n\nannotation class Annotation6() {\n    <!ANNOTATION_CLASS_MEMBER!>init {}<!>\n}\n\nannotation class Annotation1() {}\n\nannotation class Annotation7(val name: String) {}\n\nannotation class Annotation8(<!VAR_ANNOTATION_PARAMETER!>var<!> name: String = \"\") {}\n\nannotation class Annotation9(val name: String)\n\nannotation class Annotation10\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class test\n\nfun foo(@test <!UNUSED_PARAMETER!>f<!> : Int) {}\n\nvar bar : Int = 1\n    set(@test <!UNUSED_PARAMETER!>v<!>) {}\n\nval x : (Int) -> Int = {@test <!TYPE_MISMATCH, UNINITIALIZED_VARIABLE!>x<!> <!SYNTAX!>: Int -> x<!>} // todo fix parser annotation on lambda parameter\n\nclass Hello(@test <!UNUSED_PARAMETER!>args<!>: Any) {\n}\n"
        },
        {
            "code": "annotation class Ann\n\nclass C {\n    fun test() {\n        @Ann<!SYNTAX!><!>\n    }\n\n    fun foo() {\n        class Local {\n            @Ann<!SYNTAX!><!>\n        }\n    }\n    @Ann<!SYNTAX!><!>\n}\n\n@Ann<!SYNTAX!><!>"
        },
        {
            "code": "// Class constructor parameter CAN be recursively annotated\nclass RecursivelyAnnotated(<!NOT_AN_ANNOTATION_CLASS!>@RecursivelyAnnotated(1)<!> val x: Int)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !RENDER_DIAGNOSTICS_MESSAGES\n// !WITH_NEW_INFERENCE\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS)\nannotation class A\n\n@A\nclass C<T> {\n    @A\n    operator fun plus(x: Out<@A T>): @A C<@A T> = this\n}\n\nclass Out<out F>\n\nfun test(a: C<out CharSequence>, y: Out<CharSequence>) {\n    a + <!NI;TYPE_MISMATCH(\"Out<Nothing>\", \"Out<CharSequence>\"), OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS(\"Out<Nothing>\", \"Out<CharSequence>\", \"C<out CharSequence>\", \"public final operator fun plus(x: Out<T>): C<T> defined in C\")!>y<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS)\nannotation class A\n\n@A\nclass C<T> {\n    @A\n    operator fun set(x: @A Int, y: @A T) {}\n}\n\nfun test(a: C<out CharSequence>) {\n    <!OI;MEMBER_PROJECTED_OUT(\"public final operator fun set(x: Int, y: T): Unit defined in C\", \"C<out CharSequence>\")!>a[1]<!> = <!NI;CONSTANT_EXPECTED_TYPE_MISMATCH(\"integer\", \"Nothing\")!>25<!>\n}"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS)\nannotation class Ann(val s: String = \"\")\n\n@Ann(\"s\")\nfun foo() {}\n\nval bar = foo(\n    <!TOO_MANY_ARGUMENTS(\"public fun foo(): Unit defined in root package in file tooManyArguments.kt\")!>15<!>\n)"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS,  AnnotationTarget.PROPERTY,  AnnotationTarget.VALUE_PARAMETER)\nannotation class An\n\n@An\ninterface A {\n    @An\n    val p1: @An String\n    @An\n    var p2: @An String\n    @An\n    fun test(@An arg: @An String): @An String\n}\n\n@An\ninterface B : A {\n    override val p1: <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE(\"p1\", \"public abstract val p1: String defined in A\")!>Int<!>\n    @An\n    override <!VAR_OVERRIDDEN_BY_VAL(\"public abstract val p2: String defined in B\", \"public abstract var p2: String defined in A\")!>val<!> p2: @An String\n    override fun test(arg: String): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE(\"test\", \"public abstract fun test(arg: String): String defined in A\")!>Int<!>\n}\n\ninterface C : A {\n    override var p2: <!VAR_TYPE_MISMATCH_ON_OVERRIDE(\"p2\", \"public abstract var p2: String defined in A\")!>Int<!>\n}"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n\n@Target(AnnotationTarget.PROPERTY,  AnnotationTarget.FUNCTION, AnnotationTarget.TYPE,  AnnotationTarget.LOCAL_VARIABLE)\nannotation class A\n\n@A\nfun test() {\n    @A\n    var b: @A Int = 0\n    <!UNUSED_VALUE(\"15\", \"var b: Int defined in test\")!>b =<!> 15\n}\n"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS,  AnnotationTarget.PROPERTY,  AnnotationTarget.VALUE_PARAMETER)\nannotation class An\n\n@An\ndata class A(@An val x: @An Int) {\n    <!CONFLICTING_OVERLOADS(\"public final fun copy(x: Int): Int defined in A\")!>@An\n    fun copy(@An x: @An Int)<!> = x\n}"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS,  AnnotationTarget.VALUE_PARAMETER,  AnnotationTarget.PROPERTY)\nannotation class An\n\n@An\ninterface A {\n    @An\n    fun a(@An arg: @An Int)\n}\n\n@An\ninterface B {\n    @An\n    fun <T> a(@An arg: @An Int)\n}\n\n<!CONFLICTING_INHERITED_MEMBERS(\"C\", \"public abstract fun a(arg: Int): Unit defined in A, public abstract fun <T> a(arg: Int): Unit defined in B\")!>interface C<!> : A, B\n\n@An\nabstract class D {\n    @An\n    abstract val d: @An Int\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED(\"Class 'E'\", \"public abstract val d: Int defined in D\")!>class E<!> : D(), A\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED(\"Class 'F'\", \"public abstract fun a(arg: Int): Unit defined in A\")!>class F<!> : A\n\n@An\ninterface G {\n    @An\n    fun a(@An arg: @An Int)\n}\n\n@An\ninterface AI : A {\n    @An\n    override fun a(@An arg: @An Int) {}\n}\n\n@An\ninterface GI : G {\n    @An\n    override fun a(@An arg: @An Int) {}\n}\n\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED(\"Class 'AG1'\", \"public open fun a(arg: Int): Unit defined in AG1\")!>class AG1<!>(val a: A, val g: G) : A by a, G by g\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED(\"Class 'AG2'\", \"public open fun a(arg: Int): Unit defined in AI\")!>class AG2<!>() : AI, GI"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n// JAVAC_SKIP\n\n// FILE: k.kt\n\nimport org.jetbrains.annotations.NotNull;\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS,  AnnotationTarget.PROPERTY,  AnnotationTarget.VALUE_PARAMETER)\nannotation class An\n\nclass B : A {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE(\"foo\", \"@NotNull @MyTypeQualifier public abstract fun foo(): String defined in A\")!>String?<!> = null\n}\n\n@An\npublic interface C {\n    @NotNull\n    @An\n    fun foo(): String\n}\n\nclass D : C {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE(\"foo\", \"public abstract fun foo(): String defined in C\")!>String?<!> = null\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -INCOMPATIBLE_MODIFIERS\n// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS)\nannotation class A\n\n@A\nopen class B1 {\n    @A\n    private open fun foo() {}\n}\n\nclass D1 : B1() {\n    <!CANNOT_OVERRIDE_INVISIBLE_MEMBER(\"public open fun foo(): Unit defined in D1\", \"private open fun foo(): Unit defined in B1\")!>override<!> fun foo() {}\n}"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS,  AnnotationTarget.PROPERTY,  AnnotationTarget.VALUE_PARAMETER)\nannotation class An\n\n@An\ninterface A {\n    @An\n    fun foo(@An a : @An Int)\n}\n\n@An\ninterface B {\n    @An\n    fun foo(@An b : @An Int)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES(\"public abstract fun foo(a: Int): Unit defined in A, public abstract fun foo(b: Int): Unit defined in B\", \"1\")!>interface C<!> : A, B"
        },
        {
            "code": "// !RENDER_DIAGNOSTICS_MESSAGES\n// !DIAGNOSTICS: -ABSTRACT_MEMBER_NOT_IMPLEMENTED\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.CLASS,  AnnotationTarget.VALUE_PARAMETER,  AnnotationTarget.PROPERTY,  AnnotationTarget.EXPRESSION)\n@Retention( AnnotationRetention.SOURCE)\nannotation class An\n\n@An\ninterface A {\n    @An\n    fun foo(@An a: @An Int = @An 1)\n}\n\n@An\ninterface B {\n    @An\n    fun foo(@An a: @An Int = @An 2)\n}\n\n<!MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE(\"value-parameter a: Int = ... defined in AB1.foo\")!>class AB1<!> : A, B\n\n@An\nclass AB2 : A, B {\n    @An\n    override fun foo(<!MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES(\"value-parameter a: Int = ... defined in AB2.foo\")!>@An a: @An Int<!>) {}\n}"
        },
        {
            "code": "// Check that there won't be \"Rewrite at slice ANNOTATION key\" exception - EA-36935\n@<!UNRESOLVED_REFERENCE!>someErrorAnnotation<!> object Test {\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n@Target(AnnotationTarget.FUNCTION)\nannotation class FunAnn\n\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class SourceAnn\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class ExprAnn\n\nfun bar(arg: () -> Int) = arg()\n\ninline fun fast(arg: () -> Int) = arg()\n\ninline fun fast2(x: Int, arg: () -> Int) = x + arg()\n\n@FunAnn fun gav() = 13\n\nfun foo(arg: Int) {\n    // Literal is annotatable\n    bar @FunAnn { arg }\n    // Annotatable in principle but useless, fast is inline\n    fast <!NON_SOURCE_ANNOTATION_ON_INLINED_LAMBDA_EXPRESSION!>@FunAnn<!> { arg }\n    fast2(1, <!NON_SOURCE_ANNOTATION_ON_INLINED_LAMBDA_EXPRESSION!>@FunAnn<!> { arg })\n    // Source annotation, ok\n    fast @SourceAnn { arg }\n    fast2(1, @SourceAnn { arg })\n    // Expression annotation, ok\n    fast @ExprAnn { arg }\n    fast2(1, @ExprAnn { arg })\n    // Function expression too\n    val f = @FunAnn fun(): Int { return 42 }\n    // But here, f and gav should be annotated instead\n    bar(<!WRONG_ANNOTATION_TARGET!>@FunAnn<!> f)\n    bar(<!OI;WRONG_ANNOTATION_TARGET!>@<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>FunAnn<!><!> ::gav)\n    // Function expression, ok\n    fast(f)\n}"
        },
        {
            "code": "@Target(AnnotationTarget.FUNCTION)\nannotation class FunAnn\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class ExprAnn\n\nfun foo(): Int {\n    var x = 5\n    <!WRONG_ANNOTATION_TARGET!>@FunAnn<!> ++x\n    @ExprAnn ++x\n    return x\n}"
        },
        {
            "code": "annotation class base\n\nval x: List<<!WRONG_ANNOTATION_TARGET!>@base<!> String>? = null\n\nval y: List<@[<!WRONG_ANNOTATION_TARGET!>base<!>] String>? = null\n\n@Target(AnnotationTarget.TYPE)\nannotation class typeAnn\n\nfun foo(list: List<@typeAnn Int>) = list"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Target(AnnotationTarget.VALUE_PARAMETER) annotation class base\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(@base val x: Int, @base w: Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0, 0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(@base y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(@base z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n@Target(AnnotationTarget.FIELD) \nannotation class Field\n\n<!WRONG_ANNOTATION_TARGET!>@Field<!>\nannotation class Another\n\n@Field\nval x: Int = 42\n\n<!WRONG_ANNOTATION_TARGET!>@Field<!>\nval y: Int\n    get() = 13\n\n<!WRONG_ANNOTATION_TARGET!>@Field<!>\nabstract class My(<!WRONG_ANNOTATION_TARGET!>@Field<!> arg: Int, @Field val w: Int) {\n    @Field\n    val x: Int = arg\n\n    <!WRONG_ANNOTATION_TARGET!>@Field<!>\n    val y: Int\n        get() = 0\n\n    <!WRONG_ANNOTATION_TARGET!>@Field<!>\n    abstract val z: Int\n\n    <!WRONG_ANNOTATION_TARGET!>@Field<!>\n    fun foo() {}\n\n    <!WRONG_ANNOTATION_TARGET!>@Field<!>\n    val v: Int by <!UNRESOLVED_REFERENCE!>Delegates<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>lazy<!> { 42 }\n}\n\nenum class Your {\n    @Field FIRST\n}\n\ninterface His {\n    <!WRONG_ANNOTATION_TARGET!>@Field<!>\n    val x: Int\n\n    <!WRONG_ANNOTATION_TARGET!>@Field<!>\n    val y: Int\n        get() = 42\n}\n"
        },
        {
            "code": "// FILE: test/AnnotationTargets.java\n\npackage test;\n\nimport java.lang.annotation.*;\n\npublic class AnnotationTargets {\n\n    public @interface base {\n\n    }\n\n    @Target(ElementType.ANNOTATION_TYPE)\n    public @interface meta {\n\n    }\n\n    @Target(ElementType.CONSTRUCTOR)\n    public @interface konstructor {\n\n    }\n\n    @Target(ElementType.FIELD)\n    public @interface fieldann {\n\n    }\n\n\n    @Target(ElementType.LOCAL_VARIABLE)\n    public @interface local {\n\n    }\n\n    @Target(ElementType.METHOD)\n    public @interface method {\n\n    }\n\n    @Target(ElementType.PARAMETER)\n    public @interface parameter {\n\n    }\n\n\n    @Target(ElementType.TYPE)\n    public @interface type {\n\n    }\n\n    @Target({ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.FIELD})\n    public @interface multiple {\n\n    }\n}\n\n// FILE: test/AnnotationTargets.kt\n\n@file:AnnotationTargets.type\npackage test\n\nimport test.AnnotationTargets.*\n\n@base @meta @type <!WRONG_ANNOTATION_TARGET!>@konstructor<!> annotation class KMeta\n\n@base <!WRONG_ANNOTATION_TARGET!>@meta<!> @type <!WRONG_ANNOTATION_TARGET!>@method<!> <!WRONG_ANNOTATION_TARGET!>@multiple<!> class KClass(\n        @base @fieldann @parameter val y:\n        <!WRONG_ANNOTATION_TARGET!>@base<!> <!WRONG_ANNOTATION_TARGET!>@type<!> Int) {\n\n    @base @multiple @fieldann <!WRONG_ANNOTATION_TARGET!>@local<!> val x = 0\n    @method <!WRONG_ANNOTATION_TARGET!>@konstructor<!> <!WRONG_ANNOTATION_TARGET!>@type<!> get\n\n    @base @method @multiple <!WRONG_ANNOTATION_TARGET!>@konstructor<!>\n    fun foo(@parameter <!WRONG_ANNOTATION_TARGET!>@type<!> i:\n    <!WRONG_ANNOTATION_TARGET!>@base<!> <!WRONG_ANNOTATION_TARGET!>@multiple<!> Int\n    ): <!WRONG_ANNOTATION_TARGET!>@fieldann<!> <!WRONG_ANNOTATION_TARGET!>@parameter<!> Int {\n\n        @local @base <!WRONG_ANNOTATION_TARGET!>@multiple<!> <!WRONG_ANNOTATION_TARGET!>@fieldann<!> val j = i + 1\n        <!WRONG_ANNOTATION_TARGET!>@base<!> <!WRONG_ANNOTATION_TARGET!>@multiple<!> return j\n    }\n\n    @base <!WRONG_ANNOTATION_TARGET!>@method<!> @konstructor constructor(): this(0)\n}\n"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_PARAMETER\n\n@Target(AnnotationTarget.TYPE_PARAMETER)\nannotation class A\n\n@Target(AnnotationTarget.TYPE_PARAMETER)\nannotation class B(val i: Int = 12)\n\n\nfun <@A @B(3) T> topFun() = 12\n\nclass Class1 {\n    fun <@A @B(3)T> method() = 12\n\n    fun foo() {\n        fun <@A @B(3) T> innerFun() = 12\n    }\n}\n\nval <@A @B(3) T> T.topProp: Int get() = 12\n\nclass Class2 {\n    val <@A @B(3) T> T.field: Int get() = 12\n}\n\n\n<!WRONG_ANNOTATION_TARGET!>@A<!> fun foo() {}\n<!WRONG_ANNOTATION_TARGET!>@A<!> class D\nfun foo(i: <!WRONG_ANNOTATION_TARGET!>@A<!> Int) {\n    <!WRONG_ANNOTATION_TARGET!>@A<!> val <!NAME_SHADOWING, UNUSED_VARIABLE!>i<!> = 1\n}\nfun <T> test(t: <!WRONG_ANNOTATION_TARGET!>@A<!> T): T = t\n\n\n@Target(AnnotationTarget.TYPE)\ninternal annotation class C\n\nfun <<!WRONG_ANNOTATION_TARGET!>@C<!> T> test2(t: T): T = t"
        },
        {
            "code": "@Target(AnnotationTarget.FUNCTION) annotation class base\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(<!WRONG_ANNOTATION_TARGET!>@base<!> val x: Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0)\n\n    @base public fun baz() {}\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My <!WRONG_ANNOTATION_TARGET!>@base<!> constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n@base fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    @base fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Target(AnnotationTarget.PROPERTY) annotation class base\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(@base val x: Int, <!WRONG_ANNOTATION_TARGET!>@base<!> w: Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0, 0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My {\n    @base FIRST,\n    @base SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n@base val z = 0\n"
        },
        {
            "code": "annotation class base\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class special\n\nfun transform(i: Int, tr: (Int) -> Int): Int = <!WRONG_ANNOTATION_TARGET!>@base<!> @special tr(@special i)\n\n@base <!WRONG_ANNOTATION_TARGET!>@special<!> fun foo(i: Int): Int {\n    val j = <!WRONG_ANNOTATION_TARGET!>@base<!> @special i + 1\n    if (j == 1) return foo(@special <!WRONG_ANNOTATION_TARGET!>@base<!> 42)\n    return transform(@special j, @base @special { <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@special it<!> * 2 })\n}\n"
        },
        {
            "code": "annotation class base\n\n@Target(AnnotationTarget.TYPE)\nannotation class typed\n\n@base class My(val x: <!WRONG_ANNOTATION_TARGET!>@base<!> @typed Int, y: <!WRONG_ANNOTATION_TARGET!>@base<!> @typed Int) {\n    val z: <!WRONG_ANNOTATION_TARGET!>@base<!> @typed Int = y\n    fun foo(): <!WRONG_ANNOTATION_TARGET!>@base<!> @typed Int = z\n}\n"
        },
        {
            "code": "// FILE: annotation.kt\n\npackage test\n\n@Target(AnnotationTarget.FILE) annotation class special\n\nannotation class common\n\n// FILE: other.kt\n\n@file:special\n\npackage test\n\n<!WRONG_ANNOTATION_TARGET!>@special<!> class Incorrect\n\n// FILE: another.kt\n\n<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:common<!>\n\npackage test\n\n@common class Correct\n"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE) annotation class base\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(<!WRONG_ANNOTATION_TARGET!>@base<!> val x: @base Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My <!WRONG_ANNOTATION_TARGET!>@base<!> constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: @base Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: @base Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0\n"
        },
        {
            "code": "@Target(AnnotationTarget.CLASS)\nannotation class base\n\n@Target(AnnotationTarget.ANNOTATION_CLASS)\nannotation class meta\n\n@base class Outer {\n    @base <!WRONG_ANNOTATION_TARGET!>@meta<!> class Nested\n\n    @base @meta annotation class Annotated\n\n    fun foo() {\n        @base <!WRONG_ANNOTATION_TARGET!>@meta<!> class Local\n    }\n}\n"
        },
        {
            "code": "annotation class base\n\n@base class My {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> init {\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Target(AnnotationTarget.CLASS) annotation class base\n\n@base annotation class derived\n\n@base class correct(<!WRONG_ANNOTATION_TARGET!>@base<!> val x: Int, <!WRONG_ANNOTATION_TARGET!>@base<!> w: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0, 0)\n}\n\n@base enum class My <!WRONG_ANNOTATION_TARGET!>@base<!> constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0\n"
        },
        {
            "code": "@Target(AnnotationTarget.PROPERTY_GETTER)\nannotation class smartget\n\n@Target(AnnotationTarget.PROPERTY_SETTER)\nannotation class smartset\n\n@Target(AnnotationTarget.FUNCTION)\nannotation class base\n\nclass My(x: Int) {\n    <!WRONG_ANNOTATION_TARGET!>@smartget<!> var y = x\n    <!WRONG_ANNOTATION_TARGET!>@base<!> @smartget <!WRONG_ANNOTATION_TARGET!>@smartset<!> get\n    <!WRONG_ANNOTATION_TARGET!>@base<!> <!WRONG_ANNOTATION_TARGET!>@smartget<!> @smartset set\n\n    @base <!WRONG_ANNOTATION_TARGET!>@smartget<!> <!WRONG_ANNOTATION_TARGET!>@smartset<!> fun foo() = y\n}"
        },
        {
            "code": "@Target(AnnotationTarget.LOCAL_VARIABLE) annotation class base\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(<!WRONG_ANNOTATION_TARGET!>@base<!> val x: Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    @base val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0\n"
        },
        {
            "code": "@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class special\n\n@Target(AnnotationTarget.TYPE)\nannotation class base\n\nfun transform(i: Int, tr: (<!WRONG_ANNOTATION_TARGET!>@special<!> Int) -> Int): Int = @special tr(@special i)\n\nfun foo(i: Int): Int {\n    val j = @special i + 1\n    if (j == 1) return foo(@special 42)\n    return transform(@special j, @special { <!NAME_SHADOWING!>i<!>: @base Int -> <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!><!WRONG_ANNOTATION_TARGET!>@base<!> i<!> * 2 })\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Target() annotation class empty\n\n<!WRONG_ANNOTATION_TARGET!>@empty<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@empty<!> class correct(<!WRONG_ANNOTATION_TARGET!>@empty<!> val x: Int, <!WRONG_ANNOTATION_TARGET!>@empty<!> w: <!WRONG_ANNOTATION_TARGET!>@empty<!> Int) {\n    <!WRONG_ANNOTATION_TARGET!>@empty<!> constructor(): this(0, 0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@empty<!> enum class My <!WRONG_ANNOTATION_TARGET!>@empty<!> constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@empty<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@empty<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@empty<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@empty<!> y: <!WRONG_ANNOTATION_TARGET!>@empty<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@empty<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@empty<!> z: <!WRONG_ANNOTATION_TARGET!>@empty<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@empty<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@empty<!> val z = <!WRONG_ANNOTATION_TARGET!>@empty<!> 0\n"
        },
        {
            "code": "@Target(AnnotationTarget.CONSTRUCTOR) annotation class base\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(<!WRONG_ANNOTATION_TARGET!>@base<!> val x: Int) {\n    @base constructor(): this(0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My @base constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0\n"
        },
        {
            "code": "@Target(AnnotationTarget.ANNOTATION_CLASS) annotation class base\n\n@base annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> class correct(<!WRONG_ANNOTATION_TARGET!>@base<!> val x: Int) {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> constructor(): this(0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> enum class My {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@base<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@base<!> y: <!WRONG_ANNOTATION_TARGET!>@base<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@base<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@base<!> z: <!WRONG_ANNOTATION_TARGET!>@base<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@base<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@base<!> val z = 0\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Target(AnnotationTarget.<!UNRESOLVED_REFERENCE!>INIT<!>) annotation class incorrect\n\n<!WRONG_ANNOTATION_TARGET!>@incorrect<!> annotation class derived\n\n<!WRONG_ANNOTATION_TARGET!>@incorrect<!> class correct(<!WRONG_ANNOTATION_TARGET!>@incorrect<!> val x: Int, <!WRONG_ANNOTATION_TARGET!>@incorrect<!> w: <!WRONG_ANNOTATION_TARGET!>@incorrect<!> Int) {\n    <!WRONG_ANNOTATION_TARGET!>@incorrect<!> constructor(): this(0, 0)\n}\n\n<!WRONG_ANNOTATION_TARGET!>@incorrect<!> enum class My <!WRONG_ANNOTATION_TARGET!>@incorrect<!> constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@incorrect<!> FIRST,\n    <!WRONG_ANNOTATION_TARGET!>@incorrect<!> SECOND\n}\n\n<!WRONG_ANNOTATION_TARGET!>@incorrect<!> fun foo(<!WRONG_ANNOTATION_TARGET!>@incorrect<!> y: <!WRONG_ANNOTATION_TARGET!>@incorrect<!> Int): Int {\n    <!WRONG_ANNOTATION_TARGET!>@incorrect<!> fun bar(<!WRONG_ANNOTATION_TARGET!>@incorrect<!> z: <!WRONG_ANNOTATION_TARGET!>@incorrect<!> Int) = z + 1\n    <!WRONG_ANNOTATION_TARGET!>@incorrect<!> val local = bar(y)\n    return local\n}\n\n<!WRONG_ANNOTATION_TARGET!>@incorrect<!> val z = <!WRONG_ANNOTATION_TARGET!>@incorrect<!> 0\n"
        },
        {
            "code": "annotation class unrepann(val x: Int)\n\nannotation class ann(val y: Int)\n\n@unrepann(1) <!REPEATED_ANNOTATION!>@unrepann(2)<!> class DoubleAnnotated\n\n@ann(3) <!REPEATED_ANNOTATION!>@ann(7)<!> <!REPEATED_ANNOTATION!>@ann(42)<!> class TripleAnnotated\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class annexpr\n\n@ann(0) <!REPEATED_ANNOTATION!>@ann(1)<!> fun foo(@ann(7) <!REPEATED_ANNOTATION!>@ann(2)<!> x: Int): Int {\n    @annexpr <!REPEATED_ANNOTATION!>@annexpr<!> return x\n}\n\n@unrepann(0)\n@get:unrepann(1)\nvar annotated = 1 // No errors should be here\n\n@unrepann(0)\n<!REPEATED_ANNOTATION!>@property:unrepann(1)<!>\nvar annotated2 = 2\n"
        },
        {
            "code": "@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class ExprAnn\n\nfun foo(): Int {\n    var a: Int\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@ExprAnn a<!> = 1\n    <!ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE!>@ExprAnn a<!> += 1\n    return a\n}\n"
        },
        {
            "code": "@Repeatable\nannotation class repann\n\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class repann1(val x: Int)\n\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class repann2(val f: Boolean)\n\n@Retention(AnnotationRetention.BINARY)\n@Repeatable\nannotation class binrepann\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class repexpr\n\n@repann <!NON_SOURCE_REPEATED_ANNOTATION!>@repann<!> class DoubleAnnotated\n\n@repann1(1) @repann1(2) @repann1(3) class TripleAnnotated\n\n@repann2(true) @repann2(false) @repann2(false) @repann2(true) class FourTimesAnnotated\n\n@binrepann <!NON_SOURCE_REPEATED_ANNOTATION!>@binrepann<!> class BinaryAnnotated\n\n@repann <!NON_SOURCE_REPEATED_ANNOTATION!>@repann<!> fun foo(@repann <!NON_SOURCE_REPEATED_ANNOTATION!>@repann<!> x: Int): Int {\n    @repexpr @repexpr return x\n}"
        },
        {
            "code": "import java.lang.annotation.*\n\n<!DEPRECATED_JAVA_ANNOTATION!>@java.lang.annotation.Target(ElementType.PACKAGE)<!>\n@Target(AnnotationTarget.CLASS)\nannotation class my\n\n<!DEPRECATED_JAVA_ANNOTATION!>@java.lang.annotation.Retention(RetentionPolicy.SOURCE)<!>\n@Retention(AnnotationRetention.BINARY)\nannotation class your\n"
        },
        {
            "code": "// See KT-9145\n\n@Target(AnnotationTarget.CLASS)\nannotation class Ann\n\nfun foo() {\n    for (<!WRONG_ANNOTATION_TARGET!>@Ann<!> <!WRONG_MODIFIER_TARGET!>private<!> x in 1..100) {\n        if (x == 1) return\n    }\n}"
        },
        {
            "code": "@Target(AnnotationTarget.CLASS)\nannotation class My\ndata class Pair(val a: Int, val b: Int)\nfun foo(): Int {\n    val (<!WRONG_ANNOTATION_TARGET!>@My<!> <!WRONG_MODIFIER_TARGET!>private<!> a, <!WRONG_ANNOTATION_TARGET!>@My<!> <!WRONG_MODIFIER_TARGET!>public<!> b) = Pair(12, 34)\n    return a + b\n}"
        },
        {
            "code": "// KT-9145\n\n@Target(AnnotationTarget.CLASS)\nannotation class Ann\n\nvar x: Int\n    get() = 1\n    set(<!WRONG_ANNOTATION_TARGET!>@Ann<!> <!WRONG_MODIFIER_TARGET!>private<!> <!UNUSED_PARAMETER!>x<!>) { }"
        },
        {
            "code": "@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Ann(val x: Int = 1)\n\ninline fun bar(block: () -> Int): Int = block()\n\nfun foo() {\n    bar() @Ann(1) @Ann(2) { 101 }\n    bar() @Ann(3) { 102 }\n\n    bar @Ann l1@ {\n        return@l1 103\n    }\n\n    bar @Ann(<!TYPE_MISMATCH!>\"\"<!>) {\n        104\n    }\n}\n"
        },
        {
            "code": "annotation class Ann\n\nclass C {\n    fun foo() {\n        class Local {\n            @Ann<!SYNTAX!><!>\n        }\n    }\n\n    @Ann<!SYNTAX!><!>\n}\n\n@Ann<!SYNTAX!><!>"
        },
        {
            "code": "class A {\n    <!WRONG_ANNOTATION_TARGET!>@ann<!> init {}\n    <!WRONG_ANNOTATION_TARGET!>@<!UNRESOLVED_REFERENCE!>aaa<!><!> init {}\n}\n\ninterface T {\n    <!WRONG_ANNOTATION_TARGET!>@ann<!> <!ANONYMOUS_INITIALIZER_IN_INTERFACE!>init<!> {}\n    <!WRONG_ANNOTATION_TARGET!>@<!UNRESOLVED_REFERENCE!>aaa<!><!> <!ANONYMOUS_INITIALIZER_IN_INTERFACE!>init<!> {}\n}\n\nannotation class ann\n"
        },
        {
            "code": "// SKIP_ERRORS_BEFORE\n\nannotation class X(val value: Y, val y: Y)\nannotation class Y()\n\n@X(<!ANNOTATION_USED_AS_ANNOTATION_ARGUMENT!>@Y()<!><!SYNTAX!><!>, y = Y())\nfun foo1() {\n}\n@X(<!ANNOTATION_USED_AS_ANNOTATION_ARGUMENT!>@Y()<!><!SYNTAX!><!>, y = <!ANNOTATION_USED_AS_ANNOTATION_ARGUMENT!>@Y()<!><!SYNTAX!><!>)\nfun foo2() {\n}\n"
        },
        {
            "code": "annotation <!DEPRECATED_JAVA_ANNOTATION!>@java.lang.Deprecated<!> class my\n"
        },
        {
            "code": "// FILE: A.kt\npackage foo.bar\n\nclass X\n\n// FILE: B.kt\n\npackage foo\n\nfun f() {\n    class Local1 {\n        fun g() : <!UNRESOLVED_REFERENCE!>bar<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>X<!>? = null\n    }\n    class Local2 {\n        fun g() : foo.bar.X? = null\n    }\n}\n"
        },
        {
            "code": "fun foo(d: Any?) {\n    if (d is String?) {\n        <!DEBUG_INFO_SMARTCAST!>d<!>!!\n        doString(<!DEBUG_INFO_SMARTCAST!>d<!>)\n    }\n}\n\nfun doString(s: String) = s"
        },
        {
            "code": "//KT-2195 error \"Only safe calls are allowed ...\" but it is function param (val)\npackage foo\n\nprivate fun <T> sendCommand(errorCallback: (()->Unit)? = null) {\n    if (errorCallback != null) {\n        <!DEBUG_INFO_SMARTCAST!>errorCallback<!>()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\nfun main() {\n    val a : Int? = null\n    val b : Int? = null\n    checkSubtype<Int>(a!!)\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!> + 2\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.plus(2)\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.plus(b!!)\n    2.plus(b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    2 + b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n\n    val c = 1\n    c<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n\n    val d : Any? = null\n\n    if (d != null) {\n        d<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n\n    // smart cast isn't needed, but is reported due to KT-4294\n    if (d is String) {\n        <!DEBUG_INFO_SMARTCAST!>d<!><!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n\n    if (d is String?) {\n        if (d != null) {\n            <!DEBUG_INFO_SMARTCAST!>d<!><!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n        }\n        if (d is String) {\n            <!DEBUG_INFO_SMARTCAST!>d<!><!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n        }\n    }\n\n    val <!UNUSED_VARIABLE!>f<!> : String = <!NI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>a<!><!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!><!>\n    checkSubtype<String>(<!NI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>a<!><!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!><!>)\n}"
        },
        {
            "code": "//KT-2109 Nullability inference fails in extension function\npackage kt2109\n\nclass A {\n    fun foo() {}\n}\n\nfun A?.bar() {\n    if (this == null) {\n        return\n    }\n    <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>foo<!>()\n}\n\nfun A.baz() {\n    if (<!SENSELESS_COMPARISON!>this == null<!>) {\n        return\n    }\n    foo()\n}\n"
        },
        {
            "code": "class A {\n    fun foo() {}\n}\n\nfun A.bar() {}\nfun A?.buzz() {}\n\nfun test(a : A?) {\n    a<!UNSAFE_CALL!>.<!>foo() // error\n    a<!UNSAFE_CALL!>.<!>bar() // error\n    a.buzz()\n\n    a?.foo()\n    a?.bar()\n    a?.buzz()\n}\n\nfun A.test2() {\n    foo()\n    bar()\n    buzz()\n\n    this.foo()\n    this.bar()\n    this.buzz()\n\n    this<!UNNECESSARY_SAFE_CALL!>?.<!>foo() // warning\n    this<!UNNECESSARY_SAFE_CALL!>?.<!>bar() // warning\n    this<!UNNECESSARY_SAFE_CALL!>?.<!>buzz() // warning\n}\n\nfun A?.test3() {\n    <!UNSAFE_CALL!>foo<!>() // error\n    <!UNSAFE_CALL!>bar<!>() // error\n    buzz()\n\n    this<!UNSAFE_CALL!>.<!>foo() // error\n    this<!UNSAFE_CALL!>.<!>bar() // error\n    this.buzz()\n\n    this?.foo()\n    this?.bar()\n    this?.buzz()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A {\n    fun f(x: Boolean): Int = 0\n\n    fun f(y: String): Int = 0\n}\n\nclass B {\n    private var a: A? = null\n\n    fun takeInt(i: Int) {}\n\n    fun f() {\n        a = A()\n        <!SMARTCAST_IMPOSSIBLE!>a<!>.f(true)\n        takeInt(<!SMARTCAST_IMPOSSIBLE!>a<!>.f(\"\"))\n        a.<!NONE_APPLICABLE!>f<!>()\n    }\n\n    fun g() {\n        takeInt(if (3 > 2) {\n            a = A()\n            <!SMARTCAST_IMPOSSIBLE!>a<!>.f(true)\n        } else {\n            6\n        })\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -SENSELESS_COMPARISON, -DEBUG_INFO_SMARTCAST\n\nfun takeNotNull(s: String) {}\nfun <T> notNull(): T = TODO()\nfun <T> nullable(): T? = null\nfun <T> dependOn(x: T) = x\n\nfun test() {\n    takeNotNull(notNull()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    takeNotNull(nullable()!!)\n\n    var x: String? = null\n    takeNotNull(dependOn(x)!!)\n    takeNotNull(dependOn(dependOn(x))!!)\n    takeNotNull(dependOn(dependOn(x)!!))\n    takeNotNull(dependOn(dependOn(x!!)))\n\n    if (x != null) {\n        takeNotNull(dependOn(x)<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n        takeNotNull(dependOn(dependOn(x))<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n        takeNotNull(dependOn(dependOn(x)<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>))\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\npackage d\n\nfun bar() {\n    val i: Int? = 42\n    if (i != null) {\n        <!OVERLOAD_RESOLUTION_AMBIGUITY!>doSmth1<!> {\n        val x = <!DEBUG_INFO_SMARTCAST!>i<!> + 1\n    }\n}\n}\n\nfun doSmth1(f: ()->Unit) {}\nfun doSmth1(g: (Int)->Unit) {}"
        },
        {
            "code": "//KT-1680 Warn if non-null variable is compared to null\npackage kt1680\n\nfun foo() {\n    val x = 1\n    if (<!SENSELESS_COMPARISON!>x != null<!>) {} // <-- need a warning here!\n    if (<!SENSELESS_COMPARISON!>x == null<!>) {}\n    if (<!SENSELESS_COMPARISON!>null != x<!>) {}\n    if (<!SENSELESS_COMPARISON!>null == x<!>) {}\n\n    val y : Int? = 1\n    if (y != null) {}\n    if (y == null) {}\n}"
        },
        {
            "code": "fun foo(b: Boolean?, c: Boolean) {\n    if (b != null && <!DEBUG_INFO_SMARTCAST!>b<!>) {}\n    if (b == null || <!DEBUG_INFO_SMARTCAST!>b<!>) {}\n    if (b != null) {\n        if (<!DEBUG_INFO_SMARTCAST!>b<!> && c) {}\n        if (<!DEBUG_INFO_SMARTCAST!>b<!> || c) {}\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-2176 non-nullability is not inferred after !! or \"as\"\npackage kt2176\n\nfun f1(a: String?) {\n    a!!\n    checkSubtype<String>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun f2(a: String) {\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    checkSubtype<String>(a)\n}\n\nfun f3(a: Any?) {\n    a as String\n    checkSubtype<String>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun f4(a: Any) {\n    a as String\n    checkSubtype<String>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun f5(a: String) {\n    a <!USELESS_CAST!>as Any?<!>\n    checkSubtype<String>(a)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A() {\n    operator infix fun plus(<!UNUSED_PARAMETER!>i<!> : Int) {}\n    operator fun unaryMinus() {}\n    operator infix fun contains(<!UNUSED_PARAMETER!>a<!> : Any?) : Boolean = true\n}\n\noperator infix fun A.div(<!UNUSED_PARAMETER!>i<!> : Int) {}\noperator infix fun A?.times(<!UNUSED_PARAMETER!>i<!> : Int) {}\n\nfun test(x : Int?, a : A?) {\n    x<!UNSAFE_CALL!>.<!>plus(1)\n    x?.plus(1)\n    x <!UNSAFE_OPERATOR_CALL!>+<!> 1\n    <!UNSAFE_CALL!>-<!>x\n    x<!UNSAFE_CALL!>.<!>unaryMinus()\n    x?.unaryMinus()\n\n    a<!UNSAFE_CALL!>.<!>plus(1)\n    a?.plus(1)\n    a <!UNSAFE_INFIX_CALL!>plus<!> 1\n    a <!UNSAFE_OPERATOR_CALL!>+<!> 1\n    <!UNSAFE_CALL!>-<!>a\n    a<!UNSAFE_CALL!>.<!>unaryMinus()\n    a?.unaryMinus()\n\n    a<!UNSAFE_CALL!>.<!>div(1)\n    a <!UNSAFE_OPERATOR_CALL!>/<!> 1\n    a <!UNSAFE_INFIX_CALL!>div<!> 1\n    a?.div(1)\n\n    a.times(1)\n    a * 1\n    a times 1\n    a?.times(1)\n\n    1 <!UNSAFE_OPERATOR_CALL!>in<!> a\n    a <!UNSAFE_INFIX_CALL!>contains<!> 1\n    a<!UNSAFE_CALL!>.<!>contains(1)\n    a?.contains(1)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\npackage a\n\n//KT-2234 'period!!' has type Int?\n\nclass Pair<A, B>(val a: A, val b: B)\n\nfun main() {\n    val d : Long = 1\n    val period : Int? = null\n    if (period != null) Pair(d, checkSubtype<Int>(period<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)) else Pair(d, 1)\n    if (period != null) Pair(d, checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>period<!>)) else Pair(d, 1)\n}\n\nfun foo() {\n    val x : Int? = 3\n    if (x != null)  {\n        val <!UNUSED_VARIABLE!>u<!> = checkSubtype<Int>(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n        val y = checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        val <!UNUSED_VARIABLE!>z<!> : Int = y\n    }\n}\n"
        },
        {
            "code": "//KT-2223 Comparing non-null value with null might produce helpful warning\npackage kt2223\n\nfun foo() {\n    val x: Int? = null\n    if (x == null) return\n    if (<!SENSELESS_COMPARISON!>x == null<!>) return\n}\n"
        },
        {
            "code": "// FILE: this.kt\n\n// KT-362 Don't allow.smartcasts on vals that are not internal\npackage example\n\nfun test() {\n  val p = test.Public()\n  if (p.public is Int) <!DEBUG_INFO_SMARTCAST!>p.public<!> + 1\n  if (p.<!INVISIBLE_MEMBER!>protected<!> is Int) <!DEBUG_INFO_SMARTCAST!>p.<!INVISIBLE_MEMBER!>protected<!><!> + 1\n  if (p.internal is Int) <!DEBUG_INFO_SMARTCAST!>p.internal<!> + 1\n  val i = test.Internal()\n  if (i.public is Int) <!DEBUG_INFO_SMARTCAST!>i.public<!> + 1\n  if (i.<!INVISIBLE_MEMBER!>protected<!> is Int) <!DEBUG_INFO_SMARTCAST!>i.<!INVISIBLE_MEMBER!>protected<!><!> + 1\n  if (i.internal is Int) <!DEBUG_INFO_SMARTCAST!>i.internal<!> + 1\n}\n\n// FILE: other.kt\npackage test\n\npublic class Public() {\n    public val public : Int? = 1;\n    protected val protected : Int? = 1;\n    val internal : Int? = 1\n}\ninternal class Internal() {\n    public val public : Int? = 1;\n    protected val protected : Int? = 1;\n    val internal : Int? = 1\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\nclass Foo {\n    fun foo(a: Foo): Foo = a\n}\n\nfun main() {\n    val x: Foo? = null\n    val y: Foo? = null\n    \n    x<!UNSAFE_CALL!>.<!>foo(<!TYPE_MISMATCH!>y<!>)\n    x!!.foo(<!TYPE_MISMATCH!>y<!>)\n    x.foo(y!!)\n    x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(y<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    \n    val a: Foo? = null\n    val b: Foo? = null\n    val c: Foo? = null\n    \n    a<!UNSAFE_CALL!>.<!>foo(b<!UNSAFE_CALL!>.<!>foo(<!TYPE_MISMATCH!>c<!>))\n    a!!.foo(b<!UNSAFE_CALL!>.<!>foo(<!TYPE_MISMATCH!>c<!>))\n    a.foo(b!!.foo(<!TYPE_MISMATCH!>c<!>))\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(<!TYPE_MISMATCH!>c<!>))\n    a.foo(b.foo(c!!))\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(b.foo(c<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>))\n    a.foo(b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(c<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>))\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.foo(c<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>))\n    \n    val z: Foo? = null\n    z!!.foo(z<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n}\n"
        },
        {
            "code": "package kt244\n\n\n// KT-244 Use dataflow info while resolving variable initializers\n\nfun f(s: String?) {\n    if (s != null) {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length  //ok\n        var <!UNUSED_VARIABLE!>i<!> = <!DEBUG_INFO_SMARTCAST!>s<!>.length //error: Only safe calls are allowed on a nullable receiver\n        System.out.println(<!DEBUG_INFO_SMARTCAST!>s<!>.length) //error\n    }\n}\n\n// more tests\nclass A(a: String?) {\n    val b = if (a != null) <!DEBUG_INFO_SMARTCAST!>a<!>.length else 1\n    init {\n        if (a != null) {\n            val <!UNUSED_VARIABLE!>c<!> = <!DEBUG_INFO_SMARTCAST!>a<!>.length\n        }\n    }\n\n    val i : Int\n\n    init {\n        if (a is String) {\n            i = <!DEBUG_INFO_SMARTCAST!>a<!>.length\n        }\n        else {\n            i = 3\n        }\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n//KT-1778 Automatically cast error\npackage kt1778\n\nfun main(args : Array<String>) {\n    val x = checkSubtype<Any>(args[0])\n    if(x is <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.CharSequence<!>) {\n        if (\"a\" == x) <!DEBUG_INFO_SMARTCAST!>x<!>.length else <!DEBUG_INFO_SMARTCAST!>x<!>.length() // OK\n        if (\"a\" == x || \"b\" == x) <!DEBUG_INFO_SMARTCAST!>x<!>.length else <!DEBUG_INFO_SMARTCAST!>x<!>.length() // < THEN ERROR\n        if (\"a\" == x && \"a\" == x) <!DEBUG_INFO_SMARTCAST!>x<!>.length else <!DEBUG_INFO_SMARTCAST!>x<!>.length() // < ELSE ERROR\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-2164 !! does not propagate nullability information\npackage kt2164\n\nfun foo(x: Int): Int = x + 1\n\nfun main() {\n    val x: Int? = null\n\n    foo(<!TYPE_MISMATCH!>x<!>)\n\n    if (x != null) {\n        foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        foo(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n        foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n\n    foo(<!TYPE_MISMATCH!>x<!>)\n\n    if (x != null) {\n        foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        foo(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n        foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    } else {\n        foo(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>)\n        <!UNREACHABLE_CODE!>foo(<!><!ALWAYS_NULL!>x<!>!!<!UNREACHABLE_CODE!>)<!>\n        <!UNREACHABLE_CODE!>foo(<!DEBUG_INFO_SMARTCAST!>x<!>)<!>\n    }\n\n    foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    foo(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    \n    val y: Int? = null\n    y!!\n    y<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    foo(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    foo(y<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// !LANGUAGE: +NewInference\n// Issue: KT-30734\n\nclass Sample {\n    fun foo(): Boolean = true\n}\n\nfun test(ls: Sample?) {\n    val filter: () -> Boolean = if (ls == null) {\n        { false }\n    } else {\n        { <!DEBUG_INFO_SMARTCAST!>ls<!>.foo() } // OK in OI, error in NI\n    }\n}"
        },
        {
            "code": "fun test(a: Any?) {\n    if (a != null) {\n        <!DEBUG_INFO_SMARTCAST!>a<!>.foo(11)\n    }\n}\n\nfun <T> Any.foo(t: T) = t"
        },
        {
            "code": "// The type checker used to think that T is not null no matter what the upper bound\n\nfun <T, INDIRECT: T> nullableUpperBound(t: T, ind: INDIRECT) {\n    if (t == null) {} // was a warning\n    if (t != null) {}  // was a warning\n    if (ind == null) {}  // was a warning\n    if (ind != null) {}  // was a warning\n}\n\nfun <T: Any, INDIRECT: T> notNullUpperBound(t: T, ind: INDIRECT) {\n    if (<!SENSELESS_COMPARISON!>t == null<!>) {} // still a warning\n    if (<!SENSELESS_COMPARISON!>t != null<!>) {} // still a warning\n    if (<!SENSELESS_COMPARISON!>ind == null<!>) {} // still a warning\n    if (<!SENSELESS_COMPARISON!>ind != null<!>) {} // still a warning\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\n//KT-2216 Nullability of a value determined in function parameter computation doesn't pass to code following\npackage kt2216\n\nfun bar(y: Int, z: Int) = y + z\nfun baz(a: Int, b: Int, c: Int, d: Int) = a + b + c + d\n\nfun foo() {\n    val x: Int? = 0\n\n    bar(if (x != null) x else return, x)\n    x + 2\n    bar(x, x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n\n    val y: Int? = 0\n    val z: Int? = 0\n    bar(<!NI;TYPE_MISMATCH!>if (y != null) y else <!OI;TYPE_MISMATCH!>z<!><!>, <!TYPE_MISMATCH!>y<!>)\n    y <!UNSAFE_OPERATOR_CALL!>+<!> 2\n    baz(<!TYPE_MISMATCH!>y<!>, <!TYPE_MISMATCH!>y<!>, if (y == null) return else y, y)\n    baz(y, z!!, z, y)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Ctx\nclass CtxImpl : Ctx {\n    fun doJob(a: Int) {}\n    fun doJob(s: String) {}\n}\n\nopen class Test(open val ctx: Ctx) {\n    fun test() {\n        when (ctx) {\n            is CtxImpl -> <!SMARTCAST_IMPOSSIBLE!>ctx<!>.doJob(2)\n        }\n    }\n}"
        },
        {
            "code": "//KT-2125 Inconsistent error message on UNSAFE_CALL\n\npackage e\n\nfun main() {\n    val <!UNUSED_VARIABLE!>compareTo<!> = 1\n    val s: String? = null\n    s<!UNSAFE_CALL!>.<!>compareTo(\"\")\n\n    val <!UNUSED_VARIABLE!>bar<!> = 2\n    s.<!UNRESOLVED_REFERENCE!>bar<!>()\n}\n"
        },
        {
            "code": "package a\n\nfun foo() {\n    val i : Int? = 42\n    if (i != null) {\n        <!UNRESOLVED_REFERENCE!>doSmth<!> {\n            val <!UNUSED_VARIABLE!>x<!> = <!DEBUG_INFO_SMARTCAST!>i<!> + 1\n        }\n    }\n}"
        },
        {
            "code": "package a\n\nfun foo() {\n    bar()!!\n}\n\nfun bar() = <!UNRESOLVED_REFERENCE!>aa<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A\nclass B\n\nfun A.foo(a: A) {}\nfun A.foo(b: B) {}\nvar a: A? = null\n\nfun smartCastInterference(b: B) {\n    if (a != null) {\n        <!SMARTCAST_IMPOSSIBLE!>a<!>.foo(b)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n//KT-1270 Poor highlighting when trying to dereference a nullable reference\n\npackage kt1270\n\nfun foo() {\n    val sc = java.util.HashMap<String, SomeClass>()[\"\"]\n    val value = sc<!UNSAFE_CALL!>.<!>value\n}\n\nprivate class SomeClass() {\n    val value : Int = 5\n}\n"
        },
        {
            "code": "//KT-2212 Incomplete nullability information\npackage kt2212\n\nfun main() {\n    val x: Int? = 1\n    if (x == null) return\n    System.out.println(<!DEBUG_INFO_SMARTCAST!>x<!>.plus(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>))\n}\n"
        },
        {
            "code": "fun test() {\n  val out : Int? = null\n  val x : Nothing? = null\n  if (out != <!DEBUG_INFO_CONSTANT!>x<!>)\n    <!DEBUG_INFO_SMARTCAST!>out<!>.plus(1)\n  if (out == <!DEBUG_INFO_CONSTANT!>x<!>) return\n  <!DEBUG_INFO_SMARTCAST!>out<!>.plus(1)\n}\n"
        },
        {
            "code": "fun main() {\n    val b: Boolean? = null\n    if (b != null) {\n        if (!<!DEBUG_INFO_SMARTCAST!>b<!>) {} // OK\n        if (<!DEBUG_INFO_SMARTCAST!>b<!>) {} // Error: Condition must be of type kotlin.Boolean, but is of type kotlin.Boolean?\n        if (b<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>) {} // WARN: Unnecessary non-null assertion (!!) on a non-null receiver of type kotlin.Boolean?\n        foo(<!DEBUG_INFO_SMARTCAST!>b<!>) // OK\n    }\n}\n\nfun foo(a: Boolean) = a\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-2146 Nullability casts in when.\npackage kt2146\n\nfun f1(s: Int?): Int {\n    return when (s) {\n        null -> 3\n        else -> <!DEBUG_INFO_SMARTCAST!>s<!>\n    }\n}\n\nfun f2(s: Int?): Int {\n    return <!NI;TYPE_MISMATCH!>when (s) {\n        !is Int -> <!OI;TYPE_MISMATCH!>s<!>\n        else -> <!DEBUG_INFO_SMARTCAST!>s<!>\n    }<!>\n}\n\nfun f3(s: Int?): Int {\n    return <!NI;TYPE_MISMATCH!>when (s) {\n        is Int -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> <!OI;TYPE_MISMATCH!>s<!>\n    }<!>\n}\n\nfun f4(s: Int?): Int {\n    return <!NI;TYPE_MISMATCH!>when {\n        s == 4 -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        s == null -> <!DEBUG_INFO_CONSTANT, OI;TYPE_MISMATCH!>s<!>\n        else -> <!DEBUG_INFO_SMARTCAST!>s<!>\n    }<!>\n}\n\nfun f5(s: Int?): Int {\n    return <!NI;TYPE_MISMATCH!>when (s) {\n        s -> <!OI;TYPE_MISMATCH!>s<!>\n        s!! -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        s -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> 0\n    }<!>\n}\n\nfun f6(s: Int?): Int {\n    return <!NI;TYPE_MISMATCH!>when {\n        s is Int -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        else -> <!OI;TYPE_MISMATCH!>s<!>\n    }<!>\n}\n\nfun f7(s: Int?): Int {\n    return <!NI;TYPE_MISMATCH!>when {\n        s !is Int -> <!OI;TYPE_MISMATCH!>s<!>\n        else -> <!DEBUG_INFO_SMARTCAST!>s<!>\n    }<!>\n}\n"
        },
        {
            "code": "// FILE: test.kt\nfun <T : Any> test() {\n    var value: T? = null\n    if (value == null) {\n        value = JClass.getNotNullT()\n    }\n\n    <!DEBUG_INFO_SMARTCAST!>value<!>.hashCode() // unsafe call error\n}"
        },
        {
            "code": "//KT-2457 Verify error when comparing not null value with null in when\n\npackage kt2457\n\nfun foo(i: Int) : Int =\n    when (i) {\n        1 -> 1\n        <!SENSELESS_NULL_IN_WHEN!>null<!> -> 1\n        else -> 1\n    }\n"
        },
        {
            "code": "// FILE: use.kt\n\nfun use(a: A, b: B, c: C) {\n    a.<!DEPRECATION!>f<!>()\n    b.f()\n    c.<!DEPRECATION!>f<!>()\n\n    A.<!DEPRECATION!>D<!>\n    B.D\n    C.<!DEPRECATION!>D<!>\n\n    A.<!DEPRECATION!>bar<!>()\n    B.bar()\n    C.<!DEPRECATION!>bar<!>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nclass PropertyHolder {\n    @Deprecated(\"\")\n    val a1 = 1\n\n    @property:Deprecated(\"\")\n    var a2 = \"\"\n\n    @get:Deprecated(\"\")\n    public val withGetter: String = \"\"\n\n    @set:Deprecated(\"\")\n    public var withSetter: String = \"\"\n}\n\nfun fn() {\n    val holder = PropertyHolder()\n\n    holder.<!DEPRECATION!>a1<!>\n    holder.<!DEPRECATION!>a2<!>\n    holder.<!DEPRECATION!>withGetter<!>\n    holder.<!DEPRECATION!>withSetter<!> = \"A\"\n}\n\nfun literals() {\n    PropertyHolder::<!DEPRECATION!>a1<!>\n    PropertyHolder::<!DEPRECATION!>a2<!>\n    PropertyHolder::withGetter\n    PropertyHolder::withSetter\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n@Deprecated(\"alas\", level = DeprecationLevel.ERROR)\nfun foo() {}\n\n@Deprecated(\"alas\", level = DeprecationLevel.ERROR)\nclass C\n\nfun test(c: <!DEPRECATION_ERROR!>C<!>) {\n    <!DEPRECATION_ERROR!>foo<!>()\n    <!DEPRECATION_ERROR!>C<!>()\n}"
        },
        {
            "code": "class Iter {\n    @Deprecated(\"text\")\n    operator fun iterator() : IterIterator = throw Exception()\n\n    class IterIterator {\n        operator fun hasNext(): Boolean = throw UnsupportedOperationException()\n        operator fun next(): String = throw UnsupportedOperationException()\n    }\n}\n\nclass Iter2 {\n    operator fun iterator() : Iter2Iterator = throw Exception()\n    class Iter2Iterator {\n        @Deprecated(\"text\")\n        operator fun hasNext(): Boolean = throw UnsupportedOperationException()\n        @Deprecated(\"text\")\n        operator fun next(): String = throw UnsupportedOperationException()\n    }\n}\n\nfun use() {\n    for (x in <!DEPRECATION!>Iter()<!>) {}\n    for (x in <!DEPRECATION, DEPRECATION!>Iter2()<!>) {}\n}\n"
        },
        {
            "code": "@Deprecated(\"No\")\nval f: () -> Unit = {}\n\nfun test() {\n    <!DEPRECATION!>f<!>()\n}\n"
        },
        {
            "code": "package foo\n\ninterface HiddenDeprecated {\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    var p: Int\n}\n\ninterface NoDeprecation {\n    var p: Int\n}\n\n\nopen class WarningDeprecated {\n    @Deprecated(\"\", level = DeprecationLevel.WARNING)\n    open var p: Int = 3\n}\n\nopen class ErrorDeprecated {\n    @Deprecated(\"\", level = DeprecationLevel.ERROR)\n    open var p: Int = 3\n}\n\nopen class GetterDeprecated {\n    open var p: Int = 3\n        @Deprecated(\"\") get\n}\n\nopen class SetterDeprecated {\n    open var p: Int = 3\n        @Deprecated(\"\") set\n}\n\nclass WD: WarningDeprecated() {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nclass ED: ErrorDeprecated() {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {\n        }\n}\n\nclass GD: GetterDeprecated() {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {\n        }\n}\n\nclass SD: SetterDeprecated() {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {\n        }\n}\n\nclass SDH: SetterDeprecated(), HiddenDeprecated {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {\n        }\n}\n\nclass EDH: ErrorDeprecated(), HiddenDeprecated {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {\n        }\n}\n\nclass NED: ErrorDeprecated(), NoDeprecation {\n    override var p: Int\n        get() = 3\n        set(<!UNUSED_PARAMETER!>value<!>) {\n        }\n}\n\nclass Diff {\n    @Deprecated(\"\", level = DeprecationLevel.WARNING)\n    var p: Int\n        @Deprecated(\"\", level = DeprecationLevel.ERROR) get() = 3\n        @Deprecated(\"\", level = DeprecationLevel.HIDDEN) set(<!UNUSED_PARAMETER!>value<!>) {\n\n        }\n}\n\nfun use(\n        warningDeprecated: WarningDeprecated, errorDeprecated: ErrorDeprecated, setterDeprecated: SetterDeprecated,\n        getterDeprecated: GetterDeprecated, hiddenDeprecated: HiddenDeprecated,\n        wd: WD, ed: ED, gd: GD, sd: SD,\n        sdh: SDH, edh: EDH, ned: NED,\n        diff: Diff\n) {\n    warningDeprecated.<!DEPRECATION!>p<!>\n    warningDeprecated.<!DEPRECATION!>p<!> = 1\n\n    errorDeprecated.<!DEPRECATION_ERROR!>p<!>\n    errorDeprecated.<!DEPRECATION_ERROR!>p<!> = 1\n\n    getterDeprecated.<!DEPRECATION!>p<!>\n    getterDeprecated.p = 1\n\n    setterDeprecated.p\n    setterDeprecated.<!DEPRECATION!>p<!> = 1\n\n    hiddenDeprecated.<!UNRESOLVED_REFERENCE!>p<!>\n    hiddenDeprecated.<!UNRESOLVED_REFERENCE!>p<!> = 1\n\n    wd.<!DEPRECATION!>p<!>\n    wd.<!DEPRECATION!>p<!> = 1\n\n    ed.<!DEPRECATION_ERROR!>p<!>\n    ed.<!DEPRECATION_ERROR!>p<!> = 1\n\n    gd.<!DEPRECATION!>p<!>\n    gd.p = 1\n\n    sd.p\n    sd.<!DEPRECATION!>p<!> = 1\n\n    sdh.p\n    sdh.<!DEPRECATION!>p<!> = 1\n\n    edh.<!DEPRECATION_ERROR!>p<!>\n    edh.<!DEPRECATION_ERROR!>p<!> = 1\n\n    ned.p\n    ned.p = 1\n\n    diff.<!DEPRECATION!>p<!>\n    diff.<!DEPRECATION, DEPRECATION_ERROR!>p<!> = 1\n}"
        },
        {
            "code": "val v1: String\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    get() = \"\"\n\n@Deprecated(\"\", level = DeprecationLevel.HIDDEN)\nval v2 = \"\"\n\nvar v3: String\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\nvar v4: String\n    get() = \"\"\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\nvar v5: String\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    get() = \"\"\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\n@Deprecated(\"\", level = DeprecationLevel.HIDDEN)\nvar v6: String\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\nfun test() {\n    <!DEPRECATION_ERROR!>v1<!>\n    <!UNRESOLVED_REFERENCE!>v2<!>\n    <!DEPRECATION_ERROR!>v3<!>\n    v3 = \"\"\n    v4\n    <!DEPRECATION_ERROR!>v4<!> = \"\"\n    <!DEPRECATION_ERROR!>v5<!>\n    <!DEPRECATION_ERROR!>v5<!> = \"\"\n    <!UNRESOLVED_REFERENCE!>v6<!>\n    <!UNRESOLVED_REFERENCE!>v6<!> = \"\"\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n@Deprecated(\"\", level = DeprecationLevel.HIDDEN)\nopen class Foo\n\nfun test(f: <!DEPRECATION_ERROR!>Foo<!>) {\n    f.toString()\n    val g: <!DEPRECATION_ERROR!>Foo<!>? = <!DEPRECATION_ERROR!>Foo<!>()\n}\n\nclass Bar : <!DEPRECATION_ERROR!>Foo<!>()\n"
        },
        {
            "code": "// SKIP_TXT\n// FILE: test/J.java\n\npackage test;\n\n@Deprecated\npublic interface J {\n    public String foo(int x);\n}\n\n// FILE: K.kt\n\nimport test.<!DEPRECATION!>J<!>\n"
        },
        {
            "code": "@Deprecated(\"\")\nclass Foo\n\n@Deprecated(\"\", level = DeprecationLevel.ERROR)\nclass Err\n\ntypealias Test1 = <!DEPRECATION!>Foo<!>\ntypealias Test2 = List<<!DEPRECATION!>Foo<!>>\ntypealias Test3 = List<<!TYPEALIAS_EXPANSION_DEPRECATION!>Test2<!>>\n\ntypealias TestErr1 = <!DEPRECATION_ERROR!>Err<!>\ntypealias TestErr2 = List<<!DEPRECATION_ERROR!>Err<!>>\ntypealias TestErr3 = List<<!TYPEALIAS_EXPANSION_DEPRECATION_ERROR!>TestErr2<!>>\n\nfun use1(b: <!TYPEALIAS_EXPANSION_DEPRECATION!>Test1<!>) = b\nfun use2(b: <!TYPEALIAS_EXPANSION_DEPRECATION!>Test2<!>) = b\nfun use3(b: <!TYPEALIAS_EXPANSION_DEPRECATION!>Test3<!>) = b\n\nfun useErr1(b: <!TYPEALIAS_EXPANSION_DEPRECATION_ERROR!>TestErr1<!>) = b\nfun useErr2(b: <!TYPEALIAS_EXPANSION_DEPRECATION_ERROR!>TestErr2<!>) = b\nfun useErr3(b: <!TYPEALIAS_EXPANSION_DEPRECATION_ERROR!>TestErr3<!>) = b"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nimport kotlin.reflect.KProperty\n\nclass UsefulClass(val param: Int = 2) {\n    operator fun getValue(instance: Any, property: KProperty<*>) : Int = 1\n    operator fun setValue(instance: Any, property: KProperty<*>, value: Int) {}\n\n    @Deprecated(\"message\")\n    fun member() {}\n}\n\n@Deprecated(\"message\")\nfun Obsolete(param: Int = 1): UsefulClass = UsefulClass(param)\n\nclass Invocable {\n    @Deprecated(\"message\")\n    operator fun invoke() {}\n}\n\nobject InvocableHolder {\n    val invocable = Invocable()\n}\n\nfun invoker() {\n    val invocable = Invocable()\n    <!DEPRECATION!>invocable<!>()\n    InvocableHolder.<!DEPRECATION!>invocable<!>()\n}\n\nfun block() {\n    <!DEPRECATION!>Obsolete<!>()\n    <!DEPRECATION!>Obsolete<!>(2)\n}\n\nfun expression() = <!DEPRECATION!>Obsolete<!>()\n\nfun reflection() = ::<!DEPRECATION!>Obsolete<!>\nfun reflection2() = UsefulClass::<!DEPRECATION!>member<!>\n\nclass Initializer {\n    val x = <!DEPRECATION!>Obsolete<!>()\n}\n\n@Deprecated(\"does nothing good\")\nfun Any.doNothing() = this.toString()  // \"this\" should not be marked as deprecated despite it referes to deprecated function\n\nclass Delegation {\n    val x by <!DEPRECATION!>Obsolete<!>()\n    var y by <!DEPRECATION!>Obsolete<!>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: A.kt\nclass A(s: String) {\n    @Deprecated(\"\")\n    constructor(i: Int) : this(i.toString()) {\n\n    }\n}\n\n// FILE: C.kt\nclass C @Deprecated(\"\") constructor(s: String) {\n}\n\n// FILE: use.kt\nfun use(a: A, b: B, c: C) {\n    <!DEPRECATION!>A<!>(3)\n    A(\"\")\n    <!DEPRECATION!>B<!>(3)\n    B(\"\")\n    <!DEPRECATION!>C<!>(\"s\")\n}\n"
        },
        {
            "code": "class TopLevel {\n    @Deprecated(\"Nested\")\n    class Nested {\n        companion object {\n            fun use() {}\n\n            class CompanionNested2\n        }\n\n        class Nested2\n    }\n}\n\nfun useNested() {\n    val <!UNUSED_VARIABLE!>d<!> = TopLevel.<!DEPRECATION!>Nested<!>.use()\n    TopLevel.<!DEPRECATION!>Nested<!>.Nested2()\n    TopLevel.<!DEPRECATION!>Nested<!>.<!UNRESOLVED_REFERENCE!>CompanionNested2<!>()\n}"
        },
        {
            "code": "@Deprecated(\"Class\")\nopen class Obsolete {\n    fun use() {}\n}\n\n@Deprecated(\"Class\")\nopen class Obsolete2 @Deprecated(\"Constructor\") constructor() {\n    fun use() {}\n}\n\ninterface Generic<T>\n\nopen class Derived() : <!DEPRECATION!>Obsolete<!>()\n\nclass Derived2() : Derived()\n\nclass TypeParam : Generic<<!DEPRECATION!>Obsolete<!>>\n\nobject Object : <!DEPRECATION!>Obsolete<!>()\n\nclass Properties {\n    val x : <!DEPRECATION!>Obsolete<!> = <!DEPRECATION!>Obsolete<!>()\n    var y : <!DEPRECATION!>Obsolete<!> = <!DEPRECATION!>Obsolete<!>()\n\n    var n : <!DEPRECATION!>Obsolete<!>\n        get() = <!DEPRECATION!>Obsolete<!>()\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nfun param(param: <!DEPRECATION!>Obsolete<!>) { param.use() }\n\nfun funcParamReceiver(param: <!DEPRECATION!>Obsolete<!>.()->Unit) { <!DEPRECATION!>Obsolete<!>().param() }\nfun funcParamParam(param: (<!DEPRECATION!>Obsolete<!>)->Unit) { param(<!DEPRECATION!>Obsolete<!>()) }\nfun funcParamRetVal(param: ()-><!DEPRECATION!>Obsolete<!>) { param() }\n\nfun <T: <!DEPRECATION!>Obsolete<!>> constraint() {}\n\nfun <!DEPRECATION!>Obsolete<!>.receiver() {}\n\nfun retVal(): <!DEPRECATION!>Obsolete<!> = <!DEPRECATION!>Obsolete<!>()\n\nfun nullableRetVal(): <!DEPRECATION!>Obsolete<!>? = null\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass Table\nclass Tr\n\nfun table(body: Table.() -> Unit) {}\nfun Table.tr(body: Tr.() -> Unit) {}\n@Deprecated(\"Don't call me\", level = DeprecationLevel.ERROR)\nfun Tr.tr(body: Tr.() -> Unit) {}\n\nfun builderTest() {\n    table {\n        tr {\n            <!DEPRECATION_ERROR!>tr<!> {}\n            table {\n                tr {\n                    <!DEPRECATION_ERROR!>tr<!> {}\n                }\n            }\n        }\n    }\n}"
        },
        {
            "code": "package foo\n\ninterface WarningDeprecated {\n    @Deprecated(\"\", level = DeprecationLevel.WARNING)\n    fun f() {\n\n    }\n}\n\ninterface ErrorDeprecated {\n    @Deprecated(\"\", level = DeprecationLevel.ERROR)\n    fun f() {\n\n    }\n}\n\ninterface HiddenDeprecated {\n    @Deprecated(\"\", level = DeprecationLevel.HIDDEN)\n    fun f() {\n\n    }\n}\n\ninterface NotDeprecated {\n    fun f() {\n\n    }\n}\n\nopen class WE : WarningDeprecated, ErrorDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class WH : WarningDeprecated, HiddenDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class EH : ErrorDeprecated, HiddenDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class NW : WarningDeprecated, NotDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class NE : ErrorDeprecated, NotDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class NH : HiddenDeprecated, NotDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class WEH: WarningDeprecated, ErrorDeprecated, HiddenDeprecated {\n    override fun f() {\n\n    }\n}\n\nopen class NWEH: NotDeprecated, WarningDeprecated, ErrorDeprecated, HiddenDeprecated {\n    override fun f() {\n\n    }\n}\n\nclass WE2: WE()\n\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class NWE2<!>: WE(), NotDeprecated\n\nclass NWE3: WE(), NotDeprecated {\n    override fun f() {\n    }\n}\n\ninterface E2: ErrorDeprecated\ninterface W2: WarningDeprecated\n\ninterface EW2: E2, W2 {\n    override fun f() {\n    }\n}\n\ninterface HEW2: EW2, HiddenDeprecated {\n    override fun f() {\n    }\n}\n\ninterface ExplicitError: HEW2 {\n    @Deprecated(\"\", level = DeprecationLevel.ERROR)\n    override fun f() {\n        super.<!DEPRECATION!>f<!>()\n    }\n}\n\nfun use(\n        wd: WarningDeprecated, ed: ErrorDeprecated, hd: HiddenDeprecated,\n        we: WE, wh: WH, eh: EH, nw: NW, ne: NE, nh: NH,\n        weh: WEH, nweh: NWEH,\n        we2: WE2, nwe2: NWE2, nwe3: NWE3,\n        e2: E2, w2: W2, ew2: EW2, hew2: HEW2,\n        explicitError: ExplicitError\n) {\n    wd.<!DEPRECATION!>f<!>()\n    ed.<!DEPRECATION_ERROR!>f<!>()\n    hd.<!UNRESOLVED_REFERENCE!>f<!>()\n\n    we.<!DEPRECATION!>f<!>()\n    wh.<!DEPRECATION!>f<!>()\n    eh.<!DEPRECATION_ERROR!>f<!>()\n\n    nw.f()\n    ne.f()\n    nh.f()\n\n    weh.<!DEPRECATION!>f<!>()\n    nweh.f()\n\n    we2.<!DEPRECATION!>f<!>()\n    nwe2.f()\n    nwe3.f()\n\n    e2.<!DEPRECATION_ERROR!>f<!>()\n    w2.<!DEPRECATION!>f<!>()\n    ew2.<!DEPRECATION!>f<!>()\n    hew2.<!DEPRECATION!>f<!>()\n\n    explicitError.<!DEPRECATION_ERROR!>f<!>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -NO_VALUE_FOR_PARAMETER\n// FILE: B.kt\n\nclass B(private val foo: String) : <!DEPRECATION!>A<!>() {\n    override fun getFoo(text: String): String = super.<!DEPRECATION!>getFoo<!>(text + foo)\n}\n"
        },
        {
            "code": "@Deprecated(\"Deprecated class\")\nopen class DeprecatedClass\n\nopen class WithDeprecatedCtor(val x: Int) {\n    @Deprecated(\"Deprecated constructor\")\n    constructor() : this(0)\n}\n\ntypealias DeprecatedClassAlias = <!DEPRECATION!>DeprecatedClass<!>\ntypealias WithDeprecatedCtorAlias = WithDeprecatedCtor\ntypealias ArrayListOfDeprecatedClass = ArrayList<<!DEPRECATION!>DeprecatedClass<!>>\n\nclass Test1 : <!TYPEALIAS_EXPANSION_DEPRECATION!>DeprecatedClassAlias<!>()\n\nclass Test2 : <!TYPEALIAS_EXPANSION_DEPRECATION!>WithDeprecatedCtorAlias<!>()\n\nval test3 = <!TYPEALIAS_EXPANSION_DEPRECATION!>ArrayListOfDeprecatedClass<!>()"
        },
        {
            "code": "@Deprecated(\"Object\")\nobject Obsolete {\n    fun use() {}\n}\n\nfun useObject() {\n    <!DEPRECATION!>Obsolete<!>.use()\n    val <!UNUSED_VARIABLE!>x<!> = <!DEPRECATION!>Obsolete<!>\n}\n"
        },
        {
            "code": "// KT-15245 Report deprecation on associated declarations if level is greater than the deprecation on the declaration itself\n\n@Deprecated(\"error\", level = DeprecationLevel.ERROR)\nclass Foo @Deprecated(\"warning\", level = DeprecationLevel.WARNING) constructor()\n\nfun test1() = <!DEPRECATION, DEPRECATION_ERROR!>Foo<!>()\n\nfun test2(): <!DEPRECATION_ERROR!>Foo<!> = <!DEPRECATION, DEPRECATION_ERROR!>Foo<!>()\n"
        },
        {
            "code": "import <!DEPRECATION!>C<!> as C2\n\n@Deprecated(\"obsolete\")\nclass C {\n    fun use() {}\n}\n\nfun useAlias(c : <!DEPRECATION!>C2<!>) { c.use() }\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nclass Data {\n    @Deprecated(\"text\")\n    operator fun component1(): String = throw Exception()\n    operator fun component2(): String = throw Exception()\n}\n\nfun use() {\n    val (<!DEPRECATION!>x<!>, y) = Data()\n}\n"
        },
        {
            "code": "class Another {\n    @Deprecated(\"Object\")\n    companion object {\n        fun use() {}\n        const val USE = 42\n    }\n}\n\nfun first() {\n    <!DEPRECATION!>Another<!>.use()\n    Another.<!DEPRECATION!>Companion<!>.USE\n    <!DEPRECATION!>Another<!>.USE\n}\n\nfun useCompanion() {\n    val <!UNUSED_VARIABLE!>d<!> = <!DEPRECATION!>Another<!>\n    val <!UNUSED_VARIABLE!>x<!> = Another.<!DEPRECATION!>Companion<!>\n    Another.<!DEPRECATION!>Companion<!>.use()\n    <!DEPRECATION!>Another<!>.use()\n}\n\n@Deprecated(\"Some\")\nclass Some {\n    companion object {\n        fun use() {}\n    }\n}\n\nfun some() {\n    <!DEPRECATION!>Some<!>.use()\n    <!DEPRECATION!>Some<!>.Companion.use()\n}\n"
        },
        {
            "code": "class Relevant {\n    companion object {\n        val value = \"\"\n    }\n}\n\n@Deprecated(\"Use Relevant\")\ntypealias Obsolete = Relevant\n\nfun test1() = <!DEPRECATION!>Obsolete<!>\nfun test2() = <!DEPRECATION!>Obsolete<!>.value\nfun test3() = <!DEPRECATION!>Obsolete<!>.toString()\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nimport kotlin.reflect.KProperty\n\nclass Delegate() {\n    @Deprecated(\"text\")\n    operator fun getValue(instance: Any, property: KProperty<*>) : Int = 1\n\n    @Deprecated(\"text\")\n    operator fun setValue(instance: Any, property: KProperty<*>, value: Int) {}\n}\n\nclass PropertyHolder {\n    @Deprecated(\"text\")\n    val x = 1\n\n    @Deprecated(\"text\")\n    var name = \"String\"\n\n    val valDelegate by <!DEPRECATION!>Delegate()<!>\n    var varDelegate by <!DEPRECATION, DEPRECATION!>Delegate()<!>\n\n    public val test1: String = \"\"\n        @Deprecated(\"val-getter\") get\n\n    public var test2: String = \"\"\n        @Deprecated(\"var-getter\") get\n        @Deprecated(\"var-setter\") set\n\n    public var test3: String = \"\"\n        @Deprecated(\"var-getter\") get\n        set\n\n    public var test4: String = \"\"\n        get\n        @Deprecated(\"var-setter\") set\n}\n\nfun PropertyHolder.extFunction() {\n    <!DEPRECATION!>test2<!> = \"ext\"\n    <!DEPRECATION!>test1<!>\n}\n\nfun fn() {\n    PropertyHolder().<!DEPRECATION!>test1<!>\n    PropertyHolder().<!DEPRECATION!>test2<!>\n    PropertyHolder().<!DEPRECATION!>test2<!> = \"\"\n\n    PropertyHolder().<!DEPRECATION!>test3<!>\n    PropertyHolder().test3 = \"\"\n\n    PropertyHolder().test4\n    PropertyHolder().<!DEPRECATION!>test4<!> = \"\"\n\n    val <!UNUSED_VARIABLE!>a<!> = PropertyHolder().<!DEPRECATION!>x<!>\n    val <!UNUSED_VARIABLE!>b<!> = PropertyHolder().<!DEPRECATION!>name<!>\n    PropertyHolder().<!DEPRECATION!>name<!> = \"value\"\n\n    val <!UNUSED_VARIABLE!>d<!> = PropertyHolder().valDelegate\n    PropertyHolder().varDelegate = 1\n}\n\nfun literals() {\n    PropertyHolder::test1\n    PropertyHolder::<!DEPRECATION!>name<!>\n}\n"
        },
        {
            "code": "@Deprecated(\"text\")\nannotation class obsolete()\n\n@Deprecated(\"text\")\nannotation class obsoleteWithParam(val text: String)\n\n@<!DEPRECATION!>obsolete<!> class Obsolete\n\n@<!DEPRECATION!>obsoleteWithParam<!>(\"text\") class Obsolete2\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NO_VALUE_FOR_PARAMETER\n// FILE: B.kt\n\nclass B(private @property:Deprecated val foo: String) : <!DEPRECATION!>A<!>() {\n    override fun getFoo(text: String): String = super.<!DEPRECATION!>getFoo<!>(text + <!DEPRECATION!>foo<!>)\n}\n"
        },
        {
            "code": "open class Base {\n    companion object\n}\ninterface IFoo\nopen class CG<T>\ninterface IG<T>\n\n@Deprecated(\"Obsolete\")\ntypealias Obsolete = Base\n\n@Deprecated(\"Obsolete\")\ntypealias IObsolete = IFoo\n\nfun test1(x: <!DEPRECATION!>Obsolete<!>) = x\nfun test1a(x: List<<!DEPRECATION!>Obsolete<!>>) = x\n\nval test2 = <!DEPRECATION!>Obsolete<!>()\n\nval test3 = <!DEPRECATION!>Obsolete<!>\n\nclass Test4: <!DEPRECATION!>Obsolete<!>()\nclass Test4a: <!DEPRECATION!>IObsolete<!>\nclass Test4b: IG<<!DEPRECATION!>Obsolete<!>>\nclass Test4c: CG<<!DEPRECATION!>Obsolete<!>>()"
        },
        {
            "code": "// FILE: A.kt\n\npackage test\n\n@Deprecated(\"A\")\ninterface A\n\n// FILE: B.kt\n\nimport test.<!DEPRECATION!>A<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION, -UNUSED_PARAMETER\n\nopen class C<T>() {\n    @Deprecated(\"\")\n    constructor(p: Int) : this(){}\n}\n\nclass D : <!DEPRECATION!>C<String><!>(1)\n"
        },
        {
            "code": "// !DIAGNOSTICS: -MISSING_CONSTRUCTOR_KEYWORD\n\nclass C(val a: String) {}\n\ninterface T1<!CONSTRUCTOR_IN_INTERFACE!>(val x: String)<!> {}\n\ninterface T2 <!CONSTRUCTOR_IN_INTERFACE!>constructor()<!> {}\n\ninterface T3 private <!CONSTRUCTOR_IN_INTERFACE!>constructor(<!UNUSED_PARAMETER!>a<!>: Int)<!> {}\n\ninterface T4 {\n    <!CONSTRUCTOR_IN_INTERFACE!>constructor(<!UNUSED_PARAMETER!>a<!>: Int)<!> {\n        val <!UNUSED_VARIABLE!>b<!>: Int = 1\n    }\n}\n\ninterface T5 private <!CONSTRUCTOR_IN_INTERFACE!>()<!> : T4 {}\ninterface T6 <!CONSTRUCTOR_IN_INTERFACE!>private<!><!SYNTAX!><!> : T5 {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_EXPRESSION -UNREACHABLE_CODE -UNUSED_VARIABLE -WRONG_ANNOTATION_TARGET -UNUSED_LAMBDA_EXPRESSION\n\n// FILE: 1.kt\n\nannotation class yield\n\nfun bar(p: Int) {\n    <!REDUNDANT_LABEL_WARNING!><!YIELD_IS_RESERVED!>yield<!>@<!> p\n    <!REDUNDANT_LABEL_WARNING!>`yield`@<!> p\n\n    @<!YIELD_IS_RESERVED!>yield<!>() p\n    @`yield`() p\n\n    for (yield in 1..5) {\n\n    }\n    { yield: Int -> }\n\n    val (yield) = listOf(4)\n\n}\n\nfun <T> listOf(vararg e: T): List<T> = null!!\noperator fun <T> List<T>.component1() = get(0)\n\n// FILE: 2.kt\npackage p3\n\nenum class yield {\n    yield\n}\n\nfun f1(yield: Int, foo: Int = <!YIELD_IS_RESERVED!>yield<!>) {}\n\nfun f2(foo: <!YIELD_IS_RESERVED!>yield<!>) {}\n\n// FILE: 3.kt\npackage p4\n\ntypealias yield = Number\n\nfun <yield: Number> f1() {}\nfun <y: <!YIELD_IS_RESERVED!>yield<!>> f2() {}\n\n// FILE: 4.kt\nobject X {\n    fun yield() {}\n\n    fun test3(yield: Int) {\n        X::<!YIELD_IS_RESERVED!>yield<!>\n\n        <!YIELD_IS_RESERVED!>yield<!>::toInt\n    }\n}\n"
        },
        {
            "code": "interface NoC {\n  <!ANONYMOUS_INITIALIZER_IN_INTERFACE!>init<!> {\n\n  }\n\n  val a : Int get() = 1\n\n  <!ANONYMOUS_INITIALIZER_IN_INTERFACE!>init<!> {\n\n  }\n}\n\nclass WithC() {\n  val x : Int = 1\n  init {\n    val <!UNUSED_VARIABLE!>b<!> = x\n\n  }\n\n  val a : Int get() = 1\n\n  init {\n    val <!UNUSED_VARIABLE!>z<!> = <!UNRESOLVED_REFERENCE!>b<!>\n    val <!UNUSED_VARIABLE!>zz<!> = x\n  }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// JAVAC_SKIP\n\n// FILE: f.kt\n\nimport java.*\nimport java.util.*\nimport <!UNRESOLVED_REFERENCE!>utils<!>.*\n\nimport java.io.PrintStream\nimport <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<!> as Com\n\nval l : MutableList<in Int> = ArrayList<Int>()\n\nfun test(<!UNUSED_PARAMETER!>l<!> : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.List<Int><!>) {\n  val <!UNUSED_VARIABLE!>x<!> : java.<!UNRESOLVED_REFERENCE!>List<!>\n  val <!UNUSED_VARIABLE!>y<!> : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.List<Int><!>\n  val <!UNUSED_VARIABLE!>b<!> : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Object<!>\n  val <!UNUSED_VARIABLE!>z<!> : java.<!UNRESOLVED_REFERENCE!>utils<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>List<!><Int>\n\n  val <!UNUSED_VARIABLE!>f<!> : java.io.File? = null\n\n  Collections.<!FUNCTION_CALL_EXPECTED, NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>\n  Collections.<!FUNCTION_CALL_EXPECTED!>emptyList<Int><!>\n  Collections.emptyList<Int>()\n  Collections.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyList<!>()\n\n  checkSubtype<Set<Int>?>(Collections.singleton<Int>(1))\n  Collections.singleton<Int>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>)\n\n  <!RESOLUTION_TO_CLASSIFIER!>List<!><Int>\n\n\n  val <!UNUSED_VARIABLE!>o<!> = \"sdf\" as <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!>\n\n  try {\n    // ...\n  }\n  catch(e: Exception) {\n    System.out.println(e.message)\n  }\n\n  PrintStream(\"sdf\")\n\n  val c : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Com<Int><!>? = null\n\n  checkSubtype<<!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<Int><!>?>(c)\n\n//  Collections.sort<Integer>(ArrayList<Integer>())\n  xxx.<!UNRESOLVED_REFERENCE!>Class<!>()\n}\n\n\n// FILE: f.kt\npackage xxx\n  import java.lang.Class;"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test() {\n  val a : Int? = 0\n  if (a != null) {\n    <!DEBUG_INFO_SMARTCAST!>a<!>.plus(1)\n  }\n  else {\n    <!DEBUG_INFO_CONSTANT!>a<!>?.plus(1)\n  }\n\n  val out : java.io.PrintStream? = null\n  val ins : java.io.InputStream? = null\n\n  out?.println()\n  ins?.read()\n\n  if (ins != null) {\n    <!DEBUG_INFO_SMARTCAST!>ins<!>.read()\n    out?.println()\n    if (out != null) {\n      <!DEBUG_INFO_SMARTCAST!>ins<!>.read();\n      <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n    }\n  }\n\n  if (out != null && ins != null) {\n    <!DEBUG_INFO_SMARTCAST!>ins<!>.read();\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n\n  if (out == null) {\n    <!DEBUG_INFO_CONSTANT!>out<!>?.println()\n  } else {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println()\n  }\n\n  if (out != null && ins != null || out != null) {\n    ins?.read();\n    ins<!UNSAFE_CALL!>.<!>read();\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n\n  if (out == null || <!DEBUG_INFO_SMARTCAST!>out<!>.println(0) == Unit) {\n    out?.println(1)\n    out<!UNSAFE_CALL!>.<!>println(1)\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println(2)\n  }\n\n  if (out != null && <!DEBUG_INFO_SMARTCAST!>out<!>.println() == Unit) {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n  else {\n    out?.println();\n  }\n\n  if (out == null || <!DEBUG_INFO_SMARTCAST!>out<!>.println() == Unit) {\n    out?.println();\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n\n  if (1 == 2 || out != null && <!DEBUG_INFO_SMARTCAST!>out<!>.println(1) == Unit) {\n    out?.println(2);\n    out<!UNSAFE_CALL!>.<!>println(2);\n  }\n  else {\n    out?.println(3)\n    out<!UNSAFE_CALL!>.<!>println(3)\n  }\n\n  out?.println()\n  ins?.read()\n\n  if (ins != null) {\n    <!DEBUG_INFO_SMARTCAST!>ins<!>.read()\n    out?.println()\n    if (out != null) {\n      <!DEBUG_INFO_SMARTCAST!>ins<!>.read();\n      <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n    }\n  }\n\n  if (out != null && ins != null) {\n    <!DEBUG_INFO_SMARTCAST!>ins<!>.read();\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n\n  if (out == null) {\n    <!DEBUG_INFO_CONSTANT!>out<!>?.println()\n  } else {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println()\n  }\n\n  if (out != null && ins != null || out != null) {\n    ins?.read();\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n\n  if (out == null || <!DEBUG_INFO_SMARTCAST!>out<!>.println(0) == Unit) {\n    out?.println(1)\n    out<!UNSAFE_CALL!>.<!>println(1)\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println(2)\n  }\n\n  if (out != null && <!DEBUG_INFO_SMARTCAST!>out<!>.println() == Unit) {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n  else {\n    out?.println();\n    out<!UNSAFE_CALL!>.<!>println();\n  }\n\n  if (out == null || <!DEBUG_INFO_SMARTCAST!>out<!>.println() == Unit) {\n    out?.println();\n    out<!UNSAFE_CALL!>.<!>println();\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n\n  if (1 == 2 || out != null && <!DEBUG_INFO_SMARTCAST!>out<!>.println(1) == Unit) {\n    out?.println(2);\n    out<!UNSAFE_CALL!>.<!>println(2);\n  }\n  else {\n    out?.println(3)\n    out<!UNSAFE_CALL!>.<!>println(3)\n  }\n\n  if (1 > 2) {\n    if (out == null) return;\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n  out?.println();\n\n  while (out != null) {\n    <!DEBUG_INFO_SMARTCAST!>out<!>.println();\n  }\n  <!DEBUG_INFO_CONSTANT!>out<!>?.println();\n\n  val out2 : java.io.PrintStream? = null\n  \n  while (out2 == null) {\n    <!DEBUG_INFO_CONSTANT!>out2<!>?.println();\n    <!OI;DEBUG_INFO_CONSTANT!>out2<!><!UNSAFE_CALL!>.<!>println();\n  }\n  <!DEBUG_INFO_SMARTCAST!>out2<!>.println()\n\n}\n\n\nfun f(out : String?) {\n  out?.get(0)\n  out<!UNSAFE_CALL!>.<!>get(0)\n  if (out != null) else return;\n  <!DEBUG_INFO_SMARTCAST!>out<!>.get(0)\n}\n\nfun f1(out : String?) {\n  out?.get(0)\n  if (out != null) else {\n    1 + 2\n    return;\n  }\n  <!DEBUG_INFO_SMARTCAST!>out<!>.get(0)\n}\n\nfun f2(out : String?) {\n  out?.get(0)\n  if (out == null) {\n    1 + 2\n    return;\n  }\n  <!DEBUG_INFO_SMARTCAST!>out<!>.get(0)\n}\n\nfun f3(out : String?) {\n  out?.get(0)\n  if (out == null) {\n    1 + 2\n    return;\n  }\n  else {\n    1 + 2\n  }\n  <!DEBUG_INFO_SMARTCAST!>out<!>.get(0)\n}\n\nfun f4(s : String?) {\n  s?.get(0)\n  while (1 < 2 && s != null) {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n  }\n  s?.get(0)\n  while (s == null || 1 < 2) {\n     s?.get(0)\n  }\n  <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n}\n\nfun f5(s : String?) {\n  s?.get(0)\n  while (1 < 2 && s != null) {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n  }\n  s?.get(0)\n  while (s == null || 1 < 2) {\n    if (1 > 2) break\n     s?.get(0)\n  }\n  s?.get(0);\n}\n\nfun f6(s : String?) {\n  s?.get(0)\n  do {\n    s?.get(0)\n    if (1 < 2) break;\n  } while (s == null)\n  s?.get(0)\n  do {\n    s?.get(0)\n  } while (s == null)\n  <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n}\n\nfun f7(s : String?, t : String?) {\n  s?.get(0)\n  if (!(s == null)) {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n  }\n  s?.get(0)\n  if (!(s != null)) {\n    <!DEBUG_INFO_CONSTANT!>s<!>?.get(0)\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n  }\n  s?.get(0)\n  if (!!(s != null)) {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n  }\n  else {\n    <!DEBUG_INFO_CONSTANT!>s<!>?.get(0)\n  }\n  s?.get(0)\n  t?.get(0)\n  if (!(s == null || t == null)) {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n    <!DEBUG_INFO_SMARTCAST!>t<!>.get(0)\n  }\n  else {\n    s?.get(0)\n    t?.get(0)\n  }\n  s?.get(0)\n  t?.get(0)\n  if (!(s == null)) {\n    <!DEBUG_INFO_SMARTCAST!>s<!>.get(0)\n    t?.get(0)\n  }\n  else {\n    <!DEBUG_INFO_CONSTANT!>s<!>?.get(0)\n    t?.get(0)\n  }\n}\n\nfun f8(b : String?, a : String) {\n  b?.get(0)\n  if (b == a) {\n    <!DEBUG_INFO_SMARTCAST!>b<!>.get(0);\n  }\n  b?.get(0)\n  if (a == b) {\n    <!DEBUG_INFO_SMARTCAST!>b<!>.get(0)\n  }\n  if (a != b) {\n    b?.get(0)\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>b<!>.get(0)\n  }\n}\n\nfun f9(a : Int?) : Int {\n  if (a != null)\n    return <!DEBUG_INFO_SMARTCAST!>a<!>\n  return 1\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nimport java.util.stream.*\n\ninterface A : Collection<String> {\n    override fun stream(): Stream<String> = Stream.<!INTERFACE_STATIC_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>of<!>()\n}\n\nfun foo(x: List<String>, y: A) {\n    x.stream().filter { it.length > 0 }.collect(Collectors.toList())\n    y.stream().filter { it.length > 0 }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nimport java.util.concurrent.*\n\nval concurrent: ConcurrentMap<String, Int> = null!!\nval concurrentHash: ConcurrentHashMap<String, Int> = null!!\n\nfun foo() {\n    concurrent.remove(\"\", 1)\n    concurrent.remove(\"\", <!TYPE_MISMATCH!>\"\"<!>)\n    concurrentHash.remove(\"\", 1)\n    concurrentHash.remove(\"\", <!TYPE_MISMATCH!>\"\"<!>)\n\n    // Flexible types\n    concurrent.remove(null, 1)\n    concurrent.remove(null, null)\n\n    // @PurelyImplements\n    concurrentHash.remove(<!NULL_FOR_NONNULL_TYPE!>null<!>, 1)\n    concurrentHash.remove(<!NULL_FOR_NONNULL_TYPE!>null<!>, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n}\n"
        },
        {
            "code": "// FULL_JDK\n\nabstract class A : Map<Int, String>\n\nfun foo(x: Map<Int, String>, a: A, b: java.util.HashMap<Int, String>) {\n    x.getOrDefault(1, \"\")\n    x.getOrDefault(<!TYPE_MISMATCH!>\"\"<!>, \"\")\n    x.getOrDefault(1, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n    x.getOrDefault(<!TYPE_MISMATCH!>\"\"<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n\n    a.getOrDefault(1, \"\")\n    a.getOrDefault(<!TYPE_MISMATCH!>\"\"<!>, \"\")\n    a.getOrDefault(1, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n    a.getOrDefault(<!TYPE_MISMATCH!>\"\"<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n\n    b.getOrDefault(1, \"\")\n    b.getOrDefault(<!TYPE_MISMATCH!>\"\"<!>, \"\")\n    b.getOrDefault(1, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n    b.getOrDefault(<!TYPE_MISMATCH!>\"\"<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PARAMETER_NAME_CHANGED_ON_OVERRIDE\n// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nclass KotlinMap1<K, V> : java.util.AbstractMap<K, V>() {\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() = throw UnsupportedOperationException()\n\n    override fun remove(x: K, y: V) = true\n}\n\nclass KotlinMap2 : java.util.AbstractMap<String, Int>() {\n    override val entries: MutableSet<MutableMap.MutableEntry<String, Int>>\n        get() = throw UnsupportedOperationException()\n\n    override fun remove(x: String, y: Int) = true\n}\n\nfun foo(x: MutableMap<String, Int>, y: java.util.HashMap<String, Int>, z: java.util.AbstractMap<String, Int>) {\n    x.remove(\"\", 1)\n    x.remove(\"\", <!TYPE_MISMATCH!>\"\"<!>)\n    x.remove(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n\n    y.remove(\"\", 1)\n    y.remove(\"\", <!TYPE_MISMATCH!>\"\"<!>)\n    y.remove(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n\n    z.remove(\"\", 1)\n    z.remove(\"\", <!TYPE_MISMATCH!>\"\"<!>)\n    z.remove(\"\", null)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PLATFORM_CLASS_MAPPED_TO_KOTLIN\n\n\n// Default methods from Java interfaces are NOT overridden by delegation.\n// So, in the example below 'TestNoDelegationToDefaultMethods#replace' implicitly overrides a method from 'java.util.Map' (which is ok),\n// but not a method from 'WithDelegation' (would be an error).\nopen class WithDelegation(val m: Map<String, String>) : Map<String, String> by m\n\nclass TestNoDelegationToDefaultMethods(m: Map<String, String>): WithDelegation(m) {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>containsKey<!>(key: String): Boolean = TODO()\n\n    fun getOrDefault(key: String, defaultValue: String): String = TODO()\n\n    fun replace(key: String, value: String): String? = TODO()\n}\n\n\n\ninterface IBaseWithKotlinDeclaration : Map<String, String> {\n    fun replace(key: String, value: String): String?\n}\n\nabstract class WithDelegation2(val m: Map<String, String>) : Map<String, String> by m, IBaseWithKotlinDeclaration\n\nabstract class TestNoDelegationToDefaultMethods2(m: Map<String, String>): WithDelegation2(m) {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>containsKey<!>(key: String): Boolean = TODO()\n\n    fun getOrDefault(key: String, defaultValue: String): String = TODO()\n\n    // VIRTUAL_MEMBER_HIDDEN: hides member declaration inherited from a Kotlin interface\n    fun <!VIRTUAL_MEMBER_HIDDEN!>replace<!>(key: String, value: String): String? = TODO()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PLATFORM_CLASS_MAPPED_TO_KOTLIN\n\nabstract class Test1 : Map<String, String> {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>containsKey<!>(key: String): Boolean = TODO()\n\n    fun getOrDefault(key: String, defaultValue: String): String = TODO()\n}\n\nabstract class Test2 : MutableMap<String, String> {\n    fun replace(key: String, value: String): String? = TODO()\n}\n\nabstract class Test3 : java.util.AbstractMap<String, String>() {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>containsKey<!>(key: String): Boolean = TODO()\n\n    fun replace(key: String, value: String): String? = TODO()\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -PLATFORM_CLASS_MAPPED_TO_KOTLIN\n\ninterface IBaseWithKotlinDeclaration : Map<String, String> {\n    fun replace(key: String, value: String): String?\n}\n\ninterface TestDerivedInterfaceHidingWithKotlinDeclaration : IBaseWithKotlinDeclaration {\n    // VIRTUAL_MEMBER_HIDDEN: hides member declaration inherited from a Kotlin interface\n    fun <!VIRTUAL_MEMBER_HIDDEN!>replace<!>(key: String, value: String): String?\n}\n\ninterface TestDerivedInterfaceDefaultWithKotlinDeclaration : IBaseWithKotlinDeclaration {\n    // VIRTUAL_MEMBER_HIDDEN: hides member declaration inherited from a Kotlin interface\n    fun <!VIRTUAL_MEMBER_HIDDEN!>replace<!>(key: String, value: String): String? = TODO()\n}\n"
        },
        {
            "code": "enum class TestEnum {\n    ENTRY;\n\n    fun <!VIRTUAL_MEMBER_HIDDEN!>getDeclaringClass<!>() {}\n    fun <!VIRTUAL_MEMBER_HIDDEN!>finalize<!>() {}\n}\n\nclass TestFinalize {\n    fun finalize() {}\n}\n"
        },
        {
            "code": "// FULL_JDK\n\nimport java.util.function.Consumer\n\nabstract class MyIt1<out T> : Iterator<T> {\n    override fun forEachRemaining(x: Consumer<in T>) {}\n}\n\nabstract class MyIt2<out T> : Iterator<T> {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun forEachRemaining(x: Consumer<in T?>) {}\n}\n\nabstract class MyIt3<out T> : Iterator<T> {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun forEachRemaining(x: Consumer<in T>?) {}\n}\n\nabstract class MyIt4 : Iterator<String?> {\n    override fun forEachRemaining(x: Consumer<in String?>) {}\n}\n\nabstract class MyIt5 : Iterator<String> {\n    override fun forEachRemaining(x: Consumer<in String>) {}\n}\n\nabstract class MyIt6 : Iterator<String?> {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun forEachRemaining(x: Consumer<in String>) {}\n}\n\nabstract class MyIt7 : Iterator<String> {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun forEachRemaining(x: Consumer<in String?>) {}\n}\n\n\nfun foo(x: Iterator<String>, y: Iterator<String?>) {\n    x.forEachRemaining(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n\n    x.forEachRemaining { it -> it.length }\n    x.forEachRemaining { it -> it<!UNNECESSARY_SAFE_CALL!>?.<!>length }\n    y.forEachRemaining { it -> it<!UNSAFE_CALL!>.<!>length }\n    y.forEachRemaining { it -> it?.length }\n}\n"
        },
        {
            "code": "class A() {\n    <!CONFLICTING_OVERLOADS!>fun b()<!> {\n    }\n\n    <!CONFLICTING_OVERLOADS!>fun b()<!> {\n    }\n}\n"
        },
        {
            "code": "import java.io.Serializable\n\ninterface Test1 {\n    <!CONFLICTING_OVERLOADS!>fun <T> foo(t: T)<!> where T : Cloneable, T : Serializable\n    <!CONFLICTING_OVERLOADS!>fun <T> foo(t: T)<!> where T : Serializable, T : Cloneable\n}\n\n\ninterface I1\ninterface I2 : I1\n\ninterface Test2 {\n    <!CONFLICTING_OVERLOADS!>fun <T> foo(t: T)<!> where T : I1, T : I2\n    <!CONFLICTING_OVERLOADS!>fun <T> foo(t: T)<!> where T : I2, T : I1\n}\n"
        },
        {
            "code": "class A {\n    <!CONFLICTING_OVERLOADS!>fun a(<!UNUSED_PARAMETER!>a<!>: Int): Int<!> = 0\n\n    <!CONFLICTING_OVERLOADS!>fun a(<!UNUSED_PARAMETER!>a<!>: Int)<!> {\n    }\n}\n"
        },
        {
            "code": "// constructor vs. fun overload\n\npackage constructorVsFun\n\nclass a<!CONFLICTING_OVERLOADS!>()<!> { }\n\n<!CONFLICTING_OVERLOADS!>fun a()<!> = 1\n\nclass Tram {\n    <!CONFLICTING_OVERLOADS!>fun f()<!> { }\n\n    class f<!CONFLICTING_OVERLOADS!>()<!> { }\n}\n\nclass Yvayva {\n    companion object {\n        <!CONFLICTING_OVERLOADS!>fun fghj()<!> { }\n\n        class fghj<!CONFLICTING_OVERLOADS!>()<!> { }\n    }\n}\n\nclass Rtyu {\n    fun ololo() { }\n\n    companion object {\n        class ololo() { }\n    }\n}"
        },
        {
            "code": "fun test() {\n    <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n    <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n    fun Any.test2() {}\n    fun test2(x: Any) = x\n\n    <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n    <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n    <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n    <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n    class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n        <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n    }\n    <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n    <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n\n    fun local() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n    }\n}\n\nclass Test {\n    init {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n    }\n\n    fun test() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n    }\n\n    val property: Any get() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n\n        return 0\n    }\n}\n\nval property: Any get() {\n    <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n    <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n    fun Any.test2() {}\n    fun test2(x: Any) = x\n\n    <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n    <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n    <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n    <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n    class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n        <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n    }\n    <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n    <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n\n    return 0\n}\n\nobject Object {\n    fun test() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n    }\n\n    val property: Any get() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n\n        return 0\n    }\n}\n\nval obj = object {\n    fun test() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n    }\n\n    val property: Any get() {\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}\n\n        fun Any.test2() {}\n        fun test2(x: Any) = x\n\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}\n\n        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0\n        <!CONFLICTING_OVERLOADS!>fun test4(): String<!> = \"\"\n\n        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {\n            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)\n        }\n        <!CONFLICTING_OVERLOADS!>fun Test5()<!> {}\n        <!CONFLICTING_OVERLOADS!>fun Test5(x: Int)<!> = x\n\n        return 0\n    }\n}"
        },
        {
            "code": "<!CONFLICTING_OVERLOADS!>fun <T1> test1(x: List<T1>)<!> = x\n<!CONFLICTING_OVERLOADS!>fun <T2> test1(x: List<T2>)<!> = x\n\n<!CONFLICTING_OVERLOADS!>fun <T1> List<T1>.test1a()<!> {}\n<!CONFLICTING_OVERLOADS!>fun <T2> List<T2>.test1a()<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> test2(x: List<T>)<!> = x\n<!CONFLICTING_JVM_DECLARATIONS!>fun test2(x: List<String>)<!> = x\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> List<T>.test2a()<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun List<String>.test2a()<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T : Any> test3(x: List<T>)<!> = x\n<!CONFLICTING_JVM_DECLARATIONS!>fun test3(x: List<Any>)<!> = x\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T : Any> List<T>.test3a()<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun List<Any>.test3a()<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> test4(x: Map<T, T>)<!> = x\n<!CONFLICTING_JVM_DECLARATIONS!>fun <K, V> test4(x: Map<K, V>)<!> = x\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T> Map<T, T>.test4a()<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun <K, V> Map<K, V>.test4a()<!> {}\n\nclass Inv<T>\n\n<!CONFLICTING_OVERLOADS!>fun <T> test5(x: Inv<T>)<!> = x\n<!CONFLICTING_OVERLOADS!>fun <T> test5(x: Inv<out T>)<!> = x\n\nfun <T> test6(x: Array<T>) = x\nfun test6(x: Array<String>) = x\n\nfun <T> test7(x: Inv<T>) = x\nfun <T> Inv<T>.test7() {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A {\n    private fun foo(i: Int) {}\n    private fun foo(s: String) {}\n}\n\nfun test(a: A) {\n    a.<!INVISIBLE_MEMBER!>foo<!>(3)\n    a.<!NONE_APPLICABLE!>foo<!>()\n}\n\n"
        },
        {
            "code": "// FILE: pkg1.kt\n// check no error in overload in different packages\n\npackage pkg1\nfun e() = 1\n\n// FILE: pkg2.kt\npackage pkg2\nfun e() = 1\n\n// FILE: pkg3pkg1.kt\npackage pkg3.pkg1\nfun e() = 1\n"
        },
        {
            "code": "package qwertyuiop\n\n<!CONFLICTING_OVERLOADS!>fun c(<!UNUSED_PARAMETER!>s<!>: String)<!> {\n}\n\n<!CONFLICTING_OVERLOADS!>fun c(<!UNUSED_PARAMETER!>s<!>: String)<!> {\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun simple() = 1\nfun simple(a: Int = 3) = \"\"\n\nfun twoDefault(a: Int = 2) = 1\nfun twoDefault(a: Any = 2, b: String = \"\") = \"\"\n\nfun <T> withGeneric(a: T) = 1\nfun <T> withGeneric(a: T, b: Int = 4) = \"\"\n\nfun <T> discriminateGeneric(a: T) = 1\nfun discriminateGeneric(a: Int, b: String = \"\") = \"\"\n\nfun <T: CharSequence> withDefaultGeneric(t: T, d: T? = null) = 1\nfun <T: Any> withDefaultGeneric(t: T, d: T? = null, a: Int = 1) = \"\"\n\nfun withDefaults(a: Any = 2) = 1\nfun withDefaults(a: Int = 2, b: String = \"\") = \"\"\n\nfun <T: Any> withGenericDefaults(t: T, d: T? = null) = 1\nfun <T: CharSequence> withGenericDefaults(t: T, d: T? = null, a: Int = 1) = \"\"\n\nfun wrong(a: Int = 1) {}\nfun wrong(a: String = \"\", b: Int = 1) {}\n\nfun test() {\n    val a = simple()\n    a checkType { _<Int>() }\n\n    val b = simple(1)\n    b checkType { _<String>() }\n\n    val c = twoDefault()\n    c checkType { _<Int>() }\n\n    val d = twoDefault(1)\n    d checkType { _<Int>() }\n\n    val e = twoDefault(1, \"\")\n    e checkType { _<String>() }\n\n    val f = withGeneric(3)\n    f checkType { _<Int>() }\n\n    val g = discriminateGeneric(1)\n    g checkType { _<String>() }\n\n    val h = withDefaultGeneric(\"\")\n    h checkType { _<Int>() }\n\n    withDefaults(1)\n\n    withGenericDefaults(\"\")\n\n    <!UNREACHABLE_CODE!><!OVERLOAD_RESOLUTION_AMBIGUITY!>wrong<!>(<!>null!!<!UNREACHABLE_CODE!>)<!>\n}"
        },
        {
            "code": "class Aaa() {\n    val <!REDECLARATION!>a<!> = 1\n    val <!REDECLARATION!>a<!> = \"\"\n}"
        },
        {
            "code": "package extensionFunctions\n\n<!CONFLICTING_OVERLOADS!>fun Int.qwe(<!UNUSED_PARAMETER!>a<!>: Float)<!> = 1\n\n<!CONFLICTING_OVERLOADS!>fun Int.qwe(<!UNUSED_PARAMETER!>a<!>: Float)<!> = 2\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\ninterface A\ninterface B\n\nfun <R: A> R.f() {\n}\n\nfun <R: B> R.f() {\n}\n\nclass AImpl: A\nclass BImpl: B\n\nclass C: A, B\n\nfun main() {\n    AImpl().f()\n    BImpl().f()\n    C().<!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>f<!>()\n}"
        },
        {
            "code": "class Aaa() {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun f()<!> = 1\n    <!CONFLICTING_JVM_DECLARATIONS!>fun <P> f()<!> = 1\n}\n"
        },
        {
            "code": "class Aaa() {\n    val <!REDECLARATION!>a<!> = 1\n    val <!REDECLARATION!>a<!> = 1\n}"
        },
        {
            "code": "// FILE: KotlinFile.kt\n\nfun test() {\n   if (<!USELESS_IS_CHECK!>1 is Int<!>) {\n     if (1 is <!INCOMPATIBLE_TYPES!>Boolean<!>) {\n\n     }\n   }\n\n   A.create() is A\n   <!USELESS_IS_CHECK!>A.create() is A?<!>\n\n   <!UNRESOLVED_REFERENCE!>unresolved<!> is A\n   <!UNRESOLVED_REFERENCE!>unresolved<!> is A?\n\n   val x = foo()\n   x as String\n   <!USELESS_IS_CHECK!>x is String<!>\n}\n\nfun foo(): Any = \"\"\n\n"
        },
        {
            "code": "class A {\n    operator fun A.minus(o: A) = o\n\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun A.add(o: A) = o\n    operator fun A.get(o: A) = o\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun A.invokee() {}\n}\n\noperator fun A.plus(o: A) = o\noperator fun A.component1() = 1\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun A.componentN() = 1"
        },
        {
            "code": "// FILE: b.kt\ninterface A<in T> {}\ninterface B<T> : A<Int> {}\ninterface C<T> : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>B<T>, A<T><!> {}\ninterface C1<T> : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>B<T>, A<Any><!> {}\ninterface D : <!INCONSISTENT_TYPE_PARAMETER_VALUES, INCONSISTENT_TYPE_PARAMETER_VALUES!>C<Boolean>, B<Double><!>{}\n\ninterface A1<out T> {}\ninterface B1 : A1<Int> {}\ninterface B2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>A1<Any>, B1<!> {}\n\ninterface BA1<T> {}\ninterface BB1 : BA1<Int> {}\ninterface BB2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>BA1<Any>, BB1<!> {}\n\n\n// FILE: b.kt\npackage x\n    interface AA1<out T> {}\n    interface AB1 : AA1<Int> {}\n    interface AB3 : AA1<Comparable<Int>> {}\n    interface AB2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>AA1<Number>, AB1, AB3<!> {}\n\n// FILE: b.kt\npackage x2\n    interface AA1<out T> {}\n    interface AB1 : AA1<Any> {}\n    interface AB3 : AA1<Comparable<Int>> {}\n    interface AB2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>AA1<Number>, AB1, AB3<!> {}\n\n// FILE: b.kt\npackage x3\n    interface AA1<in T> {}\n    interface AB1 : AA1<Any> {}\n    interface AB3 : AA1<Comparable<Int>> {}\n    interface AB2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>AA1<Number>, AB1, AB3<!> {}\n\n// FILE: b.kt\npackage sx2\n    interface AA1<in T> {}\n    interface AB1 : AA1<Int> {}\n    interface AB3 : AA1<Comparable<Int>> {}\n    interface AB2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>AA1<Number>, AB1, AB3<!> {}"
        },
        {
            "code": "class X {\n    val foo = object {\n        <!NESTED_CLASS_NOT_ALLOWED!>class Foo<!>\n    }\n\n    fun test() {\n        object {\n            <!NESTED_CLASS_NOT_ALLOWED!>class Foo<!>\n        }\n    }\n}\n"
        },
        {
            "code": "interface A\n\ninterface B\n\nfun test1(): B = <!TYPE_MISMATCH!>object : A<!> {\n}\n\nfun test2(): B = <!TYPE_MISMATCH!>object<!> {\n}"
        },
        {
            "code": "package toplevelObjectDeclarations\n\nobject CObj {}\n\nobject DOjb : <!SINGLETON_IN_SUPERTYPE!>CObj<!> {}\n"
        },
        {
            "code": "object Obj {\n    fun foo() {}\n\n    <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> fun bar() {}\n\n    var x: Int = 0\n\n    <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> var y: Int = 1\n}\n"
        },
        {
            "code": "package nestedObejcts\n\nobject A {\n    val b = B\n    val d = A.B.A\n\n    object B {\n        val a = A\n        val e = B.A\n\n        object A {\n            val a = A\n            val b = B\n            val x = nestedObejcts.A.B.A\n            val y = this<!AMBIGUOUS_LABEL!>@A<!>\n        }\n    }\n\n}\nobject B {\n    val b = B\n    val c = A.B\n}\n\nval a = A\nval b = B\nval c = A.B\nval d = A.B.A\nval e = B.<!UNRESOLVED_REFERENCE!>A<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>B<!>"
        },
        {
            "code": "interface Trait<N : Number>\n\nobject O1 : Trait<Int>\n\nobject O2 : Trait<<!UPPER_BOUND_VIOLATED!>String<!>>\n\nclass C {\n    companion object : Trait<<!UPPER_BOUND_VIOLATED!>IntRange<!>>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: test/Java.java\npackage test;\n\npublic class Java {\n    public static void method() { }\n    public static int property = 42;\n    public static class Classifier { }\n    public static void syntheticSam(Runnable r) { }\n\n    public static int getStaticSyntheticProperty() { return 42; }\n    public static int setStaticSyntheticProperty(int x) { return 42; }\n\n    public int getInstanceSyntheticProperty() { return 42; }\n    public int setInstanceSyntheticProperty(int x) { return 42; }\n}\n\n// FILE: Kotlin.kt\npackage test\n\nopen class Base {\n    companion object : Java() {\n\n    }\n}\n\nclass Derived : Base() {\n    fun test(javaStaticInTypePosition: <!UNRESOLVED_REFERENCE!>Classifier<!>) {\n        <!UNRESOLVED_REFERENCE!>method<!>()\n        <!UNRESOLVED_REFERENCE!>property<!>\n        <!UNRESOLVED_REFERENCE!>Classifier<!>()\n        <!UNRESOLVED_REFERENCE!>syntheticSam<!> { }\n\n        // Instance members shouldn't be affected, but we check them, just in case\n        val y = instanceSyntheticProperty\n        instanceSyntheticProperty = 43\n\n        // Note that statics actually aren't converted into synthetic property in Kotlin\n        val x = <!UNRESOLVED_REFERENCE!>syntheticProperty<!>\n        <!UNRESOLVED_REFERENCE!>syntheticProperty<!> = 42\n    }\n\n    class JavaStaticInSupertypeList : <!UNRESOLVED_REFERENCE!>Classifier<!>() {\n\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// See KT-21515 for a class diagram and details\n\n// class is to prevent accidental short-name import\nclass O {\n    open class Alpha {\n        open fun foo() = 42\n\n        class FromAlpha {\n            fun foo() = 42\n        }\n\n        companion object {\n            class FromCompanionAlpha {\n                fun foo() = 42\n            }\n        }\n    }\n\n    open class Beta : Alpha() {\n        override fun foo() = 42\n\n        class FromBeta {\n            fun foo() = 42\n        }\n\n        companion object {\n            class FromCompanionBeta {\n                fun foo() = 42\n            }\n        }\n    }\n\n\n    open class A {\n        open fun foo() = 42\n\n        class FromA {\n            fun foo() = 42\n        }\n\n        companion object : Beta() {\n            class FromCompanionA {\n                fun foo() = 42\n            }\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        open fun foo() = 42\n\n        class FromFarAway {\n            fun foo() = 42\n        }\n\n    }\n\n    open class Gamma {\n        open fun foo() = 42\n\n        class FromGamma {\n            fun foo() = 42\n        }\n\n        companion object : FarAway() {\n            class FromCompanionGamma {\n                fun foo() = 42\n            }\n        }\n    }\n\n    open class B : A() {\n        override fun foo() = 42\n\n        class FromB {\n            fun foo() = 42\n        }\n\n        companion object : Gamma() {\n            override fun foo() = 42\n\n            class FromCompanionB {\n                fun foo() = 42\n            }\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    open fun foo() = 42\n    class FromDelta {\n        fun foo() = 42\n    }\n}\n\nclass C : O.B() {\n    override fun foo() = 42\n\n    companion object : Delta() {\n        class FromCompanionC {\n            fun foo() = 42\n        }\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    val c = FromA::foo\n    val d = FromB::foo\n\n    // VISIBLE: Classifiers from our own companion\n    val n = FromCompanionC::foo\n\n    // INVISIBLE: direct superclasses themselves.\n    val a = <!UNRESOLVED_REFERENCE!>A<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val b = <!UNRESOLVED_REFERENCE!>A<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    val e = <!UNRESOLVED_REFERENCE!>FromCompanionA<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val f = <!UNRESOLVED_REFERENCE!>FromCompanionB<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    val g = <!UNRESOLVED_REFERENCE!>Alpha<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val h = <!UNRESOLVED_REFERENCE!>Beta<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val i = <!UNRESOLVED_REFERENCE!>Gamma<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    val k = <!UNRESOLVED_REFERENCE!>FromAlpha<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val l = <!UNRESOLVED_REFERENCE!>FromBeta<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val m = <!UNRESOLVED_REFERENCE!>FromGamma<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    val o = <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val p = <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val q = <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    val r = <!UNRESOLVED_REFERENCE!>FromDelta<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\n// ===== Case 1: LHS is a class\n//\nobject A {\n    open class Base {\n        companion object {\n            class FromBaseCompanion {\n                fun foo() = 42\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBaseCompanion<!>::foo\n    }\n}\n\n// ===== Case 2: LHS is a class with companion object, function comes from class\n\nobject B {\n    open class Base {\n        companion object {\n            class FromBaseCompanion {\n                fun foo() = 42\n\n                companion object {}\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBaseCompanion<!>::foo\n    }\n}\n\n// ==== Case 3: LHS is a class with companion object, function comes from companion\n\nobject C {\n    open class Base {\n        companion object {\n            class FromBaseCompanion {\n                companion object {\n                    fun foo() = 42\n                }\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBaseCompanion<!>::<!UNRESOLVED_REFERENCE!>foo<!>\n    }\n}\n\n// ==== Case 4: LHS is an object\n\nobject D {\n    open class Base {\n        companion object {\n            object FromBaseCompanion {\n                fun foo() = 42\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBaseCompanion<!>::foo\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: test/Java.java\npackage test;\n\npublic class Java {\n    public static void method() { }\n    public static int property = 42;\n    public static class Classifier { }\n    public static void syntheticSam(Runnable r) { }\n\n    public static int getStaticSyntheticProperty() { return 42; }\n    public static int setStaticSyntheticProperty(int x) { return 42; }\n\n    public int getInstanceSyntheticProperty() { return 42; }\n    public int setInstanceSyntheticProperty(int x) { return 42; }\n}\n\n// FILE: Kotlin.kt\npackage test\n\nopen class Base {\n    companion object : Java() {\n\n    }\n}\n\nclass Derived : Base() {\n    fun test(javaStaticInTypePosition: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Classifier<!>) {\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>method()<!>\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>property<!>\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Classifier()<!>\n        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>syntheticSam { }<!>\n\n        // Instance members shouldn't be affected, but we check them, just in case\n        val y = instanceSyntheticProperty\n        instanceSyntheticProperty = 43\n\n        // Note that statics actually aren't converted into synthetic property in Kotlin\n        val x = <!UNRESOLVED_REFERENCE!>syntheticProperty<!>\n        <!UNRESOLVED_REFERENCE!>syntheticProperty<!> = 42\n    }\n\n    class JavaStaticInSupertypeList : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Classifier<!>() {\n\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// See KT-21515 for a class diagram and details\n\n// Object is to prevent accidental short-name import\nobject O {\n    open class Alpha {\n        class FromAlpha\n\n        companion object {\n            class FromCompanionAlpha\n        }\n    }\n\n    open class Beta : Alpha() {\n        class FromBeta\n\n        companion object {\n            class FromCompanionBeta\n        }\n    }\n\n\n    open class A {\n        class FromA\n\n        companion object : Beta() {\n            class FromCompanionA\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        class FromFarAway\n    }\n\n    open class Gamma {\n        class FromGamma\n        companion object : FarAway() {\n            class FromCompanionGamma\n        }\n    }\n\n    open class B : A() {\n        class FromB\n\n        companion object : Gamma() {\n            class FromCompanionB\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    class FromDelta\n}\n\nclass C : O.B() {\n    companion object : Delta() {\n        class FromCompanionC\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    val c = FromA()\n    val d = FromB()\n\n    // VISIBLE: Classifiers from our own companion\n    val n = FromCompanionC()\n\n    // INVISIBLE: direct superclasses themselves.\n    val a = <!UNRESOLVED_REFERENCE!>A<!>()\n    val b = <!UNRESOLVED_REFERENCE!>B<!>()\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    val e = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionA()<!>\n    val f = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionB()<!>\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    val g = <!UNRESOLVED_REFERENCE!>Alpha<!>()\n    val h = <!UNRESOLVED_REFERENCE!>Beta<!>()\n    val i = <!UNRESOLVED_REFERENCE!>Gamma<!>()\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    val k = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromAlpha()<!>\n    val l = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBeta()<!>\n    val m = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromGamma()<!>\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    val o = <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>()\n    val p = <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>()\n    val q = <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>()\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    val r = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromDelta()<!>\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// See KT-21515 for a open class diagram and details\n\n// Object is to prevent accidental short-name import\nobject O {\n    open class Alpha {\n        open class FromAlpha\n\n        companion object {\n            open class FromCompanionAlpha\n        }\n    }\n\n    open class Beta : Alpha() {\n        open class FromBeta\n\n        companion object {\n            open class FromCompanionBeta\n        }\n    }\n\n\n    open class A {\n        open class FromA\n\n        companion object : Beta() {\n            open class FromCompanionA\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        open class FromFarAway\n\n    }\n\n    open class Gamma {\n        open class FromGamma\n        companion object : FarAway() {\n            open class FromCompanionGamma\n        }\n    }\n\n    open class B : A() {\n        open class FromB\n\n        companion object : Gamma() {\n            open class FromCompanionB\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    open class FromDelta\n}\n\nopen class C : O.B() {\n    companion object : Delta() {\n        open class FromCompanionC\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    open class c : FromA()\n    open class d : FromB()\n\n    // VISIBLE: Classifiers from our own companion\n    open class n : FromCompanionC()\n\n    // INVISIBLE: direct superclasses themselves.\n    open class a : <!UNRESOLVED_REFERENCE!>A<!>()\n    open class b : <!UNRESOLVED_REFERENCE!>B<!>()\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    open class e : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionA<!>()\n    open class f : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionB<!>()\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    open class g : <!UNRESOLVED_REFERENCE!>Alpha<!>()\n    open class h : <!UNRESOLVED_REFERENCE!>Beta<!>()\n    open class i : <!UNRESOLVED_REFERENCE!>Gamma<!>()\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    open class k : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromAlpha<!>()\n    open class l : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBeta<!>()\n    open class m : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromGamma<!>()\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    open class o : <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>()\n    open class p : <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>()\n    open class q : <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>()\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    open class r : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromDelta<!>()\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: test/Java.java\npackage test;\n\npublic class Java {\n    public static void method() { }\n    public static int property = 42;\n    public static class Classifier { }\n    public static void syntheticSam(Runnable r) { }\n\n    public static int getStaticSyntheticProperty() { return 42; }\n    public static int setStaticSyntheticProperty(int x) { return 42; }\n\n    public int getInstanceSyntheticProperty() { return 42; }\n    public int setInstanceSyntheticProperty(int x) { return 42; }\n}\n\n// FILE: Kotlin.kt\npackage test\n\nimport test.Java.method\nimport test.Java.Classifier\nimport test.Java.property\nimport test.Java.syntheticSam\n\nopen class Base {\n    companion object : Java() {\n\n    }\n}\n\nclass Derived : Base() {\n    fun test(javaStaticInTypePosition: Classifier) {\n        method()\n        property\n        Classifier()\n        syntheticSam { }\n\n        // Instance members shouldn't be affected, but we check them, just in case\n        val y = instanceSyntheticProperty\n        instanceSyntheticProperty = 43\n\n        // Note that statics actually aren't converted into synthetic property in Kotlin\n        val x = <!UNRESOLVED_REFERENCE!>syntheticProperty<!>\n        <!UNRESOLVED_REFERENCE!>syntheticProperty<!> = 42\n    }\n\n    class JavaStaticInSupertypeList : Classifier() {\n\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// See KT-21515 for a class diagram and details\n\n// Object is to prevent accidental short-name import\nobject O {\n    open class Alpha {\n        class FromAlpha\n\n        companion object {\n            class FromCompanionAlpha\n        }\n    }\n\n    open class Beta : Alpha() {\n        class FromBeta\n\n        companion object {\n            class FromCompanionBeta\n        }\n    }\n\n\n    open class A {\n        class FromA\n\n        companion object : Beta() {\n            class FromCompanionA\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        class FromFarAway\n\n    }\n\n    open class Gamma {\n        class FromGamma\n        companion object : FarAway() {\n            class FromCompanionGamma\n        }\n    }\n\n    open class B : A() {\n        class FromB\n\n        companion object : Gamma() {\n            class FromCompanionB\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    class FromDelta\n}\n\nclass C : O.B() {\n    companion object : Delta() {\n        class FromCompanionC\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    val c = FromA()\n    val d = FromB()\n\n    // VISIBLE: Classifiers from our own companion\n    val n = FromCompanionC()\n\n    // INVISIBLE: direct superclasses themselves.\n    val a = <!UNRESOLVED_REFERENCE!>A<!>()\n    val b = <!UNRESOLVED_REFERENCE!>B<!>()\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    val e = <!UNRESOLVED_REFERENCE!>FromCompanionA<!>()\n    val f = <!UNRESOLVED_REFERENCE!>FromCompanionB<!>()\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    val g = <!UNRESOLVED_REFERENCE!>Alpha<!>()\n    val h = <!UNRESOLVED_REFERENCE!>Beta<!>()\n    val i = <!UNRESOLVED_REFERENCE!>Gamma<!>()\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    val k = <!UNRESOLVED_REFERENCE!>FromAlpha<!>()\n    val l = <!UNRESOLVED_REFERENCE!>FromBeta<!>()\n    val m = <!UNRESOLVED_REFERENCE!>FromGamma<!>()\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    val o = <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>()\n    val p = <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>()\n    val q = <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>()\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    val r = <!UNRESOLVED_REFERENCE!>FromDelta<!>()\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: test/Java.java\npackage test;\n\npublic class Java {\n    public static void method() { }\n    public static int property = 42;\n    public static class Classifier { }\n    public static void syntheticSam(Runnable r) { }\n\n    public static int getStaticSyntheticProperty() { return 42; }\n    public static int setStaticSyntheticProperty(int x) { return 42; }\n\n    public int getInstanceSyntheticProperty() { return 42; }\n    public int setInstanceSyntheticProperty(int x) { return 42; }\n}\n\n// FILE: Kotlin.kt\npackage test\n\nimport test.Java.method\nimport test.Java.Classifier\nimport test.Java.property\nimport test.Java.syntheticSam\n\nopen class Base {\n    companion object : Java() {\n\n    }\n}\n\nclass Derived : Base() {\n    fun test(javaStaticInTypePosition: Classifier) {\n        method()\n        property\n        Classifier()\n        syntheticSam { }\n\n        // Instance members shouldn't be affected, but we check them, just in case\n        val y = instanceSyntheticProperty\n        instanceSyntheticProperty = 43\n\n        // Note that statics actually aren't converted into synthetic property in Kotlin\n        val x = <!UNRESOLVED_REFERENCE!>syntheticProperty<!>\n        <!UNRESOLVED_REFERENCE!>syntheticProperty<!> = 42\n    }\n\n    class JavaStaticInSupertypeList : Classifier() {\n\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// See KT-21515 for a class diagram and details\n\n// Object is to prevent accidental short-name import\nobject O {\n    open class Alpha {\n        class FromAlpha\n\n        companion object {\n            class FromCompanionAlpha\n        }\n    }\n\n    open class Beta : Alpha() {\n        class FromBeta\n\n        companion object {\n            class FromCompanionBeta\n        }\n    }\n\n\n    open class A {\n        class FromA\n\n        companion object : Beta() {\n            class FromCompanionA\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        class FromFarAway\n\n    }\n\n    open class Gamma {\n        class FromGamma\n        companion object : FarAway() {\n            class FromCompanionGamma\n        }\n    }\n\n    open class B : A() {\n        class FromB\n\n        companion object : Gamma() {\n            class FromCompanionB\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    class FromDelta\n}\n\nclass C : O.B() {\n    companion object : Delta() {\n        class FromCompanionC\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    val c: FromA? = null\n    val d: FromB? = null\n\n    // VISIBLE: Classifiers from our own companion\n    val n: FromCompanionC? = null\n\n    // INVISIBLE: direct superclasses themselves.\n    val a: <!UNRESOLVED_REFERENCE!>A<!>? = null\n    val b: <!UNRESOLVED_REFERENCE!>B<!>? = null\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    val e: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionA<!>? = null\n    val f: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionB<!>? = null\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    val g: <!UNRESOLVED_REFERENCE!>Alpha<!>? = null\n    val h: <!UNRESOLVED_REFERENCE!>Beta<!>? = null\n    val i: <!UNRESOLVED_REFERENCE!>Gamma<!>? = null\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    val k: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromAlpha<!>? = null\n    val l: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBeta<!>? = null\n    val m: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromGamma<!>? = null\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    val o: <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>? = null\n    val p: <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>? = null\n    val q: <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>? = null\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    val r: <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromDelta<!>? = null\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\n// See KT-21515 for a class diagram and details\n\n// Object is to prevent accidental short-name import\nobject O {\n    open class Alpha {\n        class FromAlpha\n\n        companion object {\n            class FromCompanionAlpha\n        }\n    }\n\n    open class Beta : Alpha() {\n        class FromBeta\n\n        companion object {\n            class FromCompanionBeta\n        }\n    }\n\n\n    open class A {\n        class FromA\n\n        companion object : Beta() {\n            class FromCompanionA\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        class FromFarAway\n\n    }\n\n    open class Gamma {\n        class FromGamma\n        companion object : FarAway() {\n            class FromCompanionGamma\n        }\n    }\n\n    open class B : A() {\n        class FromB\n\n        companion object : Gamma() {\n            class FromCompanionB\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    class FromDelta\n}\n\nclass C : O.B() {\n    companion object : Delta() {\n        class FromCompanionC\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    val c: FromA? = null\n    val d: FromB? = null\n\n    // VISIBLE: Classifiers from our own companion\n    val n: FromCompanionC? = null\n\n    // INVISIBLE: direct superclasses themselves.\n    val a: <!UNRESOLVED_REFERENCE!>A<!>? = null\n    val b: <!UNRESOLVED_REFERENCE!>B<!>? = null\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    val e: <!UNRESOLVED_REFERENCE!>FromCompanionA<!>? = null\n    val f: <!UNRESOLVED_REFERENCE!>FromCompanionB<!>? = null\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    val g: <!UNRESOLVED_REFERENCE!>Alpha<!>? = null\n    val h: <!UNRESOLVED_REFERENCE!>Beta<!>? = null\n    val i: <!UNRESOLVED_REFERENCE!>Gamma<!>? = null\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    val k: <!UNRESOLVED_REFERENCE!>FromAlpha<!>? = null\n    val l: <!UNRESOLVED_REFERENCE!>FromBeta<!>? = null\n    val m: <!UNRESOLVED_REFERENCE!>FromGamma<!>? = null\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    val o: <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>? = null\n    val p: <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>? = null\n    val q: <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>? = null\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    val r: <!UNRESOLVED_REFERENCE!>FromDelta<!>? = null\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\nopen class Base {\n    companion object {\n        annotation class Foo\n    }\n}\n\nclass Derived : Base() {\n\n    @<!DEPRECATED_ACCESS_BY_SHORT_NAME!>Foo<!>\n    fun foo() = 42\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n// See KT-21515 for a open class diagram and details\n\n// Object is to prevent accidental short-name import\nobject O {\n    open class Alpha {\n        open class FromAlpha\n\n        companion object {\n            open class FromCompanionAlpha\n        }\n    }\n\n    open class Beta : Alpha() {\n        open class FromBeta\n\n        companion object {\n            open class FromCompanionBeta\n        }\n    }\n\n\n    open class A {\n        open class FromA\n\n        companion object : Beta() {\n            open class FromCompanionA\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        open class FromFarAway\n\n    }\n\n    open class Gamma {\n        open class FromGamma\n        companion object : FarAway() {\n            open class FromCompanionGamma\n        }\n    }\n\n    open class B : A() {\n        open class FromB\n\n        companion object : Gamma() {\n            open class FromCompanionB\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    open class FromDelta\n}\n\nopen class C : O.B() {\n    companion object : Delta() {\n        open class FromCompanionC\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    open class c : FromA()\n    open class d : FromB()\n\n    // VISIBLE: Classifiers from our own companion\n    open class n : FromCompanionC()\n\n    // INVISIBLE: direct superclasses themselves.\n    open class a : <!UNRESOLVED_REFERENCE!>A<!>()\n    open class b : <!UNRESOLVED_REFERENCE!>B<!>()\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    open class e : <!UNRESOLVED_REFERENCE!>FromCompanionA<!>()\n    open class f : <!UNRESOLVED_REFERENCE!>FromCompanionB<!>()\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    open class g : <!UNRESOLVED_REFERENCE!>Alpha<!>()\n    open class h : <!UNRESOLVED_REFERENCE!>Beta<!>()\n    open class i : <!UNRESOLVED_REFERENCE!>Gamma<!>()\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    open class k : <!UNRESOLVED_REFERENCE!>FromAlpha<!>()\n    open class l : <!UNRESOLVED_REFERENCE!>FromBeta<!>()\n    open class m : <!UNRESOLVED_REFERENCE!>FromGamma<!>()\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    open class o : <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>()\n    open class p : <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>()\n    open class q : <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>()\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    open class r : <!UNRESOLVED_REFERENCE!>FromDelta<!>()\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\n// ===== Case 1: LHS is a class\n//\nobject A {\n    open class Base {\n        companion object {\n            class FromBaseCompanion {\n                fun foo() = 42\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = A.Base.Companion.FromBaseCompanion::foo\n    }\n}\n\n// ===== Case 2: LHS is a class with companion object, function comes from class\n\nobject B {\n    open class Base {\n        companion object {\n            class FromBaseCompanion {\n                fun foo() = 42\n\n                companion object {}\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = B.Base.Companion.FromBaseCompanion::foo\n    }\n}\n\n// ==== Case 3: LHS is a class with companion object, function comes from companion\n\nobject C {\n    open class Base {\n        companion object {\n            class FromBaseCompanion {\n                companion object {\n                    fun foo() = 42\n                }\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = C.Base.Companion.FromBaseCompanion::<!UNRESOLVED_REFERENCE!>foo<!>\n    }\n}\n\n// ==== Case 4: LHS is an object\n\nobject D {\n    open class Base {\n        companion object {\n            object FromBaseCompanion {\n                fun foo() = 42\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = D.Base.Companion.FromBaseCompanion::foo\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// See KT-21515 for a class diagram and details\n\n// class is to prevent accidental short-name import\nclass O {\n    open class Alpha {\n        open fun foo() = 42\n\n        class FromAlpha {\n            fun foo() = 42\n        }\n\n        companion object {\n            class FromCompanionAlpha {\n                fun foo() = 42\n            }\n        }\n    }\n\n    open class Beta : Alpha() {\n        override fun foo() = 42\n\n        class FromBeta {\n            fun foo() = 42\n        }\n\n        companion object {\n            class FromCompanionBeta {\n                fun foo() = 42\n            }\n        }\n    }\n\n\n    open class A {\n        open fun foo() = 42\n\n        class FromA {\n            fun foo() = 42\n        }\n\n        companion object : Beta() {\n            class FromCompanionA {\n                fun foo() = 42\n            }\n        }\n    }\n\n//////////////////////////\n\n    open class FarAway {\n        open fun foo() = 42\n\n        class FromFarAway {\n            fun foo() = 42\n        }\n\n    }\n\n    open class Gamma {\n        open fun foo() = 42\n\n        class FromGamma {\n            fun foo() = 42\n        }\n\n        companion object : FarAway() {\n            class FromCompanionGamma {\n                fun foo() = 42\n            }\n        }\n    }\n\n    open class B : A() {\n        override fun foo() = 42\n\n        class FromB {\n            fun foo() = 42\n        }\n\n        companion object : Gamma() {\n            override fun foo() = 42\n\n            class FromCompanionB {\n                fun foo() = 42\n            }\n        }\n    }\n}\n\n///////////////////////////////\n\n\nopen class Delta {\n    open fun foo() = 42\n    class FromDelta {\n        fun foo() = 42\n    }\n}\n\nclass C : O.B() {\n    override fun foo() = 42\n\n    companion object : Delta() {\n        class FromCompanionC {\n            fun foo() = 42\n        }\n    }\n\n    // VISIBLE: Classifiers from direct superclasses\n    val c = FromA::foo\n    val d = FromB::foo\n\n    // VISIBLE: Classifiers from our own companion\n    val n = FromCompanionC::foo\n\n    // INVISIBLE: direct superclasses themselves.\n    val a = <!UNRESOLVED_REFERENCE!>A<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val b = <!UNRESOLVED_REFERENCE!>A<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // DEPRECATED: Classifiers from companions of direct superclasses\n    val e = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionA<!>::foo\n    val f = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromCompanionB<!>::foo\n\n    // INVISIBLE: \"cousin\" supertypes themselves\n    val g = <!UNRESOLVED_REFERENCE!>Alpha<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val h = <!UNRESOLVED_REFERENCE!>Beta<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val i = <!UNRESOLVED_REFERENCE!>Gamma<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // DEPRECATED: classifiers from \"cousin\" superclasses\n    val k = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromAlpha<!>::foo\n    val l = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromBeta<!>::foo\n    val m = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromGamma<!>::foo\n\n    // INVISIBLE: We don't see classifiers from companions of \"cousin\" superclasses\n    val o = <!UNRESOLVED_REFERENCE!>FromCompanionAlpha<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val p = <!UNRESOLVED_REFERENCE!>FromCompanionBeta<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val q = <!UNRESOLVED_REFERENCE!>FromCompanionGamma<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n\n    // DEPRECATED: Classifiers from supertypes of our own companion\n    val r = <!DEPRECATED_ACCESS_BY_SHORT_NAME!>FromDelta<!>::foo\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n\nimport A.Base.Companion.FromABaseCompanion\nimport B.Base.Companion.FromBBaseCompanion\nimport C.Base.Companion.FromCBaseCompanion\nimport D.Base.Companion.FromDBaseCompanion\n\n// ===== Case 1: LHS is a class\n//\nobject A {\n    open class Base {\n        companion object {\n            class FromABaseCompanion {\n                fun foo() = 42\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = FromABaseCompanion::foo\n    }\n}\n\n// ===== Case 2: LHS is a class with companion object, function comes from class\n\nobject B {\n    open class Base {\n        companion object {\n            class FromBBaseCompanion {\n                fun foo() = 42\n\n                companion object {}\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = FromBBaseCompanion::foo\n    }\n}\n\n// ==== Case 3: LHS is a class with companion object, function comes from companion\n\nobject C {\n    open class Base {\n        companion object {\n            class FromCBaseCompanion {\n                companion object {\n                    fun foo() = 42\n                }\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = FromCBaseCompanion::<!UNRESOLVED_REFERENCE!>foo<!>\n    }\n}\n\n// ==== Case 4: LHS is an object\n\nobject D {\n    open class Base {\n        companion object {\n            object FromDBaseCompanion {\n                fun foo() = 42\n            }\n        }\n    }\n\n    class Derived : Base() {\n        val a = FromDBaseCompanion::foo\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun foo() {\n    <!LOCAL_OBJECT_NOT_ALLOWED!>object a<!> {}\n    val b = object {\n        <!LOCAL_OBJECT_NOT_ALLOWED!>object c<!> {}\n    }\n    b.<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE!>c<!>\n    class A {\n        <!LOCAL_OBJECT_NOT_ALLOWED!>object d<!> {}\n    }\n    val f = {\n        <!LOCAL_OBJECT_NOT_ALLOWED!>object e<!> {}\n    }\n}"
        },
        {
            "code": "package a\n\n//KT-2240 Wrong overload resolution ambiguity when object literal is involved\n\nclass A {}\n\nfun <T> A.foo(<!UNUSED_PARAMETER!>f<!> : T) {}\n\nval o = object {\n    fun <T> foo(f: T) {\n        A().foo(f) // Ambiguity here!\n    }\n}"
        },
        {
            "code": "//no nested class access via instance reference error\nfun test() {\n    A.Companion.f(<!TYPE_MISMATCH!>\"\"<!>)\n}\n\nclass A() {\n    companion object {\n        object f {\n            operator fun invoke(i: Int) = i\n        }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nobject Boo {}\nclass A {\n    object Boo {}\n}\n\nfun foo() {\n    val i1: Int = <!TYPE_MISMATCH!>Boo<!>\n    val i2: Int = <!TYPE_MISMATCH!>A.Boo<!>\n    useInt(<!TYPE_MISMATCH!>Boo<!>)\n    useInt(<!TYPE_MISMATCH!>A.Boo<!>)\n}\nfun bar() {\n    val i1: Int = <!TYPE_MISMATCH!>Unit<!>\n    useInt(<!TYPE_MISMATCH!>Unit<!>)\n}\n\nfun useInt(i: Int) = i\n"
        },
        {
            "code": "// NI_EXPECTED_FILE\n\npackage localObjects\n\nobject A {\n    val x : Int = 0\n}\n\nopen class Foo {\n    fun foo() : Int = 1\n}\n\nfun test() {\n    A.x\n    val b = object : Foo() {\n    }\n    b.foo()\n\n    <!LOCAL_OBJECT_NOT_ALLOWED!>object B<!> {\n        fun foo() {}\n    }\n    B.foo()\n}\n\nval bb = <!UNRESOLVED_REFERENCE!>B<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()"
        },
        {
            "code": "package toplevelObjectDeclarations\n\n  open class Foo(<!UNUSED_PARAMETER!>y<!> : Int) {\n    open fun foo() : Int = 1\n  }\n\n  class T : <!SUPERTYPE_NOT_INITIALIZED!>Foo<!> {}\n\n  object A : <!SUPERTYPE_NOT_INITIALIZED!>Foo<!> {\n    val x : Int = 2\n\n    fun test() : Int {\n      return x + foo()\n    }\n  }\n\n  object B : <!SINGLETON_IN_SUPERTYPE!>A<!> {}\n\n  val x = A.foo()\n\n  val y = object : Foo(x) {\n    init {\n      x + 12\n    }\n\n    override fun foo() : Int = 1\n  }\n\n  val z = y.foo()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninfix fun Any?.foo(a: Any) {}\noperator fun Any?.contains(a: Any): Boolean = true\n\nfun test(a: Any) {\n\n    a <!UNSUPPORTED!>foo<!>\"\"\n    a <!UNSUPPORTED!>foo<!>\"asd\"\n    a <!UNSUPPORTED!>foo<!>\"$a\"\n    a <!UNSUPPORTED!>foo<!>\"asd${a}sfsa\"\n    a <!UNSUPPORTED!>foo<!>\"\"\"sdf\"\"\"\n    a <!UNSUPPORTED!>foo<!>'d'\n    a <!UNSUPPORTED!>foo<!><!EMPTY_CHARACTER_LITERAL!>''<!>\n\n    a <!UNSUPPORTED!>foo<!>\"\"<!UNSUPPORTED!>foo<!> a\n    a <!UNSUPPORTED!>foo<!>\"asd\"<!UNSUPPORTED!>foo<!> a\n    a <!UNSUPPORTED!>foo<!>\"$a\"<!UNSUPPORTED!>foo<!> a\n    a <!UNSUPPORTED!>foo<!>\"asd${a}sfsa\"<!UNSUPPORTED!>foo<!> a\n    a <!UNSUPPORTED!>foo<!>\"\"\"sdf\"\"\"<!UNSUPPORTED!>foo<!> a\n    a <!UNSUPPORTED!>foo<!>'d'<!UNSUPPORTED!>foo<!> a\n    a <!UNSUPPORTED!>foo<!><!EMPTY_CHARACTER_LITERAL!>''<!><!UNSUPPORTED!>foo<!> a\n\n    a <!UNSUPPORTED!>in<!>\"foo\"\n    a <!UNSUPPORTED!>in<!>\"\"\"foo\"\"\"\n    a <!UNSUPPORTED!>in<!>'s'\n    a <!UNSUPPORTED!>in<!><!EMPTY_CHARACTER_LITERAL!>''<!>\n\n    a <!UNSUPPORTED!>!in<!>\"foo\"\n    a <!UNSUPPORTED!>!in<!>\"\"\"foo\"\"\"\n    a <!UNSUPPORTED!>!in<!>'s'\n    a <!UNSUPPORTED!>!in<!><!EMPTY_CHARACTER_LITERAL!>''<!>\n\n    if(<!USELESS_IS_CHECK!>\"s\"<!UNSUPPORTED!>is<!> Any<!>) {}\n    if(<!USELESS_IS_CHECK!>\"s\"<!UNSUPPORTED!>is<!> Any<!>) {}\n    test(\"s\"<!UNSUPPORTED!>as<!> Any)\n\n    a <!UNSUPPORTED!>foo<!>\"\"<!SYNTAX, UNSUPPORTED!>1<!>\n    a <!UNSUPPORTED!>foo<!>\"\"<!SYNTAX, UNSUPPORTED!>1.0<!>\n}"
        },
        {
            "code": "class Pair<out A, out B>(val first: A, val second: B)\n\nclass Example {\n    infix fun to(other: Example) = Pair(this, other)\n    fun toNonInfix(other: Example) = Pair(this, other)\n}\n\ninfix fun Example.toExt(other: Example) = Pair(this, other)\nfun Example.toExtNonInfix(other: Example) = Pair(this, other)\n\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun Example.toExtWithExtraParams(other: Example, <!UNUSED_PARAMETER!>blah<!>: Int = 0) = Pair(this, other)\nfun Example.toExtNonInfixWithExtraParams(other: Example, <!UNUSED_PARAMETER!>blah<!>: Int = 0) = Pair(this, other)\n\n<!INAPPLICABLE_INFIX_MODIFIER!>infix<!> fun Example.toExtDefaultValues(other: Example? = null, <!UNUSED_PARAMETER!>blah<!>: Int = 0) = Pair(this, other)\nfun Example.toExtNonInfixDefaultValues(other: Example? = null, <!UNUSED_PARAMETER!>blah<!>: Int = 0) = Pair(this, other)\n\nfun Example.withLambda(f: () -> Unit) = Pair(this, f)\n\nfun test() {\n    Example() to Example()\n    Example() <!INFIX_MODIFIER_REQUIRED!>toNonInfix<!> Example()\n    Example().toNonInfix(Example())\n\n    val a = Example()\n    val b = Example()\n\n    a toExt b\n    a <!INFIX_MODIFIER_REQUIRED!>toExtNonInfix<!> b\n    a.toExtNonInfix(b)\n\n    a toExtWithExtraParams b\n    a <!INFIX_MODIFIER_REQUIRED!>toExtNonInfixWithExtraParams<!> b\n\n    a toExtDefaultValues b\n    a <!INFIX_MODIFIER_REQUIRED!>toExtNonInfixDefaultValues<!> b\n\n    a <!INFIX_MODIFIER_REQUIRED!>withLambda<!> { }\n}"
        },
        {
            "code": "fun f() {<!SYNTAX!><!>\n"
        },
        {
            "code": "// NI_EXPECTED_FILE\n\ninterface T {\n  val a = <!PROPERTY_INITIALIZER_IN_INTERFACE!><!UNRESOLVED_REFERENCE!>Foo<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()<!>\n}"
        },
        {
            "code": "package unresolved\n\nclass Pair<A, B>(val a: A, val b: B)\n\nfun testGenericArgumentsCount() {\n    val <!UNUSED_VARIABLE!>p1<!>: Pair<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><Int><!> = Pair(2, 2)\n    val <!UNUSED_VARIABLE!>p2<!>: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Pair<!> = Pair(2, 2)\n}\n\nfun testUnresolved() {\n    if (<!UNRESOLVED_REFERENCE!>a<!> is String) {\n        val <!UNUSED_VARIABLE!>s<!> = <!UNRESOLVED_REFERENCE!>a<!>\n    }\n    <!UNRESOLVED_REFERENCE!>foo<!>(<!UNRESOLVED_REFERENCE!>a<!>)\n    val s = \"s\"\n    <!UNRESOLVED_REFERENCE!>foo<!>(s)\n    foo1(<!UNRESOLVED_REFERENCE!>i<!>)\n    s.<!UNRESOLVED_REFERENCE!>foo<!>()\n\n    when(<!UNRESOLVED_REFERENCE!>a<!>) {\n        is Int -> <!UNRESOLVED_REFERENCE!>a<!>\n        is String -> <!UNRESOLVED_REFERENCE!>a<!>\n    }\n\n    for (j in <!UNRESOLVED_REFERENCE!>collection<!>) {\n       var i: Int = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>j<!>\n       i += 1\n       foo1(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>j<!>)\n    }\n}\n\nfun foo1(<!UNUSED_PARAMETER!>i<!>: Int) {}"
        },
        {
            "code": "package abstract\n\ninterface MyTrait {\n    //properties\n    val a: Int\n    val a1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>1<!>\n    abstract val a2: Int\n    abstract val a3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>1<!>\n\n    var b: Int                                                                                              <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    var b1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;                                                <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n    abstract var b2: Int                                               <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    abstract var b3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n\n    <!BACKING_FIELD_IN_INTERFACE!>var c: Int<!>                                   set(v: Int) { field = v }\n    <!BACKING_FIELD_IN_INTERFACE!>var c1: Int<!> = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;              set(v: Int) { field = v }\n    abstract var c2: Int                     <!ABSTRACT_PROPERTY_WITH_SETTER!>set(v: Int) { field = v }<!>\n    abstract var c3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!ABSTRACT_PROPERTY_WITH_SETTER!>set(v: Int) { field = v }<!>\n\n    val e: Int                                                  get() = a\n    val e1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;                             get() = a\n    abstract val e2: Int                     <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = a<!>\n    abstract val e3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = a<!>\n\n    //methods\n    fun f()\n    fun g() {}\n    abstract fun h()\n    <!ABSTRACT_FUNCTION_WITH_BODY!>abstract<!> fun j() {}\n\n    //property accessors\n    var i: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var i1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var j: Int                       get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var j1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;  get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var k: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var k1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var l: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var l1: Int = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var n: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get <!WRONG_MODIFIER_TARGET!>abstract<!> set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n}"
        },
        {
            "code": "fun test() {\n    fun <T> foo(){}\n    foo<<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>in<!> Int>()\n}\n"
        },
        {
            "code": "fun bar(doIt: Int.() -> Int) {\n    1.doIt()\n    1<!UNNECESSARY_SAFE_CALL!>?.<!>doIt()\n    val i: Int? = 1\n    i<!UNSAFE_CALL!>.<!>doIt()\n    i?.doIt()\n}\n"
        },
        {
            "code": "interface In<in T>\ninterface Out<out T>\ninterface Inv<T>\n\nfun <T> getT(): T = null!!\n\nclass Test<in I, out O, P>(\n        val type1: <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>I<!>,\n        val type2: O,\n        val type3: P,\n        val type4: In<I>,\n        val type5: In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>,\n\n        var type6: <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"I\")!>I<!>,\n        var type7: <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"O\")!>O<!>,\n        var type8: P,\n        var type9: In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"In<I>\")!>I<!>>,\n        var type0: In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<O>\")!>O<!>>,\n\n        <!UNUSED_PARAMETER!>type11<!>: I,\n        <!UNUSED_PARAMETER!>type12<!>: O,\n        <!UNUSED_PARAMETER!>type13<!>: P,\n        <!UNUSED_PARAMETER!>type14<!>: In<I>,\n        <!UNUSED_PARAMETER!>type15<!>: In<O>\n)"
        },
        {
            "code": "// https://ea.jetbrains.com/browser/ea_reports/1337846\n\n//interface ComputablePoint<NumberType : Number>\n//\n//interface ComputableSegment<NumberType: Number, PointType>\n//\n//interface ComputableLineSegment<NumberType: Number, PointType> : ComputableSegment<NumberType, PointType>\n\n//interface Path<NumberType, PointType, SegmentType>\n\ntypealias EachSegmentComparator<SegmentType> = (currentSegment: SegmentType, otherSegment: SegmentType, relationship: Int) -> Boolean\n\ninterface ComputablePath<NumberType, PointType, out SegmentType>\n    : <!UNRESOLVED_REFERENCE!>Path<!><NumberType, PointType, SegmentType>\nwhere\n    NumberType: Number,\n    PointType: <!UNRESOLVED_REFERENCE!>ComputablePoint<!><NumberType>,\n    SegmentType: <!UNRESOLVED_REFERENCE!>ComputableLineSegment<!><NumberType, PointType>\n{\n    fun anyTwoSegments(comparator: EachSegmentComparator<<!UNRESOLVED_REFERENCE!>ComputableSegment<!><NumberType, PointType>>): Boolean\n}\n"
        },
        {
            "code": "interface In<in T>\ninterface Out<out T>\ninterface Inv<T>\ninterface Pair<out X, out Y>\n\ninterface Test<in I, out O, P> {\n    var ok1: Inv<P>\n    var ok2: P\n    var ok3: Out<In<P>>\n    var ok4: Pair<In<P>, Out<P>>\n    var ok5: Inv<out P>\n    var ok6: Inv<in P>\n    var ok7: Inv<out P>\n\n    var neOk1: <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"O\")!>O<!>\n    var neOk2: In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"In<I>\")!>I<!>>\n    var neOk3: In<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<In<O>>\")!>O<!>>>\n    var neOk4: Inv<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<I>\")!>I<!>>\n    var neOk5: Inv<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<O>\")!>O<!>>\n    var neOk6: In<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<In<O>>\")!>O<!>>>\n    var neOk7: Pair<In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Pair<In<I>, O>\")!>I<!>>, <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Pair<In<I>, O>\")!>O<!>>\n    var neOk8: Inv<in <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<in O>\")!>O<!>>\n    var neOk9: Inv<in <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<in I>\")!>I<!>>\n    var neOk10: In<<!CONFLICTING_PROJECTION!>out<!> I>\n\n    var neOk11: <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"I\")!>I<!>\n    var neOk12: In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<O>\")!>O<!>>\n    var neOk13: In<In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"In<In<I>>\")!>I<!>>>\n    var neOk14: Out<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Out<I>\")!>I<!>>\n    var neOk15: Out<Out<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Out<Out<I>>\")!>I<!>>>\n    var neOk16: Out<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Out<In<O>>\")!>O<!>>>\n    var neOk17: Pair<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Pair<In<O>, I>\")!>O<!>>, <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Pair<In<O>, I>\")!>I<!>>\n\n    var neOk20: Inv<in <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<in O>\")!>O<!>>\n    var neOk21: Inv<in <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<in I>\")!>I<!>>\n    var neOk22: Inv<out <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<out O>\")!>O<!>>\n    var neOk23: Inv<out <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<out I>\")!>I<!>>\n\n    var neOk30: Pair<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><I<!UNSUPPORTED_FEATURE!>,<!> ><!>\n    var neOk31: Pair<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Pair<I, [ERROR : Inv]>\")!>I<!>, <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inv<!>>\n    var neOk32: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inv<!>\n    var neOk33: Inv<<!SYNTAX!><!>>\n    var neOk34: Inv<<!UNRESOLVED_REFERENCE!>C<!>>\n    var neOk35: Inv<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><P, P><!>\n}"
        },
        {
            "code": "interface In<in T>\ninterface Out<out T>\ninterface Inv<T>\nfun <T> getT(): T = null!!\n\ninterface Test<in I, out O, P> {\n    fun parameters1(i: I, o: <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>, p: P)\n    fun parameters2(i: In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>)\n    fun parameters3(i: In<O>)\n\n    fun explicitReturnType1() : <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>I<!>\n    fun explicitReturnType2() : O\n    fun explicitReturnType3() : P\n    fun explicitReturnType4() : In<I>\n    fun explicitReturnType5() : In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>\n\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>fun imlicitReturnType1()<!> = getT<I>()\n    fun imlicitReturnType2() = getT<O>()\n    fun imlicitReturnType3() = getT<P>()\n    fun imlicitReturnType4() = getT<In<I>>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>fun imlicitReturnType5()<!> = getT<In<O>>()\n\n    fun I.receiver1()\n    fun <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>.receiver2()\n    fun P.receiver3()\n    fun In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>.receiver4()\n    fun In<O>.receiver5()\n\n    fun <X : I> typeParameter1()\n    fun <X : <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>> typeParameter2()\n    fun <X : P> typeParameter3()\n    fun <X : In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>> typeParameter4()\n    fun <X : In<O>> typeParameter5()\n}"
        },
        {
            "code": "interface In<in T>\nfun <T> getT(): T = null!!\n\ninterface Test<in I, out O, P> {\n    fun ok1(i: (O) -> I) : (I) -> O\n    fun ok2(i: (P) -> P) : (P) -> P\n    fun ok3(i: (In<I>) -> In<O>) = getT<(In<O>) -> In<I>>()\n\n    fun neOk1(i: (<!TYPE_VARIANCE_CONFLICT!>I<!>) -> <!TYPE_VARIANCE_CONFLICT!>O<!>): (<!TYPE_VARIANCE_CONFLICT!>O<!>) -> <!TYPE_VARIANCE_CONFLICT!>I<!>\n    fun neOk2(i: (In<<!TYPE_VARIANCE_CONFLICT!>O<!>>) -> In<<!TYPE_VARIANCE_CONFLICT!>I<!>>)\n    <!TYPE_VARIANCE_CONFLICT, TYPE_VARIANCE_CONFLICT!>fun neOk3()<!> = getT<(In<I>) -> In<O>>()\n}"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\ninterface In<in T>\ninterface Out<out T>\ninterface Inv<T>\n\nclass Delegate<T> {\n    operator fun getValue(t: Any, p: KProperty<*>): T = null!!\n    operator fun setValue(t: Any, p: KProperty<*>, varue: T) {}\n}\n\nfun <T> getT(): T = null!!\n\nabstract class Test<in I, out O, P> {\n    abstract var type1: <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"I\")!>I<!>\n    abstract var type2: <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"O\")!>O<!>\n    abstract var type3: P\n    abstract var type4: In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"In<I>\")!>I<!>>\n    abstract var type5: In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<O>\")!>O<!>>\n\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"I\")!>var implicitType1<!> = getT<I>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"O\")!>var implicitType2<!> = getT<O>()\n    var implicitType3 = getT<P>()\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"In<I>\")!>var implicitType4<!> = getT<In<I>>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<O>\")!>var implicitType5<!> = getT<In<O>>()\n\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"I\")!>var delegateType1<!> by Delegate<I>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"O\")!>var delegateType2<!> by Delegate<O>()\n    var delegateType3 by Delegate<P>()\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"In<I>\")!>var delegateType4<!> by Delegate<In<I>>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"In<O>\")!>var delegateType5<!> by Delegate<In<O>>()\n\n    abstract var I.receiver1: Int\n    abstract var <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>.receiver2: Int\n    abstract var P.receiver3: Int\n    abstract var In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>.receiver4: Int\n    abstract var In<O>.receiver5: Int\n\n    var <X : I> X.typeParameter1: Int get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X : <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>> X.typeParameter2: Int get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X : P> X.typeParameter3: Int get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X : In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>> X.typeParameter4: Int get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X : In<O>> X.typeParameter5: Int get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n\n    var <X> X.typeParameter6: Int where X : I get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X> X.typeParameter7: Int where X : <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!> get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X> X.typeParameter8: Int where X : P get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X> X.typeParameter9: Int where X : In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>> get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n    var <X> X.typeParameter0: Int where X : In<O> get() = 0; set(<!UNUSED_PARAMETER!>i<!>) {}\n}\n"
        },
        {
            "code": "interface In<in T>\ninterface Out<out T>\ninterface Inv<T>\ninterface Pair<out X, out Y>\n\ninterface Test<in I, out O, P> {\n    fun ok1(i: I)\n    fun ok2(i: In<O>)\n    fun ok3(i: In<In<I>>)\n    fun ok4(i: Inv<P>)\n    fun ok5(i: P)\n    fun ok6(i: Out<I>)\n    fun ok7(i: Out<Out<I>>)\n    fun ok8(i: Out<In<O>>)\n    fun ok9(i: Out<In<P>>)\n    fun Ok10(i: I)\n    fun Ok11(i: In<O>)\n    fun Ok12(i: In<In<I>>)\n    fun Ok13(i: Out<I>)\n    fun Ok14(i: Pair<In<O>, I>)\n    fun Ok15(i: Inv<out I>)\n\n    fun Ok20(i: Inv<in O>)\n    fun Ok21(i: Inv<in P>)\n    fun Ok22(i: Inv<out I>)\n    fun Ok23(i: Inv<out P>)\n\n    fun neOk1(i: <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>)\n    fun neOk2(i: In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>)\n    fun neOk3(i: In<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<In<O>>\")!>O<!>>>)\n    fun neOk4(i: Inv<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<I>\")!>I<!>>)\n    fun neOk5(i: Inv<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<O>\")!>O<!>>)\n    fun neOk6(i: In<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<In<O>>\")!>O<!>>>)\n    fun neOk7(i: Pair<In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Pair<In<I>, O>\")!>I<!>>, <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Pair<In<I>, O>\")!>O<!>>)\n    fun neOk8(i: Inv<out <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Inv<out O>\")!>O<!>>)\n    fun neOk9(i: In<<!CONFLICTING_PROJECTION!>out<!> P>)\n    fun neOk10(i: Out<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Out<O>\")!>O<!>>)\n\n    fun neOk11(i: Inv<in <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Inv<in I>\")!>I<!>>)\n    fun neOk12(i: Inv<out <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Inv<out O>\")!>O<!>>)\n\n    fun neOk30(i: Pair<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><O<!UNSUPPORTED_FEATURE!>,<!> ><!>)\n    fun neOk31(i: Pair<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Pair<O, [ERROR : Inv]>\")!>O<!>, <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inv<!>>)\n    fun neOk32(i: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inv<!>)\n    fun neOk33(i: Inv<<!SYNTAX!><!>>)\n    fun neOk34(i: Inv<<!UNRESOLVED_REFERENCE!>C<!>>)\n    fun neOk35(i: Inv<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><P, P><!>)\n}"
        },
        {
            "code": "fun <T> getT(): T = null!!\n\nclass Test<in I, out O> {\n    private val i: I = getT()\n\n    init {\n        apply(i)\n        apply(this.i)\n    }\n\n    fun apply(<!UNUSED_PARAMETER!>i<!>: I) {}\n\n    fun test() {\n        apply(i)\n        apply(this.i)\n        with(Test<I, O>()) {\n            apply(i) // resolved to this@Test.i\n            apply(this.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!>)\n            apply(this@with.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!>)\n            apply(this@Test.i)\n        }\n    }\n\n    fun <I, O> test(t: Test<I, O>) {\n        t.apply(t.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!>)\n    }\n\n    companion object {\n        fun <I, O> test(t: Test<I, O>) {\n            t.apply(t.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!>)\n        }\n    }\n}\n\nfun <I, O> test(t: Test<I, O>) {\n    t.apply(t.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!>)\n}\n"
        },
        {
            "code": "fun <T> getT(): T = null!!\n\nclass Test<in I, out O> {\n    private var i: I = getT()\n    private val j: I\n\n    init {\n        j = getT()\n        i = getT()\n        this.i = getT()\n    }\n\n    fun test() {\n        i = getT()\n        this.i = getT()\n        with(Test<I, O>()) {\n            i = getT() // resolved to this@Test.i\n            this.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!> = getT()\n            this@with.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!> = getT()\n            this@Test.i  = getT()\n        }\n    }\n\n    fun <I, O> test(t: Test<I, O>) {\n        t.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!> = getT()\n    }\n\n    companion object {\n        fun <I, O> test(t: Test<I, O>) {\n            t.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!> = getT()\n        }\n    }\n}\n\nfun <I, O> test(t: Test<I, O>) {\n    t.<!INVISIBLE_MEMBER(\"i\", \"private/*private to this*/\", \"'Test'\")!>i<!> = getT()\n}\n"
        },
        {
            "code": "fun <T> getT(): T = null!!\n\nclass Test<in I> {\n    private fun foo() : I = getT()\n\n    fun apply(<!UNUSED_PARAMETER!>i<!>: I) {}\n\n    init {\n        foo()\n        this.foo()\n    }\n\n    fun test() {\n        apply(foo())\n        apply(this.foo())\n        with(Test<I>()) {\n            apply(foo()) // resolved to this@Test.foo\n            apply(this.<!INVISIBLE_MEMBER(\"foo\", \"private/*private to this*/\", \"'Test'\")!>foo<!>())\n            apply(this@with.<!INVISIBLE_MEMBER(\"foo\", \"private/*private to this*/\", \"'Test'\")!>foo<!>())\n            apply(this@Test.foo())\n        }\n    }\n\n    fun <I> test(t: Test<I>) {\n        t.apply(t.<!INVISIBLE_MEMBER(\"foo\", \"private/*private to this*/\", \"'Test'\")!>foo<!>())\n    }\n\n    companion object {\n        fun <I> test(t: Test<I>) {\n            t.apply(t.<!INVISIBLE_MEMBER(\"foo\", \"private/*private to this*/\", \"'Test'\")!>foo<!>())\n        }\n    }\n}\n\nfun <I> test(t: Test<I>) {\n    t.apply(t.<!INVISIBLE_MEMBER(\"foo\", \"private/*private to this*/\", \"'Test'\")!>foo<!>())\n}\n"
        },
        {
            "code": "interface In<in T>\ninterface Out<out T>\ninterface Inv<T>\n\ninterface TypeBounds1<in I, out O, P, X : <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>I<!>>\ninterface TypeBounds2<in I, out O, P, X : O>\ninterface TypeBounds3<in I, out O, P, X : P>\ninterface TypeBounds4<in I, out O, P, X : In<I>>\ninterface TypeBounds5<in I, out O, P, X : In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>>\n\ninterface WhereTypeBounds1<in I, out O, P, X> where X : <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>I<!>\ninterface WhereTypeBounds2<in I, out O, P, X> where X : O\ninterface WhereTypeBounds3<in I, out O, P, X> where X : P\ninterface WhereTypeBounds4<in I, out O, P, X> where X : In<I>\ninterface WhereTypeBounds5<in I, out O, P, X> where X : In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>\n\nclass SubClass1<in I, out O, P> : Out<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Out<I>\")!>I<!>>\nclass SubClass2<in I, out O, P> : Out<O>\nclass SubClass3<in I, out O, P> : Out<P>\nclass SubClass4<in I, out O, P> : In<I>\nclass SubClass5<in I, out O, P> : In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>\nclass SubClass6<in I, out O, P> : Inv<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<O>\")!>O<!>>\nclass SubClass7<in I, out O, P> : Inv<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<I>\")!>I<!>>"
        },
        {
            "code": "import kotlin.reflect.KProperty\n\ninterface In<in T>\ninterface Out<out T>\ninterface Inv<T>\n\nclass Delegate<T> {\n    operator fun getValue(t: Any, p: KProperty<*>): T = null!!\n    operator fun setValue(t: Any, p: KProperty<*>, value: T) {}\n}\n\nfun <T> getT(): T = null!!\n\nabstract class Test<in I, out O, P> {\n    abstract val type1: <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>I<!>\n    abstract val type2: O\n    abstract val type3: P\n    abstract val type4: In<I>\n    abstract val type5: In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>\n\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>val implicitType1<!> = getT<I>()\n    val implicitType2 = getT<O>()\n    val implicitType3 = getT<P>()\n    val implicitType4 = getT<In<I>>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>val implicitType5<!> = getT<In<O>>()\n\n    <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>val delegateType1<!> by Delegate<I>()\n    val delegateType2 by Delegate<O>()\n    val delegateType3 by Delegate<P>()\n    val delegateType4 by Delegate<In<I>>()\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>val delegateType5<!> by Delegate<In<O>>()\n\n    abstract val I.receiver1: Int\n    abstract val <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>.receiver2: Int\n    abstract val P.receiver3: Int\n    abstract val In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>.receiver4: Int\n    abstract val In<O>.receiver5: Int\n\n    val <X : I> X.typeParameter1: Int get() = 0\n    val <X : <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!>> X.typeParameter2: Int get() = 0\n    val <X : P> X.typeParameter3: Int get() = 0\n    val <X : In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>>> X.typeParameter4: Int get() = 0\n    val <X : In<O>> X.typeParameter5: Int get() = 0\n\n    val <X> X.typeParameter6: Int where X : I get() = 0\n    val <X> X.typeParameter7: Int where X : <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O\")!>O<!> get() = 0\n    val <X> X.typeParameter8: Int where X : P get() = 0\n    val <X> X.typeParameter9: Int where X : In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<I>\")!>I<!>> get() = 0\n    val <X> X.typeParameter0: Int where X : In<O> get() = 0\n}\n"
        },
        {
            "code": "interface In<in I>\ninterface Out<out O>\ninterface Inv<P>\nfun <T> getT(): T = null!!\n\n\ninterface Test<in I : Any, out O : Any, P : Any> {\n    fun ok1(i: I?) : O?\n    fun ok2(i: In<O?>?) : Out<O?>?\n    fun ok3(i: Inv<in O?>) = getT<Inv<in I?>>()\n\n    fun neOk1(i: <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"O?\")!>O?<!>) : <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I?\")!>I?<!>\n    fun neOk(i: Out<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Out<O?>?\")!>O?<!>>?) : In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O?>?\")!>O?<!>>?\n    fun neOk3(i: Inv<in <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Inv<in I?>\")!>I?<!>>)\n    <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Inv<in O?>?\")!>fun neOk4()<!> = getT<Inv<in O?>?>()\n}"
        },
        {
            "code": "interface In<in T>\ninterface Out<out T>\ninterface Inv<T>\ninterface Pair<out X, out Y>\n\ninterface Test<in I, out O, P> {\n    fun ok1(): O\n    fun ok2(): In<I>\n    fun ok3(): In<In<O>>\n    fun ok4(): Inv<P>\n    fun ok5(): P\n    fun ok6(): Out<O>\n    fun ok7(): Out<P>\n    fun ok8(): Out<In<P>>\n    fun ok9(): Pair<In<I>, O>\n    \n    fun ok10(): Inv<in I>\n    fun ok11(): Inv<out O>\n    fun ok12(): Inv<in P>\n    fun ok13(): Inv<out P>\n\n    fun neOk1(): <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"I\")!>I<!>\n    fun neOk2(): In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"In<O>\")!>O<!>>\n    fun neOk3(): In<In<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"In<In<I>>\")!>I<!>>>\n    fun neOk4(): Inv<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"invariant\", \"Inv<I>\")!>I<!>>\n    fun neOk5(): Inv<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"invariant\", \"Inv<O>\")!>O<!>>\n    fun neOk6(): Pair<In<<!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Pair<In<O>, I>\")!>O<!>>, <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Pair<In<O>, I>\")!>I<!>>\n    fun neOk7(): Inv<in <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Inv<in O>\")!>O<!>>\n    fun neOk8(): Out<<!CONFLICTING_PROJECTION(\"Out\")!>in<!> I>\n    \n    fun neOk10(): Inv<in <!TYPE_VARIANCE_CONFLICT(\"O\", \"out\", \"in\", \"Inv<in O>\")!>O<!>>\n    fun neOk11(): Inv<out <!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Inv<out I>\")!>I<!>>\n\n    fun neOk30(): Pair<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><I<!UNSUPPORTED_FEATURE!>,<!> ><!>\n    fun neOk31(): Pair<<!TYPE_VARIANCE_CONFLICT(\"I\", \"in\", \"out\", \"Pair<I, [ERROR : Inv]>\")!>I<!>, <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inv<!>>\n    fun neOk32(): <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Inv<!>\n    fun neOk33(): Inv<<!SYNTAX!><!>>\n    fun neOk34(): Inv<<!UNRESOLVED_REFERENCE!>C<!>>\n    fun neOk35(): Inv<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><P, P><!>\n}"
        },
        {
            "code": "interface Test<in I, out O> {\n    val internal_val: <!TYPE_VARIANCE_CONFLICT!>I<!>\n    public val public_val: <!TYPE_VARIANCE_CONFLICT!>I<!>\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> val protected_val: <!TYPE_VARIANCE_CONFLICT!>I<!>\n    <!PRIVATE_PROPERTY_IN_INTERFACE!>private<!> val private_val: I\n\n    var interlan_private_set: <!TYPE_VARIANCE_CONFLICT!>O<!>\n        <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    public var public_private_set: <!TYPE_VARIANCE_CONFLICT!>O<!>\n        <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> var protected_private_set: <!TYPE_VARIANCE_CONFLICT!>O<!>\n        <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    <!PRIVATE_PROPERTY_IN_INTERFACE!>private<!> var private_private_set: O\n        private set\n\n    fun internal_fun(i: <!TYPE_VARIANCE_CONFLICT!>O<!>) : <!TYPE_VARIANCE_CONFLICT!>I<!>\n    public fun public_fun(i: <!TYPE_VARIANCE_CONFLICT!>O<!>) : <!TYPE_VARIANCE_CONFLICT!>I<!>\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> fun protected_fun(i: <!TYPE_VARIANCE_CONFLICT!>O<!>) : <!TYPE_VARIANCE_CONFLICT!>I<!>\n    <!PRIVATE_FUNCTION_WITH_NO_BODY!>private<!> fun private_fun(i: O) : I\n}"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>annotation<!> enum class E {\n    D\n}"
        },
        {
            "code": "enum class MyEnum {\n    FIRST,\n    SECOND\n}\n\nfun foo(me: MyEnum): Boolean = me is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>FIRST<!><!>"
        },
        {
            "code": "enum class E {\n    ENTRY\n}\n\nclass A : E.<!ENUM_ENTRY_AS_TYPE!>ENTRY<!>\n"
        },
        {
            "code": "enum class<!SYNTAX!><!> {\n}"
        },
        {
            "code": "// !LANGUAGE: -NestedClassesInEnumEntryShouldBeInner\n\nenum class E {\n    FIRST,\n    SECOND {\n        <!NESTED_CLASS_DEPRECATED!>class A<!>\n    };\n}\n\nval foo: Any.() -> Unit = {}\n\nfun f1() = E.FIRST.foo()\nfun f2() = E.FIRST.(foo)()\nfun f3() = E.SECOND.foo()\nfun f4() = E.SECOND.(foo)()\nfun f5() = E.SECOND.<!UNRESOLVED_REFERENCE!>A<!>()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nenum class E : Cloneable {\n    A;\n    <!OVERRIDING_FINAL_MEMBER!>override<!> fun clone(): Any {\n        return <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>clone<!>()\n    }\n}\n"
        },
        {
            "code": "// KT-7753: attempt to call enum constructor explicitly\nenum class A(val c: Int) {\n    ONE(1),\n    TWO(2);    \n}\n\nfun createA(): A {\n    // Error should be here!\n    return <!ENUM_CLASS_CONSTRUCTOR_CALL!><!INVISIBLE_MEMBER!>A<!>(10)<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInEnumEntryShouldBeInner\n\nenum class E {\n    ABC {\n        <!NESTED_CLASS_NOT_ALLOWED!>enum class F<!> {\n            DEF\n        }\n    }\n}\n"
        },
        {
            "code": "class A {\n    companion object {\n        enum class E { ENTRY }  // OK\n    }\n    \n    inner class B {\n        <!NESTED_CLASS_NOT_ALLOWED!>enum class E<!> { ENTRY }\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -NestedClassesInEnumEntryShouldBeInner\n\nenum class E {\n    ABC {\n        <!NESTED_CLASS_DEPRECATED!>enum class F<!> {\n            DEF\n        }\n    }\n}\n"
        },
        {
            "code": "class A {\n    inner class B {\n        <!NESTED_CLASS_NOT_ALLOWED!>enum class E<!> {\n            ENTRY\n        }\n    }\n}\n"
        },
        {
            "code": "enum class E {\n    E1,\n    E2\n}\n\nfun foo() {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>e<!> = E.E1\n    <!UNUSED_VALUE!>e =<!> E.E2\n}"
        },
        {
            "code": "class Test1 : <!CLASS_CANNOT_BE_EXTENDED_DIRECTLY!>Enum<Test1><!>(\"\", 0)\n\nclass Outer {\n    class Test2 : <!CLASS_CANNOT_BE_EXTENDED_DIRECTLY!>Enum<Test2><!>(\"\", 0)\n}\n\nfun outer() {\n    class Test3 : <!CLASS_CANNOT_BE_EXTENDED_DIRECTLY!>Enum<Test3><!>(\"\", 0)\n}"
        },
        {
            "code": "enum class E {\n    <!WRONG_MODIFIER_TARGET!>public<!> <!WRONG_MODIFIER_TARGET!>final<!> SUBCLASS {\n        fun foo() {}\n    },\n\n    <!WRONG_MODIFIER_TARGET!>public<!> PUBLIC,\n    <!WRONG_MODIFIER_TARGET!>protected<!> PROTECTED,\n    <!WRONG_MODIFIER_TARGET!>private<!> PRIVATE,\n    <!WRONG_MODIFIER_TARGET!>internal<!> INTERNAL,\n\n    <!WRONG_MODIFIER_TARGET!>abstract<!> ABSTRACT,\n    <!WRONG_MODIFIER_TARGET!>open<!> OPEN,\n    <!WRONG_MODIFIER_TARGET!>override<!> OVERRIDE,\n    <!WRONG_MODIFIER_TARGET!>final<!> FINAL,\n\n    <!WRONG_MODIFIER_TARGET!>inner<!> INNER,\n    <!WRONG_MODIFIER_TARGET!>annotation<!> ANNOTATION,\n    <!WRONG_MODIFIER_TARGET!>enum<!> ENUM,\n    <!WRONG_MODIFIER_TARGET!>out<!> OUT,\n    <!WRONG_MODIFIER_TARGET!>in<!> IN,\n    <!WRONG_MODIFIER_TARGET!>vararg<!> VARARG,\n    <!WRONG_MODIFIER_TARGET!>reified<!> REIFIED\n}\n"
        },
        {
            "code": "interface T1 {\n    fun foo()\n}\n\nenum class EnumImplementingTraitWithFun: T1 {\n    E1 {\n        override fun foo() {}\n    },\n    <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>E2<!>\n}\n\ninterface T2 {\n    val bar: Int\n}\n\nenum class EnumImplementingTraitWithVal: T2 {\n    E1 {\n        override val bar = 1\n    },\n    <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>E2<!>\n}"
        },
        {
            "code": "// FILE: E.kt\npackage foo\n\nenum class E {\n    ENTRY,\n    ANOTHER;\n\n    class Nested {\n        companion object {\n            fun foo() = 42\n        }\n    }\n}\n\n// FILE: main.kt\npackage bar\n\nimport foo.E.*\n\nfun f1() = ENTRY\nfun f2() = ANOTHER\nfun f3() = Nested()\nfun f4() = Nested.foo()\nfun f5() = values()\n"
        },
        {
            "code": "package abstract\n\n\nenum class MyEnum() {\n    <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>INSTANCE<!>;\n    //properties\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val a: Int<!>\n    val a1: Int = 1\n    abstract val a2: Int\n    abstract val a3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>1<!>\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var b: Int<!>                private set\n    var b1: Int = 0;                         private set\n    abstract var b2: Int      <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n    abstract var b3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY!>private<!> set\n\n    <!MUST_BE_INITIALIZED!>var c: Int<!>                set(v: Int) { field = v }\n    var c1: Int = 0;                         set(v: Int) { field = v }\n    abstract var c2: Int                     <!ABSTRACT_PROPERTY_WITH_SETTER!>set(v: Int) { field = v }<!>\n    abstract var c3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!ABSTRACT_PROPERTY_WITH_SETTER!>set(v: Int) { field = v }<!>\n\n    val e: Int                               get() = a\n    val e1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;          get() = a\n    abstract val e2: Int                     <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = a<!>\n    abstract val e3: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>0<!>; <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = a<!>\n\n    //methods\n    <!NON_ABSTRACT_FUNCTION_WITH_NO_BODY!>fun f()<!>\n    fun g() {}\n    abstract fun h()\n    <!ABSTRACT_FUNCTION_WITH_BODY!>abstract<!> fun j() {}\n\n    //property accessors\n    var i: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var i1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var j: Int                       get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var j1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var k: Int<!>        <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var k1: Int = 0;                 <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var l: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var l1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;   <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var n: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get <!WRONG_MODIFIER_TARGET!>abstract<!> set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n}"
        },
        {
            "code": "enum class EnumClass {\n    E1 {\n        override fun foo() = 1\n        override val bar: String = \"a\"\n    },\n\n    <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>E2<!> {\n\n    };\n\n    abstract fun foo(): Int\n    abstract val bar: String\n}"
        },
        {
            "code": "enum class TestOk(val x: String = \"OK\") {\n    TEST1,\n    TEST2(),\n    TEST3(\"Hello\")\n}\n\nenum class TestErrors(val x: String) {\n    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>TEST1,<!>\n    TEST2(<!NO_VALUE_FOR_PARAMETER!>)<!>,\n    TEST3(\"Hello\")\n}\n\nenum class TestMultipleConstructors(val x: String = \"\", val y: Int = 0) {\n    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>TEST;<!>\n    constructor(x: String = \"\") : this(x, 0)\n}\n\nenum class TestVarargs(val x: Int) {\n    TEST;\n    constructor(vararg xs: Any) : this(xs.size)\n}"
        },
        {
            "code": "// Error: name should present\nenum class<!SYNTAX!><!>(val rgb : Int) {\n    RED(0xFF000),\n    GREEN(0x00FF00),\n    BLUE(0x0000FF)\n}"
        },
        {
            "code": "// FILE: enum.kt\n\npackage enum\n\nenum class HappyEnum {\n    CASE1,\n    CASE2\n}\n\n// FILE: user.kt\n\nimport enum.HappyEnum\nimport enum.HappyEnum.*\n\nfun f(e: HappyEnum) {\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (e) {\n        CASE1 -> throw UnsupportedOperationException() // unresolved reference\n        CASE2 -> throw UnsupportedOperationException() // unresolved references\n    }<!>\n}"
        },
        {
            "code": "enum class E {\n    FIRST,\n\n    SECOND {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {\n            fun foo() = 42\n        }\n    };\n}\n\nfun f() = E.SECOND.<!UNRESOLVED_REFERENCE!>foo<!>()\n"
        },
        {
            "code": "// FILE: test.kt\nenum class MyEnum(): <!CLASS_IN_SUPERTYPE_FOR_ENUM!>MyClass<!>() {}\nenum class MyEnum2(): MyTrait {}\nenum class MyEnum3(): <!CLASS_IN_SUPERTYPE_FOR_ENUM, FINAL_SUPERTYPE, INVISIBLE_MEMBER!>MyEnumBase<!>() {}\n\nopen class MyClass() {}\n\nenum class MyEnumBase() {}\n\ninterface MyTrait {}\n\n"
        },
        {
            "code": "enum class EnumWithOpenMembers {\n    E1 {\n        override fun foo() = 1\n        override val bar: String = \"a\"\n    },\n\n    E2 {\n        <!OVERRIDING_FINAL_MEMBER!>override<!> fun f() = 3\n        <!OVERRIDING_FINAL_MEMBER!>override<!> val b = 4\n    };\n\n    open fun foo() = 1\n    open val bar: String = \"\"\n\n    fun f() = 2\n    val b = 3\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun foo() {\n    <!WRONG_MODIFIER_TARGET!>enum<!> class A {\n        FOO,\n        BAR\n    }\n    val foo = A.<!UNINITIALIZED_ENUM_ENTRY!>FOO<!>\n    val b = object {\n        <!WRONG_MODIFIER_TARGET!>enum<!> class B {}\n    }\n    class C {\n        <!WRONG_MODIFIER_TARGET!>enum<!> class D {}\n    }\n    val f = {\n        <!WRONG_MODIFIER_TARGET!>enum<!> class E {}\n    }\n\n    <!WRONG_MODIFIER_TARGET!>enum<!> class<!SYNTAX!><!> {}\n}\n"
        },
        {
            "code": "interface I {\n    fun foo()\n}\n\nenum class E1 : I {\n    A {\n        override fun foo() {\n            <!EQUALITY_NOT_APPLICABLE!>this == E2.A<!>\n\n            val q = this\n            when (q) {\n                this -> {}\n                E1.A -> {}\n                E1.B -> {}\n                <!INCOMPATIBLE_TYPES!>E2.A<!> -> {}\n                <!INCOMPATIBLE_TYPES!>E2.B<!> -> {}\n                else -> {}\n            }\n        }\n    },\n    B {\n        override fun foo() {\n\n        }\n    }\n}\n\nenum class E2 : I {\n    A {\n        override fun foo() {\n\n        }\n    },\n    B {\n        override fun foo() {\n\n        }\n    }\n}\n\nfun foo1(e1: E1, e2: E2) {\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == e2<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 != e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == E2.A<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E1.B == e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E1.A == E2.B<!>\n\n    e1 == E1.A\n    E1.A == e1\n    e2 == E2.B\n    E2.B == e2\n}\n\nfun foo2(e1: E1, e2: E2) {\n    when (e1) {\n        E1.A -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>E2.A<!> -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>E2.B<!> -> {}\n        e1 -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>e2<!> -> {}\n        else -> {}\n    }\n}\n\nfun foo3(e1: Enum<E1>, e2: Enum<E2>, e: Enum<*>) {\n    e1 == e\n    e1 == e2\n\n    e1 == E1.A\n    e1 == E2.A\n\n    when (e1) {\n        e1 -> {}\n        e2 -> {}\n        e -> {}\n        E1.A -> {}\n        E2.A -> {}\n        else -> {}\n    }\n\n    when (e) {\n        e -> {}\n        e2 -> {}\n        E1.A -> {}\n        E2.A -> {}\n        else -> {}\n    }\n}\n"
        },
        {
            "code": "enum class B {}\n\nclass A {\n   <!WRONG_MODIFIER_TARGET!>enum<!> companion object {}\n}\n\n<!WRONG_MODIFIER_TARGET!>enum<!> object O {}\n\n<!WRONG_MODIFIER_TARGET!>enum<!> interface T {}\n\n<!WRONG_MODIFIER_TARGET!>enum<!> fun f() = 0\n\n<!WRONG_MODIFIER_TARGET!>enum<!> val x = 0\n\n<!WRONG_MODIFIER_TARGET!>enum<!> var y = 0"
        },
        {
            "code": "package abstract\n\n<!WRONG_MODIFIER_TARGET!>abstract<!> enum class MyAbstractEnum() {}"
        },
        {
            "code": "// See KT-20959\n\nenum class Foo {;\n    companion object  {\n        val x = <!DEBUG_INFO_LEAKING_THIS!>foo<!>() // there should be no UNINITIALIZED_ENUM_COMPANION\n\n        private fun foo() = \"OK\"\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\r\n// FILE: test.kt\r\nfun main() {\r\n    checkSubtype<String?>(A.ENTRY.s())\r\n}\r\n"
        },
        {
            "code": "// KT-5696 Prohibit type parameters for enum classes\n\npackage bug\n\npublic enum class Foo<!TYPE_PARAMETERS_IN_ENUM!><T><!> {\n    A<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><!>()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInEnumEntryShouldBeInner\n\nenum class E {\n    FIRST,\n    SECOND {\n        <!NESTED_CLASS_NOT_ALLOWED!>class A<!>\n    };\n}\n\nval foo: Any.() -> Unit = {}\n\nfun f1() = E.FIRST.foo()\nfun f2() = E.FIRST.(foo)()\nfun f3() = E.SECOND.foo()\nfun f4() = E.SECOND.(foo)()\nfun f5() = E.SECOND.<!UNRESOLVED_REFERENCE!>A<!>()\n"
        },
        {
            "code": "enum class E <!NON_PRIVATE_CONSTRUCTOR_IN_ENUM!>public<!> constructor(val x: Int) {\n    FIRST();\n\n    <!NON_PRIVATE_CONSTRUCTOR_IN_ENUM!>internal<!> constructor(): this(42)\n\n    constructor(y: Int, z: Int): this(y + z)\n}\n"
        },
        {
            "code": "// KT-7753: attempt to call enum constructor explicitly\nenum class A(val c: Int) {\n    ONE(1),\n    TWO(2);\n    \n    fun createA(): A {\n        // Error should be here!\n        return <!ENUM_CLASS_CONSTRUCTOR_CALL!>A(10)<!>\n    }\n}"
        },
        {
            "code": "// FILE: test.kt\n\nenum class KotlinEnumA\nenum class KotlinEnumB\n\nfun jj(a: JavaEnumA, b: JavaEnumB) = <!INCOMPATIBLE_ENUM_COMPARISON!>a == b<!>\nfun jk(a: JavaEnumA, b: KotlinEnumB) = <!INCOMPATIBLE_ENUM_COMPARISON!>a == b<!>\nfun kk(a: KotlinEnumA, b: KotlinEnumB) = <!INCOMPATIBLE_ENUM_COMPARISON!>a == b<!>\n"
        },
        {
            "code": "enum class E {\n    ENTRY;\n\n    <!OVERRIDING_FINAL_MEMBER!>override<!> val name: String = \"lol\"\n    <!OVERRIDING_FINAL_MEMBER!>override<!> val ordinal: Int = 0\n\n    <!OVERRIDING_FINAL_MEMBER!>override<!> fun compareTo(other: E) = -1\n\n    <!OVERRIDING_FINAL_MEMBER!>override<!> fun equals(other: Any?) = true\n    <!OVERRIDING_FINAL_MEMBER!>override<!> fun hashCode() = -1\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitComparisonOfIncompatibleEnums\n\nenum class E1 {\n    A, B\n}\n\nenum class E2 {\n    A, B\n}\n\nfun foo1(e1: E1, e2: E2) {\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == e2<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 != e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == E2.A<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E1.B == e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E1.A == E2.B<!>\n\n    e1 == E1.A\n    E1.A == e1\n    e2 == E2.B\n    E2.B == e2\n}\n\nfun foo2(e1: E1, e2: E2) {\n    when (e1) {\n        E1.A -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>E2.A<!> -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>E2.B<!> -> {}\n        e1 -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>e2<!> -> {}\n        else -> {}\n    }\n}\n\nfun foo3(e1: Enum<E1>, e2: Enum<E2>, e: Enum<*>) {\n    e1 == e\n    e1 == e2\n\n    e1 == E1.A\n    e1 == E2.A\n\n    when (e1) {\n        e1 -> {}\n        e2 -> {}\n        e -> {}\n        E1.A -> {}\n        E2.A -> {}\n        else -> {}\n    }\n\n    when (e) {\n        e -> {}\n        e2 -> {}\n        E1.A -> {}\n        E2.A -> {}\n        else -> {}\n    }\n}\n\ninterface MyInterface\nopen class MyOpenClass\n\nfun foo4(e1: E1, i: MyInterface, c: MyOpenClass) {\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == i<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>i == e1<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == c<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>c == e1<!>\n\n    when (e1) {\n        <!INCOMPATIBLE_ENUM_COMPARISON!>i<!> -> {}\n        <!INCOMPATIBLE_ENUM_COMPARISON!>c<!> -> {}\n        else -> {}\n    }\n}\n\nenum class E3 : MyInterface { X, Y }\n\nfun foo5(i: MyInterface, a: Any) {\n    E3.X == E3.Y\n    E3.X == i\n    E3.X == a\n}\n\nfun foo6(e1: E1?, e2: E2) {\n    <!SENSELESS_COMPARISON!>E1.A == null<!>\n    <!SENSELESS_COMPARISON!>null == E1.A<!>\n    e1 == null\n    null == e1\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == E2.A<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E2.A == e1<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == e2<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e2 == e1<!>\n\n    <!SENSELESS_COMPARISON!>e2 == null<!>\n    <!SENSELESS_COMPARISON!>null == e2<!>\n    <!SENSELESS_COMPARISON!>E1.A == null<!>\n    <!SENSELESS_COMPARISON!>null == E1.A<!>\n}\n\nfun foo7(e1: E1?, e2: E2?) {\n    e1 == e2 // There should be an IDE-inspection for such cases\n}\n\nfun <T> foo8(e1: E1?, e2: E2, t: T) {\n    e1 == t\n    t == e1\n\n    e2 == t\n    t == e2\n\n    E1.A == t\n    t == E1.A\n}\n\nfun <T, K> foo9(e1: E1?, e2: E2, t: T, k: K) where T : MyInterface, T : MyOpenClass, K : MyInterface {\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e1 == t<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>t == e1<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>e2 == t<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>t == e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E1.A == t<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON!>t == E1.A<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON!>E3.X == t<!>\n\n    E3.X == k\n    k == E3.X\n}\n\ninterface Inv<T>\n\nenum class E4 : Inv<Int> { A }\n\nfun foo10(e4: E4, invString: Inv<String>) {\n    e4 == invString\n    invString == e4\n\n    E4.A == invString\n    invString == E4.A\n}"
        },
        {
            "code": "// See KT-14705\n\nenum class En { A, B,  }\n\nfun foo() {\n    // nullable variable\n    val en2: Any? = En.A\n    if (en2 is En) {\n        when (<!DEBUG_INFO_SMARTCAST!>en2<!>) {\n            En.A -> {}\n            En.B -> {}\n            En. -> {}\n        }\n    }\n\n    // not nullable variable\n    val en1: Any = En.A\n    if (en1 is En) {\n        when (<!DEBUG_INFO_SMARTCAST!>en1<!>) {\n            En.A -> {}\n            En.B -> {}\n            En. -> {}\n        }\n    }\n}\n\nenum class En2 { D, E, F }\n\nfun useEn(x: En) = x\nfun useEn2(x: En2) = x\n\nfun bar(x: Any) {\n    if (x is En && x is En2) {\n        when (<!DEBUG_INFO_SMARTCAST!>x<!>) {\n            En.A -> useEn(<!DEBUG_INFO_SMARTCAST!>x<!>)\n            En2.D -> useEn2(<!DEBUG_INFO_SMARTCAST!>x<!>)\n            else -> {}\n        }\n    }\n}"
        },
        {
            "code": "// FILE: test.kt\n<!WRONG_MODIFIER_TARGET!>open<!> enum class MyEnum() {\n    A()\n}\n\nenum class MyEnum2() {}\n\nclass MyClass(): <!FINAL_SUPERTYPE, INVISIBLE_MEMBER!>MyEnum2<!>() {}\n\nclass MyClass2(): <!FINAL_SUPERTYPE!>MyJavaEnum<!>() {}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>enum<!> interface Some {\n    // Enum part\n    <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>D<!>;\n\n    // Interface like part\n    fun test()\n    val foo: Int\n}"
        },
        {
            "code": "// KT-7753: attempt to call enum constructor explicitly\nenum class A(val c: Int) {\n    ONE(1) {\n        override fun selfOrFriend(): A {\n            return this\n        }\n    },\n    TWO(2) {\n        override fun selfOrFriend(): A {\n            return <!ENUM_CLASS_CONSTRUCTOR_CALL!>A(42)<!>\n        }\n    };\n    \n    abstract fun selfOrFriend(): A\n}"
        },
        {
            "code": "enum class MyEnum {\n    FIRST,\n    SECOND\n}\n\nfun foo(me: MyEnum): Boolean = if (me is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>FIRST<!><!>) true else false"
        },
        {
            "code": "// !LANGUAGE: +ProhibitComparisonOfIncompatibleEnums\n\nenum class E1 {\n    A, B\n}\n\nenum class E2 {\n    A, B\n}\n\nfun foo1(e1: E1, e2: E2) {\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == e2<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 != e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == E2.A<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E1.B == e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E1.A == E2.B<!>\n\n    e1 == E1.A\n    E1.A == e1\n    e2 == E2.B\n    E2.B == e2\n}\n\nfun foo2(e1: E1, e2: E2) {\n    when (e1) {\n        E1.A -> {}\n            <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E2.A<!> -> {}\n            <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E2.B<!> -> {}\n        e1 -> {}\n            <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e2<!> -> {}\n        else -> {}\n    }\n}\n\nfun foo3(e1: Enum<E1>, e2: Enum<E2>, e: Enum<*>) {\n    e1 == e\n    e1 == e2\n\n    e1 == E1.A\n    e1 == E2.A\n\n    when (e1) {\n        e1 -> {}\n        e2 -> {}\n        e -> {}\n        E1.A -> {}\n            E2.A -> {}\n        else -> {}\n    }\n\n    when (e) {\n        e -> {}\n        e2 -> {}\n        E1.A -> {}\n        E2.A -> {}\n        else -> {}\n    }\n}\n\ninterface MyInterface\nopen class MyOpenClass\n\nfun foo4(e1: E1, i: MyInterface, c: MyOpenClass) {\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == i<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>i == e1<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == c<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>c == e1<!>\n\n    when (e1) {\n            <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>i<!> -> {}\n            <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>c<!> -> {}\n        else -> {}\n    }\n}\n\nenum class E3 : MyInterface { X, Y }\n\nfun foo5(i: MyInterface, a: Any) {\n    E3.X == E3.Y\n    E3.X == i\n    E3.X == a\n}\n\nfun foo6(e1: E1?, e2: E2) {\n    <!SENSELESS_COMPARISON!>E1.A == null<!>\n    <!SENSELESS_COMPARISON!>null == E1.A<!>\n    e1 == null\n    null == e1\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == E2.A<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E2.A == e1<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == e2<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e2 == e1<!>\n\n    <!SENSELESS_COMPARISON!>e2 == null<!>\n    <!SENSELESS_COMPARISON!>null == e2<!>\n    <!SENSELESS_COMPARISON!>E1.A == null<!>\n    <!SENSELESS_COMPARISON!>null == E1.A<!>\n}\n\nfun foo7(e1: E1?, e2: E2?) {\n    e1 == e2 // There should be an IDE-inspection for such cases\n}\n\nfun <T> foo8(e1: E1?, e2: E2, t: T) {\n    e1 == t\n    t == e1\n\n    e2 == t\n    t == e2\n\n    E1.A == t\n    t == E1.A\n}\n\nfun <T, K> foo9(e1: E1?, e2: E2, t: T, k: K) where T : MyInterface, T : MyOpenClass, K : MyInterface {\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e1 == t<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>t == e1<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>e2 == t<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>t == e2<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E1.A == t<!>\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>t == E1.A<!>\n\n    <!INCOMPATIBLE_ENUM_COMPARISON_ERROR!>E3.X == t<!>\n\n    E3.X == k\n    k == E3.X\n}\n\ninterface Inv<T>\n\nenum class E4 : Inv<Int> { A }\n\nfun foo10(e4: E4, invString: Inv<String>) {\n    e4 == invString\n    invString == e4\n\n    E4.A == invString\n    invString == E4.A\n}"
        },
        {
            "code": "enum class E {\n    ENTRY;\n\n    private companion object\n}\n\nfun foo() = E.values()\nfun bar() = E.valueOf(\"ENTRY\")\nfun baz() = E.ENTRY\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>quux<!>() = <!INVISIBLE_MEMBER!>E<!>"
        },
        {
            "code": "// KT-7753: attempt to call enum constructor explicitly\nenum class A(val c: Int) {\n    ONE(1),\n    TWO(2),\n    THREE(3),\n    FORTY_TWO();\n\n    var last: A? = null\n\n    constructor(): this(42) {\n        last = <!ENUM_CLASS_CONSTRUCTOR_CALL!>A(13)<!>\n    }\n}"
        },
        {
            "code": "// FILE: test.kt\n\nfun main() {\n    val c: A = A.ENTRY\n    val <!UNUSED_VARIABLE!>c2<!>: String? = c.ENTRY\n    val <!UNUSED_VARIABLE!>c3<!>: String? = A.ANOTHER.ENTRY\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitLocalAnnotations\n\nfun f() {\n    <!LOCAL_ANNOTATION_CLASS!>annotation class Anno<!>\n\n    @Anno class Local {\n        <!LOCAL_ANNOTATION_CLASS!>annotation <!NESTED_CLASS_NOT_ALLOWED!>class Nested<!><!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitLocalAnnotations\n\nfun f() {\n    <!LOCAL_ANNOTATION_CLASS_ERROR!>annotation class Anno<!>\n\n    @Anno class Local {\n        <!LOCAL_ANNOTATION_CLASS_ERROR!>annotation <!NESTED_CLASS_NOT_ALLOWED!>class Nested<!><!>\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage collections\n\nfun <T> testCollection(c: Collection<T>, t: T) {\n    c.size\n    c.isEmpty()\n    c.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    val <!UNUSED_VARIABLE!>iterator<!>: Iterator<T> = c.iterator()\n    c.containsAll(c)\n\n    val <!UNUSED_VARIABLE!>mutableIterator<!>: MutableIterator<T> = <!TYPE_MISMATCH!>c.iterator()<!>\n    c.<!UNRESOLVED_REFERENCE!>add<!>(t)\n    c.<!UNRESOLVED_REFERENCE!>remove<!>(1)\n    c.<!UNRESOLVED_REFERENCE!>addAll<!>(c)\n    c.<!UNRESOLVED_REFERENCE!>removeAll<!>(c)\n    c.<!UNRESOLVED_REFERENCE!>retainAll<!>(c)\n    c.<!UNRESOLVED_REFERENCE!>clear<!>()\n\n}\nfun <T> testMutableCollection(c: MutableCollection<T>, t: T) {\n    c.size\n    c.isEmpty()\n    c.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    val <!UNUSED_VARIABLE!>iterator<!>: Iterator<T> = c.iterator()\n    c.containsAll(c)\n\n\n    val <!UNUSED_VARIABLE!>mutableIterator<!>: MutableIterator<T> = c.iterator()\n    c.add(t)\n    c.remove(1 <!UNCHECKED_CAST!>as T<!>)\n    c.addAll(c)\n    c.removeAll(c)\n    c.retainAll(c)\n    c.clear()\n}\n\nfun <T> testList(l: List<T>, <!UNUSED_PARAMETER!>t<!>: T) {\n    val <!NAME_SHADOWING!>t<!>: T = l.get(1)\n    val <!UNUSED_VARIABLE!>i<!>: Int = l.indexOf(t)\n    val <!UNUSED_VARIABLE!>i1<!>: Int = l.lastIndexOf(t)\n    val <!UNUSED_VARIABLE!>listIterator<!>: ListIterator<T> = l.listIterator()\n    val <!UNUSED_VARIABLE!>listIterator1<!>: ListIterator<T> = l.listIterator(1)\n    val <!UNUSED_VARIABLE!>list<!>: List<T> = l.subList(1, 2)\n\n    val <!UNUSED_VARIABLE!>value<!>: T = l.<!UNRESOLVED_REFERENCE!>set<!>(1, t)\n    l.<!UNRESOLVED_REFERENCE!>add<!>(1, t)\n    l.<!UNRESOLVED_REFERENCE!>remove<!>(1)\n    val <!UNUSED_VARIABLE!>mutableListIterator<!>: MutableListIterator<T> = <!TYPE_MISMATCH!>l.listIterator()<!>\n    val <!UNUSED_VARIABLE!>mutableListIterator1<!>: MutableListIterator<T> = <!TYPE_MISMATCH!>l.listIterator(1)<!>\n    val <!UNUSED_VARIABLE!>mutableList<!>: MutableList<T> = <!TYPE_MISMATCH!>l.subList(1, 2)<!>\n}\n\nfun <T> testMutableList(l: MutableList<T>, t: T) {\n    val <!UNUSED_VARIABLE!>value<!>: T = l.set(1, t)\n    l.add(1, t)\n    l.removeAt(1)\n    val <!UNUSED_VARIABLE!>mutableListIterator<!>: MutableListIterator<T> = l.listIterator()\n    val <!UNUSED_VARIABLE!>mutableListIterator1<!>: MutableListIterator<T> = l.listIterator(1)\n    val <!UNUSED_VARIABLE!>mutableList<!>: MutableList<T> = l.subList(1, 2)\n}\n\nfun <T> testSet(s: Set<T>, t: T) {\n    s.size\n    s.isEmpty()\n    s.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    val <!UNUSED_VARIABLE!>iterator<!>: Iterator<T> = s.iterator()\n    s.containsAll(s)\n\n    val <!UNUSED_VARIABLE!>mutableIterator<!>: MutableIterator<T> = <!TYPE_MISMATCH!>s.iterator()<!>\n    s.<!UNRESOLVED_REFERENCE!>add<!>(t)\n    s.<!UNRESOLVED_REFERENCE!>remove<!>(1)\n    s.<!UNRESOLVED_REFERENCE!>addAll<!>(s)\n    s.<!UNRESOLVED_REFERENCE!>removeAll<!>(s)\n    s.<!UNRESOLVED_REFERENCE!>retainAll<!>(s)\n    s.<!UNRESOLVED_REFERENCE!>clear<!>()\n\n}\nfun <T> testMutableSet(s: MutableSet<T>, t: T) {\n    s.size\n    s.isEmpty()\n    s.contains(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    val <!UNUSED_VARIABLE!>iterator<!>: Iterator<T> = s.iterator()\n    s.containsAll(s)\n\n\n    val <!UNUSED_VARIABLE!>mutableIterator<!>: MutableIterator<T> = s.iterator()\n    s.add(t)\n    s.remove(1 <!UNCHECKED_CAST!>as T<!>)\n    s.addAll(s)\n    s.removeAll(s)\n    s.retainAll(s)\n    s.clear()\n}\n\nfun <K, V> testMap(m: Map<K, V>) {\n    val <!UNUSED_VARIABLE!>set<!>: Set<K> = m.keys\n    val <!UNUSED_VARIABLE!>collection<!>: Collection<V> = m.values\n    val <!UNUSED_VARIABLE!>set1<!>: Set<Map.Entry<K, V>> = m.entries\n\n    val <!UNUSED_VARIABLE!>mutableSet<!>: MutableSet<K> = <!TYPE_MISMATCH!>m.keys<!>\n    val <!UNUSED_VARIABLE!>mutableCollection<!>: MutableCollection<V> = <!TYPE_MISMATCH!>m.values<!>\n    val <!UNUSED_VARIABLE!>mutableSet1<!>: MutableSet<MutableMap.MutableEntry<K, V>> = <!TYPE_MISMATCH!>m.entries<!>\n}\n\nfun <K, V> testMutableMap(m: MutableMap<K, V>) {\n    val <!UNUSED_VARIABLE!>mutableSet<!>: MutableSet<K> = m.keys\n    val <!UNUSED_VARIABLE!>mutableCollection<!>: MutableCollection<V> = m.values\n    val <!UNUSED_VARIABLE!>mutableSet1<!>: MutableSet<MutableMap.MutableEntry<K, V>> = m.entries\n}\n\nfun <T> array(vararg <!UNUSED_PARAMETER!>t<!>: T): Array<T> {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>"
        },
        {
            "code": "fun test() {\n    var res : Boolean = true\n    res = (res and false)\n    res = (res or false)\n    <!UNUSED_VALUE!>res =<!> (res xor false)\n    <!UNUSED_VALUE!>res =<!> (true and false)\n    <!UNUSED_VALUE!>res =<!> (true or false)\n    <!UNUSED_VALUE!>res =<!> (true xor false)\n    <!UNUSED_VALUE!>res =<!> (!true)\n    <!UNUSED_VALUE!>res =<!> (true && false)\n    <!UNUSED_VALUE!>res =<!> (true || false)\n}\n"
        },
        {
            "code": "interface A<T> {}\ninterface B<T> {}\ninterface C<T> {}\ninterface D<T> {}\n\ninterface Test : A<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>in<!> Int>, B<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>out<!> Int>, C<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>*<!>><!NULLABLE_SUPERTYPE!>?<!><!REDUNDANT_NULLABLE!>?<!><!REDUNDANT_NULLABLE!>?<!>, D<Int> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun f(x: Int = 0) {}\n\nval inVal: (x: Int = <!UNSUPPORTED!>0<!>)->Unit = {}\n\nfun inParam(fn: (x: Int = <!UNSUPPORTED!>0<!>)->Unit) {}\n\nfun inParamNested(fn1: (fn2: (n: Int = <!UNSUPPORTED!>0<!>)->Unit)->Unit) {}\n\nfun inReturn(): (x: Int = <!UNSUPPORTED!>0<!>)->Unit = {}\n\nclass A : (Int)->Unit {\n    override fun invoke(p1: Int) {\n        var lambda: (x: Int = <!UNSUPPORTED!>0<!>)->Unit = {}\n    }\n\n    val prop: (x: Int = <!UNSUPPORTED!>0<!>)->Unit\n        get(): (x: Int = <!UNSUPPORTED!>0<!>)->Unit = {}\n}\n"
        },
        {
            "code": "package unused_variables\n\nfun testSimpleCases() {\n    var i = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>2<!>\n    <!UNUSED_VALUE!>i =<!> 34\n    i = 34\n    doSmth(i)\n    <!UNUSED_VALUE!>i =<!> 5\n\n    var j = 2\n    j = <!UNUSED_CHANGED_VALUE!>j++<!>\n    <!UNUSED_VALUE!>j =<!> <!UNUSED_CHANGED_VALUE!>j--<!>\n}\n\nclass IncDec() {\n  operator fun inc() : IncDec = this\n  operator fun dec() : IncDec = this\n}\n\nclass MyTest() {\n    fun testIncDec() {\n      var x = IncDec()\n      x++\n      ++x\n      x--\n      --x\n      x = <!UNUSED_CHANGED_VALUE!>x++<!>\n      x = <!UNUSED_CHANGED_VALUE!>x--<!>\n      x = ++x\n      <!UNUSED_VALUE!>x =<!> --x\n    }\n\n    var a: String = \"s\"\n        set(v: String) {\n            var i: Int = 23\n            doSmth(i)\n            <!UNUSED_VALUE!>i =<!> 34\n            field = v\n        }\n\n    init {\n        a = \"rr\"\n    }\n\n    fun testSimple() {\n        a = \"rro\"\n\n        var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>i<!> = 1;\n        <!UNUSED_VALUE!>i =<!> 34;\n        <!UNUSED_VALUE!>i =<!> 456;\n    }\n\n    fun testWhile() {\n        var a : Any? = true\n        var b : Any? = 34\n        while (a is Any) {\n            a = null\n        }\n        while (b != null) {\n            <!UNUSED_VALUE!>a =<!> null\n        }\n    }\n\n    fun testIf() {\n        var a : Any\n        if (1 < 2) {\n            a = 23\n        }\n        else {\n            a = \"ss\"\n            doSmth(<!DEBUG_INFO_SMARTCAST!>a<!>)\n        }\n        doSmth(a)\n\n        if (1 < 2) {\n            <!UNUSED_VALUE!>a =<!> 23\n        }\n        else {\n            <!UNUSED_VALUE!>a =<!> \"ss\"\n        }\n    }\n\n    fun testFor() {\n        for (i in 1..10) {\n            doSmth(i)\n        }\n    }\n\n    fun doSmth(<!UNUSED_PARAMETER!>s<!>: String) {}\n    fun doSmth(<!UNUSED_PARAMETER!>a<!>: Any) {}\n}\n\nfun testInnerFunctions() {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>y<!> = 1\n    fun foo() {\n        y = 1\n    }\n    var z = 1\n    fun bar() {\n        doSmth(z)\n    }\n}\n\nfun testFunctionLiterals() {\n    var x = 1\n    var <!UNUSED_VARIABLE!>fl<!> = {\n        x\n    }\n    var y = 2\n    var <!UNUSED_VARIABLE!>fl1<!> = {\n        doSmth(y)\n    }\n}\n\ninterface Trait {\n    fun foo()\n}\n\nfun testObject() : Trait {\n    val x = 24\n    val o = object : Trait {\n        val y : Int   //in this case y should not be marked as unused\n           get() = 55\n\n        override fun foo() {\n            doSmth(x)\n        }\n    }\n\n    return o\n}\n\nfun doSmth(<!UNUSED_PARAMETER!>i<!> : Int) {}\n"
        },
        {
            "code": "package lvalue_assignment\n\nopen class B() {\n    var b: Int = 2\n    val c: Int = 34\n}\n\nclass C() : B() {\n    var x = 4\n    fun foo(<!UNUSED_PARAMETER!>c<!>: C) {\n        this.x = 34\n        this.b = 123\n        super.b = 23\n        <!VAL_REASSIGNMENT!>this.c<!> = 34\n        <!VAL_REASSIGNMENT!>super.c<!> = 3535 //repeat for 'c'\n\n        <!VARIABLE_EXPECTED!>getInt()<!> = 12\n    }\n\n    fun foo1(<!UNUSED_PARAMETER!>c<!>: C) {\n        <!VAL_REASSIGNMENT!>super.c<!> = 34\n    }\n\n    fun bar(c: C) {\n        <!VARIABLE_EXPECTED!>this<!> = c  //should be an error\n    }\n}\n\nfun getInt() = 0\n\nclass D() {\n    inner class B() {\n        fun foo() {\n            <!VARIABLE_EXPECTED!>this@D<!> = D()\n        }\n    }\n}\n\nfun foo(): Unit {}\n\nfun cannotBe() {\n    var i: Int = 5\n\n    <!UNRESOLVED_REFERENCE!>z<!> = 30;\n    <!VARIABLE_EXPECTED!>\"\"<!> = \"\";\n    <!VARIABLE_EXPECTED!>foo()<!> = Unit;\n\n    (<!VARIABLE_EXPECTED!>i <!USELESS_CAST!>as Int<!><!>) = 34\n    (<!USELESS_IS_CHECK, VARIABLE_EXPECTED!>i is Int<!>) = false\n    <!VARIABLE_EXPECTED!>A()<!> = A()\n    <!VARIABLE_EXPECTED!>5<!> = 34\n}\n\nfun canBe(i0: Int, <!UNUSED_PARAMETER!>j<!>: Int) {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>i<!> = i0\n    <!UNUSED_VALUE!>(label@ i) =<!> 34\n\n    <!UNUSED_VALUE!>(label@ <!VAL_REASSIGNMENT!>j<!>) =<!> 34 //repeat for j\n\n    val a = A()\n    (l@ a.a) = 3894\n}\n\nfun canBe2(<!UNUSED_PARAMETER!>j<!>: Int) {\n    <!UNUSED_VALUE!>(label@ <!VAL_REASSIGNMENT!>j<!>) =<!> 34\n}\n\nclass A() {\n    var a: Int = 3\n}\n\nclass Test() {\n    fun testIllegalValues() {\n        <!VARIABLE_EXPECTED!>1<!> += 23\n        (l@ <!VARIABLE_EXPECTED!>1<!>) += 23\n\n        <!VARIABLE_EXPECTED!>getInt()<!> += 343\n        (f@ <!VARIABLE_EXPECTED!>getInt()<!>) += 343\n\n        <!VARIABLE_EXPECTED!>1<!>++\n        (<!REDUNDANT_LABEL_WARNING!>r@<!> <!VARIABLE_EXPECTED!>1<!>)++\n\n        <!VARIABLE_EXPECTED!>getInt()<!>++\n        (<!REDUNDANT_LABEL_WARNING!>m@<!> <!VARIABLE_EXPECTED!>getInt()<!>)++\n\n        this<!UNRESOLVED_REFERENCE!>++<!>\n\n        var s : String = \"r\"\n        s += \"ss\"\n        s += this\n        s += (<!REDUNDANT_LABEL_WARNING!>a@<!> 2)\n    }\n\n    fun testIncompleteSyntax() {\n        val s = \"s\"\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>++<!>s.<!SYNTAX!><!>\n    }\n\n    fun testVariables() {\n        var a: Int = 34\n        val b: Int = 34\n\n        a += 34\n        (l@ a) += 34\n\n        <!VAL_REASSIGNMENT!>b<!> += 34\n\n        a++\n        (<!REDUNDANT_LABEL_WARNING!>l@<!> a)++\n        <!UNUSED_CHANGED_VALUE!>(a)++<!>\n    }\n\n    fun testVariables1() {\n        val b: Int = 34\n\n        (l@ <!VAL_REASSIGNMENT!>b<!>) += 34\n        //repeat for b\n        (b) += 3\n    }\n\n    fun testArrays(a: Array<Int>, ab: Ab) {\n        a[3] = 4\n        a[4]++\n        a[6] += 43\n\n        ab.getArray()[54] = 23\n        ab.getArray()[54]++\n\n        (<!REDUNDANT_LABEL_WARNING!>f@<!> a)[3] = 4\n\n        this<!NO_SET_METHOD!><!UNRESOLVED_REFERENCE!>[<!>54<!UNRESOLVED_REFERENCE!>]<!><!> = 34\n    }\n}\n\nfun Array<Int>.checkThis() {\n    this[45] = 34\n    this[352]++\n    this[35] += 234\n}\n\nabstract class Ab {\n    abstract fun getArray() : Array<Int>\n}\n"
        },
        {
            "code": "fun <!IMPLICIT_NOTHING_RETURN_TYPE!>foo<!>() = throw Exception()\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>bar<!>() = null!!\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>baz<!>() = bar()\n\nfun gav(): Any = null!!\n\nval <!IMPLICIT_NOTHING_PROPERTY_TYPE!>x<!> = null!!\n\nval y: Nothing = throw Exception()\n\nfun check() {\n    // Error: KT-10449\n    fun <!IMPLICIT_NOTHING_RETURN_TYPE!>local<!>() = bar()\n    // Unreachable / unused, but not implicit Nothing\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>x<!> =<!> null!!\n}\n\nfun <!IMPLICIT_NOTHING_RETURN_TYPE!>nonLocalReturn<!>() = run { <!RETURN_TYPE_MISMATCH!>return<!> }\n\nclass Klass {\n    fun <!IMPLICIT_NOTHING_RETURN_TYPE!>bar<!>() = null!!\n\n    val <!IMPLICIT_NOTHING_PROPERTY_TYPE!>y<!> = null!!\n\n    init {\n        fun <!IMPLICIT_NOTHING_RETURN_TYPE!>local<!>() = bar()\n        // Should be unreachable: see KT-5311\n        val z = null!!\n    }\n\n    fun foo() {\n        fun <!IMPLICIT_NOTHING_RETURN_TYPE!>local<!>() = bar()\n\n        <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>x<!> =<!> y\n    }\n}\n\ninterface Base {\n    val x: Int\n\n    fun foo(): String\n}\n\nclass Derived : Base {\n    // Ok for override\n    \n    override val x = null!!\n\n    override fun foo() = null!!\n}"
        },
        {
            "code": "val foo: <!UNSUPPORTED!>dynamic<!> = 1\n\nfun foo() {\n    class C {\n        val foo: <!UNSUPPORTED!>dynamic<!> = 1\n    }\n}\n"
        },
        {
            "code": "// !MARK_DYNAMIC_CALLS\n\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public static class C {\n        private void sam(Sam sam) {}\n    }\n\n\n    public interface Sam {\n        void sam();\n    }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nclass K: J.C() {\n    fun <!DYNAMIC_RECEIVER_NOT_ALLOWED, UNSUPPORTED!>dynamic<!>.test() {\n        <!DEBUG_INFO_DYNAMIC!>sam<!>(null)\n        <!DEBUG_INFO_DYNAMIC!>sam<!>(\n            name = null,\n            <!ARGUMENT_PASSED_TWICE!>name<!> = null\n        <!NO_VALUE_FOR_PARAMETER!>)<!>\n    }\n\n    fun test() {\n        <!INVISIBLE_MEMBER!>sam<!>(null)\n    }\n\n}"
        },
        {
            "code": "interface Tr {\n    fun foo()\n}\n\nclass C(d: <!UNSUPPORTED!>dynamic<!>) : Tr by d"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Base\nclass Inv<K> : Base\n\nfun foo(x: Int): Inv<Int> = TODO()\nfun foo(y: String): Inv<String> = TODO()\n\nfun <T, R : Number> bar(f: (T) -> Inv<R>, p: String = \"\") {}\n\nfun <T, R : Base> bar(f: (T) -> Inv<R>, p: Int = 4) {}\n\nfun test() {\n    <!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>(::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\ninterface IA\ninterface IB : IA\n\nfun IA.extFun(x: IB) {}\nfun IB.extFun(x: IA) {}\n\nfun test() {\n    val extFun1 = IA::extFun\n    val extFun2 = IB::<!OVERLOAD_RESOLUTION_AMBIGUITY!>extFun<!>\n}\n\nfun testWithExpectedType() {\n    val extFun_AB_A: IA.(IB) -> Unit = IA::extFun\n    val extFun_AA_B: IA.(IA) -> Unit = IB::<!NONE_APPLICABLE!>extFun<!>\n    val extFun_BB_A: IB.(IB) -> Unit = IA::extFun\n    val extFun_BA_B: IB.(IA) -> Unit = IB::extFun\n    val extFun_BB_B: IB.(IB) -> Unit = IB::<!OVERLOAD_RESOLUTION_AMBIGUITY!>extFun<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun fun1() {}\nfun fun1(x: Int) {}\n\nval ref1 = ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>fun1<!>\n\nfun fun2(vararg x: Int) {}\nfun fun2(x: Int) {}\n\nval ref2 = ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>fun2<!>\n\nfun fun3(x0: Int, vararg xs: Int) {}\nfun fun3(x0: String, vararg xs: String) {}\n\nval ref3 = ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>fun3<!>\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo(x: Int) {}\nfun foo(y: String) {}\n\nfun <T> bar(f: (T) -> Unit) {}\n\nfun test() {\n    <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>(::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>foo<!>)\n}"
        },
        {
            "code": "// KT-12338 Compiler error ERROR: Rewrite at slice LEXICAL_SCOPE key: REFERENCE_EXPRESSION with when and function references\n\nfun a() { }\n\nfun test() {\n    when {\n        true -> <!UNUSED_EXPRESSION!>::a<!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNUSED_EXPRESSION\n\nclass A {\n    fun foo(i: A) {}\n\n    fun baz(i: A) {}\n}\n\nclass B {\n    fun foo(s: B) {}\n    fun foo(c: Char) {}\n\n    fun baz(s: B) {}\n}\n\nfun <T> bar(f: (T) -> Unit): T = TODO()\n\nfun test() {\n    <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>myWith<!>(A()) {\n        val t1 = bar(::foo)\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>t1<!>\n\n        val t2 = bar(::baz)\n        <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>t2<!>\n\n        <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>myWith<!>(B()) {\n            val a: A = bar(::foo)\n            val b: B = bar(::foo)\n\n            val t3 = bar(::baz)\n            <!DEBUG_INFO_EXPRESSION_TYPE(\"B\")!>t3<!>\n\n            <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>(::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>foo<!>)\n        }\n    }\n}\n\ninline fun <T, R> myWith(receiver: T, block: T.() -> R): R = TODO()"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNUSED_EXPRESSION\n\ninterface A\ninterface B\n\nfun multiple(a: A) {}\nfun multiple(b: B) {}\n\nfun singleA(a: A) {}\nfun singleB(a: B) {}\n\nfun <T> foo(f: (T) -> Unit, g: (T) -> Unit): T = TODO()\n\nfun test() {\n    val a1 = foo(::singleA, ::multiple)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>a1<!>\n\n    val a2 = foo(::singleB, ::multiple)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"B\")!>a2<!>\n\n    val a3 = foo(::multiple, ::singleA)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>a3<!>\n\n    val a4 = foo(::multiple, ::singleB)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"B\")!>a4<!>\n\n    val a5 = foo(::singleA, ::singleA)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>a5<!>\n\n    val a6 = foo(::singleA, ::singleB)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"{A & B}\")!>a6<!>\n\n    <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>multiple<!>, ::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>multiple<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A\ninterface B\n\nfun fooB(b: B) {}\n\nfun <T> bar(f: (T) -> Unit, e: T) {}\nfun <T> baz(e: T, f: (T) -> Unit) {}\n\nfun test(a: A, b: B) {\n    // Note that diagnostic is always on callable references as they are resolved after simple arguments\n    baz(a, <!TYPE_MISMATCH!>::fooB<!>)\n    bar(<!TYPE_MISMATCH!>::fooB<!>, a)\n}"
        },
        {
            "code": "// !LANGUAGE: -NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class A\nclass B : A()\n\nclass Or(left: A, right: A) : A()\n\nclass Out<out T>\n\nfun test(ls: Out<B>) {\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"A\")!>ls.reduce(::Or)<!>\n}\n\nfun <S, T : S> Out<T>.reduce(operation: (S, T) -> S): S = TODO()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER,-CONFLICTING_JVM_DECLARATIONS\n// NI_EXPECTED_FILE\n\nfun foo(i: Int) = \"$i\"\nfun foo(s: String) = s\n\nfun bar(s: String) = s\n\nfun qux(i: Int, j: Int, k: Int): Int = i + j + k\nfun qux(a: String, b: String, c: String, d: String) {}\n\nfun fn1(x: Int, f1: (Int) -> String, f2: (String) -> String) = f2(f1(x))\n\nfun fn2(f1: (Int) -> String,    f2: (String) -> String  ) = f2(f1(0))\nfun fn2(f1: (Int) -> Int,       f2: (Int) -> String     ) = f2(f1(0))\nfun fn2(f1: (String) -> String, f2: (String) -> String  ) = f2(f1(\"\"))\n\nfun fn3(i: Int, f: (Int, Int, Int) -> Int): Int = f(i, i, i)\n\nval x1 = fn1(1, ::foo, ::foo)\nval x2 = fn1(1, ::foo, ::bar)\n\nval x3 = fn2(::bar, ::foo)\nval x4 = <!OVERLOAD_RESOLUTION_AMBIGUITY!>fn2<!>(::<!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>, ::<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>)\nval x5 = <!OVERLOAD_RESOLUTION_AMBIGUITY!>fn2<!>(::<!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>, ::<!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>)\n\nval x6 = fn3(1, ::qux)"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\ninterface Parent\ninterface Child1 : Parent\ninterface Child2 : Parent\n\nfun foo(): Child1 = TODO()\nfun bar(): Child2 = TODO()\n\nfun <K> select(x: K, y: K): K = TODO()\n\nfun test() {\n    val a = select(::foo, ::bar)\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.reflect.KFunction0<Parent>\")!>a<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -EXTENSION_SHADOWED_BY_MEMBER\n\nimport kotlin.reflect.*\n\nfun <T> ofType(x: T): T = x\n\nclass A {\n    val foo: Int = 0\n    fun foo() {}\n\n    fun bar() {}\n    val bar: Int = 0\n}\n\nfun A.foo(): String = \"A\"\n\nval x0 = A::<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>\n\nval x1 = ofType<(A) -> Unit>(A::foo)\nval x2 = ofType<KProperty1<A, Int>>(A::foo)\nval x3: KProperty1<A, Int> = A::foo\nval x4: (A) -> String = A::foo\n\nval y0 = A::<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>\nval y1 = ofType<(A) -> Unit>(A::bar)\nval y2 = ofType<KProperty1<A, Int>>(A::bar)\nval y3: KProperty1<A, Int> = A::bar\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo() {}\nfun foo(s: String) {}\n\nval x1 = ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>\nval x2: () -> Unit = ::foo\nval x3: (String) -> Unit = ::foo\nval x4: (Int) -> Unit = ::<!NONE_APPLICABLE!>foo<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo(vararg ii: Int) {}\nfun foo(vararg ss: String) {}\nfun foo(i: Int) {}\n\nval fn1: (Int) -> Unit = ::foo\nval fn2: (IntArray) -> Unit = ::foo\nval fn3: (Int, Int) -> Unit = ::<!NONE_APPLICABLE!>foo<!>\nval fn4: (Array<String>) -> Unit = ::foo"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun <T> ofType(x: T): T = x\n\nfun foo() {}\nfun foo(s: String) {}\n\nval x1 = ofType<() -> Unit>(::foo)\nval x2 = ofType<(String) -> Unit>(::foo)\nval x3 = ofType<(Int) -> Unit>(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>foo<!>)"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\nimport kotlin.reflect.KFunction1\n\nopen class A {\n    open fun bar() {}\n\n    fun bas() {}\n}\nclass B: A() {\n    override fun bar() {}\n\n    fun bas(i: Int) {}\n}\n\nfun A.foo() {}\nfun B.foo() {}\n\nfun fas() {}\nfun fas(i: Int = 1) {}\n\nfun test() {\n    B::foo // todo KT-9601 Chose maximally specific function in callable reference\n\n    B::bar checkType { _<KFunction1<B, Unit>>() }\n\n    B::<!OVERLOAD_RESOLUTION_AMBIGUITY!>bas<!>\n\n    ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>fas<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER\n// KT-10036 Ambiguous overload cannot be resolved when using a member function reference in Beta 2, that worked in Beta 1\n\nclass OverloadTest {\n    fun foo(bar: Boolean) {}\n    fun foo(bar: Any?) {}\n}\n\nobject Literal\n\ninline fun <T : Any> OverloadTest.overload(value: T?, function: OverloadTest.(T) -> Unit) {\n    if (value == null) foo(Literal) else function(<!DEBUG_INFO_SMARTCAST!>value<!>)\n}\n\n// Overload resolution ambiguity\nfun OverloadTest.overloadBoolean(value: Boolean?) = overload(value, OverloadTest::foo)\n\n// Works fine\nfun OverloadTest.overloadBoolean2(value: Boolean?) = overload(value) { foo(it) }"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun foo() {}\nfun foo(s: String) {}\n\nfun bar(f: () -> Unit) = 1\nfun bar(f: (String) -> Unit) = 2\n\nval x1 = ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> as () -> Unit\nval x2 = bar(::<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!> as (String) -> Unit)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// NI_EXPECTED_FILE\n\nfun <T, R> apply(x: T, f: (T) -> R): R = f(x)\n\nfun foo(i: Int) {}\nfun foo(s: String) {}\n\nval x1 = apply(1, ::foo)\nval x2 = apply(\"hello\", ::foo)\nval x3 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>apply<!>(true, ::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>foo<!>)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KCallable\n\nclass Foo {\n    fun <T> installRoute(handler: T) where T : (String) -> Any?, T : KCallable<*> {\n    }\n\n    fun <T> installRoute(handler: T) where T : () -> Any?, T : KCallable<*> {\n    }\n\n    fun foo() {\n        <!NI;NONE_APPLICABLE, OI;OVERLOAD_RESOLUTION_AMBIGUITY!>installRoute<!><Any>(::<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>route<!>)\n    }\n\n}\n\nfun route(s: String): Any? = null"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A1 {\n    fun <T> a1(t: T): Unit {}\n    fun test1(): (String) -> Unit = A1()::a1\n}\n\nclass A2 {\n    fun <K, V> a2(key: K): V = TODO()\n\n    fun test1(): (String) -> Unit = A2()::a2\n    fun <T3> test2(): (T3) -> T3 = A2()::a2\n}\n\nclass A3<T> {\n    fun <V> a3(key: T): V = TODO()\n\n    fun test1(): (T) -> Int = this::a3\n    fun test2(): (T) -> Unit = A3<T>()::a3\n    fun test3(): (Int) -> String = A3<Int>()::a3\n\n    fun <R> test4(): (R) -> Unit = <!TYPE_MISMATCH!>this::<!TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>a3<!><!>\n    fun <R> test5(): (T) -> R = this::a3\n}"
        },
        {
            "code": "// !LANGUAGE: +SamConversionPerArgument +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: 1.kt\n\nfun <T> foo(t: T, x: (() -> Unit) -> Unit) {}\n\nfun <T> bar(s: T) {}\nfun <T> complex(t: T, f: (T) -> Unit) {}\n\nfun test1() {\n    foo(1, <!TYPE_MISMATCH!>A::invokeLater<!>) // KT-24507 SAM conversion accidentally applied to callable reference and incorrectly handled via BE\n    foo(1, ::bar)\n\n    complex(1, ::bar)\n}\n\nfun <R> test2(x: R) {\n    foo(x, <!TYPE_MISMATCH!>A::invokeLater<!>) // KT-24507 SAM conversion accidentally applied to callable reference and incorrectly handled via BE\n    foo(x, ::bar)\n\n    complex(x, ::bar)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nfun baz(i: Int) = i\nfun <T> bar(x: T): T = TODO()\n\nfun nullableFun(): ((Int) -> Int)? = null\n\nfun test() {\n    val x1: (Int) -> Int = bar(if (true) ::baz else ::baz)\n    val x2: (Int) -> Int = bar(nullableFun() ?: ::baz)\n    val x3: (Int) -> Int = bar(::baz <!USELESS_ELVIS!>?: ::baz<!>)\n\n    val i = 0\n    val x4: (Int) -> Int = bar(when (i) {\n                                   10 -> ::baz\n                                   20 -> ::baz\n                                   else -> ::baz\n                               })\n\n    val x5: (Int) -> Int = bar(::baz<!NOT_NULL_ASSERTION_ON_CALLABLE_REFERENCE!>!!<!>)\n\n    (if (true) ::baz else ::baz)(1)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_PARAMETER\n\nfun <T> takeFun(f: (T) -> Unit) {}\nfun <T, R> callFun(f: (T) -> R): R = TODO()\n\nfun <T> foo(s: T) {}\nfun <T : <!FINAL_UPPER_BOUND!>Int<!>> fooInt(s: T) {}\n\nopen class Wrapper<T>(val value: T)\nfun <T, R : Wrapper<in T>> createWrapper(s: T): R = TODO()\n\nfun <T> Wrapper<T>.baz(transform: (T) -> Unit): T = TODO()\n\nfun test() {\n    takeFun<String>(::foo)\n    takeFun<String>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>::<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>fooInt<!><!>)\n\n    callFun<String, Wrapper<String>>(::createWrapper)\n    callFun<Int, Wrapper<Number>>(::createWrapper)\n    callFun<String, Wrapper<*>>(::createWrapper)\n    callFun<String, Wrapper<Int>>(::<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>createWrapper<!>)\n\n    callFun<Int, Wrapper<Int>>(::createWrapper).baz(::foo)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_PARAMETER\n\nfun <T, R> foo(x: T): R = TODO()\n\nfun <T> fooReturnInt(x: T): Int = 1\nfun <T> fooTakeString(x: String): T = TODO()\n\nfun <T, R> bar(x: T, y: R, f: (T) -> R): Pair<T, R> = TODO()\nfun <T, R> baz(f: (T) -> R, g: (T) -> R): Pair<T, R> = TODO()\n\nclass Pair<A, B>(val a: A, val b: B)\n\nfun test1() {\n    bar(\"\", 1, ::foo).checkType { _<Pair<String, Int>>() }\n    bar(\"\", 1, ::fooReturnInt).checkType { _<Pair<String, Int>>() }\n    bar(\"\", 1, ::fooTakeString).checkType { _<Pair<String, Int>>() }\n    bar(\"\", \"\", ::fooReturnInt).checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Pair<String, Any>>() }\n\n    val x: String = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>bar(\"\", \"\", ::fooReturnInt)<!>\n\n    baz(Int::toString, ::foo).checkType { _<Pair<Int, String>>() }\n}\n\nfun <T> listOf(): List<T> = TODO()\nfun <T> setOf(): Set<T> = TODO()\n\nfun <T> test2(x: T) {\n    bar(x, x, ::foo).checkType { _<Pair<T, T>>() }\n    bar(x, 1, ::foo).checkType { _<Pair<T, Int>>() }\n    bar(1, x, ::foo).checkType { _<Pair<Int, T>>() }\n\n    bar(listOf<T>(), setOf<T>(), ::foo).checkType { _<Pair<List<T>, Set<T>>> () }\n    bar(listOf<T>(), 1, ::foo).checkType { _<Pair<List<T>, Int>>() }\n    bar(1, listOf<T>(), ::foo).checkType { _<Pair<Int, List<T>>>() }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nfun test() {\n    val a1: Array<Double.(Double) -> Double> = arrayOf(Double::plus, Double::minus)\n    val a2: Array<Double.(Int) -> Double> = arrayOf(Double::plus, Double::minus)\n\n    val a3: Array<Int.(Int) -> Double> = arrayOf(Double::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>plus<!>, Double::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>minus<!>)\n    val a4: Array<Int.(Double) -> Double> = arrayOf(Int::plus, Double::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>minus<!>)\n    val a5: Array<Double.(Double) -> Double> = arrayOf(Double::plus, Int::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>minus<!>)\n}\n\nfun foo(x: Int) {}\nfun foo(y: String) {}\n\nfun <T> bar(x: T, f: (T) -> Unit) {}\n\nfun test2() {\n    bar(1, ::foo)\n    bar(\"\", ::foo)\n    bar(1.0, ::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>foo<!>)\n}\n"
        },
        {
            "code": "// !LANGUAGE: -TypeInferenceOnGenericsForCallableReferences\n// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_PARAMETER\n\nfun <T> bar(s: T) {}\nfun <T> complex(t: T, f: (T) -> Unit) {}\nfun <T> simple(f: (T) -> Unit) {}\n\nfun test1() {\n    complex(1, <!UNSUPPORTED_FEATURE!>::bar<!>)\n    simple<String>(<!UNSUPPORTED_FEATURE!>::bar<!>)\n}\n\n// ---\n\nfun <T> takeFun(f: (T) -> Unit) {}\nfun <T, R> callFun(f: (T) -> R): R = TODO()\n\nfun <T> foo(s: T) {}\n\nopen class Wrapper<T>(val value: T)\nfun <T, R : Wrapper<in T>> createWrapper(s: T): R = TODO()\n\nfun <T> Wrapper<T>.baz(transform: (T) -> Unit): T = TODO()\n\nfun test2() {\n    takeFun<String>(<!UNSUPPORTED_FEATURE!>::foo<!>)\n\n    callFun<String, Wrapper<String>>(<!UNSUPPORTED_FEATURE!>::createWrapper<!>)\n    callFun<Int, Wrapper<Number>>(<!UNSUPPORTED_FEATURE!>::createWrapper<!>)\n    callFun<String, Wrapper<*>>(<!UNSUPPORTED_FEATURE!>::createWrapper<!>)\n\n    callFun<Int, Wrapper<Int>>(<!UNSUPPORTED_FEATURE!>::createWrapper<!>).baz(<!UNSUPPORTED_FEATURE!>::foo<!>)\n}\n\n// ---\n\nfun test3() {\n    val a1: Array<Double.(Double) -> Double> = arrayOf(Double::plus, Double::minus)\n    val a2: Array<Double.(Int) -> Double> = arrayOf(Double::plus, Double::minus)\n}\n\n// ---\n\nclass A1 {\n    fun <T> a1(t: T): Unit {}\n    fun test1(): (String) -> Unit = A1()::a1\n}\n\nclass A2 {\n    fun <K, V> a2(key: K): V = TODO()\n\n    fun test1(): (String) -> Unit = A2()::a2\n    fun <T3> test2(): (T3) -> T3 = A2()::a2\n}\n\n// ---\n\nfun foo1(x: Int?) {}\nfun foo1(y: String?) {}\nfun foo1(z: Boolean) {}\n\nfun <T> baz1(element: (T) -> Unit): T? = null\n\nfun test4() {\n    val a1: Int? = baz1(::foo1)\n    val a2: String? = baz1(::foo1)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nclass Wrapper\n\nfun <R, S> Wrapper.foo(x: R): S = TODO()\nfun Wrapper.fooIntString(x: Int): String = \"\"\nfun <T> Wrapper.fooReturnString(x: T): String = \"\"\nfun <T> Wrapper.fooTakeInt(x: Int): T = TODO()\n\nfun <T, R, S> bar(f: T.(R) -> S): Tripple<T, R, S> = TODO()\nfun <T, R, S> baz(x: T, y: R, z: S, f: T.(R) -> S): Tripple<T, R, S> = TODO()\n\nclass Tripple<A, B, C>(val a: A, val b: B, val c: C)\n\nfun test1() {\n    val x: Wrapper.(String) -> Boolean = Wrapper::foo\n    bar<Wrapper, Double, Float>(Wrapper::foo).checkType { _<Tripple<Wrapper, Double, Float>>() }\n    bar(Wrapper::fooIntString).checkType { _<Tripple<Wrapper, Int, String>>() }\n}\n\nfun <T> test2() {\n    bar<Wrapper, Int, String>(Wrapper::fooReturnString).checkType { _<Tripple<Wrapper, Int, String>>() }\n    bar<Wrapper, T, String>(Wrapper::fooReturnString).checkType { _<Tripple<Wrapper, T, String>>() }\n    bar<Wrapper, T, T>(<!NI;TYPE_MISMATCH!>Wrapper::<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>fooReturnString<!><!>)\n    bar<Wrapper, Int, Int>(<!NI;TYPE_MISMATCH!>Wrapper::<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>fooReturnString<!><!>)\n\n    bar<Wrapper, Int, T>(Wrapper::fooTakeInt).checkType { _<Tripple<Wrapper, Int, T>>() }\n    bar<Wrapper, Int, String>(Wrapper::fooTakeInt).checkType { _<Tripple<Wrapper, Int, String>>() }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_PARAMETER\n\nfun foo(i: Int) {}\nfun foo(s: String) {}\nfun <T> id(x: T): T = x\nfun <T> baz(x: T, y: T): T = TODO()\n\nfun test() {\n    val x1: (Int) -> Unit = id(id(::foo))\n    val x2: (Int) -> Unit = baz(id(::foo), ::foo)\n    val x3: (Int) -> Unit = baz(id(::foo), id(id(::foo)))\n    val x4: (String) -> Unit = baz(id(::foo), id(id(::foo)))\n    val x5: (Double) -> Unit = baz(id(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>foo<!>), id(id(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;NONE_APPLICABLE!>foo<!>)))\n\n\n    id<(Int) -> Unit>(id(id(::foo)))\n    id(id<(Int) -> Unit>(::foo))\n    baz<(Int) -> Unit>(id(::foo), id(id(::foo)))\n    baz(id(::foo), id(id<(Int) -> Unit>(::foo)))\n    baz(id(::foo), id<(Int) -> Unit>(id(::foo)))\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nfun foo(x: Int?) {}\nfun foo(y: String?) {}\nfun foo(z: Boolean) {}\n\nfun <T> baz(element: (T) -> Unit): T? = null\n\nfun test1() {\n    val a1: Int? = baz(::foo)\n    val a2: String? = baz(::foo)\n    val a3: Boolean? = baz<Boolean>(::foo)\n\n    baz<Int>(::foo).checkType { _<Int?>() }\n    baz<String>(::foo).checkType { _<String?>() }\n    baz<Boolean>(::foo).checkType { _<Boolean?>() }\n\n    val b1: Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>baz(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>foo<!>)<!>\n    val b2: String = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>baz(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>foo<!>)<!>\n    val b3: Boolean = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>baz(::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>foo<!>)<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nfun <T, R> foo(x: T): R = TODO()\nfun <T, R> bar(x: T, y: R, f: (T) -> R): Pair<T, R?> = TODO()\n\ninline fun <reified T, reified R> baz(x: T, y: R, f: (T) -> R) {}\n\ndata class Pair<A, B>(val a: A, val b: B)\n\nfun <T> test(x: T) {\n    bar(1, \"\", ::foo).checkType { _<Pair<Int, String?>>() }\n    bar(null, \"\", ::foo).checkType { _<Pair<Nothing?, String?>>() }\n    bar(1, null, ::foo).checkType { _<Pair<Int, Nothing?>>() }\n    bar(null, null, ::foo).checkType { _<Pair<Nothing?, Nothing?>>() }\n    bar(1, x, ::foo).checkType { _<Pair<Int, T?>>() }\n\n    val s1: Pair<Int, String?> = bar(1, \"\", ::foo)\n    val (a: Int, b: String?) = bar(1, \"\", ::foo)\n\n    val s2: Pair<Int?, String?> = bar(null, null, ::foo)\n\n    baz<Int?, String?>(null, null, ::foo)\n\n    baz<Int, String?>(<!NULL_FOR_NONNULL_TYPE!>null<!>, null, ::foo)\n    baz<Int?, String>(null, <!NULL_FOR_NONNULL_TYPE!>null<!>, ::foo)\n    <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>baz<!>(null, \"\", ::foo)\n    <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>baz<!>(1, null, ::foo)\n    <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION, REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>baz<!>(null, null, ::foo)\n\n    val s3: Pair<Int, String?> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>bar(null, null, ::<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>)<!>\n    val s4: Pair<Int?, String> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>bar(null, null, ::<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>)<!>\n\n    val s5: Pair<Int, String> = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>bar(1, \"\", ::foo)<!>\n    val (a1: Int, b1: String) = <!COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH!>bar(1, \"\", ::foo)<!>\n}"
        },
        {
            "code": "package test\n\nclass Foo {\n    fun <T> bar(x: Int) = x\n}\n\nfun test() {\n    Foo::<!TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!> <!SYNTAX!>< <!DEBUG_INFO_MISSING_UNRESOLVED!>Int<!> ><!> <!SYNTAX!>(2 <!DEBUG_INFO_MISSING_UNRESOLVED!>+<!> 2)<!>\n}\n"
        },
        {
            "code": "// FILE: test/GenericSam.java\n\npackage test;\n\npublic interface GenericSam<T> {\n    void invoke(T t);\n}\n\n// FILE: test.kt\n\nimport test.GenericSam\n\nfun f1() = Runnable::class\nfun f2() = Runnable::run\nfun f3() = java.lang.Runnable::class\nfun f4() = java.lang.Runnable::run\n\nfun f5() = GenericSam::class\nfun f6() = GenericSam<*>::invoke\nfun f7() = test.GenericSam::class\nfun f8() = test.GenericSam<String>::invoke\n\nfun g1() = Runnable {}::class\nfun g2() = Runnable {}::run\nfun g3() = java.lang.Runnable {}::class\nfun g4() = java.lang.Runnable {}::run\n\nfun g5() = GenericSam<String> {}::class\nfun g6() = GenericSam<String> {}::invoke\nfun g7() = test.GenericSam<String> {}::class\nfun g8() = test.GenericSam<String> {}::invoke\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// FILE: simpleName.kt\n\npackage foo\n\nfun test() {\n    <!EXPRESSION_EXPECTED_PACKAGE_FOUND!>foo<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>test<!>\n}\n\n// FILE: qualifiedName.kt\n\npackage foo.bar\n\nfun test() {\n    foo.<!EXPRESSION_EXPECTED_PACKAGE_FOUND!>bar<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>test<!>\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: 1.kt\n\npackage a\n\nclass b {\n    class c\n}\n\n// MODULE: m2\n// FILE: 2.kt\n\npackage a.b\n\nclass c {\n    fun foo() {}\n}\n\n// MODULE: m3(m1, m2)\n// FILE: test.kt\n\npackage test\n\nfun test() = a.b.c::foo\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun eat(value: Any) {}\n\nfun test(param: String) {\n    val a = ::<!UNSUPPORTED!>param<!>\n\n    val local = \"local\"\n    val b = ::<!UNSUPPORTED!>local<!>\n\n    val lambda = { -> }\n    val g = ::<!UNSUPPORTED!>lambda<!>\n\n    eat(::<!UNSUPPORTED!>param<!>)\n}\n"
        },
        {
            "code": "// FILE: test.kt\nval customerName = Customer::<!UNSUPPORTED!>name<!>\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nvar x: Int = 42\nval y: String get() = \"y\"\n\nfun testX() {\n    val xx = ::x\n    checkSubtype<KMutableProperty0<Int>>(xx)\n    checkSubtype<KProperty0<Int>>(xx)\n    checkSubtype<KMutableProperty<Int>>(xx)\n    checkSubtype<KProperty<Int>>(xx)\n    checkSubtype<KCallable<Int>>(xx)\n\n    checkSubtype<String>(xx.name)\n    checkSubtype<Int>(xx.get())\n    xx.set(239)\n}\n\nfun testY() {\n    val yy = ::y\n    checkSubtype<KMutableProperty0<String>>(<!TYPE_MISMATCH!>yy<!>)\n    checkSubtype<KProperty0<String>>(yy)\n    checkSubtype<KMutableProperty<String>>(<!TYPE_MISMATCH!>yy<!>)\n    checkSubtype<KProperty<String>>(yy)\n    checkSubtype<KCallable<String>>(yy)\n\n    checkSubtype<String>(yy.name)\n    checkSubtype<String>(yy.get())\n    yy.<!UNRESOLVED_REFERENCE!>set<!>(\"yy\")\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.KProperty1\n\ninterface Base {\n    val x: Any\n}\n\nclass A : Base {\n    override val x: String = \"\"\n}\n\nopen class B : Base {\n    override val x: Number = 1.0\n}\n\nclass C : B() {\n    override val x: Int = 42\n}\n\nfun test() {\n    val base = Base::x\n    checkSubtype<KProperty1<Base, Any>>(base)\n    checkSubtype<Any>(base.get(A()))\n    checkSubtype<Number>(<!TYPE_MISMATCH!>base.get(B())<!>)\n    checkSubtype<Int>(<!TYPE_MISMATCH!>base.get(C())<!>)\n\n    val a = A::x\n    checkSubtype<KProperty1<A, String>>(a)\n    checkSubtype<String>(a.get(A()))\n    checkSubtype<Number>(<!TYPE_MISMATCH!>a.get(<!TYPE_MISMATCH!>B()<!>)<!>)\n\n    val b = B::x\n    checkSubtype<KProperty1<B, Number>>(b)\n    checkSubtype<Int>(<!TYPE_MISMATCH!>b.get(C())<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A {\n    val foo: Int = 42\n    var bar: String = \"\"\n}\n\nfun test() {\n    val p = A::foo\n\n    checkSubtype<KProperty1<A, Int>>(p)\n    checkSubtype<KMutableProperty1<A, Int>>(<!TYPE_MISMATCH!>p<!>)\n    checkSubtype<Int>(p.get(A()))\n    p.get(<!NO_VALUE_FOR_PARAMETER!>)<!>\n    p.<!UNRESOLVED_REFERENCE!>set<!>(A(), 239)\n\n    val q = A::bar\n\n    checkSubtype<KProperty1<A, String>>(q)\n    checkSubtype<KMutableProperty1<A, String>>(q)\n    checkSubtype<String>(q.get(A()))\n    q.set(A(), \"q\")\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty1\n\nclass TestClass(var prop: Int)\nopen class OtherClass\nfun OtherClass.test(prop: KProperty1<TestClass, Int>): Unit = throw Exception()\nclass OtherClass2: OtherClass() {\n    val result = test(TestClass::<!UNRESOLVED_REFERENCE!>result<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nval String.countCharacters: Int\n    get() = length\n\nvar Int.meaning: Long\n    get() = 42L\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\nfun test() {\n    val f = String::countCharacters\n    \n    checkSubtype<KProperty1<String, Int>>(f)\n    checkSubtype<KMutableProperty1<String, Int>>(<!TYPE_MISMATCH!>f<!>)\n    checkSubtype<Int>(f.get(\"abc\"))\n    f.<!UNRESOLVED_REFERENCE!>set<!>(\"abc\", 0)\n\n    val g = Int::meaning\n\n    checkSubtype<KMutableProperty1<Int, Long>>(g)\n    checkSubtype<Long>(g.get(0))\n    g.set(1, 0L)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS:-UNUSED_VARIABLE\n// FILE: test.kt\n\nimport JavaClass.*\n\nimport kotlin.reflect.*\n\nfun test() {\n    val pubFinRef: KProperty0<String> = ::publicFinal\n    val pubMutRef: KMutableProperty0<Any?> = ::publicMutable\n    val protFinRef: KProperty<Double> = ::protectedFinal\n    val protMutRef: KMutableProperty<Char> = ::protectedMutable\n    val privFinRef: KProperty<JavaClass?> = ::<!INVISIBLE_MEMBER!>privateFinal<!>\n    val privMutRef: KMutableProperty<Throwable?> = ::<!INVISIBLE_MEMBER!>privateMutable<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS:-UNUSED_VARIABLE\n// FILE: test.kt\n\nimport kotlin.reflect.*\n\nfun test() {\n    val pubFinRef: KProperty1<JavaClass, Int> = JavaClass::publicFinal\n    val pubMutRef: KMutableProperty1<JavaClass, Long> = JavaClass::publicMutable\n    val protFinRef: KProperty1<JavaClass, Double> = JavaClass::protectedFinal\n    val protMutRef: KMutableProperty1<JavaClass, Char> = JavaClass::protectedMutable\n    val privFinRef: KProperty1<JavaClass, String?> = JavaClass::<!INVISIBLE_MEMBER!>privateFinal<!>\n    val privMutRef: KMutableProperty1<JavaClass, Any?> = JavaClass::<!INVISIBLE_MEMBER!>privateMutable<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun foo(a: String, b: Int = 5): String {\n    return a + b\n}\n\nfun bar1(body: (String) -> String): String {\n    return body(\"something\")\n}\n\nfun bar2(body: (String, Int) -> String): String {\n    return body(\"something\", 0)\n}\n\nfun test() {\n    bar1(<!NI;UNSUPPORTED_FEATURE, OI;TYPE_MISMATCH!>::foo<!>)\n    bar2(::foo)\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage a\n\nimport b.B.*\nimport kotlin.reflect.KClass\n\nclass Companion\n\nval f: KClass<a.Companion> = Companion::class\n\n// FILE: 2.kt\n\npackage b\n\nclass B {\n    companion object Companion\n}\n"
        },
        {
            "code": "class Foo {\n    fun bar() {}\n    fun f() = <!UNRESOLVED_REFERENCE!>Unresolved<!>()::<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\n}\n\nval f: () -> Unit = <!UNRESOLVED_REFERENCE!>Unresolved<!>()::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\npackage test\n\nfun nullableFun(): Int? = null\nfun Int.foo() {}\n\nval test1 = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>nullableFun()<!>?::<!UNSAFE_CALL!>foo<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\npackage test\n\nobject ClassMemberMarker\n\nclass a<T> {\n    fun foo() = ClassMemberMarker\n}\n\nclass b<T1, T2> {\n    fun foo() = ClassMemberMarker\n}\n\nfun Int.foo() {}\n\nclass Test {\n    val <T> List<T>.a: Int get() = size\n    val <T> List<T>.b: Int? get() = size\n\n    fun <T> List<T>.testCallable1(): () -> Unit = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>a<T><!>::foo\n    fun <T> List<T>.testCallable2(): () -> Unit = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>b<!>?::<!UNSAFE_CALL!>foo<!>\n    fun <T> List<T>.testCallable3(): () -> Unit = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>b<T, Any><!>::<!UNSAFE_CALL!>foo<!>\n    fun <T> List<T>.testCallable4(): () -> Unit = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>b<T><!>?::<!UNSAFE_CALL!>foo<!>\n\n    fun <T> List<T>.testClassLiteral1() = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>a<T><!>::class\n    fun <T> List<T>.testClassLiteral2() = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS, RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>b<!>?::class\n    fun <T> List<T>.testClassLiteral3() = <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS, RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>b<T, Any><!>::class\n\n    fun <T> List<T>.testUnresolved1() = <!UNRESOLVED_REFERENCE!>unresolved<!><T>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    fun <T> List<T>.testUnresolved2() = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!>a<<!UNRESOLVED_REFERENCE!>unresolved<!>><!>::foo\n    fun <T> List<T>.testUnresolved3() = a<<!SYNTAX!><!>>::foo\n    fun <T> List<T>.testUnresolved4() = <!UNRESOLVED_REFERENCE!>unresolved<!>?::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n}"
        },
        {
            "code": "class Outer {\n    class Nested\n    inner class Inner\n}\n\nfun test() {\n    Outer()::Inner\n    Outer()::<!UNRESOLVED_REFERENCE!>Nested<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nimport kotlin.reflect.KClass\n\nfun f1(x: String?): String {\n    x!!::hashCode\n    return <!DEBUG_INFO_SMARTCAST!>x<!>\n}\n\nfun f2(y: String?): String {\n    val f: KClass<*> = (y ?: return \"\")::class\n    return <!DEBUG_INFO_SMARTCAST!>y<!>\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nenum class E { EN }\n\nfun test() {\n    A()::<!UNRESOLVED_REFERENCE!>test<!>\n    E.EN::<!UNRESOLVED_REFERENCE!>valueOf<!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\npackage test\n\nobject Wrong\nobject Right\n\nclass a {\n    class b<T> {\n        class c {\n            fun foo() = Wrong\n        }\n    }\n}\n\nfun Int.foo() = Right\n\nclass Test {\n    val a: List<Int> = null!!\n\n    val <T> List<T>.b: Int get() = 42\n\n    val Int.c: Int get() = 42\n\n    val test1: () -> Right = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!><!DEBUG_INFO_MISSING_UNRESOLVED!>a<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>b<!><<!DEBUG_INFO_MISSING_UNRESOLVED!>Int<!>>.<!DEBUG_INFO_MISSING_UNRESOLVED!>c<!><!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    val test1a: () -> Right = a.<!NI;DEBUG_INFO_LEAKING_THIS!>b<!>.<!NI;DEBUG_INFO_LEAKING_THIS!>c<!>::foo\n\n    val test2: () -> Right = <!RESERVED_SYNTAX_IN_CALLABLE_REFERENCE_LHS!><!DEBUG_INFO_MISSING_UNRESOLVED!>a<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>b<!><<!DEBUG_INFO_MISSING_UNRESOLVED!>Int<!>>.<!DEBUG_INFO_MISSING_UNRESOLVED!>c<!><!>?::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n}"
        },
        {
            "code": "// FILE: 1.kt\n\npackage a\n\nimport b.*\nimport kotlin.reflect.KClass\n\nclass A\nobject B\n\nval f: KClass<a.A> = A::class\nval g: KClass<a.B> = B::class\n\n// FILE: 2.kt\n\npackage b\n\nobject A\nobject B\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nclass Foo<out T>(name: T) {\n    private var prop: T = name\n        private set\n\n    fun testProp() {\n        val ok1 = this::prop\n        val ok2 = this@Foo::prop\n        val ok3 = object { val y: Any = this@Foo::prop }\n\n        val fail1 = Foo(prop)::<!INVISIBLE_MEMBER!>prop<!>\n    }\n\n    fun testFunc() {\n        val ok1 = this::func\n        val ok2 = this@Foo::func\n        val ok3 = object { val y: Any = this@Foo::func }\n\n        val fail1 = Foo(prop)::<!INVISIBLE_MEMBER!>func<!>\n    }\n\n    private fun func(t: T): T = t\n}\n"
        },
        {
            "code": "fun unusedExpression(s: String) {\n    <!UNUSED_EXPRESSION!>s::hashCode<!>\n    <!UNUSED_EXPRESSION!>s::class<!>\n}\n\nfun noUnusedParameter(s: String): Int {\n    val f = s::hashCode\n    return f()\n}\n\nfun unreachableCode(): Int {\n    (if (true) return 1 else return 0)<!UNREACHABLE_CODE!>::toString<!>\n    <!UNREACHABLE_CODE!>return 0<!>\n}\n\nfun unreachableCodeInLoop(): Int {\n    while (true) {\n        (break)<!UNREACHABLE_CODE!>::toString<!>\n        <!UNREACHABLE_CODE!>return 1<!>\n    }\n    return 2\n}\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun f1(x: Int?): Any = x::<!UNSAFE_CALL!>hashCode<!>\nfun <T> f2(t: T): Any = t::<!UNSAFE_CALL!>hashCode<!>\nfun <S : String?> f3(s: S): Any = s::<!UNSAFE_CALL!>hashCode<!>\nfun <U : Any> f4(u: U?): Any = u::<!UNSAFE_CALL!>hashCode<!>\nfun f5(c: List<*>): Any = c[0]::<!UNSAFE_CALL!>hashCode<!>\n\nfun f6(j: J): Any = j.platformString()::hashCode\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\npackage test\n\nclass C {\n    companion object {\n        fun foo(): String = \"companion\"\n        fun bar() {}\n    }\n\n    fun foo(): Int = 0\n}\n\nfun test() {\n    val r1 = C::foo\n    checkSubtype<(C) -> Int>(r1)\n\n    val r2 = test.C::foo\n    checkSubtype<(C) -> Int>(r2)\n\n    val r3 = C.Companion::foo\n    checkSubtype<() -> String>(r3)\n\n    val r4 = test.C.Companion::foo\n    checkSubtype<() -> String>(r4)\n\n    val r5 = (C)::foo\n    checkSubtype<() -> String>(r5)\n\n    val r6 = (test.C)::foo\n    checkSubtype<() -> String>(r6)\n\n    val c = C.Companion\n    val r7 = c::foo\n    checkSubtype<() -> String>(r7)\n\n    C::<!UNRESOLVED_REFERENCE!>bar<!>\n}\n"
        },
        {
            "code": "fun test() = (\"\").<!FUNCTION_CALL_EXPECTED!>hashCode<!>::hashCode\n"
        },
        {
            "code": "open class A(val x: Any)\n\nclass B : A(<!NO_THIS!>this<!>::class)\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\nclass DTO {\n    val q: Int = 0\n    operator fun get(<!UNUSED_PARAMETER!>prop<!>: <!UNRESOLVED_REFERENCE!>KProperty1<!><*, Int>): Int = 0\n}\n\nfun foo(intDTO: DTO?, <!UNUSED_PARAMETER!>p<!>: <!UNRESOLVED_REFERENCE!>KProperty1<!><*, Int>) {\n    if (intDTO != null) {\n        <!DEBUG_INFO_SMARTCAST!>intDTO<!>[DTO::q]\n        <!DEBUG_INFO_SMARTCAST!>intDTO<!>.q\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nclass Unrelated()\n\nclass Test(val name: String = \"\") {\n    init {\n        Unrelated::<!UNRESOLVED_REFERENCE!>name<!>\n        Unrelated::<!UNRESOLVED_REFERENCE!>foo<!>\n    }\n\n    fun foo() {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nimport Obj.ext\nimport A.Companion.ext2\n\nobject Obj {\n    val String.ext: String get() = this\n}\n\nclass A {\n    companion object {\n        val String.ext2: String get() = this\n    }\n}\n\nfun test() {\n    String::<!EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED!>ext<!>\n    Obj::<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>ext<!>\n\n    String::<!EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED!>ext2<!>\n    A.Companion::<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>ext2<!>\n    A::<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>ext2<!>\n\n    A::<!UNRESOLVED_REFERENCE!>foo<!>\n    A::<!UNRESOLVED_REFERENCE!>bar<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION -UNUSED_VARIABLE\n\nimport kotlin.reflect.KProperty1\n\nclass Scope {\n    abstract class Nested<T> {\n        abstract val key: Int\n        abstract val keyT: T\n    }\n}\n\nfun simple(a: Any?) {}\nfun <K> id(x: K): K = x\n\nfun test() {\n    simple(Scope.Nested<String>::key)\n    val a = id(Scope.Nested<String>::keyT)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.reflect.KProperty1<Scope.Nested<kotlin.String>, kotlin.String>\")!>a<!>\n\n    val b = id(Scope.Nested<*>::keyT)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.reflect.KProperty1<Scope.Nested<*>, kotlin.Any?>\")!>b<!>\n\n    val c = id(Scope.Nested<out Number?>::keyT)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.reflect.KProperty1<Scope.Nested<out kotlin.Number?>, kotlin.Number?>\")!>c<!>\n\n    val d = id(Scope.Nested<*>::keyT <!UNCHECKED_CAST!>as Scope.Nested<Number><!>)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"Scope.Nested<kotlin.Number>\")!>d<!>\n\n    val g = id<KProperty1<Scope.Nested<*>, Any?>>(Scope.Nested<*>::keyT)\n\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.reflect.KProperty1<Scope.Nested<*>, kotlin.Any?>\")!>g<!>\n}\n\nfun justResolve() {\n    val a = Scope.Nested<String>::key\n    val b = Scope.Nested<String>::keyT\n    val c = Scope.Nested<*>::keyT\n    val d = Scope.Nested<out Number?>::keyT\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty1\n\nclass DTO {\n    val q: Int = 0\n    operator fun get(prop: KProperty1<*, Int>): Int = 0\n}\n\nfun foo(intDTO: DTO?, p: KProperty1<*, Int>) {\n    if (intDTO != null) {\n        <!DEBUG_INFO_SMARTCAST!>intDTO<!>[DTO::q]\n        <!DEBUG_INFO_SMARTCAST!>intDTO<!>.q\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty1\n\ninterface A\ninline val <T : A> T.bla get() = 1\n\nclass B<T>\nfun <K, V> B<K>.foo(p: KProperty1<in K, V>): B<V> = TODO()\n\nfun <K, V> B<out K>.bar(p: KProperty1<out K, V>): B<V> = TODO()\n\nfun <K, V> B<K>.baz(p: KProperty1<out K, V>): B<V> = TODO()\n\nfun <K, V> B<K>.star(p: KProperty1<*, V>): B<V> = TODO()\n\n\nfun <R : A> B<R>.test(){\n    foo(A::bla)\n    bar(A::bla)\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>baz<!>(<!NI;TYPE_MISMATCH!>A::bla<!>)\n    star(A::bla)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\ninterface A\nabstract class B\nannotation class C\nenum class D\n\nfun main() {\n    ::<!UNRESOLVED_REFERENCE!>A<!>\n    ::<!CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS!>B<!>\n    ::<!CALLABLE_REFERENCE_TO_ANNOTATION_CONSTRUCTOR!>C<!>   // KT-3465\n    ::<!INVISIBLE_MEMBER!>D<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !LANGUAGE: +CallableReferencesToClassMembersWithEmptyLHS\n\nimport kotlin.reflect.KFunction0\n\nfun expectFunction0Unit(f: () -> Unit) = f\nfun expectFunction0String(f: () -> String) = f\nfun expectFunction1Unit(f: (A) -> Unit) = f\nfun expectFunction1String(f: (A) -> String) = f\n\nfun foo(): String = \"\"\n\nclass A {\n    fun foo() {}\n    \n    fun main() {\n        val x = ::foo\n\n        checkSubtype<KFunction0<Unit>>(x)\n\n        expectFunction0Unit(x)\n        expectFunction0String(<!TYPE_MISMATCH!>x<!>)\n        expectFunction1Unit(<!TYPE_MISMATCH!>x<!>)\n        expectFunction1String(<!TYPE_MISMATCH!>x<!>)\n\n        expectFunction0Unit(::foo)\n        expectFunction0String(::foo)\n        expectFunction1Unit(<!TYPE_MISMATCH!>::foo<!>)\n        expectFunction1String(<!TYPE_MISMATCH!>::foo<!>)\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\nimport A.Inner\n\nclass A {\n    inner class Inner\n}\n\nfun main() {\n    ::<!UNRESOLVED_REFERENCE!>Inner<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: test/A.java\n\npackage test;\n\nimport java.util.Arrays;\n\npublic class A {\n    public static void main(String[] args) {\n        System.out.println(Arrays.asList(args));\n    }\n}\n\n// FILE: 1.kt\n\nimport kotlin.reflect.*\nimport test.A\n\nfun foo(args: Array<String>) {\n    val main2 = A::main\n    checkSubtype<KFunction1<Array<String>, Unit>>(main2)\n    main2(args)\n    (A::main)(args)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.KFunction1\n\nclass A {\n    fun foo() = 42\n}\n\nfun A.<!EXTENSION_SHADOWED_BY_MEMBER!>foo<!>() {}\n\nfun main() {\n    val x = A::foo\n\n    checkSubtype<KFunction1<A, Int>>(x)\n}\n"
        },
        {
            "code": "// KT-15951 Callable reference to class constructor from object is not resolved\n\nobject A {\n    class Wrapper\n}\n\nclass Outer {\n    companion object {\n        class Wrapper\n    }\n}\n\nfun test() {\n    A::Wrapper\n    (A)::<!UNRESOLVED_REFERENCE!>Wrapper<!>\n\n    Outer.Companion::Wrapper\n    (Outer.Companion)::<!UNRESOLVED_REFERENCE!>Wrapper<!>\n    <!UNUSED_EXPRESSION!>Outer::<!UNRESOLVED_REFERENCE!>Wrapper<!><!>\n    (Outer)::<!UNRESOLVED_REFERENCE!>Wrapper<!>\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// FILE: a.kt\n\npackage first\n\nclass A\n\nfun A.foo() {}\nfun A.bar() {}\nfun A.baz() {}\n\n// FILE: b.kt\n\npackage other\n\nimport kotlin.reflect.KFunction1\n\nimport first.A\nimport first.foo\n\nfun main() {\n    val x = first.A::foo\n    first.A::<!UNRESOLVED_REFERENCE!>bar<!>\n    A::<!UNRESOLVED_REFERENCE!>baz<!>\n\n    checkSubtype<KFunction1<A, Unit>>(x)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// !LANGUAGE: +CallableReferencesToClassMembersWithEmptyLHS\n\nimport kotlin.reflect.KFunction1\n\nclass A {\n    inner class Inner\n}\n    \nfun A.main() {\n    ::Inner\n    val y = A::Inner\n\n    checkSubtype<KFunction1<A, A.Inner>>(y)\n}\n\nfun Int.main() {\n    ::<!UNRESOLVED_REFERENCE!>Inner<!>\n    val y = A::Inner\n\n    checkSubtype<KFunction1<A, A.Inner>>(y)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A\n\nfun foo() {}\nfun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\nfun baz() = \"OK\"\n\nfun A.main() {\n    val x = ::foo\n    val y = ::bar\n    val z = ::baz\n\n    checkSubtype<KFunction0<Unit>>(x)\n    checkSubtype<KFunction1<Int, Unit>>(y)\n    checkSubtype<KFunction0<String>>(z)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: a.kt\n\npackage a.b.c\n\nclass D {\n    fun foo() = 42\n}\n\n// FILE: b.kt\n\nimport kotlin.reflect.KFunction1\n\nfun main() {\n    val x = a.b.c.D::foo\n\n    checkSubtype<KFunction1<a.b.c.D, Int>>(x)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\nimport kotlin.reflect.KFunction1\n\nclass A {\n    inner class Inner\n}\n\nfun main() {\n    ::<!UNRESOLVED_REFERENCE!>Inner<!>\n    val y = A::Inner\n\n    checkSubtype<KFunction1<A, A.Inner>>(y)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// !LANGUAGE: +CallableReferencesToClassMembersWithEmptyLHS\n\nimport kotlin.reflect.KFunction1\n\nclass A {\n    inner class Inner\n    \n    fun main() {\n        ::Inner\n        val y = A::Inner\n\n        checkSubtype<KFunction1<A, Inner>>(y)\n    }\n    \n    companion object {\n        fun main() {\n            ::<!UNRESOLVED_REFERENCE!>Inner<!>\n            val y = A::Inner\n\n            checkSubtype<KFunction1<A, A.Inner>>(y)\n        }\n    }\n}\n\nclass B {\n    fun main() {\n        ::<!UNRESOLVED_REFERENCE!>Inner<!>\n        val y = A::Inner\n\n        checkSubtype<KFunction1<A, A.Inner>>(y)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION,-UNUSED_VARIABLE\nfun foo(x: Int, <!UNUSED_PARAMETER!>y<!>: Any) = x\nfun foo(<!UNUSED_PARAMETER!>x<!>: Any, y: Int) = y\n\nfun main() {\n    ::<!OVERLOAD_RESOLUTION_AMBIGUITY!>foo<!>\n    \n    val fooRef: (Int, Any) -> Unit = ::<!NONE_APPLICABLE!>foo<!>\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nfun foo() {}\nfun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\nfun baz() = \"OK\"\n\nfun main() {\n    val x = ::foo\n    val y = ::bar\n    val z = ::baz\n\n    checkSubtype<KFunction0<Unit>>(x)\n    checkSubtype<KFunction1<Int, Unit>>(y)\n    checkSubtype<KFunction0<String>>(z)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A\n\nfun foo() {}\nfun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\nfun baz() = \"OK\"\n\nclass B {\n    fun A.main() {\n        val x = ::foo\n        val y = ::bar\n        val z = ::baz\n\n        checkSubtype<KFunction0<Unit>>(x)\n        checkSubtype<KFunction1<Int, Unit>>(y)\n        checkSubtype<KFunction0<String>>(z)\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nfun foo() {}\nfun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\nfun baz() = \"OK\"\n\nclass A {\n    fun main() {\n        val x = ::foo\n        val y = ::bar\n        val z = ::baz\n\n        checkSubtype<KFunction0<Unit>>(x)\n        checkSubtype<KFunction1<Int, Unit>>(y)\n        checkSubtype<KFunction0<String>>(z)\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: a.kt\n\npackage other\n\nfun foo() {}\n\nclass A {\n    fun bar() = 42\n}\n\nfun A.baz(<!UNUSED_PARAMETER!>x<!>: String) {}\n\n// FILE: b.kt\n\nimport kotlin.reflect.*\n\nimport other.foo as foofoo\nimport other.A as AA\nimport other.baz as bazbaz\n\nfun main() {\n    val x = ::foofoo\n    val y = AA::bar\n    val z = AA::bazbaz\n\n    checkSubtype<KFunction0<Unit>>(x)\n    checkSubtype<KFunction1<AA, Int>>(y)\n    checkSubtype<KFunction2<AA, String, Unit>>(z)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A\n\nfun main() {\n    fun foo() {}\n    fun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\n    fun baz() = \"OK\"\n    \n    fun A.ext() {\n        val x = ::foo\n        val y = ::bar\n        val z = ::baz\n\n        checkSubtype<KFunction0<Unit>>(x)\n        checkSubtype<KFunction1<Int, Unit>>(y)\n        checkSubtype<KFunction0<String>>(z)\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A {\n    fun foo() {}\n    fun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\n    fun baz() = \"OK\"\n}\n\nfun main() {\n    val x = A::foo\n    val y = A::bar\n    val z = A::baz\n\n    checkSubtype<KFunction1<A, Unit>>(x)\n    checkSubtype<KFunction2<A, Int, Unit>>(y)\n    checkSubtype<KFunction1<A, String>>(z)\n\n    checkSubtype<KFunction<Unit>>(x)\n    checkSubtype<KFunction<Unit>>(y)\n    checkSubtype<KFunction<String>>(z)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: a.kt\n\npackage first\n\nfun foo() {}\nfun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\nfun baz() = \"OK\"\n\n// FILE: b.kt\n\npackage other\n\nimport kotlin.reflect.*\n\nimport first.foo\nimport first.bar\nimport first.baz\n\nfun main() {\n    val x = ::foo\n    val y = ::bar\n    val z = ::baz\n\n    checkSubtype<KFunction0<Unit>>(x)\n    checkSubtype<KFunction1<Int, Unit>>(y)\n    checkSubtype<KFunction0<String>>(z)\n}\n"
        },
        {
            "code": "annotation class Ann(val prop: String)\n\nval annCtorRef = ::<!CALLABLE_REFERENCE_TO_ANNOTATION_CONSTRUCTOR!>Ann<!>\nval annClassRef = Ann::class\nval annPropRef = Ann::prop\n"
        },
        {
            "code": "class A<T, U : Any> {\n    fun foo() = <!CALLABLE_REFERENCE_LHS_NOT_A_CLASS!>T::<!UNRESOLVED_REFERENCE!>toString<!><!>\n\n    fun bar() = <!CALLABLE_REFERENCE_LHS_NOT_A_CLASS!>U::<!UNRESOLVED_REFERENCE!>toString<!><!>\n}\n\nfun <T> foo() = <!CALLABLE_REFERENCE_LHS_NOT_A_CLASS!>T::<!UNRESOLVED_REFERENCE!>toString<!><!>\n\nfun <U : Any> bar() = <!CALLABLE_REFERENCE_LHS_NOT_A_CLASS!>U::<!UNRESOLVED_REFERENCE!>toString<!><!>\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nfun main() {\n    fun foo() {}\n    fun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\n    fun baz() = \"OK\"\n    \n    class A {\n        val x = ::foo\n        val y = ::bar\n        val z = ::baz\n\n        fun main() {\n            checkSubtype<KFunction0<Unit>>(x)\n            checkSubtype<KFunction1<Int, Unit>>(y)\n            checkSubtype<KFunction0<String>>(z)\n        }\n    }\n}\n"
        },
        {
            "code": "// FILE: Foo.kt\n\npackage test\n\nclass Foo {\n    fun bar() {}\n}\n\n// FILE: test.kt\n\nimport test.Foo\n\nfun Foo(): String = \"\"\n\nval f = Foo::bar\nval g = Foo::<!UNRESOLVED_REFERENCE!>length<!>\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.KFunction2\n\nopen class A {\n    fun foo(s: String): String = s\n}\n\nclass B : A() {\n}\n\n\nfun test() {\n    B::foo checkType { _<KFunction2<B, String, String>>() }\n\n    (B::hashCode)(<!TYPE_MISMATCH!>\"No.\"<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\nimport kotlin.reflect.KFunction0\n\nclass A {\n    class Nested\n}\n    \nfun A.main() {\n    ::<!UNRESOLVED_REFERENCE!>Nested<!>\n    val y = A::Nested\n    \n    checkSubtype<KFunction0<A.Nested>>(y)\n}\n\nfun Int.main() {\n    ::<!UNRESOLVED_REFERENCE!>Nested<!>\n    val y = A::Nested\n\n    checkSubtype<KFunction0<A.Nested>>(y)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A\n\nfun A.foo() {}\nfun A.bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\nfun A.baz() = \"OK\"\n\nfun main() {\n    val x = A::foo\n    val y = A::bar\n    val z = A::baz\n\n    checkSubtype<KFunction1<A, Unit>>(x)\n    checkSubtype<KFunction2<A, Int, Unit>>(y)\n    checkSubtype<KFunction1<A, String>>(z)\n\n    checkSubtype<KFunction<Unit>>(x)\n    checkSubtype<KFunction<Unit>>(y)\n    checkSubtype<KFunction<String>>(z)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nclass A\n\nfun main() {\n    fun foo() {}\n    fun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\n    fun baz() = \"OK\"\n    \n    class B {\n        fun A.ext() {\n            val x = ::foo\n            val y = ::bar\n            val z = ::baz\n\n            checkSubtype<KFunction0<Unit>>(x)\n            checkSubtype<KFunction1<Int, Unit>>(y)\n            checkSubtype<KFunction0<String>>(z)\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION, -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nclass A\n\nfun test1() {\n    val <!UNUSED_VARIABLE!>foo<!> = ::<!UNRESOLVED_REFERENCE!>foo<!>\n\n    ::<!UNRESOLVED_REFERENCE!>bar<!>\n\n    A::<!UNRESOLVED_REFERENCE!>bar<!>\n\n    <!UNRESOLVED_REFERENCE!>B<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>bar<!>\n}\n\nfun test2() {\n    fun foo(x: Any) {}\n    fun foo() {}\n\n    <!UNRESOLVED_REFERENCE!>Unresolved<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>\n    foo(<!UNRESOLVED_REFERENCE!>Unresolved<!>::<!NI;CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY, OI;DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>)\n    foo(<!UNRESOLVED_REFERENCE!>Unresolved<!>::<!NI;UNRESOLVED_REFERENCE, OI;DEBUG_INFO_MISSING_UNRESOLVED!>unresolved<!>)\n    ::<!UNRESOLVED_REFERENCE!>unresolved<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: a.kt\n\npackage first\n\nclass A {\n    fun foo() {}\n    fun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\n    fun baz() = \"OK\"\n}\n\n// FILE: b.kt\n\npackage other\n\nimport kotlin.reflect.*\n\nimport first.A\n\nfun main() {\n    val x = first.A::foo\n    val y = first.A::bar\n    val z = A::baz\n\n    checkSubtype<KFunction1<A, Unit>>(x)\n    checkSubtype<KFunction2<A, Int, Unit>>(y)\n    checkSubtype<KFunction1<A, String>>(z)\n}\n"
        },
        {
            "code": "class A\n\nfun main() {\n    val x = :: <!SYNTAX!><!>;\n    val y = A::\n<!SYNTAX!><!>}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.*\n\ninterface A\ninterface B : A\n\nfun A.foo() {}\n\nfun take(f: (A) -> Unit) {}\nfun take(f: () -> Unit) {}\n\nfun test() {\n    B::foo checkType { _<KFunction1<B, Unit>>() }\n\n    <!NONE_APPLICABLE!>take<!>(B::<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\nimport kotlin.reflect.KFunction0\n\nclass A {\n    class Nested\n    \n    fun main() {\n        val x = ::Nested\n        val y = A::Nested\n\n        checkSubtype<KFunction0<Nested>>(x)\n        checkSubtype<KFunction0<Nested>>(y)\n    }\n    \n    companion object {\n        fun main() {\n            ::Nested\n            val y = A::Nested\n\n            checkSubtype<KFunction0<A.Nested>>(y)\n        }\n    }\n}\n\nclass B {\n    fun main() {\n        ::<!UNRESOLVED_REFERENCE!>Nested<!>\n        val y = A::Nested\n\n        checkSubtype<KFunction0<A.Nested>>(y)\n    }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: a.kt\n\npackage a.b.c\n\nclass D<E, F> {\n    fun foo(<!UNUSED_PARAMETER!>e<!>: E, <!UNUSED_PARAMETER!>f<!>: F) = this\n}\n\n// FILE: b.kt\n\nimport kotlin.reflect.KFunction3\n\nfun main() {\n    val x = a.b.c.D<String, Int>::foo\n\n    checkSubtype<KFunction3<a.b.c.D<String, Int>, String, Int, a.b.c.D<String, Int>>>(x)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\nclass A {\n    fun Int.extInt() = 42\n    fun A.extA(x: String) = x\n    \n    fun main() {\n        Int::<!EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED!>extInt<!>\n        A::<!EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED!>extA<!>\n\n        eat(Int::<!EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED!>extInt<!>)\n        eat(A::<!EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED!>extA<!>)\n    }\n}\n\nfun eat(value: Any) {}\n\nfun main() {\n    A::<!UNRESOLVED_REFERENCE!>extInt<!>\n    A::<!UNRESOLVED_REFERENCE!>extA<!>\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport kotlin.reflect.*\n\nfun main() {\n    fun foo() {}\n    fun bar(<!UNUSED_PARAMETER!>x<!>: Int) {}\n    fun baz() = \"OK\"\n    \n    val x = ::foo\n    val y = ::bar\n    val z = ::baz\n    \n    checkSubtype<KFunction0<Unit>>(x)\n    checkSubtype<KFunction1<Int, Unit>>(y)\n    checkSubtype<KFunction0<String>>(z)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nabstract class SubFunction : kotlin.Function0<Unit>\n\nfun <T> takeIt(x: T, f: SubFunction) {}\n\nfun cr() {}\n\nfun test() {\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>takeIt<!>(42, <!TYPE_MISMATCH!>::cr<!>)\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>takeIt<!>(42, <!TYPE_MISMATCH!>{ }<!>)\n}\n"
        },
        {
            "code": "fun f1() = <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Map<!>::hashCode\nfun f2() = <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Map.Entry<!>::hashCode\n\nclass Outer<T> {\n    inner class Inner\n}\n\nfun f3() = <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Outer.Inner<!>::hashCode\n"
        },
        {
            "code": "// Different modules are important for this test because otherwise everything is analyzed at once and some errors\n// already exist in the binding context when we're analyzing \"User::surname\".\n// (The assertion at DoubleColonExpressionResolver.checkNoExpressionOnLHS is only performed when there are no errors in the binding context)\n\n// MODULE: m1\n// FILE: bar.kt\n\nfun <T> bar(<!UNUSED_PARAMETER!>ff<!>: <!UNRESOLVED_REFERENCE!>Err<!>.() -> Unit) {\n}\n\n// MODULE: m2(m1)\n// FILE: foo.kt\n\ndata class User(val surname: String)\n\nfun foo() {\n    bar<String> {\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>User<!>::<!OVERLOAD_RESOLUTION_AMBIGUITY!>surname<!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty1\nimport kotlin.reflect.KMutableProperty1\n\nclass Inv<T> {\n    val size: Int = 0\n}\n\nclass DTO<T> {\n    val test: Inv<T>? = null\n    var q: Int = 0\n    operator fun <R> get(prop: KProperty1<*, R>): R = TODO()\n    operator fun <R> set(prop: KMutableProperty1<*, R>, value: R) { }\n}\n\nfun main(intDTO: DTO<Int>?) {\n    if (intDTO != null) {\n        <!DEBUG_INFO_SMARTCAST!>intDTO<!>[DTO<Int>::q] = <!DEBUG_INFO_SMARTCAST!>intDTO<!>[DTO<Int>::test]!!.size\n        <!DEBUG_INFO_SMARTCAST!>intDTO<!>[DTO<Int>::q] = <!DEBUG_INFO_SMARTCAST!>intDTO<!>[DTO<Int>::test]!!.size\n    }\n}\n"
        },
        {
            "code": "fun foo() {\n\n}\n\nclass A {\n    fun foo() {\n\n    }\n\n    class B\n}\n\nfun A.bar() {\n\n}\n\nfun test() {\n    <!UNUSED_EXPRESSION!>::foo<!>\n    <!UNUSED_EXPRESSION!>::A<!>\n    <!UNUSED_EXPRESSION!>A::B<!>\n    <!UNUSED_EXPRESSION!>A::foo<!>\n    <!UNUSED_EXPRESSION!>A::bar<!>\n}"
        },
        {
            "code": "//KT-600 Problem with 'sure' extension function type inference\n\nfun <T : Any> T?._sure() : T { if (this != null) return <!DEBUG_INFO_SMARTCAST!>this<!> else throw NullPointerException() }\n\nfun test() {\n    val i : Int? = 10\n    val <!UNUSED_VARIABLE!>i2<!> : Int = i._sure() // inferred type is Int? but Int was excepted\n}\n"
        },
        {
            "code": "// FILE: this.kt\n\n// KT-26 Import namespaces defined in this file\npackage foo\n\nimport bar.* // Must not be an error\n\n// FILE: other.kt\npackage bar\n"
        },
        {
            "code": "enum class ProtocolState {\n  WAITING {\n    override fun signal() = ProtocolState.TALKING\n  },\n\n  TALKING {\n    override fun signal() = ProtocolState.WAITING\n  };\n\n  abstract fun signal() : ProtocolState\n}\n\nfun box() {\n   val <!UNUSED_VARIABLE!>x<!>: ProtocolState = ProtocolState.WAITING\n}\n"
        },
        {
            "code": "// KT-524 sure() returns T\n\npackage StringBuilder\n\n//import kotlin.io.*\n//import java.io.*\n\nfun main() {\n}\n\nval Int.bd : StringBuilder get() = StringBuilder(this.toString())\nfun StringBuilder.plus(other : StringBuilder) : StringBuilder = this.append(other).sure1() // !!!\n\nfun <T : Any> T?.sure1() : T { return if (this != null) <!DEBUG_INFO_SMARTCAST!>this<!> else throw NullPointerException() }"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-5362 Compiler crashes on access to extension method from nested class\nclass Outer {\n    class Nested{\n        fun foo(s: String) = s.<!UNRESOLVED_REFERENCE!>extension<!>()\n    }\n\n    private fun String.extension(): String = this\n}\n\n// EA-64302 - UOE: CodegenContext.getOuterExpression\nfun Activity.toast() = Unit\nclass Activity(){\n    class Fragment{\n        fun call() = <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>toast<!>()\n    }\n}\n\n// KT-8814 No error in IDE for invalid invoke of OuterClass.()->Unit in static nested class\npublic class Manager {\n    fun task(callback: Manager.() -> Unit): Task {\n        val task = Task(callback)\n        return task\n    }\n\n    class Task(val callback: Manager.() -> Unit) : Runnable {\n        override public fun run() {\n            callback(<!NO_VALUE_FOR_PARAMETER!>)<!> // Manager is not accessible here, but no error is shown\n        }\n    }\n}"
        },
        {
            "code": "// KT-443 Write allowed to super.val\n\nopen class M() {\n    open val b: Int = 5\n}\n\nclass N() : M() {\n    val a : Int\n        get() {\n            <!VAL_REASSIGNMENT!>super.b<!> = super.b + 1\n            return super.b + 1\n        }\n    override val b: Int = a + 1\n}\n"
        },
        {
            "code": "package kt402\n\nfun getTypeChecker() : (Any)->Boolean {\n  <!UNUSED_LAMBDA_EXPRESSION!>{ a : Any -> a is <!UNRESOLVED_REFERENCE!>T<!> }<!> // reports unsupported\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun f() : (Any) -> Boolean {\n  return { a : Any -> a is String }\n}\n"
        },
        {
            "code": "// See KT-10824: Smart cast depending on control flow does not work inside `if`\nclass A\nfun foo(a: A?, aOther: A?): A {\n    return if (a == null) {\n        A()\n    }\n    else {\n        var newA = aOther\n        if (newA == null) {\n            newA = A()\n        }\n        <!DEBUG_INFO_SMARTCAST!>newA<!>\n    }\n}\nfun bar(a: A?, aOther: A?): A {\n    return if (a == null) {\n        A()\n    }\n    else {\n        if (aOther == null) {\n            return A()\n        }\n\n        <!DEBUG_INFO_SMARTCAST!>aOther<!>\n    }\n}\nfun foo1(a: A?, aOther: A?): A {\n    val result = if (a == null) {\n        A()\n    }\n    else {\n        var newA = aOther\n        if (newA == null) {\n            newA = A()\n        }\n        <!DEBUG_INFO_SMARTCAST!>newA<!>\n    }\n    return result\n}\nfun bar1(a: A?, aOther: A?): A {\n    val result = if (a == null) {\n        A()\n    }\n    else {\n        if (aOther == null) {\n            return A()\n        }\n\n        <!DEBUG_INFO_SMARTCAST!>aOther<!>\n    }\n    return result\n}"
        },
        {
            "code": "// KT-128 Support passing only the last closure if all the other parameters have default values\n\nfun div(<!UNUSED_PARAMETER!>c<!> : String = \"\", <!UNUSED_PARAMETER!>f<!> : () -> Unit) {}\nfun f() {\n    div { // Nothing passed, but could have been...\n      // ...\n    }\n\n    div (c = \"foo\") { // More things could have been passed\n      // ...\n    }\n}\n"
        },
        {
            "code": "// KT-307 Unresolved reference\n\nopen class AL {\n    fun get(i : Int) : Any? = i\n}\n\ninterface ALE<T> : <!INTERFACE_WITH_SUPERCLASS!>AL<!> {\n    fun getOrNull(index: Int, value: T) : T {\n        return get(index) <!UNCHECKED_CAST!>as? T<!> ?: value\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-557 Wrong type inference near sure extension function\n\nfun <T : Any> T?.sure() : T = this!!\n\nfun Array<String>.length() : Int {\n    return 0;\n}\n\nfun test(array : Array<String?>?) {\n    <!OI;TYPE_MISMATCH!>array?.sure<Array<String?>>()<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>length<!>()\n}\n"
        },
        {
            "code": "// FILE: a.kt\n// KT-26 Import namespaces defined in this file\n\nimport html.* // Must not be an error\n\n// FILE: b.kt\n\npackage html\n\nabstract class Factory<T: Any> {\nfun create() : T? = null\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-282 Nullability in extension functions and in binary calls\n\nclass Set {\n    operator fun contains(<!UNUSED_PARAMETER!>x<!> : Int) : Boolean = true\n}\n\noperator fun Set?.plus(<!UNUSED_PARAMETER!>x<!> : Int) : Int = 1\n\noperator fun Int?.contains(<!UNUSED_PARAMETER!>x<!> : Int) : Boolean = false\n\nfun f(): Unit {\n    var set : Set? = null\n    val i : Int? = null\n    i <!UNSAFE_OPERATOR_CALL!>+<!> 1\n    set + 1\n    1 <!UNSAFE_OPERATOR_CALL!>in<!> set\n    1 in 2\n}\n"
        },
        {
            "code": "// KT-716 Type inference failed\n\nclass TypeInfo<T>\n\nfun <T> typeinfo() : TypeInfo<T> = null <!CAST_NEVER_SUCCEEDS!>as<!> TypeInfo<T>\n\nfun <T> TypeInfo<T>.getJavaClass() : java.lang.Class<T> {\n    val t : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Object<!> = this as <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Object<!>\n    return t.getClass() <!UNCHECKED_CAST!>as java.lang.Class<T><!> // inferred type is Object but Serializable was expected\n}\n\nfun <T> getJavaClass() = typeinfo<T>().getJavaClass()\n\nfun main() {\n    System.out.println(getJavaClass<String>())\n}"
        },
        {
            "code": "import java.util.ArrayList\n\nfun foo(p: <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.List<String><!>) {\n    p.iterator(); // forcing resolve of java.util.List.iterator()\n\n    ArrayList<String>().iterator(); // this provoked exception in SignaturesPropagationData\n}"
        },
        {
            "code": "// KT-9620 AssertionError in checkBounds\n\ninterface E1<T : D<!TYPE_ARGUMENTS_NOT_ALLOWED!><String><!>, D>\n\ninterface A\ninterface B\ninterface D<X>\ninterface E2<T : D<!TYPE_ARGUMENTS_NOT_ALLOWED!><A><!>, D<!SYNTAX!><<!><!SYNTAX!>B<!><!SYNTAX!>><!><!SYNTAX!>><!>\n\n// KT-11354 AE from DescriptorResolver\n\nopen class L<E>()\n\nclass M<C> : L<C<!TYPE_ARGUMENTS_NOT_ALLOWED!><C><!>>()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See also KT-7804 (Wrong type inference of kotlin.Any? was for 'a' without explicit type)\nfun <T> foo(a: T) = a\n\nclass A\n\nfun <T> test(v: T): T {\n    val a = if (v !is A) {\n        foo(v) <!USELESS_CAST!>as T<!>\n    }\n    else {\n        v\n    }\n\n    val t: T = a\n    return t\n}\n\nfun <T> test2(v: T): T {\n    val a = if (v !is A) {\n        foo(v) <!USELESS_CAST!>as T<!>\n    }\n    else {\n        v <!USELESS_CAST!>as T<!>\n    }\n\n    val t: T = a\n    return t\n}\n\nfun <T> test3(v: T): T {\n    val a = if (v !is A) {\n        foo(v)\n    }\n    else {\n        v\n    }\n\n    val t: T = a\n    return t\n}\n\nfun <T> test4(v: T): T {\n    val a: T = if (v !is A) {\n        foo(v) <!USELESS_CAST!>as T<!>\n    }\n    else {\n        v\n    }\n\n    val t: T = a\n    return t\n}\n\nfun <T> test5(v: T): T {\n    val a: T = if (v !is A) {\n        foo(v)\n    }\n    else {\n        v\n    }\n\n    val t: T = a\n    return t\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A() {\n    var x: Int = 0\n        get() = <!TYPE_MISMATCH!>\"s\"<!>\n        set(value: <!WRONG_SETTER_PARAMETER_TYPE!>String<!>) {\n            field = <!TYPE_MISMATCH!>value<!>\n        }\n    val y: Int\n        get(): <!WRONG_GETTER_RETURN_TYPE(\"Int\", \"String\")!>String<!> = \"s\"\n    val z: Int\n        get() {\n            return <!TYPE_MISMATCH!>\"s\"<!>\n        }\n\n    var a: Any = 1\n        set(v: <!WRONG_SETTER_PARAMETER_TYPE!>String<!>) {\n            field = v\n        }\n    val b: Int\n        get(): <!WRONG_GETTER_RETURN_TYPE!>Any<!> = \"s\"\n    val c: Int\n        get() {\n            return 1\n        }\n    val d = 1\n        get() {\n            return field\n        }\n    val e = 1\n        get(): <!WRONG_GETTER_RETURN_TYPE!>String<!> {\n            return <!TYPE_MISMATCH!>field<!>\n        }\n\n}\n"
        },
        {
            "code": "package checkFiles\n\nimport java.util.HashMap\n\nfun main() {\n    val hashMap = HashMap<String, String>()\n    hashMap[<!SYNTAX!><!>]\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-328 Local function in function literals cause exceptions\n\nfun bar1() = {\n    <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar1<!>()<!>\n}\n\nfun bar2() = {\n    fun foo2() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar2<!>()<!>\n}\n\n//properties\n//in a class\nclass A() {\n    val x = { <!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;UNINITIALIZED_VARIABLE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>x<!> }\n}\n\n//in a package\nval x = { <!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;UNINITIALIZED_VARIABLE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>x<!> }\n\n//KT-787 AssertionError on code 'val x = x'\nval z = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;UNINITIALIZED_VARIABLE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>z<!>\n\n//KT-329 Assertion failure on local function\nfun block(f : () -> Unit) = f()\n\nfun bar3() = block{ <!UNRESOLVED_REFERENCE!>foo3<!>() // <-- missing closing curly bracket\nfun foo3() = block{ <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bar3<!>()<!> }<!SYNTAX!><!>\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -MUST_BE_INITIALIZED_OR_BE_ABSTRACT -TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER\nclass My {\n    fun <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T?<!>> foo() {}\n    val <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T?<!>> prop: T\n}"
        },
        {
            "code": "// KT-127 Support extension functions in when expressions\n\nclass Foo() {}\n\nfun Any?.equals1(<!UNUSED_PARAMETER!>other<!> : Any?) : Boolean = true\n\nfun main() {\n\n    val command : Foo? = null\n\n    // Commented for KT-621\n    // when (command) {\n    //   .equals(null) => 1; // must be resolved\n    //   ?.equals(null) => 1 // same here\n    // }\n    command.equals1(null)\n    command?.equals(null)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NO_VALUE_FOR_PARAMETER\nclass Tree<<!REDECLARATION!>T<!>>(T <!SYNTAX!>element<!>, <!SYNTAX!><!>Tree<T><!SYNTAX!><!> left<!SYNTAX!><!>, <!SYNTAX!><!>Tree<T><!SYNTAX!><!> right<!SYNTAX!><!>) {}"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\npackage test\n\nimport javax.swing.JFrame\n\nclass KFrame() : JFrame() {\n    init {\n        val <!UNUSED_VARIABLE!>x<!> = this.rootPaneCheckingEnabled // make sure field is visible\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_TXT\n\nclass Bar {\n    val a: Array<String>? = null\n}\n\nfun foo(bar: Bar) = bar.a?.asIterable() ?: <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!><!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>emptyArray<!>()<!>\n\nfun <T> Array<out T>.asIterable(): Iterable<T> = TODO()\n\nfun testFrontend() {\n    val bar = Bar()\n    foo(bar)\n}"
        },
        {
            "code": "// FILE: 1.kt\npackage a\nimport b.ObserverSupport\n\ninterface IEntity\n\nfun IEntity(<!UNUSED_PARAMETER!>f<!>: ObserverSupport<IEntity>) {}\n\n// FILE: 2.kt\npackage b\nimport a.IEntity\n\nclass ObserverSupport<T : IEntity>"
        },
        {
            "code": "fun <T> assertEquals(a: T, b: T) {\n    if (a != b) throw AssertionError(\"$a != $b\")\n}\n\nfun main() {\n    val bytePos = 128.toByte() // Byte.MAX_VALUE + 1\n    assertEquals(-128, bytePos.toInt()) // correct, wrapped to Byte.MIN_VALUE\n\n    val byteNeg: Byte = <!TYPE_MISMATCH!>-bytePos<!> // should not compile, byteNeg should be Int\n    assertEquals(128, byteNeg.toInt()) // passes, should not be possible\n\n    val shortPos = 32768.toShort() // Short.MAX_VALUE + 1\n    assertEquals(-32768, shortPos.toInt()) // correct, wrapped to Short.MIN_VALUE\n\n    val shortNeg: Short = <!TYPE_MISMATCH!>-shortPos<!> // should not compile, shortNeg should be Int\n    assertEquals(32768, shortNeg.toInt()) // passes, should not be possible\n\n    (-128).toByte()\n    -128.toByte()\n}\n"
        },
        {
            "code": "class B {}\n\nval b : B<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!><*><!> = 1\n"
        },
        {
            "code": "fun Any.<!EXTENSION_SHADOWED_BY_MEMBER!>equals<!>(<!UNUSED_PARAMETER!>other<!> : Any?) : Boolean = true\n\nfun main() {\n\n    val command : Any = 1\n\n    command<!UNNECESSARY_SAFE_CALL!>?.<!>equals(null)\n    command.equals(null)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval f: Boolean = true\nprivate fun doUpdateRegularTasks() {\n    try {\n        while (f) {\n            val xmlText = <!UNRESOLVED_REFERENCE!>getText<!>()\n            if (<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>xmlText<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>==<!> null) {}\n            else {\n                <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>xmlText<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>value<!> = 0 // !!!\n            }\n        }\n\n    }\n    finally {\n        fun execute() {}\n    }\n}\n"
        },
        {
            "code": "class MyClass<T: <!CYCLIC_GENERIC_UPPER_BOUND!>T<!>>"
        },
        {
            "code": "enum class MyEnum {\n    // Here we have a problem \n    // while checking on a deprecated super constructor\n    FIRST<!SYNTAX!><!SYNTAX!><!>:<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\n// FILE: foo/View.java\n\npackage foo;\n\npublic class View {}\n\n// FILE: foo/TextView.java\n\npackage foo;\n\npublic class TextView extends View {}\n\n// FILE: k.kt\n\nimport foo.View\n//import foo.TextView\n\nfun String.gah(view:View ?) {\n    if (view is <!UNRESOLVED_REFERENCE!>TextView<!>)\n        view\n    else <!UNRESOLVED_REFERENCE!>TextView<!>() as foo.TextView\n}"
        },
        {
            "code": "open class A\n\nclass E\n\nabstract class Wrapper<T: A>(protected val t: T)\n\nclass MyWrapper(a: A): Wrapper<A>(a)\n\n// This wrapper is not legal\nclass TheirWrapper(e: E): Wrapper<<!UPPER_BOUND_VIOLATED!>E<!>>(e)\n\ndata class Pair<out T>(val a: T, val b: T)\n\nfun foo(): String {\n    val matrix: Pair<Wrapper<*>>\n    // It's not legal to do such a thing because E is not derived from A\n    // But we should not have assertion errors because of it!\n    matrix = Pair(MyWrapper(A()), TheirWrapper(E()))\n    return matrix.toString()\n}\n"
        },
        {
            "code": "// FILE: kt7585.kt\n\nclass E\n\nclass MyWrapper(a: A): Wrapper<A>(a)\n\n// This wrapper is not legal\nclass TheirWrapper(e: E): Wrapper<<!UPPER_BOUND_VIOLATED!>E<!>>(e)\n\ndata class Pair<out T>(val a: T, val b: T)\n\nfun foo(): String {\n    val matrix: Pair<Wrapper<*>>\n    // It's not legal to do such a thing because E is not derived from A\n    // But we should not have assertion errors because of it!\n    matrix = Pair(MyWrapper(A()), TheirWrapper(E()))\n    return matrix.toString()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun main() {\n    val a : Int? = null;\n    var v = 1\n    val <!UNUSED_VARIABLE!>b<!> : String = <!TYPE_MISMATCH!>v<!>;\n    val <!UNUSED_VARIABLE!>f<!> : String = <!NI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>a<!>!!<!>;\n    val <!UNUSED_VARIABLE!>g<!> : String = <!TYPE_MISMATCH!>v++<!>;\n    val <!UNUSED_VARIABLE!>g1<!> : String = <!TYPE_MISMATCH!>++v<!>;\n    val <!UNUSED_VARIABLE!>h<!> : String = <!TYPE_MISMATCH!>v--<!>;\n    val <!UNUSED_VARIABLE!>h1<!> : String = <!TYPE_MISMATCH!>--v<!>;\n    val <!UNUSED_VARIABLE!>i<!> : String = <!TYPE_MISMATCH!>!true<!>;\n    val <!UNUSED_VARIABLE!>j<!> : String = <!REDUNDANT_LABEL_WARNING!>foo@<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!>;\n    val <!UNUSED_VARIABLE!>k<!> : String = <!REDUNDANT_LABEL_WARNING!>foo@<!> <!REDUNDANT_LABEL_WARNING!>bar@<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!>;\n    val <!UNUSED_VARIABLE!>l<!> : String = <!TYPE_MISMATCH!>-1<!>;\n    val <!UNUSED_VARIABLE!>m<!> : String = <!TYPE_MISMATCH!>+1<!>;\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -FUNCTION_DECLARATION_WITH_NO_NAME\nclass ClassB() {\n    private inner class ClassC: <!SYNTAX!>super<!><!SYNTAX!>.<!>@<!UNRESOLVED_REFERENCE!>ClassA<!>()<!SYNTAX!><!> {\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -MUST_BE_INITIALIZED -TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER\nfun <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T?<!>> foo() {}\nval <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T?<!>> prop"
        },
        {
            "code": "// KT-668 Failed to resolve generic parameter\nopen class A()\nopen class B() : A() {\n  fun b(): B = B()\n}\n\n\nclass C() {\n  fun <T> a(x: (T)->T, y: T): T {\n    return x(x(y))\n  }\n\n  val x: B = <!DEBUG_INFO_LEAKING_THIS!>a<!>({it.b()}, B())\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nimport <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<!> as Comparable\n\nfun f(c: <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Comparable<*><!>) {\n    checkSubtype<kotlin.Comparable<*>>(<!TYPE_MISMATCH!>c<!>)\n    checkSubtype<<!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.lang.Comparable<*><!>>(c)\n}"
        },
        {
            "code": "interface Iterator<out T> {\n fun next() : T\n val hasNext : Boolean\n\n fun <R> map(transform: (element: T) -> R) : Iterator<R> =\n    object : Iterator<R> {\n      override fun next() : R = transform(<!NO_THIS!>this@map<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>next<!>())\n\n      override val hasNext : Boolean\n        // There's no 'this' associated with the map() function, only this of the Iterator class\n        get() = <!NO_THIS!>this@map<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hasNext<!>\n    }\n}"
        },
        {
            "code": "class A<T> {\n    fun size() = 0\n}\n\nclass Foo<T>(<!UNUSED_PARAMETER!>i<!>: Int)\n\npublic fun <E> Foo(c: A<E>) {\n    val <!UNUSED_VARIABLE!>a<!> = Foo<E>(c.size())       // Check no overload resolution ambiguity\n    val <!UNUSED_VARIABLE!>b<!>: Foo<E> = Foo(c.size())  // OK\n    val <!NAME_SHADOWING, UNUSED_VARIABLE!>c<!>: Foo<Int> = Foo(c.size()) // OK\n}"
        },
        {
            "code": "// KT-201 Allow to call extension with nullable receiver with a '.'\n\nfun <T : Any> T?.npe() : T = if (this == null) throw NullPointerException() else <!DEBUG_INFO_SMARTCAST!>this<!>\n\nfun foo() {\n  val i : Int? = 1\n  i.npe() // error!\n}\n"
        },
        {
            "code": "//KT-456 No check for obligatory return in getters\n\npackage kt456\n\nclass A() {\n    val i: Int\n    get() : Int {  //no error\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\n//more tests\nclass B() {\n    val i: Int\n    get() {  //no error\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\nclass C() {\n    val i : Int\n    get() : Int {\n        try {\n            doSmth()\n        }\n        finally {\n            doSmth()\n        }\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\nfun doSmth() {}\n"
        },
        {
            "code": "//KT-1736 AssertionError in CallResolver\n\npackage kt1736\n\nobject Obj {\n    fun method() {\n    }\n}\n\nval x = Obj.method<!TOO_MANY_ARGUMENTS!>{ -> }<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage kt606_dependents\n\n//KT-1489 Code analyzer fails with assertion\ninterface AutoCloseable{\n    fun close()\n}\n\nclass C {\n    class Resource : AutoCloseable {\n        override fun close() {\n            throw UnsupportedOperationException()\n        }\n    }\n\n    fun <X : AutoCloseable> foo(<!UNUSED_PARAMETER!>x<!> : X, <!UNUSED_PARAMETER!>body<!> : (X) -> Unit) {\n    }\n\n    fun p() : Resource? = null\n\n    fun bar() {\n        <!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>foo<!>(<!NI;TYPE_MISMATCH!>p()<!>) {\n\n        }\n    }\n}\n\n//KT-1728 Can't invoke extension property as a function\n\nval Int.ext : () -> Int get() = { 5 }\nval x = 1.ext()\n"
        },
        {
            "code": "// KT-399 Type argument inference not implemented for CALL_EXPRESSION\n\nfun <T> getSameTypeChecker(<!UNUSED_PARAMETER!>obj<!>: T) : Function1<Any,Boolean> {\n    return { a : Any -> a is <!CANNOT_CHECK_FOR_ERASED!>T<!> }\n}\n\nfun box() : String {\n    if(getSameTypeChecker<String>(\"lala\")(10)) return \"fail\"\n    if(!getSameTypeChecker<String>(\"mama\")(\"lala\")) return \"fail\"\n    return \"OK\"\n}"
        },
        {
            "code": "// One of the two passes is making a scope and turning vals into functions\n// See KT-76\n\npackage x\n\nval b : Foo = Foo()\nval a1 = b.compareTo(2)\n\nclass Foo() {\n  fun compareTo(<!UNUSED_PARAMETER!>other<!> : Byte)   : Int = 0\n  fun compareTo(<!UNUSED_PARAMETER!>other<!> : Char)   : Int = 0\n}\n"
        },
        {
            "code": "val a: String = <!NO_COMPANION_OBJECT!>Nothing<!>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-312 Nullability problem when a nullable version of a generic type is returned\n\nfun <T> Array<out T>.safeGet(index : Int) : T? {\n    return if (index < size) this[index] else null\n}\n\nval args : Array<String> = Array<String>(1, {\"\"})\nval name : String = <!TYPE_MISMATCH!>args.<!NI;TYPE_MISMATCH!>safeGet<String>(0)<!><!> // No error, must be type mismatch\nval name1 : String? = args.safeGet(0)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n// See EA-76890 / KT-10843: NPE during analysis\nfun lambda(x : Int?) = x?.<!FUNCTION_CALL_EXPECTED, NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>let<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>l<!> {\n    <!OI;CANNOT_INFER_PARAMETER_TYPE!>y<!> ->\n    if (<!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>y<!> <!NI;UNREACHABLE_CODE!><!NI;UNRESOLVED_REFERENCE, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>><!> 0<!>) <!NI;UNREACHABLE_CODE!>return<!UNRESOLVED_REFERENCE!>@l<!> x<!>\n    <!NI;UNREACHABLE_CODE, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>y<!>\n}<!NOT_NULL_ASSERTION_ON_LAMBDA_EXPRESSION!>!!<!>\n"
        },
        {
            "code": "// KT-442 Type inference fails on with()\n\nfun <T> funny(f : () -> T) : T = f()\n\nfun testFunny() {\n    val <!UNUSED_VARIABLE!>a<!> : Int = funny {1}\n}\n\nfun <T> funny2(<!UNUSED_PARAMETER!>f<!> : (t : T) -> T) : T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun testFunny2() {\n    val <!UNUSED_VARIABLE!>a<!> : Int = funny2 {it}\n}\n\nfun box() : String {\n    return generic_invoker { it }\n}\n\nfun <T> generic_invoker(gen :  (String) -> T) : T {\n    return gen(\"\")\n}\n\ninfix fun <T> T.with(f :  T.() -> Unit) {\n    f()\n}\n\nfun main() {\n    val <!UNUSED_VARIABLE!>a<!> = 1 with {\n        plus(1)\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun bar() {\n    fun <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T?<!>> foo() {}\n    <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>()\n}\n"
        },
        {
            "code": "// FILE: foo/A.kt\n\npackage foo\n\nclass A(val c: C)\n\n// FILE: foo/B.kt\n\npackage foo\n\nclass B {\n    interface D {\n        fun foo(): E\n    }\n\n    class E\n}\n\n// FILE: foo/C.java\n\npackage foo;\n\nimport static foo.B.D.*;\n\n@SuppressWarnings(\"RedundantTypeArguments\")\npublic class C {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun test(a: Int, b: Boolean) {\n    <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar<!>(a.<!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>foo<!>(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>b<!>))\n}\n\nfun <T, R> T.foo(l: (T) -> R): R = TODO()\n\nfun <S> bar(a: S) {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nvar count = 0\n\noperator fun Int.get(s: Int): Int {\n    count++\n    return this + s\n}\n\noperator fun Int.set(s: Int, x: String = \"\", z: Int) {\n}\n\nfun main() {\n    1[2] = 1\n    1.set(2, z = 1)\n    1[2] += 1\n\n    1.set(2, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!><!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n"
        },
        {
            "code": "// KT-398 Internal error when property initializes with function\n\nclass X<T>() {\n    val check = { a : Any -> a is <!CANNOT_CHECK_FOR_ERASED!>T<!> }\n}\n\nfun box() : String {\n    if(X<String>().check(10)) return \"fail\"\n    if(!X<String>().check(\"lala\")) return \"fail\"\n    return \"OK\"\n}"
        },
        {
            "code": "// KT-459 Type argument inference fails when class names are fully qualified\n\nfun test() {\n  val attributes : java.util.HashMap<String, String> = java.util.HashMap() // failure!\n  attributes[\"href\"] = \"1\" // inference fails, but it shouldn't\n}\n\noperator fun <K, V> Map<K, V>.set(<!UNUSED_PARAMETER!>key<!> : K, <!UNUSED_PARAMETER!>value<!> : V) {}//= this.put(key, value)"
        },
        {
            "code": "<!MUST_BE_INITIALIZED!>var x: Int<!>\nfun foo(f: Boolean) {\n    try {\n        if (f) {\n            x = 0\n        }\n    }\n    finally {\n        fun bar() {}\n    }\n}"
        },
        {
            "code": "// KT-336 Can't infer type parameter for ArrayList in a generic function (Exception in type inference)\n// KT-335 Type inference fails on Collections.sort\n\nimport java.util.*\n\nfun <T : Comparable<T>> MutableList<T>.sort() {\n  Collections.sort(this) // Error here\n}\n\nfun <T> List<T>.plus(<!UNUSED_PARAMETER!>other<!> : List<T>) : List<T> {\n  val result = ArrayList(this)\n  return result\n}\n"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>u<!> : Unit) : Int = 1\n\nfun test() : Int {\n    foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    val <!UNUSED_VARIABLE!>a<!> : () -> Unit = {\n        foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    }\n    return 1\n}\n"
        },
        {
            "code": "interface A { fun f() }\n\nopen class P(val z: B)\n\nclass B : A {\n    override fun f() {}\n    class C : A by <!NO_THIS!>this<!> {}\n    class D(val x : B = <!NO_THIS!>this<!>)\n    class E : P(<!NO_THIS!>this<!>)\n}"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>a<!> : Any) {}\n\nfun test() {\n  foo(object {});\n}\n"
        },
        {
            "code": "// JET-72 Type inference doesn't work when iterating over ArrayList\n\nimport java.util.ArrayList\n\nabstract class Item(val room: <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!>) {\n   abstract val name : String\n}\n\nval items: ArrayList<Item> = ArrayList<Item>()\n\nfun test(room : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!>) {\n  for(item: Item? in items) {\n    if (item?.room === room) {\n      // item?.room is not null\n      System.out.println(\"You see \" + item<!UNNECESSARY_SAFE_CALL!>?.<!>name)\n    }\n  }\n}"
        },
        {
            "code": "// KT-9633: SOE occurred before\ninterface A<<!FINITE_BOUNDS_VIOLATION!>T : A<in T><!>>"
        },
        {
            "code": "// http://youtrack.jetbrains.net/issue/KT-526\n// KT-526 Unresolved reference for inner static class\n\npackage demo\n\nclass Foo {\n    companion object {\n        class Bar() { }\n    }\n}\nclass User {\n    fun main() : Unit {\n        var <!UNUSED_VARIABLE!>boo<!> : Foo.Companion.Bar? /* <-- this reference is red */ = Foo.Companion.Bar()\n    }\n}\n"
        },
        {
            "code": "class MyClass<T: <!CYCLIC_GENERIC_UPPER_BOUND!>T?<!>>"
        },
        {
            "code": "// StackOverflow\nval p = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>::p<!>\n\nfun foo() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>::foo<!>"
        },
        {
            "code": "//KT-235 Illegal assignment return type\n\npackage kt235\n\nfun main() {\n    val array = MyArray()\n    val <!UNUSED_VARIABLE!>f<!>: () -> String = {\n        <!EXPECTED_TYPE_MISMATCH!>array[2] = 23<!> //error: Type mismatch: inferred type is Int (!!!) but String was expected\n    }\n    val <!UNUSED_VARIABLE!>g<!>: () -> String = {\n        var x = 1\n        <!EXPECTED_TYPE_MISMATCH!>x += 2<!>  //no error, but it should be here\n    }\n    val <!UNUSED_VARIABLE!>h<!>: () -> String = {\n        var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>x<!> = 1\n        <!EXPECTED_TYPE_MISMATCH!><!UNUSED_VALUE!>x =<!> 2<!>  //the same\n    }\n    val array1 = MyArray1()\n    val <!UNUSED_VARIABLE!>i<!>: () -> String = {\n        <!EXPECTED_TYPE_MISMATCH!>array1[2] = 23<!>\n    }\n\n    val <!UNUSED_VARIABLE!>fi<!>: () -> String = {\n        <!EXPECTED_TYPE_MISMATCH!>array[2] = 23<!>\n    }\n    val <!UNUSED_VARIABLE!>gi<!>: () -> String = {\n        var x = 1\n        <!EXPECTED_TYPE_MISMATCH!>x += 21<!>\n    }\n\n    var m: MyNumber = MyNumber()\n    val <!UNUSED_VARIABLE!>a<!>: () -> MyNumber = {\n        m++\n    }\n}\n\nclass MyArray() {\n    operator fun get(<!UNUSED_PARAMETER!>i<!>: Int): Int = 1\n    operator fun set(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>value<!>: Int): Int = 1\n}\n\nclass MyArray1() {\n    operator fun get(<!UNUSED_PARAMETER!>i<!>: Int): Int = 1\n    operator fun set(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>value<!>: Int) {}\n}\n\nclass MyNumber() {\n    operator fun inc(): MyNumber = MyNumber()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n// JET-81 Assertion fails when processing self-referring anonymous objects\n\nclass Test {\n  private val y = object {\n    val a = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;UNINITIALIZED_VARIABLE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>y<!>;\n  }\n\n  val z = y.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>;\n\n}\n\nobject A {\n  val x = A\n}\n\nclass Test2 {\n  private val a = object {\n    init {\n      <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNINITIALIZED_VARIABLE!>b<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> 1\n    }\n    val x = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, UNINITIALIZED_VARIABLE!>b<!>\n    val y = 1\n  }\n\n  val b = <!NI;TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>a<!>.<!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!><!>\n  val c = a.y\n}"
        },
        {
            "code": "// KT-439 Support labeled function literals in call arguments\n\nfun main1(<!UNUSED_PARAMETER!>args<!> : Array<String>) {\n    run l@{ 1 } // should not be an error\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun <T> g(x: T) = 1\nfun h(x: () -> Unit) = 1\n\nfun foo() {\n    <!UNRESOLVED_REFERENCE!>f<!>(::<!NI;DEBUG_INFO_MISSING_UNRESOLVED, SYNTAX!><!>)\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>g<!>(::<!SYNTAX!><!>)\n    h(::<!SYNTAX!><!>)\n}\n"
        },
        {
            "code": "import java.util.*\n\nimport java.io.*\n\nfun takeFirst(expr: StringBuilder): Char {\n  val c = expr.get(0)\n  expr.deleteCharAt(0)\n  return c\n}\n\nfun evaluateArg(expr: CharSequence, numbers: ArrayList<Int>): Int {\n  if (expr.length == 0) throw Exception(\"Syntax error: Character expected\");\n  val c = takeFirst(<!TYPE_MISMATCH!>expr<!>)\n  if (c >= '0' && c <= '9') {\n    val n = c - '0'\n    if (!numbers.contains(n)) throw Exception(\"You used incorrect number: \" + n)\n    numbers.remove(n)\n    return n\n  }\n  throw Exception(\"Syntax error: Unrecognized character \" + c)\n}\n\nfun evaluateAdd(expr: StringBuilder, numbers: ArrayList<Int>): Int {\n  val lhs = evaluateArg(expr, numbers)\n  if (expr.length > 0) {\n\n  }\n  return lhs\n}\n\nfun evaluate(expr: StringBuilder, numbers: ArrayList<Int>): Int {\n  val lhs = evaluateAdd(expr, numbers)\n  if (expr.length > 0) {\n    val <!UNUSED_VARIABLE!>c<!> = expr.get(0)\n    expr.deleteCharAt(0)\n  }\n  return lhs\n}\n\nfun main() {\n  System.out.println(\"24 game\")\n  val numbers = ArrayList<Int>(4)\n  val rnd = Random();\n  val prompt = StringBuilder()\n  for(i in 0..3) {\n    val n = rnd.nextInt(9) + 1\n    numbers.add(n)\n    if (i > 0) prompt.append(\" \");\n    prompt.append(n)\n  }\n  System.out.println(\"Your numbers: \" + prompt)\n  System.out.println(\"Enter your expression:\")\n  val reader = BufferedReader(InputStreamReader(System.`in`))\n  val expr = StringBuilder(reader.readLine()!!)\n  try {\n    val result = evaluate(expr, numbers)\n    if (result != 24)\n      System.out.println(\"Sorry, that's \" + result)\n    else\n      System.out.println(\"You won!\");\n  }\n  catch(e: Throwable) {\n    System.out.println(e.message)\n  }\n}\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// KT-498 Very strange error in the type checker\n\nclass IdUnavailableException() : Exception() {}\n\nfun <T : Any> T.getJavaClass() : Class<T> {\n    return ((this as <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>Object<!>).getClass()) <!UNCHECKED_CAST!>as Class<T><!> // Some error here, because of Exception() used above. ?!!!\n}"
        },
        {
            "code": "//KT-455 Do not repeat errors in definite assignment checks\n\npackage kt455\n\nfun foo() {\n    val a: Int\n    doSmth(<!UNINITIALIZED_VARIABLE!>a<!>)   //error\n    doSmth(a)   //no repeat error\n}\nfun doSmth(<!UNUSED_PARAMETER!>i<!>: Int) {}\n"
        },
        {
            "code": "//KT-58 Allow finally around definite returns\n\npackage kt58\n\nimport java.util.concurrent.locks.Lock\n\nfun <T> lock(lock : Lock, body :  () -> T) : T {\n    lock.lock()\n    try {\n        return body()\n    }\n    finally {\n        lock.unlock(); // we report an error, but we chouldn't\n    }\n}\n\n//more tests\nfun t1() : Int {\n    try {\n        <!UNREACHABLE_CODE!>return<!> 1\n    }\n    finally {\n        return 2\n    }\n}\n\nfun t2() : Int {\n    try {\n        return 1\n    }\n    finally {\n        doSmth(3)\n    }\n}\n\nfun t3() : Int {\n    try {\n        return 1\n    }\n    catch (e: UnsupportedOperationException) {\n        doSmth(2)\n    }\n    finally {\n        doSmth(3)\n    }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun t4() : Int {\n    try {\n        return 1\n    }\n    catch (e: UnsupportedOperationException) {\n        doSmth(2)\n    }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun t5() : Int {\n    try {\n        return 1\n    }\n    catch (e: UnsupportedOperationException) {\n        return 2\n    }\n}\n\nfun t6() : Int {\n    try {\n        return 1\n    }\n    catch (e: UnsupportedOperationException) {\n        return 2\n    }\n    finally {\n        doSmth(3)\n    }\n}\n\nfun t7() : Int {\n    try {\n        doSmth(1)\n    }\n    catch (e: UnsupportedOperationException) {\n        return 2\n    }\n    finally {\n        doSmth(3)\n    }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\nfun doSmth(<!UNUSED_PARAMETER!>i<!>: Int) {\n}\n"
        },
        {
            "code": "//KT-629 Assignments are parsed as expressions.\n\npackage kt629\n\nclass A() {\n    var p = \"yeah\"\n    operator fun rem(<!UNUSED_PARAMETER!>other<!> : A) : A {\n        return A();\n    }\n}\n\nfun box() : Boolean {\n    var c = A()\n    val d = c;\n    c %= A();\n    return (c != d) && (<!ASSIGNMENT_IN_EXPRESSION_CONTEXT!>c.p = \"yeah\"<!>)\n}\n\n\nfun box2() : Boolean {\n    var c = A()\n    return (<!ASSIGNMENT_IN_EXPRESSION_CONTEXT!>c.p = \"yeah\"<!>) && true\n}\n"
        },
        {
            "code": "// JET-11 Redeclaration & Forward reference for classes cause an exception\nopen class <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>NoC<!>\nclass NoC1 : NoC()\nopen class <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>NoC<!>\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: com/winterbe/domain/IEntity.java\npackage com.winterbe.domain;\nimport com.winterbe.observer.ObserverSupport;\n\npublic interface IEntity {\n    ObserverSupport getObserverSupport();\n}\n\n// FILE: 1.kt\npackage com.winterbe.observer\nimport com.winterbe.domain.IEntity\n\nabstract class Observer : List<IEntity>\n\n\n// FILE: 2.kt\npackage com.winterbe.observer\nimport com.winterbe.domain.IEntity\n\nclass ObserverSupport<T : IEntity>(private val observers: List<Observer>)\n"
        },
        {
            "code": "// KT-9682 Overload Resolution Ambiguity after casting to Interface\n\nopen class Foo {\n    fun bar(): Foo {\n        return this\n    }\n}\n\nclass Foo2 : Foo(), IFoo\n\ninterface IFoo {\n    fun bar(): Foo\n}\n\nfun test() {\n    val foo : Foo = Foo2()\n    foo as IFoo\n    foo.bar() // Should be resolved to Foo#bar\n}\n\ninterface IFoo2 {\n    fun bar(): IFoo2\n}\n\nfun test2(foo: Foo) {\n    foo as IFoo2\n    foo.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!>() // should be ambiguity\n}"
        },
        {
            "code": "// KT-4827 UOE at PackageType.throwException()\n// EA-53605\n\npublic interface TestInterface {\n}\n\nclass C {\n    inner class I {\n\n    }\n}\n\nfun f() {\n    <!RESOLUTION_TO_CLASSIFIER!>TestInterface<!>()\n    C.<!RESOLUTION_TO_CLASSIFIER!>I<!>()\n}\n"
        },
        {
            "code": "fun foo1() :  (Int) -> Int = { x: Int -> x }\n\nfun foo() {\n  val h :  (Int) -> Int = foo1();\n  h(1)\n  val m :  (Int) -> Int = {<!UNUSED_ANONYMOUS_PARAMETER!>a<!> : Int -> 1}//foo1()\n  m(1)\n}\n"
        },
        {
            "code": "class A<T> : <!SUPERTYPE_NOT_A_CLASS_OR_INTERFACE!>T<!> {}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass Point() {\n}\n\nclass G<T>() {}\n\nfun <T> f(<!UNUSED_PARAMETER!>expression<!> : T) : G<out T> = G<T>()\n\n\nfun foo() : G<Point> {\n  val p = Point()\n  return <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>f<Point>(p)<!>\n}\n\nclass Out<out T>() {}\n\nfun <T> fout(<!UNUSED_PARAMETER!>expression<!> : T) : Out<<!REDUNDANT_PROJECTION!>out<!> T> = Out<T>()\n\nfun fooout() : Out<Point> {\n  val p = Point();\n  return fout<Point>(p);\n}"
        },
        {
            "code": "fun test() {\n  var a : Any? = null\n  if (a is Any) else a = null;\n  while (a is Any) a = null\n  while (true) <!UNUSED_VALUE!>a =<!> null\n}\n"
        },
        {
            "code": "// KT-41 Make functions with errors in returning statement return ERROR type and not Nothing\n\npackage kt41\n\nfun aaa() =\n  6 <!UNRESOLVED_REFERENCE!>foo<!> 1\n\nfun bbb() {\n  aaa()\n  <!UNUSED_EXPRESSION!>1<!> // Stupid error: unreachable code\n}\n"
        },
        {
            "code": "open class Foo {}\nopen class Bar {}\n\nfun <T : Bar, T1> foo(<!UNUSED_PARAMETER!>x<!> : Int) {}\nfun <T1, T : Foo> foo(<!UNUSED_PARAMETER!>x<!> : Long) {}\n\nfun f(): Unit {\n    foo<<!UPPER_BOUND_VIOLATED!>Int<!>, Int>(1)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-353 Generic type argument inference sometimes doesn't work\n\ninterface A {\n    fun <T> gen() : T\n}\n\nfun foo(a: A) {\n    val <!UNUSED_VARIABLE!>g<!> : () -> Unit = {\n        a.gen()  //it works: Unit is derived\n    }\n\n    val <!UNUSED_VARIABLE!>u<!>: Unit = a.gen() // Unit should be inferred\n\n    if (true) {\n        a.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>gen<!>() // Shouldn't work: no info for inference\n    }\n\n    val <!UNUSED_VARIABLE!>b<!> : () -> Unit = {\n        if (true) {\n            a.gen()  // unit can be inferred\n        }\n        else {\n            Unit\n        }\n    }\n\n    val <!UNUSED_VARIABLE!>f<!> : () -> Int = {\n        a.gen()  //type mismatch, but Int can be derived\n    }\n\n    a.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>gen<!>() // Shouldn't work: no info for inference\n}\n"
        },
        {
            "code": "fun main(args: Array<String>) {\n    fun f() = run {\n        <!WRONG_MODIFIER_TARGET!>private<!> class C {\n            private fun foo() {\n                <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>f<!>()<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>();\n\n            }\n        }\n        C()\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -MUST_BE_INITIALIZED -TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER\nfun <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T<!>> foo() {}\nval <<!CYCLIC_GENERIC_UPPER_BOUND!>T: T?<!>> prop: T"
        },
        {
            "code": "// KT-302 Report an error when inheriting many implementations of the same member\n\npackage kt302\n\ninterface A {\n    open fun foo() {}\n}\n\ninterface B {\n    open fun foo() {}\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class C<!> : A, B {} //should be error here"
        },
        {
            "code": "// KT-258 Support equality constraints in type inference\n\nimport java.util.*\n\nfun test() {\n  val attributes : HashMap<String, String> = HashMap()\n  attributes[\"href\"] = \"1\" // inference fails, but it shouldn't\n}\n\noperator fun <K, V> MutableMap<K, V>.set(<!UNUSED_PARAMETER!>key<!> : K, <!UNUSED_PARAMETER!>value<!> : V) {}//= this.put(key, value)"
        },
        {
            "code": "interface A {\n    var foo: String\n}\n\nclass B(override <!VAR_OVERRIDDEN_BY_VAL!>val<!> foo: String) : A\n"
        },
        {
            "code": "package lol\n\nclass B() {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plusAssign(<!UNUSED_PARAMETER!>other<!> : B) : String {\n        return \"s\"\n    }\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minusAssign(<!UNUSED_PARAMETER!>other<!> : B) : String {\n        return \"s\"\n    }\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun remAssign(<!UNUSED_PARAMETER!>other<!> : B) : String {\n        return \"s\"\n    }\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun divAssign(<!UNUSED_PARAMETER!>other<!> : B) : String {\n        return \"s\"\n    }\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun timesAssign(<!UNUSED_PARAMETER!>other<!> : B) : String {\n        return \"s\"\n    }\n}\n\nfun main() {\n    var c = B()\n    c <!ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT!>+=<!> B()\n    c <!ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT!>*=<!> B()\n    c <!ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT!>/=<!> B()\n    c <!ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT!>-=<!> B()\n    c <!ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT!>%=<!> B()\n}"
        },
        {
            "code": "// KT-702 Type inference failed\nfun <T> getJavaClass() : java.lang.Class<T> { return \"\" <!CAST_NEVER_SUCCEEDS!>as<!> Class<T> }\n\npublic class Throwables() {\n    companion object {\n        public fun <X : Throwable?> propagateIfInstanceOf(throwable : Throwable?, declaredType : Class<X?>?) {\n            if (((throwable != null) && declaredType?.isInstance(throwable)!!))\n            {\n                throw declaredType<!UNNECESSARY_SAFE_CALL!>?.<!>cast(throwable)!!\n            }\n        }\n        public fun propagateIfPossible(throwable : Throwable?) {\n            propagateIfInstanceOf(throwable, getJavaClass<Error?>()) //; Type inference failed: Mismatch while expanding constraints\n            propagateIfInstanceOf(throwable, getJavaClass<RuntimeException?>()) // Type inference failed: Mismatch while expanding constraints\n        }\n    }\n}"
        },
        {
            "code": "//kt-411 Wrong type expected when returning from a function literal\n\npackage kt411\n\nfun f() {\n    invoker(\n    l@{\n        return@l 11 // expects Function, but should expect Int\n    }\n    )\n}\nfun invoker(<!UNUSED_PARAMETER!>gen<!> : () -> Int) : Int  = 0\n\n//more tests\nfun t1() {\n    val <!UNUSED_VARIABLE!>v<!> = l@{\n        return@l 111\n    }\n}\n\nfun t2() : String {\n    val <!UNUSED_VARIABLE!>g<!> : ()-> Int = l@{\n        if (true) {\n            return@l 1\n        }\n        <!RETURN_NOT_ALLOWED!>return<!> \"s\"\n    }\n    return \"s\"\n}\n\nfun t3() : String {\n    invoker(\n    l@{\n        if (true) {\n            <!RETURN_NOT_ALLOWED!>return@t3<!> \"1\"\n        }\n        else {\n            <!RETURN_NOT_ALLOWED!>return<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>2<!>\n        }\n        <!UNREACHABLE_CODE!>return@l 0<!>\n    }\n    )\n    invoker(\n    l@{\n        return@l 1\n    }\n    )\n    invoker(\n    {\n        <!RETURN_NOT_ALLOWED!>return<!> \"0\"\n    }\n    )\n    return \"2\"\n}\n\nfun t4() : Int {\n    val <!UNUSED_VARIABLE!>h<!> :  ()-> String = l@{\n        return@l \"a\"\n    }\n    val <!UNUSED_VARIABLE!>g<!> :  ()-> String = l@{\n        return@l \"a\"\n    }\n\n    fun inner(): String {\n        return \"2\"\n    }\n\n    return 12\n}"
        },
        {
            "code": "//KT-597 Type inference failed\n\nfun <T> Array<T>?.get(i: Int) : T {\n    if (this != null)\n        return <!DEBUG_INFO_SMARTCAST!>this<!>.get(i) // <- inferred type is Any? but &T was excepted\n    else throw NullPointerException()\n}\n\noperator fun Int?.inc() : Int {\n    if (this != null)\n        return <!DEBUG_INFO_SMARTCAST!>this<!>.inc()\n    else\n        throw NullPointerException()\n}\n\nfun test() {\n   var i : Int? = 10\n   var <!UNUSED_VARIABLE!>i_inc<!> = <!UNUSED_CHANGED_VALUE!>i++<!> // <- expected Int?, but returns Any?\n}\n"
        },
        {
            "code": "// KT-306 Ambiguity when different this's have same-looking functions\n\nfun test() {\n    (<!UNUSED_EXPRESSION!>fun Foo.() {\n        bar()\n        (<!UNUSED_EXPRESSION!>fun Barr.() {\n            this.bar()\n            bar()\n        }<!>)\n    }<!>)\n    (<!UNUSED_EXPRESSION!>fun Barr.() {\n        this.bar()\n        bar()\n    }<!>)\n}\n\nclass Foo {\n    fun bar() {}\n}\n\nclass Barr {\n    fun bar() {}\n}\n"
        },
        {
            "code": "import A.<!SYNTAX!><!>;\n\nclass A\n"
        },
        {
            "code": "fun set(<!UNUSED_PARAMETER!>key<!> : String, <!UNUSED_PARAMETER!>value<!> : String) {\n  val a : String? = \"\"\n  when (a) {\n    \"\" -> <!DEBUG_INFO_SMARTCAST!>a<!>.get(0)\n    is String, is Any -> <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"\")\n    else -> a.toString()\n  }\n}"
        },
        {
            "code": "//KT-762 Wrong highlighting in imports (No errors reported on unresolved imports)\nimport <!UNRESOLVED_REFERENCE!>aaa<!> // must be an error\n\nfun main() {}\n"
        },
        {
            "code": "// KT-174 Nullability info for extension function receivers\ninterface Tree {}\n\nfun Any?.TreeValue() : Tree {\n  if (this is Tree) return <!DEBUG_INFO_SMARTCAST!>this<!>\n    throw Exception()\n}\n"
        },
        {
            "code": "// KT-313 Bug in substitutions in a function returning its type parameter T\n\nfun <T> Iterable<T>.join(separator : String?) : String {\n    return separator.npe()\n}\n\nfun <T : Any> T?.npe() : T {\n    if (this == null)\n      throw NullPointerException()\n    return <!DEBUG_INFO_SMARTCAST!>this<!>;\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-352 Function variable declaration type isn't checked inside a function body\n\npackage kt352\n\nval f : (Any) -> Unit = {  <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!>-> }  //type mismatch\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>f<!> : (Any) -> Unit = { <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!>-> }  //!!! no error\n}\n\nclass A() {\n    val f : (Any) -> Unit = { <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!>-> }  //type mismatch\n}\n\n//more tests\nval g : () -> Unit = { <!UNUSED_EXPRESSION!>42<!> }\nval gFunction : () -> Unit = <!OI;TYPE_MISMATCH!>fun(): Int = 1<!>\n\nval h : () -> Unit = { doSmth() }\n\nfun doSmth(): Int = 42\nfun doSmth(<!UNUSED_PARAMETER!>a<!>: String) {}\n\nval testIt : (Any) -> Unit = {\n    if (it is String) {\n        doSmth(<!DEBUG_INFO_SMARTCAST!>it<!>)\n    }\n}"
        },
        {
            "code": "// KT-287 Infer constructor type arguments\n\nimport java.util.*\n\nfun attributes() : Map<String, String> = HashMap() // Should be inferred;\nval attributes : Map<String, String> = HashMap() // Should be inferred;\n\nfun foo(<!UNUSED_PARAMETER!>m<!> : Map<String, String>) {}\n\nfun test() {\n    foo(HashMap())\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNREACHABLE_CODE\n\nfun foo() {\n    val <!OI;UNUSED_VARIABLE!>text<!>: List<Any> = null!!\n    text.<!UNRESOLVED_REFERENCE!>map<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>Any<!><!SYNTAX!>?<!>::<!DEBUG_INFO_MISSING_UNRESOLVED!>toString<!>\n}\n"
        },
        {
            "code": "class Command() {}\n\nfun parse(<!UNUSED_PARAMETER!>cmd<!>: String): Command? { return null  }\n\nfun Any.<!EXTENSION_SHADOWED_BY_MEMBER!>equals<!>(other : Any?) : Boolean = this === other\n\nfun main() {\n    val command = parse(\"\")\n    if (command == null) <!UNUSED_EXPRESSION!>1<!> // error on this line, but must be OK\n}"
        },
        {
            "code": "fun test(<!UNUSED_PARAMETER!>c<!> : Char) {\n  test(<!EMPTY_CHARACTER_LITERAL!>''<!>)\n  test('a')\n  test(<!TOO_MANY_CHARACTERS_IN_CHARACTER_LITERAL!>'aa'<!>)\n  test(<!INCORRECT_CHARACTER_LITERAL!>'a)<!>\n  <!UNRESOLVED_REFERENCE!>test<!>(<!INCORRECT_CHARACTER_LITERAL!>'<!>\n  <!UNRESOLVED_REFERENCE!>test<!>(0<!INCORRECT_CHARACTER_LITERAL!><!SYNTAX!><!>'<!>\n  <!UNRESOLVED_REFERENCE!>test<!>('\\n')\n  <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>test<!>('\\\\')\n  <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>test<!>(<!EMPTY_CHARACTER_LITERAL!>''<!><!EMPTY_CHARACTER_LITERAL, TOO_MANY_ARGUMENTS!><!SYNTAX!><!>''<!>)\n  test('\\'')\n  test('\\\"')\n}\n"
        },
        {
            "code": "// KT-286 Check supertype lists\n\n/*\nIn a supertype list:\n Same type should not be mentioned twice\n Same type should not be indirectly mentioned with incoherent type arguments\n Every interface's required dependencies should be satisfied\n No final types should appear\n Only one class is allowed\n*/\n\nclass C1()\n\nopen class OC1()\n\nopen class C2 {}\n\nopen class C3 {}\n\ninterface T1 {}\n\ninterface T2<T> {}\n\ninterface Test<!CONSTRUCTOR_IN_INTERFACE!>()<!> {\n}\n\ninterface Test1 : <!INTERFACE_WITH_SUPERCLASS!>C2<!><!SUPERTYPE_INITIALIZED_IN_INTERFACE!>()<!> {}\n\ninterface Test2 : <!INTERFACE_WITH_SUPERCLASS!>C2<!> {}\n\ninterface Test3 : <!INTERFACE_WITH_SUPERCLASS!>C2<!>, <!MANY_CLASSES_IN_SUPERTYPE_LIST!>C3<!> {}\n\ninterface Test4 : T1 {}\n\ninterface Test5 : T1, <!SUPERTYPE_APPEARS_TWICE!>T1<!> {}\n\ninterface Test6 : <!FINAL_SUPERTYPE, INTERFACE_WITH_SUPERCLASS!>C1<!> {}\n\nclass CTest1() : OC1() {}\n\nclass CTest2 : <!SUPERTYPE_NOT_INITIALIZED!>C2<!> {}\n\nclass CTest3 : <!SUPERTYPE_NOT_INITIALIZED!>C2<!>, <!MANY_CLASSES_IN_SUPERTYPE_LIST, SUPERTYPE_NOT_INITIALIZED!>C3<!> {}\n\nclass CTest4 : T1 {}\n\nclass CTest5 : T1, <!SUPERTYPE_APPEARS_TWICE!>T1<!> {}\n\nclass CTest6 : <!FINAL_SUPERTYPE, SUPERTYPE_NOT_INITIALIZED!>C1<!> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n<!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\nclass A\n\n@kotlin.PublishedApi\ninternal class B\n\n<!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\nprivate class C\n\n\n<!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\nfun a() {}\n\n@kotlin.PublishedApi\ninternal fun b() {}\n\n@kotlin.PublishedApi\ninternal fun c() {}\n\n\n<!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\nvar ap = 1\n\n@kotlin.PublishedApi\ninternal var bp = 1\n\n@kotlin.PublishedApi\ninternal var c = 1\n\n\n\nclass E {\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    fun a() {}\n\n    @kotlin.PublishedApi\n    internal fun b() {}\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    private fun c() {}\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    protected fun d() {}\n\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    val ap = 1\n\n    @kotlin.PublishedApi\n    internal val bp = 1\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    protected val c = 1\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    private val d = 1\n}\n\n\nclass D <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!> constructor() {\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    constructor(a: String) : this()\n\n    <!NON_INTERNAL_PUBLISHED_API!>@kotlin.PublishedApi<!>\n    private constructor(a: String, b: String): this()\n\n    @kotlin.PublishedApi\n    internal constructor(a: String, b: String, c: String): this()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: a.kt\n\npackage foo\n\n// FILE: b.kt\n\n@<!UNRESOLVED_REFERENCE!>foo<!> fun bar(p: <!UNRESOLVED_REFERENCE!>foo<!>): <!UNRESOLVED_REFERENCE!>foo<!> = null!!"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(<!UNUSED_PARAMETER!>u<!> : Unit) : Int = 1\n\nfun test() : Int {\n    foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    val <!UNUSED_VARIABLE!>a<!> : () -> Unit = {\n        foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    }\n    return 1 <!NONE_APPLICABLE!>-<!> \"1\"\n}\n\nclass A() {\n    val x : Int = <!TYPE_MISMATCH!>foo1(<!TOO_MANY_ARGUMENTS, UNRESOLVED_REFERENCE!>xx<!>)<!>\n}\n\nfun foo1() {}\n"
        },
        {
            "code": "@Target(AnnotationTarget.TYPE, AnnotationTarget.TYPE_PARAMETER)\nannotation class A\n\n@Target(AnnotationTarget.TYPE, AnnotationTarget.TYPE_PARAMETER)\nannotation class B\n\ntypealias Test0 = @A @B Int\ntypealias Test1 = @A() (<!MODIFIER_LIST_NOT_ALLOWED!>@A<!> Int)\ntypealias Test2 = @A() (<!MODIFIER_LIST_NOT_ALLOWED!>@B<!> Int)\ntypealias Test3 = @A() (@A Int) -> Int\ntypealias Test4 = @A() (<!MODIFIER_LIST_NOT_ALLOWED!>@B<!> Int)?\ntypealias Test5 = @A() ( (<!MODIFIER_LIST_NOT_ALLOWED!>@B<!> Int)? )\ntypealias Test6 = (@A @B Int)\ntypealias Test7 = (@A @B Int)?\ntypealias Test8 = (@A() (<!MODIFIER_LIST_NOT_ALLOWED!>@B<!> Int)? )\ntypealias Test9 = (@A() (<!MODIFIER_LIST_NOT_ALLOWED!>@B<!> Int)  )?"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Example {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus(): String = \"\"\n    operator fun unaryPlus(): Int = 0\n}\n\nclass ExampleDeprecated {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus(): String = \"\"\n}\n\n<!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun String.plus(): String = this\noperator fun String.unaryPlus(): Int = 0\n\nfun test() {\n    requireInt(+ \"\")\n    requireInt(+ Example())\n    requireString(<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>+<!> ExampleDeprecated())\n}\n\nfun requireInt(n: Int) {}\nfun requireString(s: String) {}\n\nclass Example2 {\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun plus() = this\n    <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun minus() = this\n\n    fun test() {\n        <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE_WRONG_RECEIVER!>+<!>this\n        <!UNRESOLVED_REFERENCE!>-<!>this\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\nval a1 = 0\nval a2 = <!DIVISION_BY_ZERO!>1 / 0<!>\nval a3 = <!DIVISION_BY_ZERO!>1 / a1<!>\nval a4 = 1 / a2\nval a5 = 2 * (<!DIVISION_BY_ZERO!>1 / 0<!>)\n\nval a6 = <!DIVISION_BY_ZERO!>1.div(0)<!>\nval a7 = <!DIVISION_BY_ZERO!>1.div(a1)<!>\nval a8 = 1.div(a2)\nval a9 = 2 * (<!DIVISION_BY_ZERO!>1.div(0)<!>)\n\nval b1: Byte = <!DIVISION_BY_ZERO, TYPE_MISMATCH!>1 / 0<!>\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST, DIVISION_BY_ZERO!>1 / 0<!>) val b2 = 1\n\nannotation class Ann(val i : Int)"
        },
        {
            "code": "fun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(-1)\n    fooInt(<!TYPE_MISMATCH!>-1111111111111111111<!>)\n    fooInt(-1.toInt())\n    fooInt(-1.toByte())\n    fooInt(<!TYPE_MISMATCH!>-1.toLong()<!>)\n    fooInt(-1.toShort())\n\n    fooByte(-1)\n    fooByte(<!TYPE_MISMATCH!>-1111111111111111111<!>)\n    fooByte(<!TYPE_MISMATCH!>-1.toInt()<!>)\n    fooByte(<!TYPE_MISMATCH!>-1.toByte()<!>)\n    fooByte((-1).toByte())\n    fooByte(<!TYPE_MISMATCH!>-1.toLong()<!>)\n    fooByte(<!TYPE_MISMATCH!>-1.toShort()<!>)\n\n    fooLong(-1)\n    fooLong(-1111111111111111111)\n    fooLong(<!TYPE_MISMATCH!>-1.toInt()<!>)\n    fooLong(<!TYPE_MISMATCH!>-1.toByte()<!>)\n    fooLong(-1.toLong())\n    fooLong(<!TYPE_MISMATCH!>-1.toShort()<!>)\n\n    fooShort(-1)\n    fooShort(<!TYPE_MISMATCH!>-1111111111111111111<!>)\n    fooShort(<!TYPE_MISMATCH!>-1.toInt()<!>)\n    fooShort(<!TYPE_MISMATCH!>-1.toByte()<!>)\n    fooShort(<!TYPE_MISMATCH!>-1.toLong()<!>)\n    fooShort(<!TYPE_MISMATCH!>-1.toShort()<!>)\n    fooShort((-1).toShort())\n}"
        },
        {
            "code": "val p1: Int = -1\nval p2: Long = -1\nval p3: Byte = -1\nval p4: Short = -1\n\nval lp1: Int = <!TYPE_MISMATCH!>-1111111111111111111<!>\nval lp2: Long = -1111111111111111111\nval lp3: Byte = <!TYPE_MISMATCH!>-1111111111111111111<!>\nval lp4: Short = <!TYPE_MISMATCH!>-1111111111111111111<!>\n\nval l1: Long = -1.toLong()\nval l2: Byte = <!TYPE_MISMATCH!>-1.toLong()<!>\nval l3: Int = <!TYPE_MISMATCH!>-1.toLong()<!>\nval l4: Short = <!TYPE_MISMATCH!>-1.toLong()<!>\n\nval b1: Byte = <!TYPE_MISMATCH!>-1.toByte()<!>\nval b2: Int = -1.toByte()\nval b3: Long = <!TYPE_MISMATCH!>-1.toByte()<!>\nval b4: Short = <!TYPE_MISMATCH!>-1.toByte()<!>\n\nval i1: Byte = <!TYPE_MISMATCH!>-1.toInt()<!>\nval i2: Int = -1.toInt()\nval i3: Long = <!TYPE_MISMATCH!>-1.toInt()<!>\nval i4: Short = <!TYPE_MISMATCH!>-1.toInt()<!>\n\nval s1: Byte = <!TYPE_MISMATCH!>-1.toShort()<!>\nval s2: Int = -1.toShort()\nval s3: Long = <!TYPE_MISMATCH!>-1.toShort()<!>\nval s4: Short = <!TYPE_MISMATCH!>-1.toShort()<!>"
        },
        {
            "code": "fun bar() {\n    false and false\n}\n\n// See exception in KT-13421\nfun foo() {\n    42 and <!CONSTANT_EXPECTED_TYPE_MISMATCH!>false<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_EXPRESSION\n\nfun test() {\n    <!FLOAT_LITERAL_CONFORMS_INFINITY!>1.2E400F<!>\n    <!FLOAT_LITERAL_CONFORMS_ZERO!>1.2E-400F<!>\n    <!FLOAT_LITERAL_CONFORMS_INFINITY!>11111111111111111111111111111111111111111111111111111111111111111F<!>\n    <!FLOAT_LITERAL_CONFORMS_ZERO!>0.000000000000000000000000000000000000000000000000000000000000001F<!>\n    0.000000000000000000000000000000000000001000000000000000000000000F\n\n    <!FLOAT_LITERAL_CONFORMS_INFINITY!>1.2E400f<!>\n    <!FLOAT_LITERAL_CONFORMS_ZERO!>1.2E-400f<!>\n    <!FLOAT_LITERAL_CONFORMS_INFINITY!>11111111111111111111111111111111111111111111111111111111111111111f<!>\n    <!FLOAT_LITERAL_CONFORMS_ZERO!>0.000000000000000000000000000000000000000000000000000000000000001f<!>\n    0.000000000000000000000000000000000000001000000000000000000000000f\n\n    val d1: Double = <!FLOAT_LITERAL_CONFORMS_INFINITY!>1.2E400<!>\n    val d2: Double = <!FLOAT_LITERAL_CONFORMS_ZERO!>1.2E-400<!>\n    val d3: Double = 11111111111111111111111111111111111111111111111111111111111111111.0\n    val d4: Double = 0.000000000000000000000000000000000000000000000000000000000000001\n    val d5: Double = 0.000000000000000000000000000000000000001000000000000000000000000\n}"
        },
        {
            "code": "// FILE: a.kt\npackage example.ns\nval y: Any? = 2\n\n// FILE: b.kt\npackage example\n\nval x: Int = if (example.ns.y is Int) <!DEBUG_INFO_SMARTCAST!>example.ns.y<!> else 2"
        },
        {
            "code": "val p1 = 1 - 1\nval p2 = 1 - 1.toLong()\nval p3 = 1 - 1.toByte()\nval p4 = 1 - 1.toInt()\nval p5 = 1 - 1.toShort()\n\nfun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(p1)\n    fooInt(<!TYPE_MISMATCH!>p2<!>)\n    fooInt(p3)\n    fooInt(p4)\n    fooInt(p5)\n\n    fooLong(<!TYPE_MISMATCH!>p1<!>)\n    fooLong(p2)\n    fooLong(<!TYPE_MISMATCH!>p3<!>)\n    fooLong(<!TYPE_MISMATCH!>p4<!>)\n    fooLong(<!TYPE_MISMATCH!>p5<!>)\n\n    fooShort(<!TYPE_MISMATCH!>p1<!>)\n    fooShort(<!TYPE_MISMATCH!>p2<!>)\n    fooShort(<!TYPE_MISMATCH!>p3<!>)\n    fooShort(<!TYPE_MISMATCH!>p4<!>)\n    fooShort(<!TYPE_MISMATCH!>p5<!>)\n\n    fooByte(<!TYPE_MISMATCH!>p1<!>)\n    fooByte(<!TYPE_MISMATCH!>p2<!>)\n    fooByte(<!TYPE_MISMATCH!>p3<!>)\n    fooByte(<!TYPE_MISMATCH!>p4<!>)\n    fooByte(<!TYPE_MISMATCH!>p5<!>)\n}"
        },
        {
            "code": "val p1: Int = 1 - 1\nval p2: Long = 1 - 1\nval p3: Byte = 1 - 1\nval p4: Short = 1 - 1\n\nval l1: Long = 1 - 1.toLong()\nval l2: Byte = <!TYPE_MISMATCH!>1 - 1.toLong()<!>\nval l3: Int = <!TYPE_MISMATCH!>1 - 1.toLong()<!>\nval l4: Short = <!TYPE_MISMATCH!>1 - 1.toLong()<!>\n\nval b1: Byte = <!TYPE_MISMATCH!>1 - 1.toByte()<!>\nval b2: Int = 1 - 1.toByte()\nval b3: Long = <!TYPE_MISMATCH!>1 - 1.toByte()<!>\nval b4: Short = <!TYPE_MISMATCH!>1 - 1.toByte()<!>\n\nval i1: Byte = <!TYPE_MISMATCH!>1 - 1.toInt()<!>\nval i2: Int = 1 - 1.toInt()\nval i3: Long = <!TYPE_MISMATCH!>1 - 1.toInt()<!>\nval i4: Short = <!TYPE_MISMATCH!>1 - 1.toInt()<!>\n\nval s1: Byte = <!TYPE_MISMATCH!>1 - 1.toShort()<!>\nval s2: Int = 1 - 1.toShort()\nval s3: Long = <!TYPE_MISMATCH!>1 - 1.toShort()<!>\nval s4: Short = <!TYPE_MISMATCH!>1 - 1.toShort()<!>"
        },
        {
            "code": "fun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(1.plus(1))\n    fooByte(1.plus(1))\n    fooLong(1.plus(1))\n    fooShort(1.plus(1))\n\n    fooInt(1.times(1))\n    fooByte(1.times(1))\n    fooLong(1.times(1))\n    fooShort(1.times(1))\n\n    fooInt(1.div(1))\n    fooByte(1.div(1))\n    fooLong(1.div(1))\n    fooShort(1.div(1))\n\n    fooInt(1.<!DEPRECATION_ERROR!>mod<!>(1))\n    fooByte(1.<!DEPRECATION_ERROR!>mod<!>(1))\n    fooLong(1.<!DEPRECATION_ERROR!>mod<!>(1))\n    fooShort(1.<!DEPRECATION_ERROR!>mod<!>(1))\n\n    fooInt(1.rem(1))\n    fooByte(1.rem(1))\n    fooLong(1.rem(1))\n    fooShort(1.rem(1))\n}"
        },
        {
            "code": "val a1: Int = <!INTEGER_OVERFLOW!>32000.toShort() * 32000.toShort() * 32000.toShort()<!>\nval a2: Int = <!INTEGER_OVERFLOW!>128.toByte() * 128.toByte() * 128.toByte() * 128.toByte() * 128.toByte()<!>"
        },
        {
            "code": "fun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(1 <!INFIX_MODIFIER_REQUIRED!>plus<!> 1)\n    fooByte(1 <!INFIX_MODIFIER_REQUIRED!>plus<!> 1)\n    fooLong(1 <!INFIX_MODIFIER_REQUIRED!>plus<!> 1)\n    fooShort(1 <!INFIX_MODIFIER_REQUIRED!>plus<!> 1)\n\n    fooInt(1 <!INFIX_MODIFIER_REQUIRED!>times<!> 1)\n    fooByte(1 <!INFIX_MODIFIER_REQUIRED!>times<!> 1)\n    fooLong(1 <!INFIX_MODIFIER_REQUIRED!>times<!> 1)\n    fooShort(1 <!INFIX_MODIFIER_REQUIRED!>times<!> 1)\n\n    fooInt(1 <!INFIX_MODIFIER_REQUIRED!>div<!> 1)\n    fooByte(1 <!INFIX_MODIFIER_REQUIRED!>div<!> 1)\n    fooLong(1 <!INFIX_MODIFIER_REQUIRED!>div<!> 1)\n    fooShort(1 <!INFIX_MODIFIER_REQUIRED!>div<!> 1)\n\n    fooInt(1 <!DEPRECATION_ERROR, INFIX_MODIFIER_REQUIRED!>mod<!> 1)\n    fooByte(1 <!DEPRECATION_ERROR, INFIX_MODIFIER_REQUIRED!>mod<!> 1)\n    fooLong(1 <!DEPRECATION_ERROR, INFIX_MODIFIER_REQUIRED!>mod<!> 1)\n    fooShort(1 <!DEPRECATION_ERROR, INFIX_MODIFIER_REQUIRED!>mod<!> 1)\n\n    fooInt(1 <!INFIX_MODIFIER_REQUIRED!>rem<!> 1)\n    fooByte(1 <!INFIX_MODIFIER_REQUIRED!>rem<!> 1)\n    fooLong(1 <!INFIX_MODIFIER_REQUIRED!>rem<!> 1)\n    fooShort(1 <!INFIX_MODIFIER_REQUIRED!>rem<!> 1)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_PARAMETER\n\ninfix fun Int.rem(other: Int) = 10\ninfix operator fun Int.minus(other: Int): Int = 20\n\nconst val a1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>(-5) rem 2<!>\nconst val a2 = (-5).rem(2)\n\nconst val b1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>5 minus 3<!>\nconst val b2 = 5.minus(3)\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nval intMaxValue: Int = 0x7fffffff\nval intMinValue: Int = 1 shl 31\n\nval a3: Int = <!INTEGER_OVERFLOW!><!INTEGER_OVERFLOW!>intMaxValue + 1<!> - 10<!>\nval a4: Int = <!INTEGER_OVERFLOW!>intMaxValue + 1<!> + 10\nval i2: Int = <!INTEGER_OVERFLOW!>intMaxValue - 1 + 2<!>\nval i3: Int = <!INTEGER_OVERFLOW!>intMaxValue - intMinValue<!>\nval i4: Int = <!INTEGER_OVERFLOW!>-intMinValue<!>\nval i5: Int = <!INTEGER_OVERFLOW!>intMinValue - 1<!>\nval i6: Int = <!INTEGER_OVERFLOW!>intMinValue - intMaxValue<!>\nval i7: Int = intMinValue + intMaxValue\nval i8: Int = -intMaxValue\nval i10: Int = <!INTEGER_OVERFLOW!>intMinValue * -1<!>\nval i11: Int = <!INTEGER_OVERFLOW!>intMinValue * 2<!>\nval i12: Int = <!INTEGER_OVERFLOW!>intMaxValue * -2<!>\nval i13: Int = intMaxValue * -1\nval i15: Int = <!INTEGER_OVERFLOW!>intMinValue / -1<!>\nval l20: Int = <!INTEGER_OVERFLOW!>30 * 24 * 60 * 60 * 1000<!>\nval l21: Int = intMinValue - intMinValue\nval l22: Int = <!INTEGER_OVERFLOW!>intMinValue + <!INTEGER_OVERFLOW!>-intMinValue<!><!>\nval l23: Int = intMaxValue + <!INTEGER_OVERFLOW!>-intMinValue<!>\nval l24: Int = (-1).<!DEPRECATION_ERROR!>mod<!>(5)\nval l25: Int = (-1).rem(5)\nval l26: Int = (-1) % 5\n\n\nfun foo() {\n    val a3: Int = <!INTEGER_OVERFLOW!><!INTEGER_OVERFLOW!>intMaxValue + 1<!> - 10<!>\n    val a4: Int = <!INTEGER_OVERFLOW!>intMaxValue + 1<!> + 10\n    val i2: Int = <!INTEGER_OVERFLOW!>intMaxValue - 1 + 2<!>\n    val i3: Int = <!INTEGER_OVERFLOW!>intMaxValue - intMinValue<!>\n    val i4: Int = <!INTEGER_OVERFLOW!>-intMinValue<!>\n    val i5: Int = <!INTEGER_OVERFLOW!>intMinValue - 1<!>\n    val i6: Int = <!INTEGER_OVERFLOW!>intMinValue - intMaxValue<!>\n    val i7: Int = intMinValue + intMaxValue\n    val i8: Int = -intMaxValue\n    val i10: Int = <!INTEGER_OVERFLOW!>intMinValue * -1<!>\n    val i11: Int = <!INTEGER_OVERFLOW!>intMinValue * 2<!>\n    val i12: Int = <!INTEGER_OVERFLOW!>intMaxValue * -2<!>\n    val i13: Int = intMaxValue * -1\n    val i15: Int = <!INTEGER_OVERFLOW!>intMinValue / -1<!>\n    val l20: Int = <!INTEGER_OVERFLOW!>30 * 24 * 60 * 60 * 1000<!>\n    val l21: Int = intMinValue - intMinValue\n    val l22: Int = <!INTEGER_OVERFLOW!>intMinValue + <!INTEGER_OVERFLOW!>-intMinValue<!><!>\n    val l23: Int = intMaxValue + <!INTEGER_OVERFLOW!>-intMinValue<!>\n    val l24: Int = (-1).<!DEPRECATION_ERROR!>mod<!>(5)\n    val l25: Int = (-1).rem(5)\n    val l26: Int = (-1) % 5\n}\n\nclass A {\n    fun foo() {\n        val a3: Int = <!INTEGER_OVERFLOW!><!INTEGER_OVERFLOW!>intMaxValue + 1<!> - 10<!>\n        val a4: Int = <!INTEGER_OVERFLOW!>intMaxValue + 1<!> + 10\n        val i2: Int = <!INTEGER_OVERFLOW!>intMaxValue - 1 + 2<!>\n        val i3: Int = <!INTEGER_OVERFLOW!>intMaxValue - intMinValue<!>\n        val i4: Int = <!INTEGER_OVERFLOW!>-intMinValue<!>\n        val i5: Int = <!INTEGER_OVERFLOW!>intMinValue - 1<!>\n        val i6: Int = <!INTEGER_OVERFLOW!>intMinValue - intMaxValue<!>\n        val i7: Int = intMinValue + intMaxValue\n        val i8: Int = -intMaxValue\n        val i10: Int = <!INTEGER_OVERFLOW!>intMinValue * -1<!>\n        val i11: Int = <!INTEGER_OVERFLOW!>intMinValue * 2<!>\n        val i12: Int = <!INTEGER_OVERFLOW!>intMaxValue * -2<!>\n        val i13: Int = intMaxValue * -1\n        val i15: Int = <!INTEGER_OVERFLOW!>intMinValue / -1<!>\n        val l20: Int = <!INTEGER_OVERFLOW!>30 * 24 * 60 * 60 * 1000<!>\n        val l21: Int = intMinValue - intMinValue\n        val l22: Int = <!INTEGER_OVERFLOW!>intMinValue + <!INTEGER_OVERFLOW!>-intMinValue<!><!>\n        val l23: Int = intMaxValue + <!INTEGER_OVERFLOW!>-intMinValue<!>\n        val l24: Int = (-1).<!DEPRECATION_ERROR!>mod<!>(5)\n        val l25: Int = (-1).rem(5)\n        val l26: Int = (-1) % 5\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nval longMaxValue: Long = 0x7fffffffffffffff\nval longMinValue: Long = -longMaxValue - 1\nval intMaxValue: Int = 0x7fffffff\nval intMinValue: Int = 1 shl 31\n\nval a2: Long = <!INTEGER_OVERFLOW!>longMinValue - 10<!>\n\nval l1: Long = <!INTEGER_OVERFLOW!>longMaxValue + 1<!>\nval l2: Long = <!INTEGER_OVERFLOW!>longMaxValue - 1 + 2<!>\nval l3: Long = <!INTEGER_OVERFLOW!>longMaxValue - longMinValue<!>\nval l4: Long = <!INTEGER_OVERFLOW!>-longMinValue<!>\nval l5: Long = <!INTEGER_OVERFLOW!>longMinValue - 1<!>\nval l6: Long = <!INTEGER_OVERFLOW!>longMinValue - longMaxValue<!>\nval l7: Long = longMinValue + longMaxValue\nval l8: Long = -longMaxValue\nval l10: Long = -intMinValue.toLong()\nval l11: Long = -1 + intMinValue.toLong()\nval l12: Long = <!INTEGER_OVERFLOW!>longMinValue * intMinValue<!>\nval l13: Long = <!INTEGER_OVERFLOW!>longMinValue * -1<!>\nval l14: Long = <!INTEGER_OVERFLOW!>longMinValue * 2<!>\nval l15: Long = <!INTEGER_OVERFLOW!>longMaxValue * -2<!>\nval l16: Long = intMinValue.toLong() * -1\nval l19: Long = <!INTEGER_OVERFLOW!>longMinValue / -1<!>\n\nfun foo() {\n    val l1: Long = <!INTEGER_OVERFLOW!>longMaxValue + 1<!>\n    val l2: Long = <!INTEGER_OVERFLOW!>longMaxValue - 1 + 2<!>\n    val l3: Long = <!INTEGER_OVERFLOW!>longMaxValue - longMinValue<!>\n    val l4: Long = <!INTEGER_OVERFLOW!>-longMinValue<!>\n    val l5: Long = <!INTEGER_OVERFLOW!>longMinValue - 1<!>\n    val l6: Long = <!INTEGER_OVERFLOW!>longMinValue - longMaxValue<!>\n    val l7: Long = longMinValue + longMaxValue\n    val l8: Long = -longMaxValue\n    val l10: Long = -intMinValue.toLong()\n    val l11: Long = -1 + intMinValue.toLong()\n    val l12: Long = <!INTEGER_OVERFLOW!>longMinValue * intMinValue<!>\n    val l13: Long = <!INTEGER_OVERFLOW!>longMinValue * -1<!>\n    val l14: Long = <!INTEGER_OVERFLOW!>longMinValue * 2<!>\n    val l15: Long = <!INTEGER_OVERFLOW!>longMaxValue * -2<!>\n    val l16: Long = intMinValue.toLong() * -1\n    val l19: Long = <!INTEGER_OVERFLOW!>longMinValue / -1<!>\n}\n\nclass A {\n    fun foo() {\n        val l1: Long = <!INTEGER_OVERFLOW!>longMaxValue + 1<!>\n        val l2: Long = <!INTEGER_OVERFLOW!>longMaxValue - 1 + 2<!>\n        val l3: Long = <!INTEGER_OVERFLOW!>longMaxValue - longMinValue<!>\n        val l4: Long = <!INTEGER_OVERFLOW!>-longMinValue<!>\n        val l5: Long = <!INTEGER_OVERFLOW!>longMinValue - 1<!>\n        val l6: Long = <!INTEGER_OVERFLOW!>longMinValue - longMaxValue<!>\n        val l7: Long = longMinValue + longMaxValue\n        val l8: Long = -longMaxValue\n        val l10: Long = -intMinValue.toLong()\n        val l11: Long = -1 + intMinValue.toLong()\n        val l12: Long = <!INTEGER_OVERFLOW!>longMinValue * intMinValue<!>\n        val l13: Long = <!INTEGER_OVERFLOW!>longMinValue * -1<!>\n        val l14: Long = <!INTEGER_OVERFLOW!>longMinValue * 2<!>\n        val l15: Long = <!INTEGER_OVERFLOW!>longMaxValue * -2<!>\n        val l16: Long = intMinValue.toLong() * -1\n        val l19: Long = <!INTEGER_OVERFLOW!>longMinValue / -1<!>\n    }\n}"
        },
        {
            "code": "fun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(1 - 1)\n    fooInt(1 - 1.toInt())\n    fooInt(1 - 1.toByte())\n    fooInt(<!TYPE_MISMATCH!>1 - 1.toLong()<!>)\n    fooInt(1 - 1.toShort())\n\n    fooByte(1 - 1)\n    fooByte(<!TYPE_MISMATCH!>1 - 1.toInt()<!>)\n    fooByte(<!TYPE_MISMATCH!>1 - 1.toByte()<!>)\n    fooByte(<!TYPE_MISMATCH!>1 - 1.toLong()<!>)\n    fooByte(<!TYPE_MISMATCH!>1 - 1.toShort()<!>)\n\n    fooLong(1 - 1)\n    fooLong(<!TYPE_MISMATCH!>1 - 1.toInt()<!>)\n    fooLong(<!TYPE_MISMATCH!>1 - 1.toByte()<!>)\n    fooLong(1 - 1.toLong())\n    fooLong(<!TYPE_MISMATCH!>1 - 1.toShort()<!>)\n\n    fooShort(1 - 1)\n    fooShort(<!TYPE_MISMATCH!>1 - 1.toInt()<!>)\n    fooShort(<!TYPE_MISMATCH!>1 - 1.toByte()<!>)\n    fooShort(<!TYPE_MISMATCH!>1 - 1.toLong()<!>)\n    fooShort(<!TYPE_MISMATCH!>1 - 1.toShort()<!>)\n}"
        },
        {
            "code": "// FILE: A.kt\nval a1: Int = Test.i1 + 1\nval a2: Int = <!INTEGER_OVERFLOW!>Test.i2 + 1<!>\nval a3: Int = <!INTEGER_OVERFLOW!>Test().i3 + 1<!>\nval a4: Int = Test().i4 + 1"
        },
        {
            "code": "val p1: Byte = (1 + 2) * 2\nval p2: Short = (1 + 2) * 2\nval p3: Int = (1 + 2) * 2\nval p4: Long = (1 + 2) * 2\n\nval b1: Byte = <!TYPE_MISMATCH!>(1.toByte() + 2) * 2<!>\nval b2: Short = <!TYPE_MISMATCH!>(1.toShort() + 2) * 2<!>\nval b3: Int = (1.toInt() + 2) * 2\nval b4: Long = (1.toLong() + 2) * 2\n\nval i1: Int = (1.toByte() + 2) * 2\nval i2: Int = (1.toShort() + 2) * 2"
        },
        {
            "code": "val a1: Int = 1<!WRONG_LONG_SUFFIX!>l<!>\nval a2: Int = 0x1<!WRONG_LONG_SUFFIX!>l<!>\nval a3: Int = 0X1<!WRONG_LONG_SUFFIX!>l<!>\nval a4: Int = 0b1<!WRONG_LONG_SUFFIX!>l<!>\nval a5: Int = 0B1<!WRONG_LONG_SUFFIX!>l<!>\nval a6: Long = 1<!WRONG_LONG_SUFFIX!>l<!>\nval a7: Long = 0x1<!WRONG_LONG_SUFFIX!>l<!>\nval a8: Long = 0X1<!WRONG_LONG_SUFFIX!>l<!>\nval a9: Long = 0b1<!WRONG_LONG_SUFFIX!>l<!>\nval a10: Long = 0B1<!WRONG_LONG_SUFFIX!>l<!>"
        },
        {
            "code": "val p1 = -1\nval p2 = -1.toLong()\nval p3 = (-1).toByte()\nval p4 = -1.toInt()\nval p5 = (-1).toShort()\nval p6 = -1111111111111111111\n\nfun fooInt(p: Int) = p\nfun fooLong(p: Long) = p\nfun fooByte(p: Byte) = p\nfun fooShort(p: Short) = p\n\nfun test() {\n    fooInt(p1)\n    fooInt(<!TYPE_MISMATCH!>p2<!>)\n    fooInt(<!TYPE_MISMATCH!>p3<!>)\n    fooInt(p4)\n    fooInt(<!TYPE_MISMATCH!>p5<!>)\n    fooInt(<!TYPE_MISMATCH!>p6<!>)\n\n    fooLong(<!TYPE_MISMATCH!>p1<!>)\n    fooLong(p2)\n    fooLong(<!TYPE_MISMATCH!>p3<!>)\n    fooLong(<!TYPE_MISMATCH!>p4<!>)\n    fooLong(<!TYPE_MISMATCH!>p5<!>)\n    fooLong(p6)\n\n    fooShort(<!TYPE_MISMATCH!>p1<!>)\n    fooShort(<!TYPE_MISMATCH!>p2<!>)\n    fooShort(<!TYPE_MISMATCH!>p3<!>)\n    fooShort(<!TYPE_MISMATCH!>p4<!>)\n    fooShort(p5)\n    fooShort(<!TYPE_MISMATCH!>p6<!>)\n\n    fooByte(<!TYPE_MISMATCH!>p1<!>)\n    fooByte(<!TYPE_MISMATCH!>p2<!>)\n    fooByte(p3)\n    fooByte(<!TYPE_MISMATCH!>p4<!>)\n    fooByte(<!TYPE_MISMATCH!>p5<!>)\n    fooByte(<!TYPE_MISMATCH!>p6<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// JAVAC_SKIP\n\n// FILE: uint.kt\n\npackage kotlin\n\ninline class UByte(private val b: Byte)\ninline class UShort(private val s: Short)\ninline class UInt(private val i: Int)\ninline class ULong(private val l: Long)\n\n// FILE: test.kt\n\nannotation class AnnoUB(val ub0: UByte, val ub1: UByte)\nannotation class AnnoUS(val us0: UShort, val us1: UShort)\nannotation class AnnoUI(val ui0: UInt, val ui1: UInt, val ui2: UInt, val ui3: UInt)\nannotation class AnnoUL(val ul0: ULong, val ul1: ULong)\n\nconst val ub0 = UByte(1)\nconst val us0 = UShort(2)\nconst val ul0 = ULong(3)\n\nconst val ui0 = UInt(-1)\nconst val ui1 = UInt(0)\nconst val ui2 = UInt(40 + 2)\n\n@AnnoUB(UByte(1), ub0)\nfun f0() {}\n\n@AnnoUS(UShort(2 + 5), us0)\nfun f1() {}\n\n@AnnoUI(ui0, ui1, ui2, UInt(100))\nfun f2() {}\n\n@AnnoUL(ul0, ULong(5))\nfun f3() {}\n\nconst val explicit: UInt = UInt(2)\n\n<!TYPE_CANT_BE_USED_FOR_CONST_VAL!>const<!> val nullable: UInt? = UInt(3)\n\nannotation class NullableAnno(val u: <!NULLABLE_TYPE_OF_ANNOTATION_MEMBER!>UInt?<!>)"
        },
        {
            "code": "val a1: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1L<!>\nval a2: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>0x1L<!>\nval a3: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>0X1L<!>\nval a4: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>0b1L<!>\nval a5: Int = <!CONSTANT_EXPECTED_TYPE_MISMATCH!>0B1L<!>\nval a6: Long = 1L\nval a7: Long = 0x1L\nval a8: Long = 0X1L\nval a9: Long = 0b1L\nval a10: Long = 0B1L"
        },
        {
            "code": "package abstract\n\nclass MyClass() {\n    //properties\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val a: Int<!>\n    val a1: Int = 1\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> val a2: Int\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> val a3: Int = 1\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var b: Int<!>                private set\n    var b1: Int = 0;                         private set\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> var b2: Int      private set\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> var b3: Int = 0; private set\n\n    <!MUST_BE_INITIALIZED!>var c: Int<!>                set(v: Int) { field = v }\n    var c1: Int = 0;                         set(v: Int) { field = v }\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> var c2: Int      set(v: Int) { field = v }\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> var c3: Int = 0; set(v: Int) { field = v }\n\n    val e: Int                               get() = a\n    val e1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;          get() = a\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> val e2: Int      get() = a\n    <!ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS!>abstract<!> val e3: Int = 0; get() = a\n\n    //methods\n    <!NON_ABSTRACT_FUNCTION_WITH_NO_BODY!>fun f()<!>\n    fun g() {}\n    <!ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS!>abstract<!> fun h()\n    <!ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS, ABSTRACT_FUNCTION_WITH_BODY!>abstract<!> fun j() {}\n\n    //property accessors\n    var i: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var i1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var j: Int                       get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var j1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  get() = i;    <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var k: Int<!>        <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var k1: Int = 0;                 <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var l: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n    var l1: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>0<!>;  <!WRONG_MODIFIER_TARGET!>abstract<!> get  <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n    var n: Int                       <!WRONG_MODIFIER_TARGET!>abstract<!> get <!WRONG_MODIFIER_TARGET!>abstract<!> set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n}"
        },
        {
            "code": "//!LANGUAGE: +ProhibitTailrecOnVirtualMember\n\nopen class A {\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec open fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>internal tailrec open fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>protected tailrec open fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    private tailrec fun boo(y: Int) {\n        boo(y)\n    }\n\n    internal tailrec fun baa(y: Int) {\n        baa(y)\n    }\n}\n\nopen class B : A() {\n    final tailrec override fun foo(x: Int) {\n        foo(x)\n    }\n\n    final tailrec override fun bar(y: Int) {\n        bar(y)\n    }\n\n    final tailrec override fun baz(y: Int) {\n        baz(y)\n    }\n}\n\n\nopen class C : A() {\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec override fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec override fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec override fun baz(y: Int)<!> {\n        baz(y)\n    }\n}\n\nobject D : A() {\n    tailrec override fun foo(x: Int) {\n        foo(x)\n    }\n\n    tailrec override fun bar(y: Int) {\n        bar(y - 1)\n    }\n\n    tailrec override fun baz(y: Int) {\n        baz(y)\n    }\n}\n\nsealed class E : A() {\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec override fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec override fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec override fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    class E1 : E() {\n        tailrec override fun foo(x: Int) {\n            foo(x)\n        }\n\n        tailrec override fun bar(y: Int) {\n            bar(y)\n        }\n\n        tailrec override fun baz(y: Int) {\n            baz(y)\n        }\n    }\n}\n\nenum class F {\n    F0,\n    F1() {\n        tailrec override fun foo(x: Int) {\n            foo(x)\n        }\n\n        tailrec override fun bar(y: Int) {\n            bar(y)\n        }\n\n        tailrec override fun baz(y: Int) {\n            baz(y)\n        }\n    };\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec open fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>internal tailrec open fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>protected tailrec open fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    private tailrec fun boo(y: Int) {\n        boo(y)\n    }\n\n    internal tailrec fun baa(y: Int) {\n        baa(y)\n    }\n}\n\nenum class G {\n\n    G1;\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>tailrec open fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>internal tailrec open fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER_ERROR!>protected tailrec open fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    private tailrec fun boo(y: Int) {\n        boo(y)\n    }\n\n    internal tailrec fun baa(y: Int) {\n        baa(y)\n    }\n}\n\nval z = object : A() {\n    tailrec override fun foo(x: Int) {\n        foo(x)\n    }\n\n    tailrec override fun bar(y: Int) {\n        bar(y)\n    }\n\n    tailrec override fun baz(y: Int) {\n        baz(y)\n    }\n}"
        },
        {
            "code": "fun use(<!UNUSED_PARAMETER!>s<!>: java.io.Serializable) {\n\n}\n\nfun useList(<!UNUSED_PARAMETER!>s<!>: List<java.io.Serializable>) {\n\n}\n\nfun testPrimitives(b: Byte, ss: Short, i: Int, l: Long, d: Double, s: String, f: Float, bool: Boolean) {\n    use(b)\n    use(ss)\n    use(i)\n    use(l)\n    use(s)\n    use(f)\n    use(d)\n    use(bool)\n}\n\nclass N\nclass S: java.io.Serializable\n\nfun testArrays(ia: IntArray, ai: Array<Int>, an: Array<N>, a: Array<S>) {\n    use(ia)\n    use(ai)\n    use(an)\n    use(a)\n}\n\nfun testLiterals() {\n    use(1)\n    use(1.0)\n    use(11111111111111)\n    use(\"Asdsd\")\n    use(true)\n}\n\nfun testNotSerializable(l: List<Int>) {\n    use(<!TYPE_MISMATCH!>l<!>)\n    use(<!TYPE_MISMATCH!>N()<!>)\n}\n\nenum class C {\n    E, E2\n}\n\nfun testEnums(a: Enum<*>) {\n    use(C.E)\n    use(C.E2)\n    use(a)\n}\n\nfun testLists(a: List<Int>) {\n    useList(a)\n}"
        },
        {
            "code": "abstract class A {\n    <!EXTERNAL_DECLARATION_CANNOT_BE_ABSTRACT!>abstract<!> val x : Int\n        external get\n}\n\ninterface B {\n    val x: Int\n        <!EXTERNAL_DECLARATION_IN_INTERFACE!>external get<!>\n}"
        },
        {
            "code": "interface IA\n\ninterface IB : IA {\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun toString(): String = \"IB\"<!>\n}\n\ninterface IC : IB {\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun toString(): String = \"IC\"<!>\n}\n\ninterface ID : IC {\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun toString(): String = \"ID\"<!>\n}"
        },
        {
            "code": "interface IA {\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun toString(): String = \"IA\"<!>\n\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun equals(other: Any?): Boolean = <!SUPERCLASS_NOT_ACCESSIBLE_FROM_INTERFACE!>super<!>.equals(other)<!>\n\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun hashCode(): Int {\n        return 42;\n    }<!>\n}"
        },
        {
            "code": "interface ILeft {\n    fun foo()\n}\n\ninterface IRight {\n    fun foo()\n}\n\ninterface IDerived : ILeft, IRight\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class CDerived<!> : ILeft, IRight\n\nabstract class ADerived : ILeft, IRight"
        },
        {
            "code": "interface ILeft {\n    override fun toString(): String\n}\n\ninterface IRight {\n    override fun toString(): String\n}\n\ninterface IDiamond : ILeft, IRight {\n    <!METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE!>override fun toString(): String = \"IDiamond\"<!>\n}"
        },
        {
            "code": "interface ILeft {\n    fun foo() {}\n}\n\ninterface IRight {\n    fun foo()\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface IDerived<!> : ILeft, IRight\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class CDerived<!> : ILeft, IRight\n\nabstract <!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class ADerived<!> : ILeft, IRight"
        },
        {
            "code": "abstract class ALeft {\n    abstract fun foo()\n}\n\ninterface IRight {\n    fun foo() {}\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class CDerived<!> : ALeft(), IRight"
        },
        {
            "code": "interface IA {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>toString<!>(): String = \"IB\"\n\n    override fun equals(other: Any?): Boolean\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nval unwrapped = <!UNRESOLVED_REFERENCE!>some<!>.<!SYNTAX!><<!><!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>cabc<!><!SYNTAX!>$Wrapper<!><out <!DEBUG_INFO_MISSING_UNRESOLVED!>Any<!>>::<!DEBUG_INFO_MISSING_UNRESOLVED!>unwrap<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -UNREACHABLE_CODE\n// !WITH_NEW_INFERENCE\n\nclass A {\n    class B {\n        class C\n    }\n}\n\nfun test(a: A.<!SYNTAX!><!>): A.<!SYNTAX!><!> {\n    val aa: A. <!SYNTAX!>=<!><!SYNTAX!><!> null!!\n}\n\nfun test1(a: A.B.<!SYNTAX!><!>): A.B.<!SYNTAX!><!> {\n    val aa: A.B. <!SYNTAX!>=<!><!SYNTAX!><!> null!!\n}\n\nfun test2(a: A.<!UNRESOLVED_REFERENCE!>e<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>C<!>): A.<!UNRESOLVED_REFERENCE!>e<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>C<!> {\n    val aa: A.<!UNRESOLVED_REFERENCE!>e<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>C<!> = null!!\n}\n\nfun test3(a: <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>A<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>C<!>): <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>A<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>C<!> {\n    val aa: <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>A<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>C<!> = null!!\n}\n\nfun test4(a: A.B.<!UNRESOLVED_REFERENCE!>ee<!>): A.B.<!UNRESOLVED_REFERENCE!>ee<!> {\n    val aa: A.B.<!UNRESOLVED_REFERENCE!>ee<!> = null!!\n}\n\nfun test5(a: A.<!UNRESOLVED_REFERENCE!>ee<!>): A.<!UNRESOLVED_REFERENCE!>ee<!> {\n    val aa: A.<!UNRESOLVED_REFERENCE!>ee<!> = null!!\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval unwrapped = <!UNRESOLVED_REFERENCE!>some<!><!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!><<!><!DEBUG_INFO_MISSING_UNRESOLVED!>sdf<!>()()<out <!DEBUG_INFO_MISSING_UNRESOLVED!>Any<!>>::<!DEBUG_INFO_MISSING_UNRESOLVED!>unwrap<!>"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a.b\n\nclass c {\n    fun ab_c() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\npackage a\n\nclass b<T> {\n    class c {\n        fun a_bc() {}\n    }\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\nimport a.b.c\n\nfun test(ab_c: c) {\n    ab_c.ab_c()\n\n    val ab_c2: a.b.c = a.b.c()\n    ab_c2.ab_c()\n\n    val ab_c3 = a.b.c()\n    ab_c3.ab_c()\n}\n\n// NB according to the maximum package prefix rule, 'a.b.c' denotes 'c' in package 'a.b' (thus ab_c, not a_bc)\nfun test2(ab_c: a.b.c) {\n    ab_c.<!UNRESOLVED_REFERENCE!>a_bc<!>()\n    ab_c.ab_c()\n}\n\n\n\n//---------------------------TOP LEVEL----------\n// MODULE: top_m1\n// FILE: top_a.kt\npackage a\n\nclass b {\n    fun a_b() {}\n}\n\n// MODULE: top_m2\n// FILE: top_b.kt\nclass a<T> {\n    class b {\n        fun _ab() {}\n    }\n    fun _a() {}\n}\n\n// MODULE: top_m3(top_m1, top_m2)\n// FILE: top_c.kt\nimport a.b\n\nfun test(a_b: b) {\n    a_b.a_b()\n\n    val _ab: a.b = a.b()\n    _ab._ab()\n\n    val _ab2 = a.b()\n    _ab2._ab()\n}\n\nfun test2(_ab: a.b) {\n    _ab._ab()\n    _ab.<!UNRESOLVED_REFERENCE!>a_b<!>()\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a\n\nclass b {\n    fun a_b() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\nclass a {\n    class b {\n        fun _ab() {}\n    }\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c1.kt\npackage some\n\nfun test(a_b: a.b) {\n    a_b.a_b()\n\n    val a_b2 = a.b()\n    a_b2.a_b()\n}\n\n// FILE: c2.kt\npackage a\n\nfun test(a_b: a.b) {\n    a_b.a_b()\n\n    val a_b2 = a.b()\n    a_b2.a_b()\n}\n\n// FILE: c3.kt\nfun test(_ab: a.b) {\n    _ab._ab()\n\n    val _ab2 = a.b()\n    _ab2._ab() // todo\n}"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a.b\n\nclass c {\n    fun ab_c() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\npackage a\n\nfun a_fun() {}\n\nclass b {\n    fun a_b() {}\n\n    class c {\n        fun a_bc() {}\n    }\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c.kt\n\nfun test(a_b: a.b) {\n    a_b.a_b()\n\n    val ab_c: a.b.c = a.b.c()\n    ab_c.ab_c()\n    ab_c.<!UNRESOLVED_REFERENCE!>a_bc<!>()\n\n    val ab_c2 = a.b.c()\n    ab_c2.ab_c()\n    ab_c2.<!UNRESOLVED_REFERENCE!>a_bc<!>()\n}\n\nfun test2(ab_c: a.b.c) {\n    ab_c.ab_c()\n}\n\n//---- Changed dependence order\n// MODULE: _m1\n// FILE: _a.kt\npackage a.b\n\nfun ab_fun() {}\n\nclass c {\n    fun ab_c() {}\n\n    class d {\n        fun ab_cd() {}\n    }\n}\n\n// MODULE: _m2\n// FILE: _b.kt\npackage a\n\nfun a_fun() {}\n\nclass b {\n    fun a_b() {}\n\n    class c {\n        fun a_bc() {}\n    }\n}\n\n// MODULE: _m3(_m1, _m2)\n// FILE: _c.kt\n\nfun test(a_b: a.b) {\n    a_b.a_b()\n\n    val ab_c: a.b.c = a.b.c()\n    ab_c.ab_c()\n    ab_c.<!UNRESOLVED_REFERENCE!>a_bc<!>()\n\n    val ab_c2 = a.b.c()\n    ab_c2.ab_c()\n    ab_c2.<!UNRESOLVED_REFERENCE!>a_bc<!>()\n}\n\nfun test2(ab_c: a.b.c) {\n    ab_c.ab_c()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// MODULE: m1\n// FILE: a.kt\npackage a\n\nclass a {\n    companion object {}\n}\n\nclass b {\n    fun a_b() {}\n}\n\n// MODULE: m2(m1)\n// FILE: b.kt\npackage test\n\nclass a\n\nval x = a.<!UNRESOLVED_REFERENCE!>b<!>()\n\n// MODULE: m3(m1)\n// FILE: c.kt\npackage test\n\nimport a.a\n\nfun foo(i: a) {\n    a\n    a()\n    a.<!UNRESOLVED_REFERENCE!>a<!>\n    a.<!UNRESOLVED_REFERENCE!>a<!>()\n}\n"
        },
        {
            "code": "// MODULE: m1\n// FILE: a.kt\npackage a\n\nclass b {\n    fun a_b() {}\n}\n\n// MODULE: m2\n// FILE: b.kt\npackage some\n\nclass a {\n    class b {\n        fun some_ab() {}\n    }\n}\n\n// MODULE: m3(m1, m2)\n// FILE: c1.kt\npackage other\n\nclass a {}\n\nfun test(a_: a.<!UNRESOLVED_REFERENCE!>b<!>) {\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_b<!>()\n\n    val a_2 = a.<!UNRESOLVED_REFERENCE!>b<!>()\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_2<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_b<!>()\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_2<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>some_ab<!>()\n    <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_2<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a_<!>()\n}\n\n// FILE: c2.kt\npackage other2\n\nclass a {\n    class b {\n        fun other2_ab() {}\n    }\n}\n\nfun test(_ab: a.b) {\n    _ab.other2_ab()\n\n    val _ab2 = a.b()\n    _ab2.other2_ab()\n}\n\n// FILE: c3.kt\npackage some\n\nfun test(_ab: a.b) {\n    _ab.some_ab()\n\n    val _ab2 = a.b()\n    _ab2.some_ab()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -DEPRECATION -TOPLEVEL_TYPEALIASES_ONLY\n\nclass `_`<`__`> {\n    fun testTypeArgument(x: List<<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>>) = x\n    fun testTypeArgument2(x: List<`__`>) = x\n}\n\nfun <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!><Any>.testTypeConstructor() {}\nfun `_`<Any>.testTypeConstructor2() {}\n\nval testConstructor = <!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>_<!><Any>()\nval testConstructor2 = `_`<Any>()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval x = \"\"\n\nfun bar(x : Int = <!TYPE_MISMATCH!>\"\"<!>, y : Int = x, <!UNUSED_PARAMETER!>z<!> : String = <!TYPE_MISMATCH!>y<!>) {\n\n}\n\n// KT-371 Resolve default parameters for constructors\n\nclass A(x : Int = <!UNINITIALIZED_PARAMETER!>y<!>, y : Int = x) { // None of the references is resolved, no types checked\n    fun foo(<!UNUSED_PARAMETER!>bool<!>: Boolean, a: Int = <!TYPE_MISMATCH, UNINITIALIZED_PARAMETER!>b<!>, b: String = <!TYPE_MISMATCH!>a<!>) {}\n}\n\nval z = 3\n\nfun foo(x: Int = <!UNINITIALIZED_PARAMETER!>y<!>, y: Int = x, <!UNUSED_PARAMETER!>i<!> : Int = z): Int = x + y\n"
        },
        {
            "code": "open class NoC\nclass NoC1 : <!SUPERTYPE_NOT_INITIALIZED!>NoC<!>\n\nclass WithC0() : NoC()\nopen class WithC1() : <!SUPERTYPE_NOT_INITIALIZED!>NoC<!>\nclass NoC2 : <!SUPERTYPE_NOT_INITIALIZED!>WithC1<!>\nclass NoC3 : WithC1()\nclass WithC2() : <!SUPERTYPE_NOT_INITIALIZED!>WithC1<!>\n\nclass WithPC0() {\n}\n\nclass WithPC1(<!UNUSED_PARAMETER!>a<!> : Int) {\n}\n\n\nclass Foo() : <!FINAL_SUPERTYPE, SUPERTYPE_NOT_INITIALIZED!>WithPC0<!>, <!SYNTAX!>this<!>() {\n\n}\n\nclass WithCPI_Dup(<!UNUSED_PARAMETER!>x<!> : Int) {\n  <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var x : Int<!>\n}\n\nclass WithCPI(x : Int) {\n  val a = 1\n  val xy : Int = x\n}\n\nclass NoCPI {\n  val a = 1\n  var ab = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>1<!>\n    get() = 1\n    set(<!UNUSED_PARAMETER!>v<!>) {}\n}"
        },
        {
            "code": "class <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!>\nclass <!PACKAGE_OR_CLASSIFIER_REDECLARATION!>A<!> {\n    constructor()\n}\n\nclass B\nclass Outer {\n    class B {\n        constructor()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    val x: Int\n    var y: Int\n    val z: Int\n    val v = -1\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val uninitialized: Int<!>\n    val overinitialized: Int\n\n    constructor() {\n        x = 1\n        y = 2\n\n        <!VAL_REASSIGNMENT!>overinitialized<!> = 3\n        uninitialized = 4\n    }\n\n    constructor(a: Int): super() {\n        x = 5\n        y = 6\n    }\n\n    constructor(x: String): this() {\n        y = 7\n        <!VAL_REASSIGNMENT!>uninitialized<!> = 8\n    }\n\n    //anonymous\n    init {\n        z = 9\n        overinitialized = 10\n    }\n\n    // anonymous\n    init {\n        y = 12\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A(val w: Char) {\n    val x: Int\n    var y: Int\n    val z: Int\n    val v = -1\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val uninitialized: Int<!>\n    val overinitialized: Int\n\n    constructor(): this('a') {\n        y = 1\n\n        <!VAL_REASSIGNMENT!>overinitialized<!> = 2\n        <!VAL_REASSIGNMENT!>uninitialized<!> = 3\n    }\n\n    // anonymous\n    init {\n        x = 4\n        z = 5\n        overinitialized = 6\n    }\n\n    constructor(a: Int): this('b') {\n        y = 7\n    }\n\n    // anonymous\n    init {\n        y = 8\n    }\n}\n"
        },
        {
            "code": "class A {\n    val prop: Int = <!TYPE_MISMATCH!>\"\"<!>\n    constructor()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass X<T> {\n    constructor(t: T, i: Int): this(<!TYPE_MISMATCH!>i<!>, 1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    constructor(): super(<!TOO_MANY_ARGUMENTS!>1<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\nclass X<T>(val t: T) {\n    constructor(t: T, i: Int) : this(<!TYPE_MISMATCH!>i<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A<!CONFLICTING_OVERLOADS!>(x: String = \"\", y: String = \"\")<!> {\n    <!CONFLICTING_OVERLOADS!>constructor(x: String, y: String)<!>: <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>(x, y)\n    <!CONFLICTING_OVERLOADS!>constructor()<!>: <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>(\"\", \"\")\n    <!CONFLICTING_OVERLOADS!>constructor()<!>: <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>(\"\", \"\")\n}\n\nclass B {\n    <!CONFLICTING_OVERLOADS!>constructor(x: Int)<!>\n}\n\n<!CONFLICTING_OVERLOADS!>fun B(x: Int)<!> {}\n\nclass Outer {\n    class A<!CONFLICTING_OVERLOADS!>(x: String = \"\", y: String = \"\")<!> {\n        <!CONFLICTING_OVERLOADS!>constructor(x: String, y: String)<!>: <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>(x, y)\n        <!CONFLICTING_OVERLOADS!>constructor()<!>: <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>(\"\", \"\")\n        <!CONFLICTING_OVERLOADS!>constructor()<!>: <!OVERLOAD_RESOLUTION_AMBIGUITY!>this<!>(\"\", \"\")\n    }\n\n    class B {\n        <!CONFLICTING_OVERLOADS!>constructor(x: Int)<!>\n    }\n\n    <!CONFLICTING_OVERLOADS!>fun B(x: Int)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B<X, Y : X> {\n    constructor(x: X, y: Y)\n    constructor(x: X, s: String)\n    constructor(y: Y, i: Int) : this(y, \"\")\n}\n\nclass A<T1, T2 : T1> : B<T1, T2> {\n    constructor(x: T1, y: T2): super(x, y)\n    constructor(x: T2, y: T2, z: String): super(x, y)\n\n    constructor(x: T2, z: String, z1: String): super(x, \"\")\n    constructor(x: T2, z: String, z1: String, z2: String): super(x, 1)\n    constructor(x: T1, z: String, z1: String, z2: String, z3: String): super(x, \"\")\n    constructor(x: T1, z: String, z1: String, z2: String, z3: String, z4: String): <!NONE_APPLICABLE!>super<!>(x, 1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(open val parentProp: Int)\nval global: Int = 1\nclass A : B {\n    val myProp: Int = 1\n    override val parentProp = 1\n\n    constructor(x: Int, y: Int = global): super(x + y + global) {\n        foo(x, y, myProp)\n        x + y + myProp + parentProp + super.parentProp\n    }\n    constructor(x: Double, y: Int): this(x.toInt() + y, x.toInt() * y) {\n        foo(x.toInt(), y, myProp)\n        x + y + myProp + parentProp + super.parentProp\n    }\n    constructor(x: String, y: Int): super(<!TYPE_MISMATCH!>x<!>) {\n        foo(<!TYPE_MISMATCH!>x<!>, y, myProp)\n        x + y + myProp + parentProp + super.parentProp\n    }\n    constructor(x: B, y: Int = <!UNRESOLVED_REFERENCE!>global2<!>): <!NONE_APPLICABLE!>this<!>(\"\", x) {\n        x.parentProp + y + myProp + parentProp + super.parentProp\n    }\n\n    fun foo(x: Int, y: Int, z: Int) = x\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    constructor(\n        <!VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER!>val<!> x: Int, y: Int,\n        <!VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER!>var<!> z: Int,\n        <!WRONG_MODIFIER_TARGET!>public<!> a: Int)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    constructor(x: Int)\n}\n\nval x = A(<!NO_VALUE_FOR_PARAMETER!>)<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\ndata class A1(val x: String) {\n    constructor(): this(\"\")\n}\n\ndata class A2(val y: String, val z: Int) {\n    constructor(x: String): this(x, 0)\n}\n\ndata class <!DATA_CLASS_WITHOUT_PARAMETERS, PRIMARY_CONSTRUCTOR_REQUIRED_FOR_DATA_CLASS!>A3<!> {\n    constructor()\n}\n\ndata class A4 internal constructor<!DATA_CLASS_WITHOUT_PARAMETERS!>()<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    companion object {\n        fun foo(): Int = 1\n        val prop = 2\n        val C = 3\n    }\n    object B {\n        fun bar(): Int = 4\n        val prop = 5\n    }\n    object C {\n    }\n\n    constructor(x: Int)\n    constructor() : this(foo() + prop + B.bar() + B.prop <!NONE_APPLICABLE!>+<!> C)\n}\n"
        },
        {
            "code": "interface A {\n    <!CONSTRUCTOR_IN_INTERFACE!>constructor()<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A1 {\n    constructor(): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>()\n}\n\nclass A2(x: Byte) {\n    constructor(x1: Int): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1, 1)\n    constructor(x1: Int, x2: Int): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1, x2, 2)\n    constructor(x1: Int, x2: Int, x3: Int): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1)\n\n    // delegating to previously declared cycle\n    constructor(x1: Double): this(1)\n\n\n    // delegating to cycle declared after\n    constructor(x1: String): this(1L)\n\n    constructor(x1: Long): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1, 1L)\n    constructor(x1: Long, x2: Long): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1, x2, 2L)\n    constructor(x1: Long, x2: Long, x3: Long): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1)\n\n    // no cycle, just call to primary constuctor\n    constructor(x1: Double, x2: Double): this(x1, x2, 1.0)\n    constructor(x1: Double, x2: Double, x3: Double): this(x1, x2, x3, 1.0)\n    constructor(x1: Double, x2: Double, x3: Double, x4: Double): this(1.toByte())\n\n    constructor(): this(\"x\", \"y\")\n\n    constructor(x1: String, x2: String): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1, x2, \"\")\n    constructor(x1: String, x2: String, x3: String): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x1, x2)\n}\n\nopen class B(x: Byte)\nclass A : B {\n    // no cycle, just call to super constuctor\n    constructor(x1: Double, x2: Double): this(x1, x2, 1.0)\n    constructor(x1: Double, x2: Double, x3: Double): this(x1, x2, x3, 1.0)\n    constructor(x1: Double, x2: Double, x3: Double, x4: Double): super(1.toByte())\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\nclass A {\n    constructor(x: Int) {}\n    constructor(x: String) {}\n    constructor(): <!NONE_APPLICABLE!>this<!>('a') {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNREACHABLE_CODE\nopen class B<T>(x: T, y: T) {\n    constructor(x: T): this(x, x)\n    constructor(): this(null!!, null!!)\n}\n\nclass A0 : B<String?> {\n    constructor()\n    constructor(x: String): super(x)\n    constructor(x: String, y: String): super(x, y)\n}\n\nclass A1<R> : B<R> {\n    constructor()\n    constructor(x: R): super(x)\n    constructor(x: R, y: R): super(x, y)\n}\n\nclass A2<R> {\n    constructor(t: R, i: Int) : this(<!TYPE_MISMATCH!>i<!>, 1)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// NI_EXPECTED_FILE\nclass A(x: Int) {\n    constructor(x: Double): this(1)\n    constructor(x: String): this(1)\n}\nval x1: A = A(1)\nval x2: A = A(1.0)\nval x3: A = A(\"abc\")\n\nclass B<R> {\n    constructor(x: String)\n    constructor(x: R)\n}\n\nval y1: B<Int> = B(1)\nval y2: B<Int> = B(\"\")\nval y3: B<Int> = B<Int>(1)\nval y4: B<Int> = B<Int>(\"\")\n\nval y5: B<String> = B<String>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\nval y6: B<String> = B<String>(\"\")\nval y7: B<String> = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>B(1)<!>\nval y8: B<String> = B(\"\")\n\nval y9 = B(1)\nval y10 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>B<!>(\"\")\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A(val w: Int) {\n    val x: Int\n    val useUnitialized = <!UNINITIALIZED_VARIABLE!>x<!> +\n                         <!UNINITIALIZED_VARIABLE!>y<!> +\n                         <!UNINITIALIZED_VARIABLE!>v<!>\n    var y: Int\n    val v = -1\n    val useInitialized = useUnitialized + v + w\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val uninitialized: Int<!>\n\n    constructor(): this(1) {\n        x + y + v + uninitialized + w\n    }\n\n    // anonymous\n    init {\n        <!UNINITIALIZED_VARIABLE!>x<!> + <!UNINITIALIZED_VARIABLE!>y<!> + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!> + w\n        x = 1\n        x + <!UNINITIALIZED_VARIABLE!>y<!> + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!> + w\n    }\n\n    // anonymous\n    init {\n        x + <!UNINITIALIZED_VARIABLE!>y<!> + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!> + w\n        y = 7\n        x + y + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!> + w\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class A(p1: String, p2: String, p3: String, p4: String, p5: String)\n\nclass B : A {\n    <!EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor(s: String)<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    val x: Int\n    val useUnitialized = <!UNINITIALIZED_VARIABLE, UNINITIALIZED_VARIABLE!>x<!> + // reported on each secondary constructor\n                         <!UNINITIALIZED_VARIABLE, UNINITIALIZED_VARIABLE!>y<!> +\n                         <!UNINITIALIZED_VARIABLE, UNINITIALIZED_VARIABLE!>v<!>\n    var y: Int\n    val v = -1\n\n    val useInitialized = useUnitialized + v\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val uninitialized: Int<!>\n\n    constructor() {\n        x = 1\n        y = 2\n\n        x + y + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!>\n\n        uninitialized = 3\n\n        x + y + v + uninitialized\n    }\n\n    constructor(a: Int): super() {\n        <!UNINITIALIZED_VARIABLE!>x<!> + y + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!>\n        x = 4\n        y = 5\n\n        x + y + v + <!UNINITIALIZED_VARIABLE!>uninitialized<!>\n    }\n\n    constructor(x: String): this() {\n        x + y + v + uninitialized\n    }\n\n    //anonymous\n    init {\n        <!UNINITIALIZED_VARIABLE, UNINITIALIZED_VARIABLE!>y<!>\n    }\n\n    // anonymous\n    init {\n        y = 9\n    }\n}\n"
        },
        {
            "code": "class A {\n    open inner class Inner\n\n    class Nested : Inner {\n        <!INACCESSIBLE_OUTER_CLASS_EXPRESSION!>constructor()<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    constructor(x: Any, y: Any, z: Any)\n    constructor(x: String?, y: String?): this(x!!, <!DEBUG_INFO_SMARTCAST!>x<!>.length.toString() + y!!, \"\") {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length + <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    }\n}\n"
        },
        {
            "code": "class X<T>(val t: T) {\n    constructor(t: String): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(t)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(x: Int) {\n    open fun foo() = 1\n}\nclass A : B {\n    override fun foo() = 2\n    constructor(x: Int, y: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super<!>.foo()) :\n        super(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super<!>.foo())\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun A.foobar() = 3\n\nclass A {\n    fun foo() = 1\n    constructor( x: Any = object {\n        fun bar() = <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@A<!>.foo() +\n                    <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foobar<!>()\n    })\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(x: A) = 1\n\nclass A {\n    constructor(x: Int)\n    constructor(x: Int, y: Int, z: Int = x + foo(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>) + foo(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@A<!>)) :\n        this(x + foo(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>) + foo(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@A<!>))\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class Base(p: Any?) {\n    fun foo1() {}\n}\n\nfun Base.foo() {\n    class B : Base {\n        constructor() : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo1<!>())\n        constructor(x: Int) : super(this@foo.foo1())\n        constructor(x: Int, y: Int) : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@B<!>.foo1())\n    }\n}\n"
        },
        {
            "code": "open class C(val x: Int)\n\nclass D : C {\n    constructor() : super(\n            {\n                val s = \"\"\n                <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>s<!>()\n                <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>\"\"()<!>\n                42\n            }())\n\n    operator fun String.invoke() { }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun A.foobar() = 3\n\nclass A {\n    fun foo() = 1\n    constructor(x: Any?)\n    constructor() : this(object {\n        fun bar() = <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@A<!>.foo() +\n                    <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foobar<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super@A<!>.hashCode()\n    })\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(x: Int)\nclass A : B {\n    val prop = 1\n    constructor(x: Int, y: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL, UNINITIALIZED_VARIABLE!>prop<!> + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.<!UNINITIALIZED_VARIABLE!>prop<!>) :\n        super(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL, UNINITIALIZED_VARIABLE!>prop<!> + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.<!UNINITIALIZED_VARIABLE!>prop<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class Base<T>(p: Any?) {\n    fun foo1(t: T) {}\n}\n\nclass D: Base<Int>(\"\") {\n    inner class B : Base<String> {\n        constructor() : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo1<!>(\"\"))\n        constructor(x: Int) : super(foo1(1))\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(val prop: Int)\nclass A : B {\n    constructor(x: Int, y: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>prop<!> + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.prop + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super<!>.prop) :\n        super(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>prop<!> + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.prop + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super<!>.prop)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    val prop = 1\n    constructor(x: Int)\n    constructor(x: Int, y: Int, z: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>prop<!> + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.prop) :\n        this(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>prop<!> + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.prop)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    fun foo() = 1\n    constructor(x: Int)\n    constructor(x: Int, y: Int, z: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo()) :\n        this(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo())\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class Base<T>(p: Any?) {\n    fun foo1(t: T) {}\n}\n\nfun Base<Int>.foo() {\n    class B : Base<String> {\n        constructor() : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo1<!>(\"\"))\n        constructor(x: Int) : super(foo1(1))\n        constructor(x: Int, y: Int) : super(this@foo.foo1(12))\n        constructor(x: Int, y: Int, z: Int) : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@B<!>.foo1(\"\"))\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(x: Int) {\n    fun foo() = 1\n}\nclass A : B {\n    constructor(x: Int, y: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super<!>.foo()) :\n        super(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo() + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>super<!>.foo())\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class Base<T>(p: Any?) {\n    fun foo1(t: T) {}\n}\n\nclass D: Base<Int>(1) {\n    inner class B : Base<Int> {\n        constructor() : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo1<!>(1))\n        constructor(x: Int) : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@B<!>.foo1(1))\n        constructor(x: Int, y: Int) : super(this@D.foo1(1))\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun A.foobar() = 3\n\nclass A {\n    fun foo() = 1\n    constructor(x: () -> Int)\n    constructor() : this(\n            {\n                <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo<!>() +\n                <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foo() +\n                <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@A<!>.foo() +\n                <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foobar<!>()\n            })\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun A.foobar() = 1\nval A.prop: Int get() = 2\n\nclass A {\n    constructor(x: Int)\n    constructor() : this(\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foobar<!>() +\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.foobar() +\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>prop<!> +\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.prop +\n            <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this@A<!>.prop\n    )\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nfun foo(x: Outer) = 1\nclass Outer {\n    inner class Inner {\n        val prop = 1\n    }\n\n    constructor(x: Int)\n    constructor(x: Int, y: Int, z: Int = x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>Inner<!>().prop + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.Inner().prop) :\n        this(x + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>Inner<!>().prop + <!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>this<!>.Inner().prop)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\nopen class B<R1, R2>(x: R1, y: R2)\n\nclass A0<T1, T2> {\n    constructor(x: T1, y: T2): <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(x, y)\n\n    constructor(x: T1, y: T2, z: T2): this(x, 1) // ok, delegates to constructor(x: T1, y: Int)\n\n    constructor(x: T1, y: Int): this(x, <!TYPE_MISMATCH!>\"\"<!>)\n    constructor(x: T1): this(x, 1)\n    constructor(x: T1, y: T2, z: String): this(<!TYPE_MISMATCH!>y<!>, <!TYPE_MISMATCH!>x<!>)\n}\n\nclass A1<T1, T2> : B<T1, T2> {\n    constructor(x: T1, y: T2): super(x, y)\n    constructor(x: T1, y: Int): super(x, <!TYPE_MISMATCH(\"T2\", \"Int\")!>y<!>)\n    constructor(x: T1, y: T1, z: T1): super(x, <!TYPE_MISMATCH(\"T2\", \"T1\")!>y<!>)\n}\n\nclass A2<T1, T2> : B<T1, Int> {\n    constructor(x: T1, y: T2): super(x, <!TYPE_MISMATCH(\"Int\", \"T2\")!>y<!>)\n    constructor(x: T1, y: Int): super(x, y)\n    constructor(x: T1, y: T1, z: T1): super(x, <!TYPE_MISMATCH(\"Int\", \"T1\")!>y<!>)\n    constructor(x: T1, y: T2, z: String): super(<!TYPE_MISMATCH(\"T1\", \"T2\")!>y<!>, 1)\n}\n\n"
        },
        {
            "code": "class A0 {\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val x: Int<!>\n    constructor() {\n        if (1 == 1) {\n            return\n        }\n        x = 1\n    }\n    constructor(arg: Int) {\n        x = arg\n    }\n}\n\nclass A1 {\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val x: Int<!>\n    constructor() {\n        if (1 == 1) {\n            return\n        } else null!!\n        <!UNREACHABLE_CODE!>x = 1<!>\n    }\n}\n\nclass A2 {\n    val x: Int\n    constructor() {\n        if (1 == 1) {\n            x = 1\n            return\n        }\n        else {\n            x = 2\n        }\n    }\n    constructor(arg: Int) {\n        x = arg\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A {\n    init {\n        <!RETURN_NOT_ALLOWED!>return<!>\n        <!UNREACHABLE_CODE!><!RETURN_NOT_ALLOWED!>return<!> 1<!>\n    }\n    constructor() <!UNREACHABLE_CODE!>{\n        if (1 == 1) {\n            return\n            return <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>\n        }\n        return\n        return <!TYPE_MISMATCH!>foo()<!>\n    }<!>\n\n    fun foo(): Int = 1\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(x: Int)\nclass A : <!SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR!>B(1)<!> {\n    constructor(): super(1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A(x: Int) {\n    <!PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED!>constructor()<!>\n}\nopen class B(x: Int)\nclass C(x: Int) : B(x) {\n    constructor(): <!PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED!>super<!>(1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B(x: Double) {\n    constructor(x: Int): this(1.0)\n    constructor(x: String): this(1.0)\n}\ninterface C\nclass A : B, C {\n    constructor(): <!NONE_APPLICABLE!>super<!>(' ')\n    <!EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor(x: Int)<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nannotation class Ann1\nannotation class Ann2(val x: Int)\n\nclass A {\n    @Ann1\n    constructor()\n    @<!NO_VALUE_FOR_PARAMETER!>Ann2<!>\n    constructor(x1: Int)\n    @Ann2(2)\n    constructor(x1: Int, x2: Int)\n}"
        },
        {
            "code": "interface A\nclass AImpl : A\n\nclass B : <!UNSUPPORTED!>A by AImpl()<!> {\n    constructor()\n}\n"
        },
        {
            "code": "object A {\n    <!CONSTRUCTOR_IN_OBJECT!>constructor()<!>\n    init {}\n}\n\nenum class B {\n    X() {\n        <!CONSTRUCTOR_IN_OBJECT!>constructor()<!>\n    }\n}\n\nclass C {\n    companion object {\n        <!CONSTRUCTOR_IN_OBJECT!>constructor()<!>\n    }\n}\n\nval anonObject = object {\n    <!CONSTRUCTOR_IN_OBJECT!>constructor()<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class A(p1: String)\n\nclass B() : A(\"\") {\n    <!PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED!>constructor(s: String)<!> {\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nenum class A {\n    W(1), X(1, 2), Y(3.0), Z(\"\"), E();\n\n    constructor()\n    constructor(x: Int)\n    constructor(x: Int, y: Int): this(x+y)\n    constructor(x: Double): this(x.toInt(), 1)\n    constructor(x: String): <!DELEGATION_SUPER_CALL_IN_ENUM_CONSTRUCTOR!>super<!>(x, 1)\n}\n\nenum class B(x: Int) {\n    W(1), X(1, 2), Y(3.0), Z(\"\");\n\n    constructor(x: Int, y: Int): this(x+y)\n    constructor(x: Double): this(x.toInt(), 1)\n    constructor(x: String): <!DELEGATION_SUPER_CALL_IN_ENUM_CONSTRUCTOR!>super<!>(x, 1)\n}\n\nenum class C {\n    EMPTY(); // may be we should avoid explicit call here\n    constructor()\n}\n\nenum class D(val prop: Int) {\n    X(123) {\n        override fun f() = 1\n    },\n    Y() {\n        override fun f() = prop\n    },\n    Z(\"abc\") {\n        override fun f() = prop\n    };\n\n    constructor(): this(1)\n    constructor(x: String): this(x.length)\n\n    abstract fun f(): Int\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class B0(x: Int)\n\nclass A0 : B0 {\n    <!EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor()<!>\n    constructor(x: Int) : super(<!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n\n// --------------------------\n\nopen class B1 {\n    constructor(x: Int = 1)\n    constructor()\n}\n\nclass A1 : B1 {\n    constructor()\n    constructor(x: Int) : super()\n}\n\n// --------------------------\n\nopen class B2 {\n    constructor(x: Int)\n    constructor(x: String)\n}\n\nclass A2 : B2 {\n    <!EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor()<!>\n    constructor(x: Int) : <!NONE_APPLICABLE!>super<!>()\n}\n\n// --------------------------\n\nopen class B3 {\n    private constructor()\n}\n\nclass A3 : B3 {\n    <!EXPLICIT_DELEGATION_CALL_REQUIRED!>constructor()<!>\n    constructor(x: Int) : <!INVISIBLE_MEMBER!>super<!>()\n}"
        },
        {
            "code": "open class A : <!CYCLIC_INHERITANCE_HIERARCHY!>B<!>()\nopen class B : <!CYCLIC_INHERITANCE_HIERARCHY!>A<!>()\n\nfun <T> select(vararg xs: T): T = xs[0]\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>x<!> = select(A(), B(), \"foo\")\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nopen class Container {\n    open class Base {\n        open fun m() {}\n    }\n\n    // note that Base() supertype will be resolved in scope that was created on recursion\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : <!UNRESOLVED_REFERENCE!>Base<!>()\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract() {\n        <!NOTHING_TO_OVERRIDE!>override<!> fun m() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nabstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base() {\n    open class Data\n}\n\npublic class C {\n\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!> ()\n\n    class Foo : <!DEPRECATED_ACCESS_BY_SHORT_NAME!>Data<!>()\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nobject WithFunctionInBase {\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\n    class Data\n\n    public class C {\n        // error-scope\n        val data: <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEPRECATED_ACCESS_BY_SHORT_NAME!>Data<!> = Data()\n\n        open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() {\n            // error-scope\n            fun foo(): <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEPRECATED_ACCESS_BY_SHORT_NAME!>Int<!> = 42\n        }\n\n        companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n    }\n}\n\nobject WithPropertyInBase {\n    // This case is very similar to previous one, but there are subtle differences from POV of implementation\n\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\n    class Data\n\n    public class C {\n\n        open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() {\n            // error-scope\n            val foo: <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEPRECATED_ACCESS_BY_SHORT_NAME!>Int<!> = 42\n        }\n\n        // error-scope\n        val data: <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEPRECATED_ACCESS_BY_SHORT_NAME!>Data<!> = Data()\n\n        companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n    }\n}\n\nobject WithPropertyInBaseDifferentOrder {\n    // This case is very similar to previous one, but there are subtle differences from POV of implementation\n    // Note how position of property in file affected order of resolve, and, consequently, its results and\n    // diagnostics.\n\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\n    class Data\n\n    public class C {\n        // Now it is successfully resolved (vs. ErrorType like in the previous case)\n        val data: Data = Data()\n\n        open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() {\n            // Now it is unresolved (vs. ErrorType like in the previous case)\n            val foo: <!UNRESOLVED_REFERENCE!>Int<!> = 42\n\n        }\n\n        companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nopen class Container {\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!> {\n        open fun m() {}\n    }\n\n    // note that Base() supertype will be resolved in scope that was created on recursion\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : Base()\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract() {\n        override fun m() {}\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\ninterface SomeIrrelevantInterface\n\n// note that C.Base() supertype will be resolved in normal scope\nabstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\nclass Data\n\npublic class C {\n\n    val data: Data = Data()\n\n    // Note that any supertype of Base will be resolved in error-scope, even if it absolutely irrelevant\n    // to the types in cycle.\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() : SomeIrrelevantInterface\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nopen class Container {\n    // Note that here we also have errors and diagnostics, even though there are actually no loops.\n    // (this is case because we can't know if there are any loops without resolving, but resolving\n    // itself provokes loops)\n\n    interface <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!> {\n        open fun m() {}\n    }\n\n    interface <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : Base\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract {\n        override fun m() {}\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nobject WithFunctionInBase {\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\n    class Data\n\n    public class C {\n        val data: Data = Data()\n\n        open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() {\n            fun foo(): Int = 42\n        }\n\n        companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n    }\n}\n\nobject WithPropertyInBase {\n    // This case is very similar to previous one, but there are subtle differences from POV of implementation\n\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\n    class Data\n\n    public class C {\n\n        open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() {\n            val foo: Int = 42\n        }\n\n        val data: Data = Data()\n\n        companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n    }\n}\n\nobject WithPropertyInBaseDifferentOrder {\n    // This case is very similar to previous one, but there are subtle differences from POV of implementation\n    // Note how position of property in file affected order of resolve, and, consequently, its results and\n    // diagnostics.\n\n    abstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\n    class Data\n\n    public class C {\n        val data: Data = Data()\n\n        open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() {\n            val foo: Int = 42\n\n        }\n\n        companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\ninterface SomeIrrelevantInterface\n\n// note that C.Base() supertype will be resolved in normal scope\nabstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\nclass Data\n\npublic class C {\n\n    val data: Data = Data()\n\n    // Note that any supertype of Base will be resolved in error-scope, even if it absolutely irrelevant\n    // to the types in cycle.\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!>() : <!UNRESOLVED_REFERENCE!>SomeIrrelevantInterface<!>\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nopen class Container {\n    // Note that here we also have errors and diagnostics, even though there are actually no loops.\n    // (this is case because we can't know if there are any loops without resolving, but resolving\n    // itself provokes loops)\n\n    interface Base {\n        open fun m() {}\n    }\n\n    interface <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : <!UNRESOLVED_REFERENCE!>Base<!>\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract {\n        <!NOTHING_TO_OVERRIDE!>override<!> fun m() {}\n    }\n}"
        },
        {
            "code": "// see https://youtrack.jetbrains.com/issue/KT-21515\n\nabstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base() {\n    override abstract fun m()\n}\n\npublic class C {\n    class Data\n\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!> () {\n        open fun m() {}\n    }\n\n    // Note that Data is resolved successfully here because we don't step on error-scope\n    val data: Data = Data()\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract() {\n        override fun m() {}\n    }\n}"
        },
        {
            "code": "// see https://youtrack.jetbrains.com/issue/KT-21515\n\nabstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base()\n\nclass Data\n\nopen class C {\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!> {\n        open fun m() {}\n    }\n\n    val field = Data()\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract() {\n        override fun m() {}\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion\n// see https://youtrack.jetbrains.com/issue/KT-21515\n\nabstract class <!CYCLIC_SCOPES_WITH_COMPANION!>DerivedAbstract<!> : C.Base() {\n    open class Data\n}\n\npublic class C {\n\n    open class <!CYCLIC_SCOPES_WITH_COMPANION!>Base<!> ()\n\n    class Foo : <!UNRESOLVED_REFERENCE!>Data<!>()\n\n    companion <!CYCLIC_SCOPES_WITH_COMPANION!>object<!> : DerivedAbstract()\n}"
        },
        {
            "code": "interface A {\n    fun foo() {}\n}\ninterface B : A, <!CYCLIC_INHERITANCE_HIERARCHY!>E<!> {}\ninterface C : <!CYCLIC_INHERITANCE_HIERARCHY!>B<!> {}\ninterface D : <!CYCLIC_INHERITANCE_HIERARCHY!>B<!> {}\ninterface E : <!CYCLIC_INHERITANCE_HIERARCHY!>F<!> {}\ninterface F : <!CYCLIC_INHERITANCE_HIERARCHY!>D<!>, <!CYCLIC_INHERITANCE_HIERARCHY!>C<!> {}\ninterface G : F {}\ninterface H : F {}\n\nval a : A? = null\nval b : B? = null\nval c : C? = null\nval d : D? = null\nval e : E? = null\nval f : F? = null\nval g : G? = null\nval h : H? = null\n\nfun test() {\n    a?.foo()\n    b?.foo()\n    c?.<!UNRESOLVED_REFERENCE!>foo<!>()\n    d?.<!UNRESOLVED_REFERENCE!>foo<!>()\n    e?.<!UNRESOLVED_REFERENCE!>foo<!>()\n    f?.<!UNRESOLVED_REFERENCE!>foo<!>()\n    g?.<!UNRESOLVED_REFERENCE!>foo<!>()\n    h?.<!UNRESOLVED_REFERENCE!>foo<!>()\n}"
        },
        {
            "code": "// FILE: K.kt\n\nclass K : <!CYCLIC_INHERITANCE_HIERARCHY!>J<!>() {\n    fun bar() {}\n}\n"
        },
        {
            "code": "open class E : <!CYCLIC_INHERITANCE_HIERARCHY!>E.EE<!>() {\n    open class EE\n}\n"
        },
        {
            "code": "// FILE: ExceptionTracker.kt\n\ninterface ExceptionTracker : <!CYCLIC_INHERITANCE_HIERARCHY!>LockBasedStorageManager.ExceptionHandlingStrategy<!> {\n}\n\n// FILE: StorageManager.kt\n\ninterface StorageManager : <!CYCLIC_INHERITANCE_HIERARCHY!>ExceptionTracker<!> {\n    fun foo()\n}\n\n"
        },
        {
            "code": "// FILE: I.kt\n\nopen class I : <!CYCLIC_INHERITANCE_HIERARCHY!>K<!>() {\n    fun foo() {}\n}\n\n// FILE: K.kt\n\nopen class K : <!CYCLIC_INHERITANCE_HIERARCHY!>J<!>() {\n    fun baz() {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-303 Stack overflow on a cyclic class hierarchy\n\nopen class Foo() : <!CYCLIC_INHERITANCE_HIERARCHY!>Bar<!>() {\n  val a : Int = 1\n}\n\nopen class Bar() : <!CYCLIC_INHERITANCE_HIERARCHY!>Foo<!>() {\n\n}\n\nval x : Int = <!TYPE_MISMATCH!>Foo()<!>\n"
        },
        {
            "code": "// As in KT-18514\nobject A : <!CYCLIC_INHERITANCE_HIERARCHY!>A.I<!> {\n    interface I\n}\n\n// Similar to 'classIndirectlyInheritsNested.kt'\nobject D : <!CYCLIC_INHERITANCE_HIERARCHY!>E<!>() {\n    open class NestedD\n}\n\nopen class E : <!CYCLIC_INHERITANCE_HIERARCHY!>D.NestedD<!>()\n\n\n\n// Similar to 'twoClassesWithNestedCycle.kt'\nobject G : <!CYCLIC_INHERITANCE_HIERARCHY!>H.NestedH<!>() {\n    open class NestedG\n}\nobject H : <!CYCLIC_INHERITANCE_HIERARCHY!>G.NestedG<!>() {\n    open class NestedH\n}\n\n"
        },
        {
            "code": "open class A : <!CYCLIC_INHERITANCE_HIERARCHY!>B.BB<!>() {\n    open class AA\n}\nopen class B : <!CYCLIC_INHERITANCE_HIERARCHY!>A.AA<!>() {\n    open class BB\n}\n"
        },
        {
            "code": "open class A : <!CYCLIC_INHERITANCE_HIERARCHY!>B<!>()\nopen class B : <!CYCLIC_INHERITANCE_HIERARCHY!>A<!>()\n\nfun <T> select(vararg xs: T): T = xs[0]\n\nfun foo() {\n    select(A(), B())\n}"
        },
        {
            "code": "open class C : <!CYCLIC_INHERITANCE_HIERARCHY!>D<!>() {\n    open class CC\n}\nopen class D : <!CYCLIC_INHERITANCE_HIERARCHY!>C.CC<!>()\n"
        },
        {
            "code": "// FILE: B.kt\n\ninterface B : <!CYCLIC_INHERITANCE_HIERARCHY!>A<!> {\n    fun bar()\n}\n\n"
        },
        {
            "code": "var x : Int = 1 + <!UNINITIALIZED_VARIABLE!>x<!>\n   get() : Int = 1\n   set(value : <!WRONG_SETTER_PARAMETER_TYPE!>Long<!>) {\n      field = value.toInt()\n      field = <!TYPE_MISMATCH!>1.toLong()<!>\n    }\n\n val xx : Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>1 + x<!>\n   get() : Int = 1\n   <!VAL_WITH_SETTER!>set(<!UNUSED_PARAMETER!>value<!> : <!WRONG_SETTER_PARAMETER_TYPE!>Long<!>) {}<!>\n\n  val p : Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>1<!>\n    get() = 1\n\nclass Test() {\n    var a : Int = 111\n    var b : Int = 222\n        get() = field\n        set(x) {a = x; field = x}\n\n   public val i = 1\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n// FILE: f.kt\npackage a\n    val foo = bar()\n\n    fun bar() = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>foo<!>\n\n// FILE: f.kt\npackage b\n    fun foo() = bar()\n\n    fun bar() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>foo<!>()<!>\n\n// FILE: f.kt\npackage c\n    fun bazz() = bar()\n\n    fun foo() = <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>bazz<!>()<!>\n\n    fun bar() = foo()\n\n// FILE: f.kt\n\n    package ok.a\n        val foo = bar()\n\n        fun bar() : Int = foo\n\n// FILE: f.kt\n    package ok.b\n        fun foo() : Int = bar()\n\n        fun bar() = foo()\n\n// FILE: f.kt\n    package ok.c\n        fun bazz() = bar()\n\n        fun foo() : Int = bazz()\n\n        fun bar() = foo()\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage m\n\nfun test(i: Int?) {\n    if (i != null) {\n        foo(<!REDUNDANT_LABEL_WARNING!>l1@<!> <!DEBUG_INFO_SMARTCAST!>i<!>)\n        foo((<!DEBUG_INFO_SMARTCAST!>i<!>))\n        foo(<!REDUNDANT_LABEL_WARNING!>l2@<!> (<!DEBUG_INFO_SMARTCAST!>i<!>))\n        foo((<!REDUNDANT_LABEL_WARNING!>l3@<!> <!DEBUG_INFO_SMARTCAST!>i<!>))\n    }\n\n    val a: Int = <!REDUNDANT_LABEL_WARNING!>l4@<!> <!TYPE_MISMATCH!>\"\"<!>\n    val b: Int = (<!TYPE_MISMATCH!>\"\"<!>)\n    val c: Int = checkSubtype<Int>(<!TYPE_MISMATCH!>\"\"<!>)\n    val d: Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>checkSubtype<Long>(<!TYPE_MISMATCH!>\"\"<!>)<!>\n\n\n    foo(<!REDUNDANT_LABEL_WARNING!>l4@<!> <!TYPE_MISMATCH!>\"\"<!>)\n    foo((<!TYPE_MISMATCH!>\"\"<!>))\n    foo(checkSubtype<Int>(<!TYPE_MISMATCH!>\"\"<!>))\n    foo(<!TYPE_MISMATCH!>checkSubtype<Long>(<!TYPE_MISMATCH!>\"\"<!>)<!>)\n    \n    use(a, b, c, d)\n}\n\nfun foo(i: Int) = i\n\nfun use(vararg a: Any?) = a\n"
        },
        {
            "code": "fun f(s : String?) : Boolean {\n    return <!REDUNDANT_LABEL_WARNING!>foo@<!>(s?.equals(\"a\"))!!\n}"
        },
        {
            "code": "fun test() {\n    (<!REDUNDANT_LABEL_WARNING!>d@<!> <!DECLARATION_IN_ILLEGAL_CONTEXT!>val <!UNUSED_VARIABLE!>bar<!> = 2<!>)\n}"
        },
        {
            "code": "//  !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER\n// TODO Uncomment all the examples when there will be no problems with light classes\n//package `foo.bar`\n\n// TODO: Uncomment after fixing KT-9416\n//import kotlin.Deprecated as `deprecate\\entity`\n\n//@`deprecate\\entity`(\"\") data class Pair(val x: Int, val y: Int)\n\n// Names should not contains characters: '.', ';', '[', ']', '/', '<', '>', ':', '\\\\'\n//class `class.name`\nclass <!INVALID_CHARACTERS!>`class;name`<!>\nclass <!INVALID_CHARACTERS!>`class[name`<!>\nclass <!INVALID_CHARACTERS!>`class]name`<!>\n//class `class/name`\nclass <!INVALID_CHARACTERS!>`class<name`<!>\nclass <!INVALID_CHARACTERS!>`class>name`<!>\nclass <!INVALID_CHARACTERS!>`class:name`<!>\nclass <!INVALID_CHARACTERS!>`class\\name`<!>\n\nclass ` ` {}\nclass `  `\n\n//val `val.X` = 10\nval <!INVALID_CHARACTERS!>`val;X`<!> = 10\nval <!INVALID_CHARACTERS!>`val[X`<!> = 10\nval <!INVALID_CHARACTERS!>`val]X`<!> = 10\n//val `val/X` = 10\nval <!INVALID_CHARACTERS!>`val<X`<!> = 10\nval <!INVALID_CHARACTERS!>`val>X`<!> = 10\nval <!INVALID_CHARACTERS!>`val:X`<!> = 10\nval <!INVALID_CHARACTERS!>`val\\X`<!> = 10\n\nval <!INVALID_CHARACTERS!>`;`<!> = 1\nval <!INVALID_CHARACTERS!>`[`<!> = 2\nval <!INVALID_CHARACTERS!>`]`<!> = 3\nval <!INVALID_CHARACTERS!>`<`<!> = 4\n\nval <!INVALID_CHARACTERS!>`>`<!> = 5\nval <!INVALID_CHARACTERS!>`:`<!> = 6\nval <!INVALID_CHARACTERS!>`\\`<!> = 7\nval <!INVALID_CHARACTERS!>`<>`<!> = 8\n\nval <!INVALID_CHARACTERS!>`[]`<!> = 9\nval <!INVALID_CHARACTERS!>`[;]`<!> = 10\n\n// TODO Uncomment when there will be no problems with light classes (Error: Invalid formal type parameter (must be a valid Java identifier))\n//class AWithTypeParameter<`T:K`> {}\n//fun <`T/K`> genericFun(x: `T/K`) {}\n\nclass B(val <!INVALID_CHARACTERS!>`a:b`<!>: Int, val <!INVALID_CHARACTERS!>`c:d`<!>: Int)\n\nval ff: (<!INVALID_CHARACTERS!>`x:X`<!>: Int) -> Unit = {}\nval fg: ((<!INVALID_CHARACTERS!>`x:X`<!>: Int) -> Unit) -> Unit = {}\nval fh: ((Int) -> ((<!INVALID_CHARACTERS!>`x:X`<!>: Int) -> Unit) -> Unit) = {{}}\n\nfun f(x: Int, g: (Int) -> Unit) = g(x)\n\ndata class Data(val x: Int,  val y: Int)\n\nclass A() {\n    init {\n        val <!INVALID_CHARACTERS!>`a:b`<!> = 10\n    }\n\n    fun g(<!INVALID_CHARACTERS!>`x:y`<!>: Int) {\n        val <!INVALID_CHARACTERS!>`s:`<!> = 30\n    }\n}\n\nfun <!INVALID_CHARACTERS!>`foo:bar`<!>(<!INVALID_CHARACTERS!>`\\arg`<!>: Int): Int {\n    val (<!INVALID_CHARACTERS!>`a:b`<!>, c) = Data(10, 20)\n    val <!INVALID_CHARACTERS!>`a\\b`<!> = 10\n\n    fun localFun() {}\n\n    for (<!INVALID_CHARACTERS!>`x/y`<!> in 0..10) {\n    }\n\n    f(10) {\n        <!INVALID_CHARACTERS!>`x:z`<!>: Int -> localFun()\n    }\n\n    f(20, fun(<!INVALID_CHARACTERS!>`x:z`<!>: Int): Unit {})\n\n    try {\n        val <!INVALID_CHARACTERS!>`a:`<!> = 10\n    }\n    catch (<!INVALID_CHARACTERS!>`e:a`<!>: Exception) {\n        val <!INVALID_CHARACTERS!>`b:`<!> = 20\n    }\n\n    return `\\arg`\n}"
        },
        {
            "code": "fun foo(x: Int): Any {\n    return <!NO_ELSE_IN_WHEN!>when<!> (x) {\n        2 -> 0\n    }\n}"
        },
        {
            "code": "// Base for KT-6227\nenum class X { A, B, C, D }\n\nfun foo(arg: X): String {\n    var res = \"XXX\"\n    <!NON_EXHAUSTIVE_WHEN!>when<!> (arg) {\n        X.A -> res = \"A\"\n        X.B -> res = \"B\"\n    }\n    return res\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun Int.foo() : Boolean = true\n\nfun foo() : Int {\n    val s = \"\"\n    val x = 1\n    when (x) {\n      is <!INCOMPATIBLE_TYPES!>String<!> -> <!UNUSED_EXPRESSION!>1<!>\n      <!USELESS_IS_CHECK!>!is Int<!> -> <!UNUSED_EXPRESSION!>1<!>\n      <!USELESS_IS_CHECK!>is Any<!USELESS_NULLABLE_CHECK!>?<!><!> -> <!UNUSED_EXPRESSION!>1<!>\n      <!USELESS_IS_CHECK!>is Any<!> -> <!UNUSED_EXPRESSION!>1<!>\n      <!INCOMPATIBLE_TYPES!>s<!> -> <!UNUSED_EXPRESSION!>1<!>\n      1 -> <!UNUSED_EXPRESSION!>1<!>\n      1 + <!UNRESOLVED_REFERENCE!>a<!> -> <!UNUSED_EXPRESSION!>1<!>\n      in 1..<!UNRESOLVED_REFERENCE!>a<!> -> <!UNUSED_EXPRESSION!>1<!>\n      !in 1..<!UNRESOLVED_REFERENCE!>a<!> -> <!UNUSED_EXPRESSION!>1<!>\n      else -> <!UNUSED_EXPRESSION!>1<!>\n    }\n\n    return 0\n}\n\nval _type_test : Int = foo() // this is needed to ensure the inferred return type of foo()\n\nfun test() {\n  val x = 1;\n  val s = \"\";\n\n  when (x) {\n    <!INCOMPATIBLE_TYPES!>s<!> -> <!UNUSED_EXPRESSION!>1<!>\n    <!DUPLICATE_LABEL_IN_WHEN, INCOMPATIBLE_TYPES!>\"\"<!> -> <!UNUSED_EXPRESSION!>1<!>\n    x -> <!UNUSED_EXPRESSION!>1<!>\n    1 -> <!UNUSED_EXPRESSION!>1<!>\n  }\n\n  val z = 1\n\n  when (z) {\n    <!ELSE_MISPLACED_IN_WHEN!>else<!> -> <!UNUSED_EXPRESSION!>1<!>\n    <!UNREACHABLE_CODE!>1 -> 2<!>\n  }\n\n  when (<!UNUSED_EXPRESSION!>z<!>) {\n    else -> <!UNUSED_EXPRESSION!>1<!>\n  }\n}"
        },
        {
            "code": "// See KT-6399: exhaustive whens on platform enums\n\n// FILE: K.kt\n\nfun foo(): Int {\n    // When is exhaustive (count a platform enum as a special case)\n    return when (<!WHEN_ENUM_CAN_BE_NULL_IN_JAVA!>J.create()<!>) {\n        J.A -> 1\n        J.B -> 2\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -DEBUG_INFO_SMARTCAST\n// NI_EXPECTED_FILE\n\ninterface Data\ninterface Item\nclass FlagData(val value: Boolean) : Data\nclass ListData<T : Item>(val list: List<T>) : Data\n\nfun <T> listOf(vararg items: T): List<T> = null!!\n\nfun test1(o: Any) = <!OI;TYPE_INFERENCE_FAILED_ON_SPECIAL_CONSTRUCT!>when<!> (o) {\n    is List<*> ->\n        ListData(listOf())\n    is Int -> when {\n        o < 0 ->\n            FlagData(true)\n        else ->\n            null\n    }\n    else ->\n        null\n}\n\nfun test1x(o: Any): Data? = when (o) {\n    is List<*> ->\n        ListData(listOf())\n    is Int -> when {\n        o < 0 ->\n            FlagData(true)\n        else ->\n            null\n    }\n    else ->\n        null\n}\n\nfun test2() =\n        <!OI;TYPE_INFERENCE_FAILED_ON_SPECIAL_CONSTRUCT!>if<!> (true)\n            ListData(listOf())\n        else\n            FlagData(true)\n\nfun test2x(): Data =\n        if (true) ListData(listOf()) else FlagData(true)\n\nfun test2y(): Any =\n        if (true) ListData(listOf()) else FlagData(true)\n\nfun test2z(): Any =\n        run { if (true) ListData(listOf()) else FlagData(true) }\n\n"
        },
        {
            "code": "fun foo(x: Int) {\n    val y: Unit = <!NO_ELSE_IN_WHEN!>when<!> (x) {\n        2 -> {}\n        3 -> {}\n    }\n    return y\n}"
        },
        {
            "code": "fun foo(x: Int): Any {\n    val v = <!NO_ELSE_IN_WHEN!>when<!> (x) {\n        2 -> 0\n    }\n    return v\n}"
        },
        {
            "code": "enum class Color { RED, GREEN, BLUE }\n\nfun foo(arr: Array<Color>): Color {\n    loop@ for (color in arr) {\n        <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (color) {\n            Color.RED -> return color\n            Color.GREEN -> break@loop\n            Color.BLUE -> if (arr.size == 1) return color else continue@loop\n        }<!>\n        // Unreachable\n        <!UNREACHABLE_CODE!>return Color.BLUE<!>\n    }\n    return Color.GREEN\n}"
        },
        {
            "code": "// KT-7857: when exhaustiveness does not take previous nullability checks into account\nfun foo(arg: Boolean?): Int {\n    if (arg != null) {\n        return when (<!DEBUG_INFO_SMARTCAST!>arg<!>) {\n            true -> 1\n            false -> 0\n            // else or null branch should not be required here!\n        }\n    } \n    else {\n        return -1\n    }\n}"
        },
        {
            "code": "enum class E { A, B }\n\nfun foo(e: E, something: Any?): Int {\n    if (something != null) return 0\n\n    return when (e) {\n        E.A -> 1\n        E.B -> 2\n        <!DEBUG_INFO_CONSTANT!>something<!> -> 3\n    }\n}\n"
        },
        {
            "code": "fun foo(a: Boolean, b: Boolean): Int {\n    var x: Int\n    if (a) {\n        x = 1\n    }\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (b) {\n        true -> x = 2\n        false -> x = 3\n    }<!>\n    return x\n}\n\nfun bar(a: Boolean, b: Boolean): Int {\n    var x: Int\n    if (a) {\n        x = 1\n    }\n    when (b) {\n        false -> x = 3\n    }\n    return <!UNINITIALIZED_VARIABLE!>x<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval test: Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (true) {\n    when (2) {\n        1 -> 1\n        else -> <!OI;NULL_FOR_NONNULL_TYPE!>null<!>\n    }\n}\nelse {\n    2\n}<!>"
        },
        {
            "code": "// KT-7857: when exhaustiveness does not take previous nullability checks into account\nenum class X { A, B }\nfun foo(arg: X?): Int {\n    if (arg != null) {\n        return when (<!DEBUG_INFO_SMARTCAST!>arg<!>) {\n            X.A -> 1\n            X.B -> 2\n            // else or null branch should not be required here!\n        }\n    } \n    else {\n        return 0\n    }\n}"
        },
        {
            "code": "// KT-7857: when exhaustiveness does not take previous nullability checks into account\nenum class X { A, B }\nfun foo(arg: X?): Int {\n    if (arg != null) {\n        return <!NO_ELSE_IN_WHEN!>when<!> (<!DEBUG_INFO_SMARTCAST!>arg<!>) {\n            X.B -> 2\n        }\n    } \n    else {\n        return 0\n    }\n}"
        },
        {
            "code": "// See KT-6399: exhaustive whens on platform enums\n\n// FILE: K.kt\n\nfun foo(): Int {\n    // When is not-exhaustive\n    return <!NO_ELSE_IN_WHEN!>when<!> (J.create()) {\n        J.A -> 1\n    }\n}"
        },
        {
            "code": "class A\n\nfun test(a: Any): String {\n    var q: String?\n\n    when (a) {\n        is A -> q = \"1\"\n        else -> q = \"2\"\n    }\n    // When is not exhaustive\n    return <!DEBUG_INFO_SMARTCAST!>q<!>\n}\n"
        },
        {
            "code": "fun foo(a: Boolean, b: Boolean): Int {\n    val x: Int\n    if (a) {\n        x = 1\n    }\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (b) {\n        true -> <!VAL_REASSIGNMENT!>x<!> = 2\n        false -> x = 3\n    }<!>\n    return x\n}\n\nfun bar(a: Boolean, b: Boolean): Int {\n    val x: Int\n    if (a) {\n        x = 1\n    }\n    when (b) {\n        false -> <!VAL_REASSIGNMENT!>x<!> = 3\n    }\n    return <!UNINITIALIZED_VARIABLE!>x<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun test1(): Int {\n    val x: String = <!NI;TYPE_MISMATCH!>if (true) {\n        when {\n            true -> <!OI;TYPE_MISMATCH!>Any()<!>\n            else -> <!OI;NULL_FOR_NONNULL_TYPE!>null<!>\n        }\n    } else \"\"<!>\n    return x.hashCode()\n}\n\nfun test2(): Int {\n    val x: String = <!NI;TYPE_MISMATCH!>when {\n                        true -> <!OI;TYPE_MISMATCH!>Any()<!>\n                        else -> null\n                    } ?: return 0<!>\n    return x.hashCode()\n}"
        },
        {
            "code": "enum class MyEnum {\n    A, B, C\n}\n\nfun foo(x: MyEnum): Int {\n    return when (x) {\n        is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>A<!><!> -> 1\n        is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>B<!><!> -> 2\n        is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>C<!><!> -> 3\n    }\n}"
        },
        {
            "code": "enum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n\nfun foo(dir: Direction): Int {\n    val res: Int\n    // See KT-6046: res is always initialized\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (dir) {\n        Direction.NORTH -> res = 1\n        Direction.SOUTH -> res = 2\n        Direction.WEST  -> res = 3\n        Direction.EAST  -> res = 4\n    }<!>\n    return res\n}"
        },
        {
            "code": "// See KT-5113\nenum class E {\n    A,\n    B\n}\n\nclass Outer(e: E) {\n    private val prop: Int\n    init {\n        <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when(e ) {\n            // When is exhaustive, property is always initialized\n            E.A -> prop = 1\n            E.B -> prop = 2\n        }<!>\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\nval <!OI;IMPLICIT_NOTHING_PROPERTY_TYPE!>test1<!> = when {\n    true -> { <!OI;TYPE_MISMATCH!>{ true }<!> }\n    else -> TODO()\n}\n\nval test1a: () -> Boolean = when {\n    true -> { { true } }\n    else -> TODO()\n}\n\nval <!OI;IMPLICIT_NOTHING_PROPERTY_TYPE!>test2<!> = when {\n    true -> { <!OI;TYPE_MISMATCH!>{ true }<!> }\n    else -> when {\n        true -> { <!OI;TYPE_MISMATCH!>{ true }<!> }\n        else -> TODO()\n    }\n}\n\nval test2a: () -> Boolean = when {\n    true -> { { true } }\n    else -> when {\n        true -> { <!OI;TYPE_MISMATCH!>{ true }<!> } // TODO\n        else -> TODO()\n    }\n}\n\nval <!OI;IMPLICIT_NOTHING_PROPERTY_TYPE!>test3<!> = when {\n    true -> { <!OI;TYPE_MISMATCH!>{ true }<!> }\n    true -> { <!OI;TYPE_MISMATCH!>{ true }<!> }\n    else -> TODO()\n}\n\nval test3a: () -> Boolean = when {\n    true -> { { true } }\n    true -> { { true } }\n    else -> TODO()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninfix fun Any.sealed(a: Any?) {}\n\nval x = 1 <!UNSUPPORTED!>sealed<!> when (1) {\n    1 -> 1\n    else -> 2\n}\n\nval x1 = 1 <!UNSUPPORTED!>sealed<!> /**/ when (1) {\n    1 -> 1\n    else -> 2\n}\n\nfun foo() {\n    <!UNRESOLVED_REFERENCE, UNSUPPORTED!>sealed<!><!SYNTAX!><!> when {\n        else -> {}\n    }\n\n    1 <!UNSUPPORTED!>sealed<!> when {\n        else -> {}\n    }\n\n    1 sealed (when {\n        else -> {}\n    })\n\n    <!UNUSED_EXPRESSION!>1<!>\n    <!UNRESOLVED_REFERENCE, UNSUPPORTED!>sealed<!><!SYNTAX!><!> when {\n        else -> {}\n    }\n\n    1 <!UNSUPPORTED!>sealed<!>\n    when {\n        else -> {}\n    }\n}"
        },
        {
            "code": "// KT-7857: when exhaustiveness does not take previous nullability checks into account\nenum class X { A, B }\nfun foo(arg: X?): Int {\n    if (arg == null) {\n        return 0\n    }\n    else {\n        return when (<!DEBUG_INFO_SMARTCAST!>arg<!>) {\n            X.A -> 1\n            X.B -> 2\n            // else or null branch should not be required here!\n        }\n    } \n}"
        },
        {
            "code": "enum class My { A, B }\n\nfun test(a: My): String {\n    val q: String?\n\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (a) {\n        My.A -> q = \"1\"\n        My.B -> q = \"2\"\n    }<!>\n    // When is exhaustive\n    return <!DEBUG_INFO_SMARTCAST!>q<!>\n}\n"
        },
        {
            "code": "// Base for KT-6227\nenum class X { A, B, C, D }\n\nfun foo(arg: X): String {\n    val res: String\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (arg) {\n        X.A -> res = \"A\"\n        X.B -> res = \"B\"\n        X.C -> res = \"C\"\n        X.D -> res = \"D\"\n    }<!>\n    return res\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A\n\nfun test(a: Any) {\n    var q: String? = null\n\n    when (a) {\n        is A -> q = \"1\"\n    }\n    // When is not exhaustive\n    return <!TYPE_MISMATCH!>q<!>\n}\n"
        },
        {
            "code": "// EA-68871: empty when condition\nenum class My { FIRST, SECOND }\nfun foo(arg: My): Int {\n    when (arg) {\n        My.FIRST -> return 0\n        <!SYNTAX!><!>-> return 4\n        else -> return -1\n    }\n}"
        },
        {
            "code": "fun foo(b: Boolean): Int {\n    val x: Int\n    val y: Int\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (b) {\n        true -> y = 1\n        false -> y = 0\n    }<!>\n    // x is initialized here\n    x = 3\n    return x + y\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n\nfun foo(): Any = 42\n\nfun test() {\n    when (val <!UNUSED_VARIABLE!>x<!> = foo()) {\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun foo(): Any = 42\n\nfun test(x: Any) {\n    // NB check that we still resolve 'y', even though current language version doesn' support variable declaration in when subject\n\n    val z1 = when (<!UNSUPPORTED_FEATURE!>val y = foo()<!>) {\n        42 -> \"Magic: $y, $x\"\n        else -> {\n            \"Not magic: $y, $x\"\n        }\n    }\n    val z2 = \"Anyway, it was $<!UNRESOLVED_REFERENCE!>y<!>\"\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// WITH_RUNTIME\n\nfun foo(): Any = 42\nfun String.bar(): Any = 42\n\n\nfun testSimpleValInWhenSubject() {\n    when (val y = foo()) {\n    }\n}\n\nfun testValWithoutInitializerWhenSubject() {\n    when (<!ILLEGAL_DECLARATION_IN_WHEN_SUBJECT!>val y: Any<!>) {\n        is String -> <!DEBUG_INFO_SMARTCAST, UNINITIALIZED_VARIABLE!>y<!>.length\n    }\n}\n\nfun testVarInWhenSubject() {\n    when (<!ILLEGAL_DECLARATION_IN_WHEN_SUBJECT!>var y = foo()<!>) {\n        is String -> <!DEBUG_INFO_SMARTCAST!>y<!>.length\n    }\n}\n\nfun testDelegatedValInWhenSubject() {\n    when (<!ILLEGAL_DECLARATION_IN_WHEN_SUBJECT!>val y by <!UNRESOLVED_REFERENCE!>lazy<!> { 42 }<!>) {\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -UNUSED_VALUE\n\nfun foo() {}\nfun <T> bar(x: T, y: T) {}\n\nfun test1() {\n    when (1) {\n        1 ->\n            when (val y = 2) {\n                2 -> foo()\n            }\n    }\n}\n\nfun test2() {\n    when (val x = 1) {\n        1 ->\n            when (val y = 2) {\n                2 -> foo()\n            }\n    }\n}\n\nfun test3() {\n    when (val x = 1) {\n        1 ->\n            when (val <!NAME_SHADOWING!>x<!> = 2) {\n                2 -> foo()\n            }\n    }\n}\n\nfun test4() {\n    when (val x = 1) {\n        1 ->\n            when (val y = 2) {\n                2 -> bar(x, y)\n            }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\nfun foo(): Any = 42\nfun useInt(i: Int) {}\n\nfun testShadowingParameter(y: Any) {\n    when (val <!NAME_SHADOWING!>y<!> = foo()) {\n        else -> {}\n    }\n}\n\nfun testShadowedInWhenBody(x: Any) {\n    when (val y = x) {\n        is String -> {\n            val <!NAME_SHADOWING!>y<!> = <!DEBUG_INFO_SMARTCAST!>y<!>.length\n            useInt(y)\n        }\n    }\n}\n\nfun testShadowinLocalVariable() {\n    val y = foo()\n    when (val <!NAME_SHADOWING!>y<!> = foo()) {\n        else -> {}\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun getBoolean() = true\n\nfun testSafeCaptureVarInInitializer() {\n    var x: Int? = 42\n    x!!\n    <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n\n    val s = when (val y = run { x = 42; 32 }) {\n        0 -> {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.inc() // TODO fix smart casts for captured variables\n            \"0\"\n        }\n        else -> \"!= 0\"\n    }\n\n    <!SMARTCAST_IMPOSSIBLE!>x<!>.inc() // TODO fix smart casts for captured variables\n}\n\n\nfun testUnsafeCaptureVarInInitializer() {\n    var x: Int? = 42\n    x!!\n    <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n\n    val s = when (val y = run { x = null; 32 }) {\n        0 -> {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.inc() // NB smart cast should be impossible\n            \"0\"\n        }\n        else -> \"!= 0\"\n    }\n\n    <!SMARTCAST_IMPOSSIBLE!>x<!>.inc() // NB smart cast should be impossible\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -UNUSED_VALUE\n\nfun foo(): Any = 42\n\nfun test1(x: Any) {\n    when (val y = foo()) {\n        is String -> <!VAL_REASSIGNMENT!>y<!> = \"\"\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !WITH_NEW_INFERENCE\n\nfun foo(s1: Int, s2: Int) = s1 + s2\n\nfun test1(x: String?) =\n    when (val y = x?.length) {\n        null -> 0\n        else -> foo(<!DEBUG_INFO_SMARTCAST!>x<!>.length, <!DEBUG_INFO_SMARTCAST!>y<!>)\n    }\n\nfun test2(x: String?) {\n    when (val y = run { x!! }) {\n        \"foo\" -> x<!UNSAFE_CALL!>.<!>length\n        \"bar\" -> y.length\n    }\n}\n\nfun test3(x: String?, y: String?) {\n    when (val z = x ?: y!!) {\n        \"foo\" -> x<!UNSAFE_CALL!>.<!>length\n        \"bar\" -> y<!UNSAFE_CALL!>.<!>length\n        \"baz\" -> z.length\n    }\n}\n\nfun <T> id(x: T): T = x\n\nfun test4(x: String?) {\n    when (val y = id(x!!)) {\n        \"foo\" -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        \"bar\" -> y.length\n    }\n}\n\nclass Inv<T>(val data: T)\n\nfun test5(x: Inv<out Any?>) {\n    when (val y = x.data) {\n        is String -> <!DEBUG_INFO_SMARTCAST!>y<!>.length // should be ok\n        null -> x.data.<!UNRESOLVED_REFERENCE!>length<!> // should be error\n    }\n}\n\nfun test6(x: Inv<out String?>) {\n    when (val <!UNUSED_VARIABLE!>y<!> = x.data) {\n        is String -> <!DEBUG_INFO_SMARTCAST!>x.data<!>.length // should be ok\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nsealed class Either\nclass Left : Either()\nclass Right : Either()\n\nfun testSmartcastToSealedInSubjectInitializer1(x: Any?) {\n    val y1 = when (val either = x as Either) {\n        is Left -> \"L\"\n        is Right -> \"R\"\n    }\n}\n\nfun testSmartcastToSealedInSubjectInitializer2(x: Any?) {\n    val y2 = <!NO_ELSE_IN_WHEN!>when<!> (val either: Any = x as Either) { // NB explicit type annotation\n        is Left -> \"L\"\n        is Right -> \"R\"\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n\nfun test(x: Any?) =\n        when (val y = x) {\n            is String -> \"String, length = ${<!DEBUG_INFO_SMARTCAST!>y<!>.length}\"\n            null -> \"Null\"\n            else -> \"Any, hashCode = ${<!DEBUG_INFO_SMARTCAST!>y<!>.hashCode()}\"\n        }\n"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\n\nfun testJumpOutInElvis(x: Int?) {\n    loop@ while (true) {\n        val y = when (val z = x ?: break@loop) {\n            0 -> \"0\"\n            else -> \"not 0\"\n        }\n\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n\n    x<!UNSAFE_CALL!>.<!>inc()\n}\n\nfun testJumpOutInElvisLikeIf(x: Int?) {\n    loop@ while (true) {\n        val y = when (val z = if (x == null) break@loop else <!DEBUG_INFO_SMARTCAST!>x<!>) {\n            0 -> \"0\"\n            else -> \"not 0\"\n        }\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n\n    x<!UNSAFE_CALL!>.<!>inc()\n}\n\n\nfun getBoolean() = true\n\nfun testJumpOutInIf(x: Int?) {\n    loop@ while (true) {\n        val y = when (val z = if (getBoolean()) { x!!; break@loop } else x) {\n            0 -> \"0\"\n            else -> \"not 0\"\n        }\n        x<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    x<!UNSAFE_CALL!>.<!>inc() // Actually, safe, but it's OK if it's error\n}"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nenum class E { FIRST, SECOND }\n\nfun testSmartcastToEnumInSubjectInitializer1(e: E?) {\n    val x1 = when (val ne = e!!) {\n        E.FIRST -> \"f\"\n        E.SECOND -> \"s\"\n    }\n}\n\nfun testSmartcastToEnumInSubjectInitializer2(e: E?) {\n    val x2 = <!NO_ELSE_IN_WHEN!>when<!> (val ne: Any = e!!) { // NB explicit type annotation\n        E.FIRST -> \"f\"\n        E.SECOND -> \"s\"\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +VariableDeclarationInWhenSubject\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\n\nfun testNoSubjectVariableName(x: Int?) {\n    val y = when (val<!SYNTAX!><!> = 42) {\n        0 -> \"0\"\n        else -> \"not 0\"\n    }\n}"
        },
        {
            "code": "enum class MyEnum {\n    A, B\n}\n\nfun foo(x: MyEnum?): Int {\n    val y: Int\n    // See KT-6046: y is always initialized\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (x) {\n        MyEnum.A -> y = 1\n        MyEnum.B -> y = 2\n        null -> y = 0\n    }<!>\n    return y\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nval test1: (String) -> Boolean =\n        when {\n            true -> {{ true }}\n            else -> {{ false }}\n        }\n\nval test2: (String) -> Boolean =\n        when {\n            true -> {{ true }}\n            else -> null!!\n        }\n\nval test3: (String) -> Boolean =\n        when {\n            true -> { <!UNUSED_ANONYMOUS_PARAMETER!>s<!> -> true }\n            else -> null!!\n        }\n\nval test4: (String) -> Boolean =\n        when {\n            true -> <!NI;TYPE_MISMATCH!>{ <!EXPECTED_PARAMETERS_NUMBER_MISMATCH!><!UNUSED_ANONYMOUS_PARAMETER!>s1<!>, <!CANNOT_INFER_PARAMETER_TYPE, UNUSED_ANONYMOUS_PARAMETER!>s2<!><!> -> true }<!>\n            else -> null!!\n        }\n\n"
        },
        {
            "code": "sealed class S\n\nobject First : S()\n\nclass Derived(val s: String) : S()\n\nobject Last : S()\n\nfun use(s: String) = s\n\nfun foo(s: S) {\n    <!NON_EXHAUSTIVE_WHEN_ON_SEALED_CLASS!>when<!> (s) {\n        First -> {}\n        is Derived -> use(<!DEBUG_INFO_SMARTCAST!>s<!>.s)\n    }\n}"
        },
        {
            "code": "enum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n\nfun foo(dir: Direction): Int {\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (dir) {\n        Direction.NORTH -> return 1\n        Direction.SOUTH -> return 2\n        Direction.WEST  -> return 3\n        Direction.EAST  -> return 4\n    }<!>\n    // See KT-1882: no return is needed at the end\n}"
        },
        {
            "code": "fun foo(x: Int) {\n    r {\n        when (x) {\n            2 -> <!UNUSED_EXPRESSION!>0<!>\n        }\n    }\n}\n\nfun r(f: () -> Unit) {\n    f()\n}"
        },
        {
            "code": "// KT-4434 Missed diagnostic about else branch in when\n\npackage test\n\nfun foo(): Int {\n    val a = \"a\"\n    return if (a.length > 0) {\n        <!NO_ELSE_IN_WHEN!>when<!> (a) {\n            \"a\" -> 1\n        }\n    }\n    else {\n        3\n    }\n}\n\nfun bar(): Int {\n    val a = \"a\"\n    if (a.length > 0) {\n        return <!NO_ELSE_IN_WHEN!>when<!> (a) {\n            \"a\" -> 1\n        }\n    }\n    else {\n        return 3\n    }\n}\n"
        },
        {
            "code": "enum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n\nfun foo(dir: Direction): Int {\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (dir) {\n        Direction.NORTH -> return 1\n        Direction.SOUTH -> throw AssertionError(\"!!!\")\n        Direction.WEST  -> return 3\n        Direction.EAST  -> return 4\n    }<!>\n    // Error: Unreachable code. Return is not required.\n    <!UNREACHABLE_CODE!>if (dir == Direction.SOUTH) return 2<!>\n}"
        },
        {
            "code": "package test\n\nconst val four = 4\n\nfun first(arg: Int) = when (arg) {\n    1 -> 2\n    2 -> 3\n    <!DUPLICATE_LABEL_IN_WHEN!>1<!> -> 4\n    4 -> 5\n    <!DUPLICATE_LABEL_IN_WHEN!>1<!> -> 6\n    <!DUPLICATE_LABEL_IN_WHEN!>2<!> -> 7\n    // Error should be here: see KT-11971\n    four -> 8\n    else -> 0\n}\n\nfun second(arg: String): Int {\n    when (arg) {\n        \"ABC\" -> return 0\n        \"DEF\" -> return 1\n        <!DUPLICATE_LABEL_IN_WHEN!>\"ABC\"<!> -> return -1\n        <!DUPLICATE_LABEL_IN_WHEN!>\"DEF\"<!> -> return -2\n    }\n    return 42\n}\n\nfun third(arg: Any?): Int {\n    when (arg) {\n        null -> return -1\n        is String -> return 0\n        is Double -> return 1\n        is <!DUPLICATE_LABEL_IN_WHEN!>Double<!> -> return 2\n        <!DUPLICATE_LABEL_IN_WHEN!>null<!> -> return 3\n        else -> return 5\n    }\n}\n\nenum class Color { RED, GREEN, BLUE }\n\nfun fourth(arg: Color) = when (arg) {\n    Color.RED -> \"RED\"\n    Color.GREEN -> \"GREEN\"\n    <!DUPLICATE_LABEL_IN_WHEN!>Color.RED<!> -> \"BLUE\"\n    Color.BLUE -> \"BLUE\"\n}\n\nfun fifth(arg: Any?) = when (arg) {\n    is Any -> \"Any\"\n    <!ELSE_MISPLACED_IN_WHEN!>else<!> -> \"\"\n    <!UNREACHABLE_CODE!>else -> null<!>\n}\n"
        },
        {
            "code": "// KT-2902 Check for null should be required when match nullable enum element\n\n// FILE: 1.kt\n\nenum class E { A, B }\n\nfun test(e: E?) = <!NO_ELSE_IN_WHEN!>when<!> (e) {\n    E.A -> 1\n    E.B -> 2\n}\n\nfun withNull(e: E?) = when (e) {\n    E.A -> 3\n    E.B -> 4\n    null -> null\n}\n\nfun nullableNothing(): Nothing? = null\nfun withNullableNothing(e: E?) = when (e) {\n    E.A -> 5\n    E.B -> 6\n    nullableNothing() -> null\n}\n\nfun platformType() = when (<!WHEN_ENUM_CAN_BE_NULL_IN_JAVA!>J.foo()<!>) {\n    E.A -> 7\n    E.B -> 8\n}\n\nfun platformTypeSmartCast(): Int {\n    val e = J.foo()\n    if (e == null) return -1\n    return when (<!DEBUG_INFO_SMARTCAST!>e<!>) {\n        E.A -> 1\n        E.B -> 2\n    }\n}\n\n\n"
        },
        {
            "code": "fun foo(x: Int) {\n    r {\n        <!NO_ELSE_IN_WHEN!>when<!> (x) {\n            2 -> 0\n        }\n    }\n}\n\nfun r(f: () -> Int) {\n    f()\n}"
        },
        {
            "code": "// KT-7857: when exhaustiveness does not take previous nullability checks into account\nenum class X { A, B }\nfun foo(arg: X?): Int {\n    if (arg == null) {\n        return 0\n    }\n    return when (<!DEBUG_INFO_SMARTCAST!>arg<!>) {\n        X.A -> 1\n        X.B -> 2\n        // else or null branch should not be required here!\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass A\n\nfun test(a: Any): String {\n    val q: String? = null\n\n    when (a) {\n        is A -> q!!\n    }\n    // When is not exhaustive\n    return <!TYPE_MISMATCH!>q<!>\n}\n"
        },
        {
            "code": "fun foo(s: Any): String {\n    val x = when (s) {\n        is String -> <!DEBUG_INFO_SMARTCAST!>s<!>\n        is Int -> \"$s\"\n        else -> return \"\"\n    }\n\n    val y: String = x // should be Ok\n    return y\n}\n\nfun bar(s: Any): String {\n    val x = when (s) {\n        is String -> s <!USELESS_CAST!>as String<!> // meaningless\n        is Int -> \"$s\"\n        else -> return \"\"\n    }\n\n    val y: String = x // no error\n    return y\n}"
        },
        {
            "code": "// EA-68871: empty when condition\nfun foo(arg: Int): Int {\n    when (arg) {\n        0 -> return 0\n        <!SYNTAX!><!>-> return 4\n        else -> return -1\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nsealed class A {\n    class B: A() {\n        class C: A()\n    }\n}\n\nclass D: A()\n\nfun test(a: A) {\n    val nonExhaustive = <!NO_ELSE_IN_WHEN!>when<!> (a) {\n        is A.B -> \"B\"\n        is A.B.C -> \"C\"\n    }\n\n    val exhaustive = when (a) {\n        is A.B -> \"B\"\n        is A.B.C -> \"C\"\n        is D -> \"D\"\n    }\n}"
        },
        {
            "code": "// See KT-6399: exhaustive whens on platform enums\n\n// FILE: K.kt\n\nfun foo(): Int {\n    <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when (<!WHEN_ENUM_CAN_BE_NULL_IN_JAVA!>J.create()<!>) {\n        J.A -> return 1\n        J.B -> return 2\n    }<!>\n}\n"
        },
        {
            "code": "enum class MyEnum {\n    A, B, C\n}\n\nfun foo(x: MyEnum): Int {\n    return when (x) {\n        MyEnum.A -> 1\n        is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>B<!><!> -> 2\n        is <!IS_ENUM_ENTRY!>MyEnum.<!ENUM_ENTRY_AS_TYPE!>C<!><!> -> 3\n    }\n}"
        },
        {
            "code": "// FILE: test.kt\n\nsealed class X {\n    class A : X()\n    class B : X()\n}\n\nfun foo(x: X) = when (x) {\n    is X.A -> {}\n    is X.B -> {}\n    <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> {}\n}\n\nfun bar(x: X?): String = when (x) {\n    is X.A -> \"A\"\n    is X.B -> \"B\"\n    null -> \"null\"\n    <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> \"Unreachable\"\n}\n\nfun justUse(x: X) {\n    when (x) {\n        is X.A -> {}\n        is X.B -> {}\n        // Redundant even in statement position\n        <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> {}\n    }\n}\n\nenum class E {\n    A, B\n}\n\nfun foo(e: E): String = when (e) {\n    E.A -> \"A\"\n    E.B -> \"B\"\n    <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> \"\"\n}\n\nfun bar(e: E?): String = when (e) {\n    E.A -> \"A\"\n    E.B -> \"B\"\n    else -> \"\" // no warning\n}\n\nfun foo(b: Boolean) = when (b) {\n    true -> 1\n    false -> 0\n    <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> -1\n}\n\nfun useJava(): String {\n    val me = MyEnum.getInstance()\n    return when (me) {\n        MyEnum.SINGLE -> \"OK\"\n        else -> \"FAIL\" // no warning\n    }\n}"
        },
        {
            "code": "fun foo(x: Int, y: Int): Int =\n        when {\n            x > 0<!COMMA_IN_WHEN_CONDITION_WITHOUT_ARGUMENT!>,<!> y > 0<!COMMA_IN_WHEN_CONDITION_WITHOUT_ARGUMENT!>,<!><!SYNTAX!>,<!> x < 0 -> 1\n            else -> 0\n        }\n\nfun bar(x: Int): Int =\n        when (x) {\n            0 -> 0\n            else -> 1\n        }"
        },
        {
            "code": "// See also: KT-3743\nfun foo(arg: Boolean?): String {\n    // Must be NOT exhaustive\n    return <!NO_ELSE_IN_WHEN!>when<!>(arg) {\n        true -> \"truth\"\n        false -> \"falsehood\"\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(x: Int) = x\n\nfun test0(flag: Boolean) {\n    foo(<!NI;TYPE_MISMATCH!>if (flag) <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!> else <!OI;TYPE_MISMATCH!>\"\"<!><!>)\n}\n\nfun test1(flag: Boolean) {\n    foo(<!NI;TYPE_MISMATCH!>when (flag) {\n        true -> <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>true<!>\n        else -> <!OI;TYPE_MISMATCH!>\"\"<!>\n    }<!>)\n}\n"
        },
        {
            "code": "fun foo(x: Int) {\n    return <!NO_ELSE_IN_WHEN!>when<!> (x) {\n        2 -> {}\n        3 -> {}\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -LateinitTopLevelProperties -LateinitLocalVariables\nimport kotlin.reflect.KProperty\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\npublic abstract class A<T: Any, V: String?>(<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var p2: String) {\n\n    public <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val a: String\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val b: T\n    private lateinit var c: CharSequence\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val d: String\n        get\n\n    public lateinit var e: String\n        get\n        private set\n\n    fun a() {\n        <!UNSUPPORTED_FEATURE!>lateinit<!> var <!UNUSED_VARIABLE!>a<!>: String\n    }\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e1: V\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e2: String?\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e3: Int\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e4: Int?\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e5 = \"A\"\n\n    // With initializer, primitive\n    <!INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e6 = 3\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e7 by CustomDelegate()\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e8: String\n        get() = \"A\"\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e9: String\n        set(v) { field = v }\n\n    abstract <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e10: String\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var String.e11: String\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var String.e12: String\n}\n\n<!INAPPLICABLE_LATEINIT_MODIFIER, UNSUPPORTED_FEATURE!>lateinit<!> val topLevel: String\n<!UNSUPPORTED_FEATURE!>lateinit<!> var topLevelMutable: String\n\npublic interface Intf {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var str: String\n}\n\npublic abstract class AbstractClass {\n    abstract var str: String\n}\n\npublic class AbstractClassImpl : AbstractClass() {\n    override lateinit var str: String\n}\n\npublic class B {\n    lateinit var a: String\n\n    init {\n        a.length\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +LateinitTopLevelProperties +LateinitLocalVariables\nimport kotlin.reflect.KProperty\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\npublic abstract class A<T: Any, V: String?>(<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var p2: String) {\n\n    public <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val a: String\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val b: T\n    private lateinit var c: CharSequence\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val d: String\n        get\n\n    public lateinit var e: String\n        get\n        private set\n\n    fun a() {\n        lateinit var <!UNUSED_VARIABLE!>a<!>: String\n    }\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e1: V\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e2: String?\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e3: Int\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e4: Int?\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e5 = \"A\"\n\n    // With initializer, primitive\n    <!INAPPLICABLE_LATEINIT_MODIFIER, INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e6 = 3\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e7 by CustomDelegate()\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e8: String\n        get() = \"A\"\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e9: String\n        set(v) { field = v }\n\n    abstract <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var e10: String\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var String.e11: String\n\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var String.e12: String\n}\n\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val topLevel: String\nlateinit var topLevelMutable: String\n\npublic interface Intf {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var str: String\n}\n\npublic abstract class AbstractClass {\n    abstract var str: String\n}\n\npublic class AbstractClassImpl : AbstractClass() {\n    override lateinit var str: String\n}\n\npublic class B {\n    lateinit var a: String\n\n    init {\n        a.length\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VALUE -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n// !LANGUAGE: +LateinitLocalVariables\n\nimport kotlin.reflect.KProperty\n\nobject Delegate {\n    operator fun getValue(instance: Any?, property: KProperty<*>) : String = \"\"\n    operator fun setValue(instance: Any?, property: KProperty<*>, value: String) {}\n}\n\n\nfun test() {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> val test0: Any\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var test1: Int\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var test2: Any?\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var test3: String = \"\"\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var test4 by Delegate\n}\n"
        },
        {
            "code": "class My {\n\n    lateinit var x: String\n        private set\n\n    lateinit var y: String\n        internal set\n\n    lateinit protected var z: String\n        private set\n\n    lateinit private var w: String\n        // Ok, private var / private set\n        private set\n\n    lateinit protected var v: String\n        <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>public<!> set\n\n    lateinit public var u: String\n        // Ok, public var / public set\n        public set\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n\ninline fun foo(bar1: (String.() -> Int) -> Int, bar2: (()->Int) -> Int) {\n    bar1 label@ {\n        this@label.length\n    }\n\n    bar1 {\n        this.length\n    }\n    //unmute after KT-4247 fix\n    //bar1  {\n    //    this@bar1.length\n    //}\n\n    bar2 l@ {\n        11\n    }\n\n    bar2 {\n        12\n    }\n\n}\n\ninline fun foo2(bar1: (String.() -> Int) -> Int) {\n    <!REDUNDANT_LABEL_WARNING!>l1@<!> <!USAGE_IS_NOT_INLINABLE!>bar1<!>\n\n    <!REDUNDANT_LABEL_WARNING!>l2@<!> bar1 {\n        11\n    }\n\n    (<!REDUNDANT_LABEL_WARNING!>l3@<!> bar1) {\n        11\n    }\n\n    (<!REDUNDANT_LABEL_WARNING!>l5@<!> (<!REDUNDANT_LABEL_WARNING!>l4@<!> bar1)) {\n        11\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// !LANGUAGE: -InlineDefaultFunctionalParameters\n\nfun test() = \"OK\"\n\nval prop = \"OK\"\n\nclass Foo {\n    fun test() = \"OK\"\n    val prop = \"OK\"\n}\n\nobject FooObject {\n    fun test() = \"OK\"\n    val prop = \"OK\"\n}\n\ninline fun default1(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = { \"OK\" }<!>) {}\ninline fun default2(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = ::test<!>) {}\ninline fun default3(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = ::prop<!>) {}\ninline fun default4(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = FooObject::test<!>) {}\ninline fun default5(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = FooObject::prop<!>) {}\ninline fun default6(<!NOT_YET_SUPPORTED_IN_INLINE!>s : (a: Foo) -> String = Foo::test<!>) {}\ninline fun default7(<!NOT_YET_SUPPORTED_IN_INLINE!>s : (a: Foo) -> String = Foo::prop<!>) {}\n\nval a = Foo()\n\ninline fun default8(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = a::test<!>) {}\ninline fun default9(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = a::prop<!>) {}\n\ninline fun default10(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> String = object : Function0<String> {\n    override fun invoke(): String {\n        return \"FAIL\"\n    }\n}<!>) {}\n\n\nabstract class Base {\n    abstract fun foo(f: () -> Unit = { })\n}\n\nclass Derived : Base() {\n    <!OVERRIDE_BY_INLINE!>override final inline fun foo(<!NOT_YET_SUPPORTED_IN_INLINE!>f: () -> Unit<!>)<!> {\n        f()\n    }\n}\n\ninline fun default11(<!NOT_YET_SUPPORTED_IN_INLINE!>s : () -> Derived = ::Derived<!>) {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -UNNECESSARY_NOT_NULL_ASSERTION -UNNECESSARY_SAFE_CALL\n\nfun getFun(s: (p: Int) -> Unit): Function1<Int, Int> = {11}\n\ninline fun getInlineFun(s: (p: Int) -> Unit): Function1<Int, Int> = {11}\n\ninline fun testExtension(s: (p: Int) -> Unit) {\n    getFun(<!USAGE_IS_NOT_INLINABLE!>s<!>).invoke(10)\n    getInlineFun(s).invoke(10)\n    getInlineFun(s)!!.invoke(10)\n    getInlineFun(s)?.invoke(10)\n}"
        },
        {
            "code": "public fun test() {\n\n    fun localFun() {\n\n    }\n\n    <!NOT_YET_SUPPORTED_IN_INLINE!>inline<!> fun localFun2() {\n        localFun()\n    }\n\n}"
        },
        {
            "code": "public fun test() {\n\n    class Z {\n        public fun localFun() {\n\n        }\n    }\n\n    <!NOT_YET_SUPPORTED_IN_INLINE!>inline<!> fun localFun2() {\n        Z().localFun()\n    }\n\n}"
        },
        {
            "code": "<!NOTHING_TO_INLINE!>inline<!> fun foo() {\n    <!UNRESOLVED_REFERENCE!>unresolved<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>another<!>\n    <!UNRESOLVED_REFERENCE!>unresolved<!>().<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>another<!>()\n}\n\nfun main() {\n    foo()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\npublic class Z {\n    internal val privateProperty = 11;\n\n    internal fun privateFun() {\n\n    }\n}\n\npublic inline fun test() {\n    Z().<!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateProperty<!>\n    Z().<!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n}\n\ninternal inline fun testInternal() {\n    Z().privateProperty\n    Z().privateFun()\n}\n\n\npublic class Z2 {\n    private val privateProperty = 11;\n\n    private fun privateFun() {\n\n    }\n\n    public inline fun test() {\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateProperty<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n    }\n\n    internal inline fun testInternal() {\n        privateProperty\n        privateFun()\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\nprivate val privateProperty = 11;\nprivate fun privateFun() {}\n\ninternal val internalProperty = 11;\ninternal fun internalFun() {}\n\npublic inline fun test() {\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateProperty<!>\n}\n\npublic inline fun test2() {\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalProperty<!>\n}\n\ninternal inline fun testInternal() {\n    privateFun()\n    privateProperty\n}\n\ninternal inline fun test2Internal() {\n    internalFun()\n    internalProperty\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -EXPOSED_PARAMETER_TYPE -NOTHING_TO_INLINE\n\n\ninline fun call(a: A) {\n    a.<!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>test<!>()\n\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n}\n\n@PublishedApi\ninternal inline fun callFromPublishedApi(a: A) {\n    a.<!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>test<!>()\n\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n}\n\ninternal class A {\n    @PublishedApi\n    internal fun test() {\n        test()\n\n        privateFun()\n\n        internalFun()\n    }\n\n    @PublishedApi\n    internal fun testInline() {\n        test()\n\n        privateFun()\n\n        internalFun()\n    }\n}\n\n\nprivate fun privateFun() {\n\n}\n\ninternal fun internalFun() {\n\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -PRIVATE_CLASS_MEMBER_FROM_INLINE\nprivate class Z public constructor(){\n    public val publicProperty:Int = 12\n    public fun publicFun() {}\n}\n\npublic inline fun test() {\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>Z<!>().<!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>publicProperty<!>\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>Z<!>().<!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>publicFun<!>()\n}\n\ninternal inline fun testInternal() {\n    Z().publicProperty\n    Z().publicFun()\n}\n\ninternal class Z2 {\n    private val privateProperty = 11;\n\n    public val publicProperty:Int = 12\n\n    private fun privateFun() {}\n\n    public fun publicFun() {}\n\n    public inline fun test() {\n        privateProperty\n        privateFun()\n        publicProperty\n        publicFun()\n        Z2().publicProperty\n        Z2().publicFun()\n        Z2().privateProperty\n        Z2().privateFun()\n    }\n\n    internal inline fun testInternal() {\n        privateProperty\n        privateFun()\n        publicProperty\n        publicFun()\n        Z2().publicProperty\n        Z2().publicFun()\n        Z2().privateProperty\n        Z2().privateFun()\n    }\n}"
        },
        {
            "code": "fun main() {\n    <!NOT_YET_SUPPORTED_IN_INLINE!>inline<!> fun a(){\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\ninline public fun reg(converter: (Any) -> Any, flag: Boolean) {\n    flag\n    converter(\"\")\n}\n\npublic inline fun register(converter: (Any) -> Any) {\n    <!USELESS_IS_CHECK!><!USAGE_IS_NOT_INLINABLE!>converter<!> is (Any) -> Any<!>\n    reg(converter, <!USELESS_IS_CHECK!><!USAGE_IS_NOT_INLINABLE!>converter<!> is (Any) -> Any<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -NON_LOCAL_RETURN_NOT_ALLOWED\n\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    subInline(s, ext)\n    subNoInline(<!USAGE_IS_NOT_INLINABLE!>s<!>, <!USAGE_IS_NOT_INLINABLE!>ext<!>)\n}\n\ninline fun inlineFunWithInvokeClosure(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    subInline({p: Int -> s(p)}, { p -> this.ext(p)})\n    subNoInline({p: Int -> s(p)}, { p -> this.ext(p)})\n}\n\n//No inline\ninline fun inlineFunWithInvokeNonInline(noinline s: (p: Int) -> Unit, noinline ext: Int.(p: Int) -> Unit) {\n    subInline(s, ext)\n    subNoInline(s, ext)\n}\n\ninline fun inlineFunWithInvokeClosureNoinline(noinline s: (p: Int) -> Unit, noinline ext: Int.(p: Int) -> Unit) {\n    subInline({p: Int -> s(p)}, { p -> this.ext(p)})\n    subNoInline({p: Int -> s(p)}, { p -> this.ext(p)})\n}\n\n//ext function\ninline fun Function1<Int, Unit>.inlineExt(ext: Int.(p: Int) -> Unit) {\n    subInline(this, ext)\n    subNoInline(this, <!USAGE_IS_NOT_INLINABLE!>ext<!>)\n}\n\ninline fun Function1<Int, Unit>.inlineExtWithClosure(ext: Int.(p: Int) -> Unit) {\n    subInline({p: Int -> this(p)}, { p -> this.ext(p)})\n    subNoInline({p: Int -> this(p)}, { p -> this.ext(p)})\n}\n\ninline fun subInline(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {}\n\nfun subNoInline(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -VAL_REASSIGNMENT -UNUSED_CHANGED_VALUE -VARIABLE_EXPECTED\n\ninline operator fun <T, V> Function1<T, V>.unaryPlus() = this\noperator fun <T, V> Function1<T, V>.unaryMinus() = this\ninline operator fun <T, V> Function1<T, V>.inc() = this\noperator fun <T, V> Function1<T, V>.dec() = this\n\ninline operator fun <T, V> @ExtensionFunctionType Function2<T, T, V>.unaryPlus(){}\noperator fun <T, V> @ExtensionFunctionType Function2<T, T, V>.unaryMinus(){}\ninline operator fun <T, V> @ExtensionFunctionType Function2<T, T, V>.inc() = this\noperator fun <T, V> @ExtensionFunctionType Function2<T, T, V>.dec() = this\n\ninline fun <T, V> inlineFunWithInvoke(s: (p: T) -> V, ext: T.(p: T) -> V) {\n    +s\n    -<!USAGE_IS_NOT_INLINABLE!>s<!>\n    s++\n    ++s\n    <!USAGE_IS_NOT_INLINABLE!>s<!>--\n    --<!USAGE_IS_NOT_INLINABLE!>s<!>\n    +ext\n    -<!USAGE_IS_NOT_INLINABLE!>ext<!>\n    ext++\n    ++ext\n    <!USAGE_IS_NOT_INLINABLE!>ext<!>--\n    --<!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n\ninline fun <T, V> Function1<T, V>.inlineFunWithInvoke() {\n    +this\n    -this\n    this++\n    ++this\n    this--\n    --this\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -RECURSION_IN_INLINE\ninline operator fun <T, V> Function1<T, V>.not() : Boolean {\n    return !this\n}\n\ninline fun <T, V> inlineFunWithInvoke(s: (p: T) -> V) {\n    !s\n}\n\noperator fun <T, U, V> Function2<T, U, V>.not() : Boolean {\n    return !this\n}\n\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.not() : Boolean {\n    return !this\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T, l: U) -> V, ext: T.(p: T, l : U) -> V) {\n    !<!USAGE_IS_NOT_INLINABLE!>s<!>\n    !<!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NON_LOCAL_RETURN_NOT_ALLOWED\n// FILE: test.kt\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    Test().test(){\n        s(11)\n        s.invoke(11)\n        s <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n\n        11.ext(11)\n        11 <!INFIX_MODIFIER_REQUIRED!>ext<!> 11\n\n        <!UNUSED_EXPRESSION, USAGE_IS_NOT_INLINABLE!>s<!>\n        <!UNUSED_EXPRESSION, USAGE_IS_NOT_INLINABLE!>ext<!>\n        11\n    }\n}\n\ninline fun inlineFunWithInvokeNonInline(noinline s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    Test().test(){\n        s(11)\n        s.invoke(11)\n        s <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n\n        11.ext(11)\n        11 <!INFIX_MODIFIER_REQUIRED!>ext<!> 11\n\n        <!UNUSED_EXPRESSION!>s<!>\n        <!UNUSED_EXPRESSION, USAGE_IS_NOT_INLINABLE!>ext<!>\n\n        11\n    }\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun Function1<Int, Unit>.inlineExt() {\n    Test().test(){\n        invoke(11)\n        this.invoke(11)\n        this <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n        this(11)\n\n        <!UNUSED_EXPRESSION!>this<!>\n\n        11\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -NOTHING_TO_INLINE -USELESS_ELVIS\n\ninline fun inlineFunWrongUsage(s: (p: Int) -> Unit) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!>\n\n    if (true) <!USAGE_IS_NOT_INLINABLE!>s<!> else 0\n\n    <!USAGE_IS_NOT_INLINABLE!>s<!> ?: <!USAGE_IS_NOT_INLINABLE!>s<!>\n}\n\ninline fun inlineFunWrongUsageExt(ext: Int.(p: Int) -> Unit) {\n    <!USAGE_IS_NOT_INLINABLE!>ext<!>\n\n    if (true) <!USAGE_IS_NOT_INLINABLE!>ext<!> else 0\n\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> ?: <!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n\ninline fun inlineFunWrongUsageInClosure(s: (p: Int) -> Unit) {\n    {\n        <!USAGE_IS_NOT_INLINABLE!>s<!>\n\n        if (true) <!USAGE_IS_NOT_INLINABLE!>s<!> else 0\n\n        <!USAGE_IS_NOT_INLINABLE!>s<!> ?: <!USAGE_IS_NOT_INLINABLE!>s<!>\n    }()\n}\n\ninline fun inlineFunWrongUsageInClosureExt(ext: Int.(p: Int) -> Unit) {\n    {\n        <!USAGE_IS_NOT_INLINABLE!>ext<!>\n\n        if (true) <!USAGE_IS_NOT_INLINABLE!>ext<!> else 0\n\n        <!USAGE_IS_NOT_INLINABLE!>ext<!> ?: <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    }()\n}\n\ninline fun inlineFunNoInline(noinline s: (p: Int) -> Unit) {\n    s\n    if (true) s else 0\n\n    s ?: s\n}\n\ninline fun inlineFunNoInline(noinline ext: Int.(p: Int) -> Unit) {\n    ext\n    if (true) ext else 0\n\n    ext ?: ext\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -NOTHING_TO_INLINE -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -VARIABLE_EXPECTED\n\ninline fun inlineFun(s: (p: Int) -> Unit) {\n    <!RECURSION_IN_INLINE!>inlineFun<!>(s)\n}\n\ninline fun <T> inlineFun(s: T) {\n    <!RECURSION_IN_INLINE!>inlineFun<!><Int>(11)\n}\n\n\ninline fun <T> Function0<T>.inlineExt() {\n    (checkSubtype<Function0<Int>>({11})).<!RECURSION_IN_INLINE!>inlineExt<!>();\n    {11}.<!RECURSION_IN_INLINE!>inlineExt<!>()\n}\n\ninline operator fun <T, V> Function1<T, V>.not() : Boolean {\n    return <!RECURSION_IN_INLINE!>!<!>this\n}\n\ninline operator fun <T, V> Function1<T, V>.inc() : Function1<T, V> {\n    return this<!RECURSION_IN_INLINE!>++<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -EXPOSED_PARAMETER_TYPE -NOTHING_TO_INLINE\n\n// FILE: main.kt\nopen class A {\n    protected fun test() {}\n\n    protected val z: String = \"1\"\n\n    public var zVar: String = \"1\"\n        protected set(<!UNUSED_PARAMETER!>value<!>) {}\n\n    inline fun call() {\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>test<!>()\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>z<!>\n        zVar\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>zVar<!> = \"123\"\n    }\n\n    internal inline fun callFromInternal() {\n        test()\n        zVar\n        zVar = \"123\"\n    }\n\n    @PublishedApi\n    internal inline fun callFromPublished() {\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>test<!>()\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>z<!>\n        zVar\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>zVar<!> = \"123\"\n    }\n\n    protected inline fun callFromProtected() {\n        test()\n        zVar\n        zVar = \"123\"\n    }\n\n}\n\nclass B : A() {\n    inline fun testB() {\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>test<!>()\n    }\n}\n\nclass C : JavaClass() {\n    inline fun call() {\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>bind<!>()\n    }\n\n    internal inline fun callFromInternal() {\n        bind()\n    }\n\n    protected inline fun callFromProtected() {\n        bind()\n    }\n\n    @PublishedApi\n    internal inline fun callFromPublished() {\n        <!PROTECTED_CALL_FROM_PUBLIC_INLINE!>bind<!>()\n    }\n}\n\n\ninternal class AInternal {\n    protected fun test() {}\n\n    protected val z: String = \"1\"\n\n    public var zVar: String = \"1\"\n        protected set(<!UNUSED_PARAMETER!>value<!>) {}\n\n\n    inline fun call() {\n        test()\n    }\n\n    @PublishedApi\n    internal inline fun call2() {\n        test()\n    }\n}\n\nprivate class X {\n\n    public class Z : A() {\n        public inline fun effictivelyNonPublic() {\n            test()\n        }\n    }\n\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -CONFLICTING_JVM_DECLARATIONS\n\npublic inline fun <T> Function1<Int, Int>?.submit(action: ()->T) {\n    this?.invoke(11)\n}\n\npublic inline fun <T> submit(<!NULLABLE_INLINE_PARAMETER!>action: Function1<Int, Int>?<!>, s: () -> Int) {\n    action?.invoke(10)\n}\n\npublic inline fun <T> submitNoInline(noinline action: Function1<Int, Int>?, s: () -> Int) {\n    action?.invoke(10)\n}\n\npublic <!NOTHING_TO_INLINE!>inline<!> fun <T> Function1<Int, Int>?.submit() {\n\n}\n\npublic <!NOTHING_TO_INLINE!>inline<!> fun <T> submit(<!NULLABLE_INLINE_PARAMETER!>action: Function1<Int, Int>?<!>) {\n\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class Foo protected constructor()\n\ninline fun foo(f: () -> Unit) = object: Foo() {}\n\nclass A : Foo() {\n    inline fun foo(f: () -> Unit) = <!PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL!>Foo<!>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\ninline public fun reg(converter: (Any) -> Any) {\n    converter(\"\")\n}\n\npublic inline fun register(converter: (Any) -> Any) {\n    reg(when(<!USAGE_IS_NOT_INLINABLE!>converter<!>) {\n        <!USELESS_IS_CHECK!>is (Any) -> Any<!> -> <!USAGE_IS_NOT_INLINABLE!>converter<!>\n        else -> <!USAGE_IS_NOT_INLINABLE!>converter<!>\n    })\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// !LANGUAGE: +InlineDefaultFunctionalParameters\n\ninline fun inlineFun(lambda: () -> String) = lambda()\n\nfun noInlineFun(lambda: () -> String) = lambda()\n\n\ninline fun default0_1(lambda: () -> String, dlambda: () -> String = { <!NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE!>lambda<!>; \"OK\" }) {\n    lambda() + dlambda()\n}\n\ninline fun default0_2(lambda: () -> String, dlambda: () -> String = { noInlineFun (<!NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE, NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE!>lambda<!>) }) {\n    lambda() + dlambda()\n}\n\n\n\ninline fun default0(lambda: () -> String, dlambda: () -> String = { noInlineFun (<!NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE, NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE!>lambda<!>) }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_0(lambda: () -> String, dlambda: () -> String = { <!NON_LOCAL_RETURN_NOT_ALLOWED, NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE!>lambda<!>() }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_1(lambda: () -> String, noinline dlambda: () -> String = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>lambda<!>() }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_1crossinline(crossinline lambda: () -> String, noinline dlambda: () -> String = { lambda() }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_2(noinline lambda: () -> String, dlambda: () -> String = { lambda() }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_3(noinline lambda: () -> String, noinline dlambda: () -> String = { lambda() }) {\n    lambda() + dlambda()\n}\n\n\ninline fun default2_1(lambda: () -> String, noinline dlambda: () -> String = { inlineFun(<!NON_LOCAL_RETURN_NOT_ALLOWED!>lambda<!>) }) {\n    lambda() + dlambda()\n}\n\ninline fun default2_1crossinline(crossinline lambda: () -> String, noinline dlambda: () -> String = { inlineFun(lambda) }) {\n    lambda() + dlambda()\n}\n\ninline fun default2_2(noinline lambda: () -> String, dlambda: () -> String = { inlineFun(lambda) }) {\n    lambda() + dlambda()\n}\n\ninline fun default2_3(noinline lambda: () -> String, noinline dlambda: () -> String = { inlineFun(lambda) }) {\n    lambda() + dlambda()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNNECESSARY_SAFE_CALL -UNNECESSARY_NOT_NULL_ASSERTION -CONFLICTING_JVM_DECLARATIONS\ninline fun String.submit(action: Function1<Int, Int>) {\n\n}\n\ninline fun Function1<Int, Int>.submit() {\n    this?.invoke(11)\n    this!!.invoke(11)\n\n    submit(this!!)\n}\n\ninline fun submit(action: Function1<Int, Int>) {\n    <!USAGE_IS_NOT_INLINABLE!>action<!>?.invoke(10)\n    <!USAGE_IS_NOT_INLINABLE!>action<!>!!.invoke(10)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE -NOTHING_TO_INLINE\n// SKIP_TXT\n\nsuspend inline fun test1(<!NOT_YET_SUPPORTED_IN_INLINE!>s : suspend () -> String = { \"OK\" }<!>) {}\nsuspend inline fun test2(s : () -> String = { \"OK\" }) {}\nsuspend inline fun test3(<!NOT_YET_SUPPORTED_IN_INLINE!>crossinline s : suspend () -> String = { \"OK\" }<!>) {}\nsuspend inline fun test4(crossinline s : () -> String = { \"OK\" }) {}\nsuspend inline fun test5(noinline s : suspend () -> String = { \"OK\" }) {}\nsuspend inline fun test6(noinline s : () -> String = { \"OK\" }) {}\n\n"
        },
        {
            "code": "inline fun inlineFun(s: (p: Int) -> Unit) : (p: Int) -> Unit {\n    return <!USAGE_IS_NOT_INLINABLE!>s<!>\n}\n\ninline fun inlineFun2(s: (p: Int) -> Unit) : (p: Int) -> Unit = <!USAGE_IS_NOT_INLINABLE!>s<!>\n\n\ninline fun inlineFunWithExt(ext: Int.(p: Int) -> Unit) : Int.(p: Int) -> Unit {\n    return <!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n\ninline fun inlineFunWithExt2(ext: Int.(p: Int) -> Unit) : Int.(p: Int) -> Unit = <!USAGE_IS_NOT_INLINABLE!>ext<!>\n\n\n\n<!NOTHING_TO_INLINE!>inline<!> fun Function1<Int, Unit>.inlineExt(): Function1<Int, Unit> {\n    return this\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun Function1<Int, Unit>.inlineExt2(): Function1<Int, Unit> = this"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NULLABLE_INLINE_PARAMETER -CONFLICTING_JVM_DECLARATIONS\n\n<!NOTHING_TO_INLINE!>inline<!> fun test() {\n\n}\n\ninline fun test2(s : (Int) -> Int) {\n\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun test3(noinline s : (Int) -> Int) {\n\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun test4(noinline s : Int.() -> Int) {\n\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun Function1<Int, Int>?.test5() {\n\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun Function1<Int, Int>?.test6() {\n\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun test2(s : ((Int) -> Int)?) {\n\n}"
        },
        {
            "code": "inline fun <R> onlyLocal(p: () -> R) {\n    inlineAll(<!USAGE_IS_NOT_INLINABLE!>p<!>)\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun <R> inlineAll(noinline p: () -> R) {\n    p()\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit) {\n    (s)(11)\n    (s).invoke(11)\n    (s) <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n    (<!UNUSED_EXPRESSION, USAGE_IS_NOT_INLINABLE!>s<!>)\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun Function1<Int, Unit>.inlineExt() {\n    (this).invoke(11)\n    (this) <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n    (this)(11)\n    (<!UNUSED_EXPRESSION!>this<!>)\n}\n\ninline fun inlineFunWithInvoke2(s: (p: Int) -> Unit) {\n    (((s)))(11)\n    (((s))).invoke(11)\n    (((s))) <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n    (((<!UNUSED_EXPRESSION, USAGE_IS_NOT_INLINABLE!>s<!>)))\n}\n\ninline fun propagation(s: (p: Int) -> Unit) {\n    inlineFunWithInvoke((<!REDUNDANT_LABEL_WARNING!>label@<!> s))\n    inlineFunWithInvoke((<!REDUNDANT_LABEL_WARNING!>label2@<!> <!REDUNDANT_LABEL_WARNING!>label@<!> s))\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -NON_LOCAL_RETURN_NOT_ALLOWED\n\ninfix fun Function1<Int, Unit>.noInlineExt(p: Int) {}\n\ninline infix fun Function1<Int, Unit>.inlineExt2(p: Int) {\n    {\n        noInlineExt(11)\n        this.noInlineExt(11)\n        this noInlineExt 11\n        this\n    }()\n}\n\n\ninline fun Function1<Int, Unit>.inlineExt() {\n    {\n        inlineExt2(1)\n        this.inlineExt2(1)\n        this inlineExt2 1\n        this(11)\n    }()\n}\n\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit) {\n    {\n        s(11)\n        s.invoke(11)\n        s <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n    }()\n}\n\ninline fun inlineFunWithInvokeNonInline(noinline s: (p: Int) -> Unit) {\n    {\n        s(11)\n        s.invoke(11)\n        s <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n    }()\n}\n\n\ninline fun testExtension(s: (p: Int) -> Unit) {\n    {\n        s.inlineExt()\n    } ()\n}\n\ninline fun inlineFunWrongExtension(s: (p: Int) -> Unit) {\n    {\n        <!USAGE_IS_NOT_INLINABLE!>s<!>.noInlineExt(11)\n    } ()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline private fun a() {}\n\ninline fun b() {}\n\ninline public fun c() {}\n\nabstract class A {\n    inline private fun good1() {}\n    inline public final fun good2() {}\n    inline protected final fun good3() {}\n    inline final fun good4() {}\n\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open protected fun wrong1()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open public fun wrong2()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open fun wrong3()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline abstract protected fun wrong4()<!>\n\n    <!DECLARATION_CANT_BE_INLINED!>inline abstract public fun wrong5()<!>\n\n    <!DECLARATION_CANT_BE_INLINED!>inline abstract fun wrong6()<!>\n}\n\n\ninterface B {\n\n    inline private fun good1() {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline fun wrong1()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open fun wrong2()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open public fun wrong3()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open fun wrong4()<!> {}\n\n    <!DECLARATION_CANT_BE_INLINED!>inline fun wrong5()<!>\n\n    <!DECLARATION_CANT_BE_INLINED!>inline public fun wrong6()<!>\n\n    <!DECLARATION_CANT_BE_INLINED!>inline fun wrong7()<!>\n}\n"
        },
        {
            "code": "final class FinalProperty {\n    inline val valProp: Int\n        get() = 1\n\n    val valProp_1: Int\n        inline get() = 1\n\n    inline var varProp: Int\n        get() = 1\n        set(<!UNUSED_PARAMETER!>p<!>: Int) {}\n\n    var varProp_2: Int\n        get() = 1\n        inline set(<!UNUSED_PARAMETER!>p<!>: Int) {}\n}\n\n\nopen class OpenProperty {\n    <!DECLARATION_CANT_BE_INLINED!>inline open val valProp: Int<!>\n        get() = 1\n\n    <!DECLARATION_CANT_BE_INLINED!>open val valProp_1: Int<!>\n        inline get() = 1\n\n    <!DECLARATION_CANT_BE_INLINED!>inline open var varProp: Int<!>\n        get() = 1\n        set(<!UNUSED_PARAMETER!>p<!>: Int) {}\n\n    <!DECLARATION_CANT_BE_INLINED!>open var varProp_2: Int<!>\n        get() = 1\n        inline set(<!UNUSED_PARAMETER!>p<!>: Int) {}\n}\n\n\ninterface AbstractProperty {\n    <!DECLARATION_CANT_BE_INLINED!>inline abstract val valProp: Int<!>\n    <!DECLARATION_CANT_BE_INLINED!>inline abstract var varProp: Int<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline val z: Int\n    get()  {\n\n    <!NOT_YET_SUPPORTED_IN_INLINE!>class<!> A {\n        fun a() {\n           class AInner {}\n        }\n    }\n\n    <!LOCAL_OBJECT_NOT_ALLOWED!>object B<!>{\n        <!LOCAL_OBJECT_NOT_ALLOWED!>object BInner<!> {}\n    }\n\n    <!NOT_YET_SUPPORTED_IN_INLINE!>fun<!> local() {\n        fun localInner() {}\n    }\n    return 1\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -INFIX_MODIFIER_REQUIRED\n\ninline var value: (p: Int) -> String\n    get() = {\"123\" }\n    set(s: (p: Int) -> String) {\n        s(11)\n        s.invoke(11)\n        s invoke 11\n\n        val z = <!USAGE_IS_NOT_INLINABLE!>s<!>\n    }\n\ninline var value2: Int.(p: Int) -> String\n    get() = {\"123\" }\n    set(ext: Int.(p: Int) -> String) {\n        11.ext(11)\n        11.ext(11)\n\n        val p = <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    }"
        },
        {
            "code": "// WITH_REFLECT\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(t: Any?, p: KProperty<*>): Int = 1\n}\n\nopen class A {\n    <!INLINE_PROPERTY_WITH_BACKING_FIELD!>inline val z1<!> = 1\n\n    <!INLINE_PROPERTY_WITH_BACKING_FIELD!>val z1_1<!> = 1\n        inline get() = field + 1\n\n    <!INLINE_PROPERTY_WITH_BACKING_FIELD!>inline var z2<!> = 1\n\n    <!INLINE_PROPERTY_WITH_BACKING_FIELD!>var z2_1<!> = 1\n        inline set(<!UNUSED_PARAMETER!>p<!>: Int) {}\n\n    <!INLINE_PROPERTY_WITH_BACKING_FIELD!>inline val z<!> by Delegate()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    var d = <!USAGE_IS_NOT_INLINABLE!>s<!>\n    d = <!USAGE_IS_NOT_INLINABLE!>s<!>\n\n    var e = <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    e = <!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n\n\ninline fun Function1<Int, Unit>.inlineExt() {\n    var d = this\n    d = this\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\nfun main() {\n    test {\n        <!RETURN_NOT_ALLOWED!>return<!>\n    }\n}\n\ninline fun test(noinline lambda: () -> Unit) {\n    lambda()\n}"
        },
        {
            "code": "fun box() : String {\n    test {\n        <!RETURN_NOT_ALLOWED!>return@box<!> \"123\"\n    }\n\n    return \"OK\"\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun <T> test(p: T) {\n    p.toString()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun <R> inlineFunOnlyLocal(crossinline p: () -> R) {\n    val s = object {\n\n        val z = p()\n\n        fun a() {\n            p()\n        }\n    }\n}\n\ninline fun <R> inlineFun(p: () -> R) {\n    val s = object {\n\n        val z = <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n\n        fun a() {\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun <R> inlineFunOnlyLocal(crossinline p: () -> R) {\n    <!NOT_YET_SUPPORTED_IN_INLINE!>fun<!> a() {\n        val z = p()\n    }\n    a()\n}\n\ninline fun <R> inlineFun(p: () -> R) {\n    <!NOT_YET_SUPPORTED_IN_INLINE!>fun<!> a() {\n        <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n    }\n    a()\n}\n"
        },
        {
            "code": "fun box() : String {\n    test {\n        <!RETURN_NOT_ALLOWED!>return@box<!> \"123\"\n    }\n\n    return \"OK\"\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun test(p: Any) {\n    p.toString()\n}"
        },
        {
            "code": "inline fun <R> doCall(p: () -> R) {\n    p()\n}\n\ninline fun <R> doCallInt(p: () -> R): R {\n    return p()\n}\n\nclass A {\n    var result: Int = doCallInt { <!RETURN_NOT_ALLOWED!>return<!> this };\n\n    var field: Int\n        get() {\n            doCall { return 1 }\n            return 2\n        }\n        set(v: Int) {\n            doCall {\n                result = v / 2\n                return\n            }\n            result = v\n        }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\nclass Z {\n    inline infix fun <R> inlineFun(crossinline p: () -> R) {\n        p()\n    }\n}\n\nfun <R> fun1(p: () -> R) {\n    Z() inlineFun {\n        p()\n    }\n}\n\nfun <R> fun3(p: () -> R) {\n    Z() inlineFun {\n        <!RETURN_NOT_ALLOWED!>return<!>;\n    }\n}\n\nfun <R> fun4(p: () -> R) {\n    Z() inlineFun lambda@ {\n        return@lambda p();\n    }\n}\n"
        },
        {
            "code": "\ninline fun testSameCaptured(lambdaWithResultCaptured: () -> Unit) : String {\n    doWork({<!NON_LOCAL_RETURN_NOT_ALLOWED!>lambdaWithResultCaptured<!>()})\n    return \"OK\"\n}\n\ninline fun <R> doWork(crossinline job: ()-> R) : R {\n    return job()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun <R> inlineFunOnlyLocal(crossinline p: () -> R) {\n    <!NOT_YET_SUPPORTED_IN_INLINE!>class<!> A {\n\n        val z = p()\n\n        fun a() {\n            p()\n        }\n    }\n}\n\ninline fun <R> inlineFun(p: () -> R) {\n    <!NOT_YET_SUPPORTED_IN_INLINE!>class<!> A {\n\n        val z = <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n\n        fun a() {\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\nfun <R> fun1(p: () -> R) {\n    inlineFun {\n        p()\n    }\n}\n\nfun <R> fun1ValueArgument(p: () -> R) {\n    inlineFun ({\n                   p()\n               })\n}\n\nfun <R> fun3(p: () -> R) {\n    inlineFun {\n        <!RETURN_NOT_ALLOWED!>return<!>;\n    }\n}\n\nfun <R> fun3ValueArgument(p: () -> R) {\n    inlineFun ({\n                   <!RETURN_NOT_ALLOWED!>return<!>;\n               })\n}\n\n\nfun <R> fun4(p: () -> R) {\n    inlineFun lambda@ {\n        return@lambda p();\n    }\n}\n\nfun <R> fun4ValueArgument(p: () -> R) {\n    inlineFun (lambda@ {\n        return@lambda p();\n    })\n}\n\n\ninline fun <R> inlineFun(crossinline p: () -> R) {\n    p()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun <R> inlineFunOnlyLocal(crossinline p: () -> R) {\n    val s = object {\n\n        val z = p();\n\n        init {\n            doCall {\n                p()\n            }\n        }\n\n        fun a() {\n            doCall {\n                p()\n            }\n\n            p()\n        }\n    }\n}\n\ninline fun <R> inlineFun(p: () -> R) {\n    val s = object {\n\n        val z = <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n\n        init {\n            doCall {\n                <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n            }\n        }\n\n\n        fun a() {\n            doCall {\n                <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n            }\n\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n        }\n    }\n}\n\ninline fun <R> doCall(p: () -> R) {\n    p()\n}\n"
        },
        {
            "code": "\ninline fun <R> toOnlyLocal(crossinline p: () -> R) {\n    p()\n}\n\ninline fun <R> inlineAll(p: () -> R) {\n    toOnlyLocal(<!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>)\n}\n"
        },
        {
            "code": "fun inlineCall(): String {\n    inlineFun {\n        if (true) {\n            return@inlineCall \"\"\n        }\n        1\n    }\n\n    return \"x\"\n}\n\ninline fun inlineFun(s: ()->Int) {\n    s()\n}\n\n\nfun noInlineCall(): String {\n    noInline {\n        if (true) {\n            <!RETURN_NOT_ALLOWED!>return@noInlineCall<!> \"\"\n        }\n        1\n    }\n\n    return \"x\"\n}\n\n\nfun noInline(s: ()->Int) {\n    s()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun <R> inlineFunOnlyLocal(crossinline p: () -> R) {\n    {\n        p()\n    }()\n}\n\ninline fun <R> inlineFun(p: () -> R) {\n    {\n        <!NON_LOCAL_RETURN_NOT_ALLOWED!>p<!>()\n    }()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// !LANGUAGE: +InlineDefaultFunctionalParameters\n\nfun test() = \"OK\"\n\nval prop = \"OK\"\n\nclass Foo {\n    fun test() = \"OK\"\n    val prop = \"OK\"\n}\n\nobject FooObject {\n    fun test() = \"OK\"\n    val prop = \"OK\"\n}\n\ninline fun default1(s : () -> String = {\"OK\"}) {}\ninline fun default2(s : () -> String = ::test) {}\ninline fun default3(s : () -> String = ::prop) {}\ninline fun default4(s : () -> String = FooObject::test) {}\ninline fun default5(s : () -> String = FooObject::prop) {}\ninline fun default6(s : (a: Foo) -> String = Foo::test) {}\ninline fun default7(s : (a: Foo) -> String = Foo::prop) {}\n\nval a = Foo()\n\ninline fun default8(s : () -> String = a::test) {}\ninline fun default9(s : () -> String = a::prop) {}\n\ninline fun default10(s : () -> String = <!INVALID_DEFAULT_FUNCTIONAL_PARAMETER_FOR_INLINE!>object : Function0<String><!> {\n    override fun invoke(): String {\n        return \"FAIL\"\n    }\n}) {}\n\nabstract class Base {\n    abstract fun foo(f: () -> Unit = { })\n}\n\nclass Derived : Base() {\n    <!OVERRIDE_BY_INLINE!>override final inline fun foo(<!NOT_YET_SUPPORTED_IN_INLINE!>f: () -> Unit<!>)<!> {\n        f()\n    }\n}\n\ninline fun default11(s : () -> Derived = ::Derived) {}"
        },
        {
            "code": "//KT-4341 No resolved call for right-hand side of equals expression\npackage g\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!> == <!USAGE_IS_NOT_INLINABLE!>s<!> //resolved call for right-hand side 's' not traced\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -EXPOSED_PARAMETER_TYPE -NOTHING_TO_INLINE\ninline fun call(a: A) {\n    a.test()\n    publishedTopLevel()\n    \n    a.publishedVar\n    a.publishedVar = 1\n\n    publishedVarTopLevel\n    publishedVarTopLevel = 1\n}\n\ninline var inlineVar: Int\n    get() {\n        val a = A()\n        a.test()\n        publishedTopLevel()\n\n        a.publishedVar\n        a.publishedVar = 1\n\n        publishedVarTopLevel\n        publishedVarTopLevel = 1\n        return 1\n    }\n    set(<!UNUSED_PARAMETER!>value<!>) {\n        val a = A()\n        a.test()\n        publishedTopLevel()\n\n        a.publishedVar\n        a.publishedVar = 1\n\n        publishedVarTopLevel\n        publishedVarTopLevel = 1\n    }\n\n@PublishedApi\ninternal class A {\n    @PublishedApi\n    internal fun test() {\n        publicFun()\n        internalFun()\n        privateFun()\n\n        publicVarTopLevel\n        publicVarTopLevel = 1\n        internalVarTopLevel\n        internalVarTopLevel = 1\n        privateVarTopLevel\n        privateVarTopLevel = 1\n\n        publishedVar\n        publishedVar = 1\n    }\n\n    @PublishedApi\n    internal inline fun testInline() {\n        publicFun()\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n        publicVarTopLevel\n        publicVarTopLevel = 1\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!> = 1\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!> = 1\n\n        publishedVar\n        publishedVar = 1\n    }\n\n\n    @PublishedApi\n    internal inline var publishedVar: Int\n        get() {\n            publicFun()\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n            publicVarTopLevel\n            publicVarTopLevel = 1\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!>\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!> = 1\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!>\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!> = 1\n            return 1\n        }\n\n        set(<!UNUSED_PARAMETER!>value<!>) {\n            publicFun()\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n            publicVarTopLevel\n            publicVarTopLevel = 1\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!>\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!> = 1\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!>\n            <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!> = 1\n        }\n\n}\n\n@PublishedApi\ninternal fun publishedTopLevel() {\n    publicFun()\n    internalFun()\n    privateFun()\n\n    publicVarTopLevel\n    publicVarTopLevel = 1\n    internalVarTopLevel\n    internalVarTopLevel = 1\n    privateVarTopLevel\n    privateVarTopLevel = 1\n}\n\n@PublishedApi\ninline internal fun publishedTopLevelInline() {\n    publicFun()\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n    publicVarTopLevel\n    publicVarTopLevel = 1\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!>\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!> = 1\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!>\n    <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!> = 1\n}\n\n@PublishedApi\ninline internal var publishedVarTopLevel: Int\n    get() {\n        publicFun()\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n        publicVarTopLevel\n        publicVarTopLevel = 1\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!> = 1\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!> = 1\n        return 1\n    }\n\n    set(<!UNUSED_PARAMETER!>value<!>) {\n        publicFun()\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalFun<!>()\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateFun<!>()\n\n        publicVarTopLevel\n        publicVarTopLevel = 1\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>internalVarTopLevel<!> = 1\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!>\n        <!NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, NON_PUBLIC_CALL_FROM_PUBLIC_INLINE!>privateVarTopLevel<!> = 1\n    }\n\n\nfun publicFun() {}\n\ninternal fun internalFun() {}\n\nprivate fun privateFun() {}\n\n\nvar publicVarTopLevel = 1\n\ninternal var internalVarTopLevel = 1\n\nprivate var privateVarTopLevel = 1"
        },
        {
            "code": "// !DIAGNOSTICS: -EXPOSED_PARAMETER_TYPE\n\nprivate class S public constructor() {\n    fun a() {\n\n    }\n}\n\ninternal inline fun x(s: S, z: () -> Unit) {\n    z()\n    <!PRIVATE_CLASS_MEMBER_FROM_INLINE!>S<!>()\n    s.<!PRIVATE_CLASS_MEMBER_FROM_INLINE!>a<!>()\n    test()\n}\n\nprivate inline fun x2(s: S, z: () -> Unit) {\n    z()\n    S()\n    s.a()\n    test()\n}\n\nprivate fun test(): S {\n    return S()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// !LANGUAGE: -InlineDefaultFunctionalParameters\n\ninline fun unsupported() {\n\n    <!NOT_YET_SUPPORTED_IN_INLINE!>class<!> A {\n        fun a() {\n           class AInner {}\n        }\n    }\n\n    <!LOCAL_OBJECT_NOT_ALLOWED!>object B<!>{\n        <!LOCAL_OBJECT_NOT_ALLOWED!>object BInner<!> {}\n    }\n\n    <!NOT_YET_SUPPORTED_IN_INLINE!>fun<!> local() {\n        fun localInner() {}\n    }\n}\n\ninline fun unsupportedDefault(<!NOT_YET_SUPPORTED_IN_INLINE!>s : ()->Unit = {}<!>) {\n\n}\n\nopen class Base {\n    open fun foo(a: Int = 1) {}\n}\n\nclass Derived: Base() {\n    <!OVERRIDE_BY_INLINE!>inline final override fun foo(<!NOT_YET_SUPPORTED_IN_INLINE!>a: Int<!>)<!> {\n\n    }\n}"
        },
        {
            "code": "<!NOTHING_TO_INLINE!>inline<!> fun inlineFun() {\n    <!NOT_YET_SUPPORTED_IN_INLINE(\"Local functions\")!>fun<!> localFun() {}\n    <!NOT_YET_SUPPORTED_IN_INLINE(\"Local classes\")!>class<!> LocalClass {}\n}\n\nfun outerFun() {\n    <!NOT_YET_SUPPORTED_IN_INLINE(\"Local inline functions\")!>inline<!> fun localInlineFun() {}\n}\n\nabstract class Base {\n    abstract fun withDefault(f: () -> Unit = { -> })\n}\n\nclass Derived : Base() {\n    <!OVERRIDE_BY_INLINE!>override final inline fun withDefault(\n            <!NOT_YET_SUPPORTED_IN_INLINE(\"Functional parameters with inherited default values\")!>f: () -> Unit<!>\n    )<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    s(11)\n    s.invoke(11)\n    s <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n\n    11.ext(11)\n    11 <!INFIX_MODIFIER_REQUIRED!>ext<!> 11\n}\n\ninline fun inlineFunWithInvokeNonInline(noinline s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    s(11)\n    s.invoke(11)\n    s <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n\n    11.ext(11)\n    11 <!INFIX_MODIFIER_REQUIRED!>ext<!> 11\n}\n\ninline fun Function1<Int, Unit>.inlineExt() {\n    invoke(11)\n    this.invoke(11)\n    this <!INFIX_MODIFIER_REQUIRED!>invoke<!> 11\n    this(11)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -RECURSION_IN_INLINE\noperator inline fun <T, U> Function1<T, U>.contains(p: Function1<T, U>): Boolean {\n    this in p\n    p in this\n    return false\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U) {\n    s in s\n    s !in s\n}\n\n\noperator fun <T, U, V> Function2<T, U, V>.contains(p: Function2<T, U, V>): Boolean = false\n\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.contains(ext: @ExtensionFunctionType Function3<T, U, V, W>): Boolean = false\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T, l: U) -> U, ext: T.(p: U, l: U) -> V) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!> in <!USAGE_IS_NOT_INLINABLE!>s<!>\n    <!USAGE_IS_NOT_INLINABLE!>s<!> !in <!USAGE_IS_NOT_INLINABLE!>s<!>\n\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> in <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> !in <!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE\ninline operator fun <T, U> Function1<T, U>.component1() = 1\ninline operator fun <T, U> Function1<T, U>.component2() = 2\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U) {\n    val (d1, e1) = s\n}\n\noperator fun <T, U, V> Function2<T, U, V>.component1() = 1\noperator fun <T, U, V> Function2<T, U, V>.component2() = 2\n\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.component1() = 1\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.component2() = 2\n\ninline fun <T, U, V, W> inlineFunWithInvoke(s: (p: T, l: U) -> V, ext: T.(p: U, l: V) -> W) {\n    val (d1, e1) = <!USAGE_IS_NOT_INLINABLE, USAGE_IS_NOT_INLINABLE!>s<!>\n    val (d2, e2) = <!USAGE_IS_NOT_INLINABLE, USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -CONFLICTING_JVM_DECLARATIONS -CONFLICTING_OVERLOADS\noperator fun <T, U> Function1<T, U>.minus(p: Function1<T, U>) {\n\n}\n\noperator fun <T, U, V> @ExtensionFunctionType Function2<T, U, V>.minus(p: T.(p: U) -> V) {\n\n}\n\ninline operator fun <T, U> Function1<T, U>.plus(p: Function1<T, U>) {\n    this - <!USAGE_IS_NOT_INLINABLE!>p<!>\n}\n\ninline operator fun <T, U, V> @ExtensionFunctionType Function2<T, U, V>.plus(p: T.(p: U) -> V) {\n    this - <!USAGE_IS_NOT_INLINABLE!>p<!>\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U, ext: T.(p: U) -> V) {\n    s + s\n    ext + ext\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U, ext: T.(p: U) -> V) {\n    s + s\n    ext + ext\n}\n\ninline fun <T, U> Function1<T, U>.submit() {\n    this + this\n}\n\ninline fun <T, U, V> @ExtensionFunctionType Function2<T, U, V>.submit() {\n    this + this\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE\n\ninline operator fun <T, U> Function1<T, U>.compareTo(p: Function1<T, U>) = 1\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U) {\n    s < s\n    s <= s\n    s > s\n    s >= s\n}\n\n//noinline\noperator fun <T, U, V> Function2<T, U, V>.compareTo(index : Function2<T, U, V>) = 1\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.compareTo(index : @ExtensionFunctionType Function3<T, U, V, W>) = 1\n\ninline fun <T, U, V, W> inlineFunWithInvoke(s: (p: T, l: U) -> V, ext: T.(p: U, l: V) -> W) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!> < <!USAGE_IS_NOT_INLINABLE!>s<!>\n    <!USAGE_IS_NOT_INLINABLE!>s<!> <= <!USAGE_IS_NOT_INLINABLE!>s<!>\n    <!USAGE_IS_NOT_INLINABLE!>s<!> > <!USAGE_IS_NOT_INLINABLE!>s<!>\n    <!USAGE_IS_NOT_INLINABLE!>s<!> >= <!USAGE_IS_NOT_INLINABLE!>s<!>\n\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> < <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> > <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> <= <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> >= <!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE\noperator inline fun <T, U> Function1<T, U>.get(index : Int) {\n\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U) {\n    s[1]\n}\n\n//noinline\noperator fun <T, U, V> Function2<T, U, V>.get(index : Int) {\n\n}\n\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.get(index : Int) {\n\n}\n\ninline fun <T, U, V, W> inlineFunWithInvoke(s: (p: T, l: U) -> V, ext: T.(p: U, l: V) -> W) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!>[1]\n    <!USAGE_IS_NOT_INLINABLE!>ext<!>[1]\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -RECURSION_IN_INLINE\n\ninline operator fun <T, U> Function1<T, U>.rangeTo(p: Function1<T, U>): ClosedRange<Int> {\n    this..p\n    p..this\n    return 1..2\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U) {\n    s..s\n    s..s\n}\n\n\noperator fun <T, U, V> Function2<T, U, V>.rangeTo(p: Function2<T, U, V>): ClosedRange<Int> {\n    return 1..2\n}\n\noperator fun <T, U, V, W> @ExtensionFunctionType Function3<T, U, V, W>.rangeTo(ext: @ExtensionFunctionType Function3<T, U, V, W>): ClosedRange<Int> {\n    return 1..2\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T, l: U) -> U, ext: T.(p: U, l: U) -> V) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!>..<!USAGE_IS_NOT_INLINABLE!>s<!>\n    <!USAGE_IS_NOT_INLINABLE!>s<!>..<!USAGE_IS_NOT_INLINABLE!>s<!>\n\n    <!USAGE_IS_NOT_INLINABLE!>ext<!>..<!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>ext<!>..<!USAGE_IS_NOT_INLINABLE!>ext<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -NON_LOCAL_RETURN_NOT_ALLOWED\n\noperator fun <T, U> Function1<T, U>.minusAssign(p: Function1<T, U>) {}\n\ninline <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun <T, U> Function1<T, U>.modAssign(p: Function1<T, U>) = {\n    this += p\n    p += this\n}\n\ninline operator fun <T, U> Function1<T, U>.plusAssign(p: Function1<T, U>) {\n    this -= <!USAGE_IS_NOT_INLINABLE!>p<!>\n    <!USAGE_IS_NOT_INLINABLE!>p<!> -= this\n}\n\noperator fun <T, U, V> @ExtensionFunctionType Function2<T, U, V>.minusAssign(ext : @ExtensionFunctionType Function2<T, U, V>) {}\n\ninline <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun <T, U, V> @ExtensionFunctionType Function2<T, U, V>.modAssign(ext : @ExtensionFunctionType Function2<T, U, V>) = {\n    this += ext\n    ext += this\n}\n\ninline operator fun <T, U, V> @ExtensionFunctionType Function2<T, U, V>.plusAssign(ext : @ExtensionFunctionType Function2<T, U, V>) {\n    this -= <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>ext<!> -= this\n}\n\ninline fun <T, U, V> inlineFunWithInvoke(s: (p: T) -> U, ext: T.(p: U) -> V) {\n    s += s\n    ext += ext\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -TYPE_MISMATCH\n\ninline fun inlineFunWithInvoke(s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!> && <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    <!USAGE_IS_NOT_INLINABLE!>s<!> || <!USAGE_IS_NOT_INLINABLE!>s<!>\n}\n\ninline fun inlineFunWithInvokeNonInline(noinline s: (p: Int) -> Unit, ext: Int.(p: Int) -> Unit) {\n    s && <!USAGE_IS_NOT_INLINABLE!>ext<!>\n    s || s\n}\n\ninline fun Function1<Int, Unit>.inlineExt() {\n    invoke(11)\n    this && this\n    this || this\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninfix fun Function1<Int, Unit>.noInlineExt(p: Int) {}\n\ninline infix fun Function1<Int, Unit>.inlineExt2(p: Int) {\n    noInlineExt(11)\n    this.noInlineExt(11)\n    this noInlineExt 11\n    this\n}\n\ninline fun Function1<Int, Unit>.inlineExt() {\n    inlineExt2(1)\n    this.inlineExt2(1)\n    this inlineExt2 1\n}\n\ninline fun testExtension(s: (p: Int) -> Unit) {\n    s.inlineExt()\n}\n\ninline fun inlineFunWrongExtension(s: (p: Int) -> Unit) {\n    <!USAGE_IS_NOT_INLINABLE!>s<!>.noInlineExt(11)\n}\n\ninline fun inlineFunNoInline(noinline s: (p: Int) -> Unit) {\n    s.noInlineExt(11)\n}"
        },
        {
            "code": "inline fun foo(f: () -> Unit) {\n    val ff = { <!NAME_SHADOWING!>f<!>: () -> Unit ->\n        f.invoke()\n    }\n    ff(<!USAGE_IS_NOT_INLINABLE!>f<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE -UNUSED_PARAMETER\n\ninterface IBase {\n    fun foo()\n    fun bar()\n    fun <T> qux(x: T)\n}\n\nclass CDerived : IBase {\n    <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n    <!OVERRIDE_BY_INLINE!>override inline fun bar()<!> {}\n    <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n\n    class CNested : IBase {\n        <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline fun bar()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n    }\n\n    val anObject = object : IBase {\n        <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline fun bar()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n    }\n\n    fun aMethod() {\n        class CLocal : IBase {\n            <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n            <!OVERRIDE_BY_INLINE!>override inline fun bar()<!> {}\n            <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n        }\n    }\n}\n\nopen class COpen : IBase {\n    <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n    <!DECLARATION_CANT_BE_INLINED!>override inline fun bar()<!> {}\n    <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n\n    open class COpenNested : IBase {\n        <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n        <!DECLARATION_CANT_BE_INLINED!>override inline fun bar()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n    }\n\n    val anObject = object : IBase {\n        <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline fun bar()<!> {}\n        <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n    }\n\n    fun aMethod() {\n        open class COpenLocal : IBase {\n            <!OVERRIDE_BY_INLINE!>override inline final fun foo()<!> {}\n            <!DECLARATION_CANT_BE_INLINED!>override inline fun bar()<!> {}\n            <!OVERRIDE_BY_INLINE!>override inline final fun <<!REIFIED_TYPE_PARAMETER_IN_OVERRIDE!>reified<!> T> qux(x: T)<!> {}\n        }\n    }\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNCHECKED_CAST -USELESS_CAST\ninline public fun reg(convertFunc: (Any) -> Any) {\n    convertFunc(\"\")\n}\n\npublic inline fun <reified T : Any, reified R : Any> register(converter: (T) -> R) {\n    <!USAGE_IS_NOT_INLINABLE!>converter<!> as (Any) -> Any\n    reg(<!USAGE_IS_NOT_INLINABLE!>converter<!> as (Any) -> Any)\n}"
        },
        {
            "code": "inline fun test(s: () -> Unit, <!NULLABLE_INLINE_PARAMETER!>p: (() -> Unit)?<!>) {\n    s()\n    p?.invoke()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// !LANGUAGE: -InlineDefaultFunctionalParameters\n\ninline fun inlineFun(lambda: () -> String) = lambda()\n\nfun noInlineFun(lambda: () -> String) = lambda()\n\n\ninline fun default0_1(lambda: () -> String, <!NOT_YET_SUPPORTED_IN_INLINE!>dlambda: () -> String = { <!TYPE_MISMATCH, USAGE_IS_NOT_INLINABLE!>lambda<!> }<!>) {\n    lambda() + dlambda()\n}\n\ninline fun default0_2(lambda: () -> String, <!NOT_YET_SUPPORTED_IN_INLINE!>dlambda: () -> String = { noInlineFun (<!USAGE_IS_NOT_INLINABLE!>lambda<!>) }<!>) {\n    lambda() + dlambda()\n}\n\n\n\ninline fun default1_0(lambda: () -> String, <!NOT_YET_SUPPORTED_IN_INLINE!>dlambda: () -> String = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>lambda<!>() }<!>) {\n    lambda() + dlambda()\n}\n\ninline fun default1_1(lambda: () -> String, noinline dlambda: () -> String = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>lambda<!>() }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_1crossinline(crossinline lambda: () -> String, noinline dlambda: () -> String = { lambda() }) {\n    lambda() + dlambda()\n}\n\ninline fun default1_2(noinline lambda: () -> String, <!NOT_YET_SUPPORTED_IN_INLINE!>dlambda: () -> String = { lambda() }<!>) {\n    lambda() + dlambda()\n}\n\ninline fun default1_3(noinline lambda: () -> String, noinline dlambda: () -> String = { lambda() }) {\n    lambda() + dlambda()\n}\n\n\n\n\ninline fun default2_0(lambda: () -> String, <!NOT_YET_SUPPORTED_IN_INLINE!>dlambda: () -> String = { inlineFun(<!NON_LOCAL_RETURN_NOT_ALLOWED!>lambda<!>) }<!>) {\n    lambda() + dlambda()\n}\n\ninline fun default2_1(lambda: () -> String, noinline dlambda: () -> String = { inlineFun(<!NON_LOCAL_RETURN_NOT_ALLOWED!>lambda<!>) }) {\n    lambda() + dlambda()\n}\n\ninline fun default2_1crossinline(crossinline lambda: () -> String, noinline dlambda: () -> String = { inlineFun(lambda) }) {\n    lambda() + dlambda()\n}\n\ninline fun default2_2(noinline lambda: () -> String, <!NOT_YET_SUPPORTED_IN_INLINE!>dlambda: () -> String = { inlineFun(lambda) }<!>) {\n    lambda() + dlambda()\n}\n\ninline fun default2_3(noinline lambda: () -> String, noinline dlambda: () -> String = { inlineFun(lambda) }) {\n    lambda() + dlambda()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE -NOTHING_TO_INLINE\n\ninline fun inlineFun(s: (p: Int) -> Unit, noinline b: (p: Int) -> Unit) {\n    subInline(<!USAGE_IS_NOT_INLINABLE!>s<!>, b)\n    subNoInline(<!USAGE_IS_NOT_INLINABLE!>s<!>, b)\n}\n\ninline fun Function1<Int, Unit>.inlineExt(s: (p: Int) -> Unit, noinline b: (p: Int) -> Unit) {\n    subInline(this, <!USAGE_IS_NOT_INLINABLE!>s<!>, b)\n    subNoInline(this, <!USAGE_IS_NOT_INLINABLE!>s<!>, b)\n}\n\n\ninline fun subInline(vararg s: (p: Int) -> Unit) {}\n\nfun subNoInline(vararg s: (p: Int) -> Unit) {}"
        },
        {
            "code": "class Z(<!UNUSED_PARAMETER!>s<!>: (Int) -> Int) {\n\n}\n\npublic inline fun test(s : (Int) -> Int) {\n    Z(<!USAGE_IS_NOT_INLINABLE!>s<!>)\n}"
        },
        {
            "code": "import<!SYNTAX!><!>\n\nfun firstFun() {}"
        },
        {
            "code": "// !LANGUAGE: +WarningOnMainUnusedParameter\n\nfun main(<!UNUSED_PARAMETER!>args<!>: Array<String>) {\n\n}"
        },
        {
            "code": "fun testPrefix() {\n    operator fun Any.not() {}\n    <!UNREACHABLE_CODE!>!<!>todo()\n}\n\nfun testPostfixWithCall(n: Nothing) {\n    operator fun Nothing.inc(): Nothing = this\n    n<!UNREACHABLE_CODE!>++<!>\n}\n\nfun testPostfixSpecial() {\n    todo()<!UNNECESSARY_NOT_NULL_ASSERTION, UNREACHABLE_CODE!>!!<!>\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "fun test11() {\n    fun Any.bar(<!UNUSED_PARAMETER!>i<!>: Int) {}\n    todo().<!UNREACHABLE_CODE!>bar(1)<!>\n}\n\nfun test12() {\n    fun Any.bar(<!UNUSED_PARAMETER!>i<!>: Int) {}\n    todo()<!UNNECESSARY_SAFE_CALL!>?.<!><!UNREACHABLE_CODE!>bar(1)<!>\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "//KT-3162 More precise try-finally error marking\n\nfun foo(x: String) : String {\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>a<!> =<!> try {\n        x\n    } finally {\n        try {\n        } catch (e: Exception) {\n        }\n        return x\n    }\n}"
        },
        {
            "code": "//KT-2585 Code in try-finally is incorrectly marked as unreachable\n\nfun foo(x: String): String {\n    try {\n        <!UNREACHABLE_CODE!>throw<!> RuntimeException()\n    } finally {\n        try {\n        } catch (e: Exception) {\n        }\n        return x     // <- Wrong UNREACHABLE_CODE\n    }\n}"
        },
        {
            "code": "package a\n\nfun test1() {\n    <!UNREACHABLE_CODE!>bar(<!>\n        11,\n        todo(),//comment1\n        <!UNREACHABLE_CODE!>\"\"//comment2\n    )<!>\n}\n\nfun test2() {\n    <!UNREACHABLE_CODE!>bar(<!>11, todo()/*comment1*/, <!UNREACHABLE_CODE!>\"\"/*comment2*/)<!>\n}\nfun test3() {\n    <!UNREACHABLE_CODE!>bar(<!>11, <!REDUNDANT_LABEL_WARNING!>l@<!>(todo()/*comment*/), <!UNREACHABLE_CODE!>\"\")<!>\n}\n\nfun todo(): Nothing = throw Exception()\n\nfun bar(<!UNUSED_PARAMETER!>i<!>: Int, <!UNUSED_PARAMETER!>s<!>: String, <!UNUSED_PARAMETER!>a<!>: Any) {}\n\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun testCompound() {\n    operator fun Nothing.get(i: Int) {}\n    todo()<!UNREACHABLE_CODE!><!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>[12]<!>\n}\n\nfun testCompound1() {\n    operator fun Int.times(s: String): Array<String> = throw Exception()\n    <!UNREACHABLE_CODE!>(<!>todo() <!UNREACHABLE_CODE!>* \"\")[1]<!>\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun testArgumentInCall() {\n    fun bar(i: Int, s: String, x: Any) {}\n\n    <!UNREACHABLE_CODE!>bar(<!>1, todo(), <!UNREACHABLE_CODE!>\"\")<!>\n}\n\nfun testArgumentInVariableAsFunctionCall(f: (Any) -> Unit) {\n    f<!UNREACHABLE_CODE!>(<!>todo()<!UNREACHABLE_CODE!>)<!>\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "fun testBinary1() {\n    operator fun Int.times(<!UNUSED_PARAMETER!>s<!>: String) {}\n\n    todo() <!UNREACHABLE_CODE!>* \"\"<!>\n}\nfun testBinary2() {\n    \"1\" <!UNREACHABLE_CODE!>+<!> todo()\n}\n\nfun testElvis1() {\n    todo() <!UNREACHABLE_CODE, USELESS_ELVIS!>?: \"\"<!>\n}\n\nfun testElvis2(s: String?) {\n    s ?: todo()\n\n    bar()\n}\n\nfun testAnd1(b: Boolean) {\n    b && todo()\n\n    bar()\n}\n\nfun testAnd2(<!UNUSED_PARAMETER!>b<!>: Boolean) {\n    todo() <!UNREACHABLE_CODE!>&& b<!>\n}\n\nfun returnInBinary1(): Boolean {\n    (return true) <!UNREACHABLE_CODE!>&& (return false)<!>\n}\n\nfun returnInBinary2(): Boolean {\n    (return true) <!UNREACHABLE_CODE!>|| (return false)<!>\n}\n\nfun todo(): Nothing = throw Exception()\nfun bar() {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun testCommasAndWhitespaces() {\n    fun bar(i: Int, s: String, x: Any) {}\n\n    <!UNREACHABLE_CODE!>bar(<!> 1 , todo() , <!UNREACHABLE_CODE!>\"\" )<!>\n}\n\nfun todo(): Nothing = throw Exception()\n\n\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun testArrayAccess1(array: Array<Any>) {\n    array<!UNREACHABLE_CODE!>[<!>todo()<!UNREACHABLE_CODE!>]<!>\n}\n\nfun testArrayAccess2() {\n    operator fun Nothing.get(i: Int, s: String) {}\n    todo()<!UNREACHABLE_CODE!>[1, \"\"]<!>\n}\n\nfun testAraryAccess3() {\n    operator fun Nothing.get(n: Nothing) {}\n    todo()<!UNREACHABLE_CODE!>[todo()]<!>\n}\n\nfun testArrayAssignment1(array: Array<Any>) {\n    array[todo()] <!UNREACHABLE_CODE!>= 11<!>\n}\n\nfun testArrayAssignment2(array: Array<Any>) {\n    array[1] <!UNREACHABLE_CODE!>=<!> todo()\n}\n\nfun testArrayAssignment3(n: Nothing) {\n    operator fun Nothing.set(i: Int, j: Int) {}\n    n<!UNREACHABLE_CODE!>[1] = 2<!>\n}\n\nfun testArrayAssignment4(n: Nothing) {\n    operator fun Nothing.set(i: Int, a: Any) {}\n    n<!UNREACHABLE_CODE!>[1] = todo()<!>\n}\n\nfun testArrayPlusAssign(array: Array<Any>) {\n    operator fun Any.plusAssign(a: Any) {}\n    array[1] <!UNREACHABLE_CODE!>+=<!> todo()\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "//KT-2585 Code in try-finally is incorrectly marked as unreachable\n\nfun foo() {\n    try {\n        <!UNREACHABLE_CODE!>throw<!> RuntimeException()\n    } catch (e: Exception) {\n        <!UNREACHABLE_CODE!>return<!>     // <- Wrong UNREACHABLE_CODE\n    } finally {\n        while (true);\n    }\n}\n\nfun bar() {\n    try {\n        throw RuntimeException()\n    } catch (e: Exception) {\n        return     // <- Wrong UNREACHABLE_CODE\n    } finally {\n        while (cond());\n    }\n}\n\nfun cond() = true"
        },
        {
            "code": "fun testInvoke() {\n    operator fun Nothing.invoke(): Nothing = this\n    todo()<!UNREACHABLE_CODE!>()<!>\n}\n\nfun testInvokeWithLambda() {\n    operator fun Nothing.invoke(<!UNUSED_PARAMETER!>i<!>: Int, f: () -> Int) = f\n    todo()<!UNREACHABLE_CODE!>(1){ 42 }<!>\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "\ninline fun myRun(b: () -> Unit) = b()\n\nfun foo() {\n    var <!UNUSED_VARIABLE!>a<!>: Int\n    return\n\n    <!UNREACHABLE_CODE!>myRun {\n        return\n    }<!>\n}\n"
        },
        {
            "code": "fun testIf() {\n    if (todo()) <!UNREACHABLE_CODE!>1<!> else <!UNREACHABLE_CODE!>2<!>\n}\n\nfun testIf1(b: Boolean) {\n    if (b) todo() else <!UNUSED_EXPRESSION!>1<!>\n\n    bar()\n}\n\nfun todo(): Nothing = throw Exception()\nfun bar() {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_EXPRESSION\n\nfun t1() : Int{\n  return 0\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t1a() : Int {\n  <!RETURN_TYPE_MISMATCH!>return<!>\n  <!UNREACHABLE_CODE!>return 1<!>\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t1b() : Int {\n  return 1\n  <!UNREACHABLE_CODE!>return 1<!>\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t1c() : Int {\n  return 1\n  <!RETURN_TYPE_MISMATCH, UNREACHABLE_CODE!>return<!>\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t2() : Int {\n  if (1 > 2)\n    return 1\n  else return 1\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t2a() : Int {\n  if (1 > 2) {\n    return 1\n    <!UNREACHABLE_CODE!>1<!>\n  } else { return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t3() : Any {\n  if (1 > 2)\n    return 2\n  else return \"\"\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t4(a : Boolean) : Int {\n  do {\n    return 1\n  }\n  while (<!UNREACHABLE_CODE!>a<!>)\n  <!UNREACHABLE_CODE!>1<!>\n}\n\nfun t4break(a : Boolean) : Int {\n  do {\n    break\n  }\n  while (<!UNREACHABLE_CODE!>a<!>)\n  return 1\n}\n\nfun t5() : Int {\n  do {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  while (<!UNREACHABLE_CODE!>1 > 2<!>)\n  <!UNREACHABLE_CODE!>return 1<!>\n}\n\nfun t6() : Int {\n  while (1 > 2) {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  return 1\n}\n\nfun t6break() : Int {\n  while (1 > 2) {\n    break\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  return 1\n}\n\nfun t7(b : Int) : Int {\n  for (i in 1..b) {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  return 1\n}\n\nfun t7break(b : Int) : Int {\n  for (i in 1..b) {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  return 1\n}\n\nfun t7() : Int {\n  try {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  catch (<!TYPE_MISMATCH!>e : Any<!>) {\n    2\n  }\n  return 1 // this is OK, like in Java\n}\n\nfun t8() : Int {\n  try {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  catch (<!TYPE_MISMATCH!>e : Any<!>) {\n    return 1\n    <!UNREACHABLE_CODE!>2<!>\n  }\n  <!UNREACHABLE_CODE!>return 1<!>\n}\n\nfun blockAndAndMismatch() : Boolean {\n  (return true) <!UNREACHABLE_CODE!>|| (return false)<!>\n  <!UNREACHABLE_CODE!>return true<!>\n}\n\nfun tf() : Int {\n  try {<!UNREACHABLE_CODE!>return<!> 1} finally{return 1}\n  <!UNREACHABLE_CODE!>return 1<!>\n}\n\nfun failtest(a : Int) : Int {\n  if (fail() <!UNREACHABLE_CODE!>|| true<!>) <!UNREACHABLE_CODE!>{\n\n  }<!>\n  <!UNREACHABLE_CODE!>return 1<!>\n}\n\nfun foo(a : Nothing) : Unit {\n  1\n  a\n  <!UNREACHABLE_CODE!>2<!>\n}\n\nfun fail() : Nothing {\n  throw java.lang.RuntimeException()\n}\n\nfun nullIsNotNothing() : Unit {\n    val x : Int? = 1\n    if (x != null) {\n         return\n    }\n    fail()\n}\n\nfun returnInWhile(a: Int) {\n    do {return}\n    while (<!UNREACHABLE_CODE!>1 > a<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun unreachable0() {\n    return\n    <!UNREACHABLE_CODE!>return todo()<!>\n}\n\nfun unreachable2() {\n    return\n    <!UNREACHABLE_CODE!>val a = todo()<!>\n}\n\nfun unreachable3() {\n    return\n    <!UNREACHABLE_CODE!>bar(todo())<!>\n}\n\nfun unreachable4(array: Array<Any>) {\n    return\n    <!UNREACHABLE_CODE!>array[todo()]<!>\n}\n\nfun bar(a: Any) {}\nfun todo(): Nothing = throw Exception()\n"
        },
        {
            "code": "fun testReturn() {\n    <!UNREACHABLE_CODE!>return<!> todo()\n}\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "//KT-5200 Mark unreachable code in lambdas\n\nfun test1(): String {\n    doCall local@ {\n        throw NullPointerException()\n        <!UNREACHABLE_CODE!>\"b3\"<!> //unmarked\n    }\n\n    return \"OK\"\n}\n\nfun test2(nonLocal: String, b: Boolean): String {\n    doCall local@ {\n        if (b) {\n            return@local \"b1\"\n        } else {\n            return@local \"b2\"\n        }\n        <!UNREACHABLE_CODE!>\"b3\"<!> //unmarked\n    }\n\n    return nonLocal\n}\n\ninline fun doCall(block: ()-> String) = block()\n"
        },
        {
            "code": "fun testAssignment() {\n    var <!UNUSED_VARIABLE!>a<!> = 1\n    <!UNREACHABLE_CODE!>a =<!> todo()\n}\n\nfun testVariableDeclaration() {\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>a<!> =<!> todo()\n}\n\nfun testPlusAssign() {\n    operator fun Int.plusAssign(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n    var a = 1\n    a <!UNREACHABLE_CODE!>+=<!> todo()\n}\n\n\nfun todo(): Nothing = throw Exception()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun testObject() {\n    <!UNREACHABLE_CODE!>object : Foo(<!>todo()<!UNREACHABLE_CODE!>) {\n        fun foo() = 1\n    }<!>\n}\n\nfun testObjectExpression() {\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>a<!>  = object : Foo(<!>todo()<!UNREACHABLE_CODE!>) {\n        fun foo() = 1\n    }<!>\n}\n\nfun testObjectExpression1() {\n    fun bar(i: Int, x: Any) {}\n\n    <!UNREACHABLE_CODE!>bar(<!>1, <!UNREACHABLE_CODE!>object : Foo(<!>todo()<!UNREACHABLE_CODE!>) {\n        fun foo() = 1\n    })<!>\n}\n\nfun testClassDeclaration() {\n    class C : <!UNREACHABLE_CODE!>Foo(<!>todo()<!UNREACHABLE_CODE!>)<!> {}\n\n    bar()\n}\n\nfun testFunctionDefaultArgument() {\n    fun foo(x: Int = todo()) { bar() }\n}\n\nopen class Foo(i: Int) {}\n\nfun todo(): Nothing = throw Exception()\nfun bar() {}"
        },
        {
            "code": "//KT-2585 Code in try-finally is incorrectly marked as unreachable\n\nfun foo(<!UNUSED_PARAMETER!>x<!>: String): String {\n    try {\n        <!UNREACHABLE_CODE!>throw<!> RuntimeException() //should be marked as unreachable, but is not\n    } finally {\n        throw NullPointerException()\n    }\n}"
        },
        {
            "code": "fun testFor() {\n    operator fun Nothing.iterator() = (0..1).iterator()\n\n    <!UNREACHABLE_CODE!>for (i in<!> todo()<!UNREACHABLE_CODE!>) {}<!>\n}\n\nfun testWhile() {\n    <!UNREACHABLE_CODE!>while (<!>todo()<!UNREACHABLE_CODE!>) {\n    }<!>\n}\n\nfun testDoWhile() {\n    do {\n\n    } while(todo())\n\n    <!UNREACHABLE_CODE!>bar()<!>\n}\n\nfun todo(): Nothing = throw Exception()\nfun bar() {}"
        },
        {
            "code": "fun foo(<!UNUSED_PARAMETER!>a<!>: Any) {}\nfun bar(<!UNUSED_PARAMETER!>a<!>: Any, <!UNUSED_PARAMETER!>b<!>: Any) {}\n\nfun test(arr: Array<Int>) {\n    while (true) {\n        <!UNREACHABLE_CODE!>foo(<!>break<!UNREACHABLE_CODE!>)<!>\n    }\n\n\n    while (true) {\n        <!UNREACHABLE_CODE!>bar(<!>arr, break<!UNREACHABLE_CODE!>)<!>\n    }\n\n    while (true) {\n        arr<!UNREACHABLE_CODE!>[<!>break<!UNREACHABLE_CODE!>]<!>\n    }\n\n    while (true) {\n        arr[1] <!UNREACHABLE_CODE!>=<!> break\n    }\n\n    while (true) {\n        break\n        <!UNREACHABLE_CODE!>foo(1)<!>\n    }\n\n    while (true) {\n        var <!UNUSED_VARIABLE!>x<!> = 1\n        break\n        <!UNREACHABLE_CODE!>x = 2<!>\n    }\n\n    while (true) {\n        var <!UNUSED_VARIABLE!>x<!> = 1\n        <!UNREACHABLE_CODE!>x =<!> break\n    }\n\n    // TODO: bug, should be fixed in CFA\n    while (true) {\n        if (1 > 2 && break && 2 > 3) {\n\n        }\n    }\n\n    // TODO: bug, should be fixed in CFA\n    while (true) {\n        if (1 > 2 || break || 2 > 3) {\n\n        }\n    }\n\n    while (true) {\n        break <!UNREACHABLE_CODE, USELESS_ELVIS!>?: null<!>\n    }\n}\n"
        },
        {
            "code": "package c\n\nfun test1() {\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>r<!>: Nothing =<!> null!!\n}\n\nfun test2(a: A) {\n    a + a\n    <!UNREACHABLE_CODE!>bar()<!>\n}\n\nfun test3() {\n    null!!\n    <!UNREACHABLE_CODE!>bar()<!>\n}\n\nfun throwNPE(): Nothing = null!!\n\nclass A {\n    operator fun plus(<!UNUSED_PARAMETER!>a<!>: A): Nothing = throw Exception()\n}\n\nfun bar() {}"
        },
        {
            "code": "fun main() {\n    \"\".run {\n        <!UNUSED_EXPRESSION!>\"\"<!>\n    }\n}\n\n\nfun <T> T.run(f: (T) -> Unit): Unit = f(this)\n"
        },
        {
            "code": "package f\n\n\n//KT-3444 Front-end doesn't check if local function or function of anonymous class returns value\n\nfun box(): Int {\n\n    fun local(): Int {\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n    return local()\n}\n\nfun main() {\n    box()\n}\n\n"
        },
        {
            "code": "// FILE: a.kt\npackage test\n\nclass A {}\n\n// FILE: b.kt\npackage test.p; class C {fun f() {}}\n\n// FILE: c.kt\npackage test.p; open class G<T> {open fun f(): T {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!> fun a() {}}\n\n// FILE: d.kt\npackage test.p; class G2<E> : <!SUPERTYPE_NOT_INITIALIZED!>G<E><!> { fun g() : E {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!> override fun f() : E {<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>}\n\n// FILE: e.kt\npackage test.p; fun foo() {}\n\n// FILE: f.kt\npackage test.p; fun foo(<!UNUSED_PARAMETER!>a<!>: C) {}"
        },
        {
            "code": "interface X {\n    fun f(): Boolean\n}\n\nval m = object : X {\n    override fun f(): Boolean {\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n    fun foo() {\n        fun local(): Int {\n        <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n\nfun ignoreIt(<!UNUSED_PARAMETER!>f<!>: () -> Unit) {}\n\nfun exec(f: () -> Unit) = f()\n\nfun foo() {\n    var x: Int\n    ignoreIt() {\n        // Ok\n        x = 42\n    }\n    // Error!\n    <!UNINITIALIZED_VARIABLE!>x<!>.hashCode()\n}\n\nfun bar() {\n    val x: Int\n    exec {\n        <!CAPTURED_VAL_INITIALIZATION!>x<!> = 13\n    }\n}\n\nfun bar2() {\n    val x: Int\n    fun foo() {\n        <!CAPTURED_VAL_INITIALIZATION!>x<!> = 3\n    }\n    foo()\n}\n\nclass My(val cond: Boolean) {\n\n    val y: Int\n\n    init {\n        val x: Int\n        if (cond) {\n            exec {\n\n            }\n            x = 1\n        }\n        else {\n            x = 2\n        }\n        y = x\n    }\n\n    constructor(): this(false) {\n        val x: Int\n        x = 2\n        exec {\n            x.hashCode()\n        }\n    }\n}\n\nclass Your {\n    val y = if (true) {\n        val xx: Int\n        exec {\n            <!CAPTURED_VAL_INITIALIZATION!>xx<!> = 42\n        }\n        24\n    }\n    else 0\n}\n\nval z = if (true) {\n    val xx: Int\n    exec {\n        <!CAPTURED_VAL_INITIALIZATION!>xx<!> = 24\n    }\n    42\n}\nelse 0"
        },
        {
            "code": "//KT-843 Don't highlight incomplete variables as unused\n\npackage kt843\n\nfun main() {\n    // Integer type\n    val<!SYNTAX!><!> // this word is grey, which looks strange\n}"
        },
        {
            "code": "//KT-1027 Strange selection of unreachable code\n\npackage kt1027\n\nfun foo(<!UNUSED_PARAMETER!>c<!>: List<Int>) {\n    var <!UNUSED_VARIABLE!>i<!> = 2\n\n    return\n\n    <!UNREACHABLE_CODE!>for (j in c) {  //strange selection of unreachable code\n        i += 23\n    }<!>\n}\n\nfun t1() {\n    return\n\n    <!UNREACHABLE_CODE!>while(true) {\n        doSmth()\n    }<!>\n}\n\nfun t2() {\n    return\n\n    <!UNREACHABLE_CODE!>do {\n        doSmth()\n    } while (true)<!>\n}\n\nfun t3() {\n    return\n\n    <!UNREACHABLE_CODE!>try {\n        doSmth()\n    }\n    finally {\n        doSmth()\n    }<!>\n}\n\nfun t4() {\n    return\n\n    <!UNREACHABLE_CODE!>(43)<!>\n}\n\nfun doSmth() {}\n"
        },
        {
            "code": "package aa\n\nval a : Int = <!UNINITIALIZED_VARIABLE!>b<!>\nval b : Int = a + <!UNINITIALIZED_VARIABLE!>b<!>\n\nclass C {\n    val a : Int = <!UNINITIALIZED_VARIABLE!>b<!>\n    val b : Int = a + <!UNINITIALIZED_VARIABLE!>b<!>\n}\n\nfun foo() {\n    val a : Int\n    <!UNINITIALIZED_VARIABLE!>a<!> + 1\n    a + 1\n}\n"
        },
        {
            "code": "fun unreachable() {}\n\nfun a() {\n    do {\n    } while (true)\n    <!UNREACHABLE_CODE!>unreachable()<!>\n}\n\nfun b() {\n    while (true) {\n    }\n    <!UNREACHABLE_CODE!>unreachable()<!>\n}\n\nfun c() {\n    do {} while (1 == 1)\n}\n\nfun d() {\n    while (2 == 2) {}\n}\n\nfun use(arg: Any) = arg\n\nfun f(cond: Boolean) {\n    val bar: Any\n    do {\n        if (cond) {\n            bar = \"value\"\n            break\n        }\n    } while (true)\n    use(bar) // should work\n\n    val foo: Any\n    while (true) {\n        if (cond) {\n            foo = \"value\"\n            break\n        }\n    }\n    use(foo) // should work\n}\n\nfun g(): Int {\n    do {\n        if (true) return 12\n    } while (true)\n} // should work\n\nfun h(): Int {\n    while (true) {\n        if (true) return 12\n    }\n} // should work"
        },
        {
            "code": "// See also KT-10869: Accessing lazy properties from init causes IllegalArgumentException\n\nimport kotlin.reflect.KProperty\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\nclass Kaboom() {\n    // Here and below we should have errors for simple AND delegated\n    init {\n        <!DEBUG_INFO_LEAKING_THIS, UNINITIALIZED_VARIABLE!>delegated<!>.hashCode()\n        <!UNINITIALIZED_VARIABLE!>simple<!>.hashCode()\n        <!DEBUG_INFO_LEAKING_THIS!>withGetter<!>.hashCode()\n    }\n\n    val other = <!DEBUG_INFO_LEAKING_THIS, UNINITIALIZED_VARIABLE!>delegated<!>\n\n    val another = <!UNINITIALIZED_VARIABLE!>simple<!>\n\n    val something = <!DEBUG_INFO_LEAKING_THIS!>withGetter<!>\n    \n    val delegated: String by CustomDelegate()\n\n    val simple = \"xyz\"\n\n    val withGetter: String\n        get() = \"abc\"\n\n    // No error should be here\n    val after = <!DEBUG_INFO_LEAKING_THIS!>delegated<!>\n}\n"
        },
        {
            "code": "//KT-897 Don't allow assignment to a property before it is defined\n\npackage kt897\n\nclass A() {\n    init {\n        <!INITIALIZATION_BEFORE_DECLARATION!>i<!> = 11\n    }\n    val i : Int? = null // must be an error\n\n    init {\n        <!INITIALIZATION_BEFORE_DECLARATION!>j<!> = 1\n    }\n    var j : Int = 2\n\n    init {\n        <!INITIALIZATION_BEFORE_DECLARATION!>k<!> = 3\n    }\n    val k : Int\n}\n"
        },
        {
            "code": "//KT-609 Analyze not only local variables, but function parameters as well in 'unused values' analysis\n\npackage kt609\n\nfun test(a: Int) {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>aa<!> = a\n    <!UNUSED_VALUE!>aa =<!> 324 //should be an 'unused value' warning here\n}\n\nclass C() {\n    fun foo(<!UNUSED_PARAMETER!>s<!>: String) {}  //should be an 'unused variable' warning\n}\n\nopen class A() {\n    open fun foo(s : String) {}  //should not be a warning\n}\n\nclass B() : A() {\n    final override fun foo(s : String) {}  //should not be a warning\n}"
        },
        {
            "code": "fun foo() {\n    outer@while (true) {\n        try {\n            while (true) {\n                <!UNREACHABLE_CODE!>continue@outer<!>\n            }\n        } finally {\n            break\n        }\n    }\n    \"OK\".hashCode()\n}\n\nfun bar(): String {\n    outer@while (true) {\n        try {\n            while (true) {\n                <!UNREACHABLE_CODE!>continue@outer<!>\n            }\n        } finally {\n            return \"OK\"\n        }\n    }\n}\n"
        },
        {
            "code": "fun find2(): Any? {\n    fun visit(element: Any) {\n        <!RETURN_NOT_ALLOWED!>return@find2<!> element\n    }\n    return null\n}\n\n// For find(): AssertionError at ControlFlowInstructionsGeneratorWorker.getExitPoint()\n\nfun find(): Any? {\n    object : Any() {\n        fun visit(element: Any) {\n            <!RETURN_NOT_ALLOWED!>return@find<!> element\n        }\n    }\n    return null\n}\n\nfun find4(): Any? {\n    <!NOT_YET_SUPPORTED_IN_INLINE!>inline<!> fun visit(element: Any) {\n        <!RETURN_NOT_ALLOWED!>return@find4<!> element\n    }\n    return null\n}\n\nfun find3(): Any? {\n    object : Any() {\n        <!NOTHING_TO_INLINE!>inline<!> fun visit(element: Any) {\n            <!RETURN_NOT_ALLOWED!>return@find3<!> element\n        }\n    }\n    return null\n}\n"
        },
        {
            "code": "class A(val next: A? = null) {\n    val x: String\n    init {\n        <!VAL_REASSIGNMENT!>next?.x<!> = \"a\"\n        x = \"b\"\n        <!VAL_REASSIGNMENT!>this.x<!> = \"c\"\n        x = \"d\" // don't repeat the same diagnostic again with this receiver\n        this.x = \"e\"\n\n        <!VAL_REASSIGNMENT!>next?.x<!> = \"f\"\n    }\n}\n"
        },
        {
            "code": "fun test1() {\n    fun bar() {\n        var i : Int\n        doSmth(<!UNINITIALIZED_VARIABLE!>i<!>)\n    }\n}\n\nfun test2() {\n    fun foo() {\n        val s: String?\n\n        try {\n            s = \"\"\n        }\n        catch(e: Exception) {\n            doSmth(e)\n        }\n\n        doSmth(<!UNINITIALIZED_VARIABLE!>s<!>)\n    }\n}\n\nfun test3() {\n    val <!UNUSED_VARIABLE!>f<!> = {\n        val a : Int\n        doSmth(<!UNINITIALIZED_VARIABLE!>a<!>)\n    }\n}\n\nfun test4() {\n    doSmth {\n        val a : Int\n        doSmth(<!UNINITIALIZED_VARIABLE!>a<!>)\n    }\n}\n\nfun test5() {\n    fun inner1() {\n        fun inner2() {\n            fun inner3() {\n                fun inner4() {\n                    val a : Int\n                    doSmth(<!UNINITIALIZED_VARIABLE!>a<!>)\n                }\n            }\n        }\n    }\n}\n\nfun doSmth(a: Any?) = a"
        },
        {
            "code": "//KT-2334 An error 'local function without body' is not reported\n\nfun foo() {\n    <!NON_MEMBER_FUNCTION_NO_BODY!>fun bar()<!>\n}"
        },
        {
            "code": "//KT-1185 Support full enumeration check for 'when'\n\npackage kt1185\n\nenum class Direction {\n    NORTH,\n    SOUTH,\n    WEST,\n    EAST\n}\n\nclass A {\n    companion object {\n\n    }\n}\n\nenum class Color(val rgb : Int) {\n    RED(0xFF0000),\n    GREEN(0x00FF00),\n    BLUE(0x0000FF)\n}\n\nfun foo(d: Direction) = when(d) { //no 'else' should be requested\n    Direction.NORTH -> 1\n    Direction.SOUTH -> 2\n    <!INCOMPATIBLE_TYPES!>A<!> -> 1\n    Direction.WEST -> 3\n    Direction.EAST -> 4\n}\n\nfun foo1(d: Direction) = <!NO_ELSE_IN_WHEN!>when<!>(d) {\n    Direction.NORTH -> 1\n    Direction.SOUTH -> 2\n    Direction.WEST -> 3\n}\n\nfun bar(c: Color) = when (c) {\n    Color.RED -> 1\n    Color.GREEN -> 2\n    Color.BLUE -> 3\n}\n\nfun bar1(c: Color) = <!NO_ELSE_IN_WHEN!>when<!> (c) {\n    Color.RED -> 1\n    Color.GREEN -> 2\n}"
        },
        {
            "code": "fun test() {\n    while (true) {\n        fun local1() {\n            <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n        }\n    }\n}\n\nfun test2() {\n    while (true) {\n        <!UNUSED_LAMBDA_EXPRESSION!>{\n            <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>continue<!>\n        }<!>\n    }\n}\n\nfun test3() {\n    while (true) {\n        class LocalClass {\n            init {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>continue<!>\n            }\n\n            fun foo() {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n            }\n        }\n    }\n}\n\nfun test4() {\n    while (true) {\n        object: Any() {\n            init {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n            }\n        }\n    }\n}\n\nfun test5() {\n    while (true) {\n        class LocalClass(val x: Int) {\n            constructor() : this(42) {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n            }\n            constructor(y: Double) : this(y.toInt()) {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>continue<!>\n            }\n        }\n    }\n}\n\nfun test6() {\n    while (true) {\n        class LocalClass(val x: Int) {\n            init {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n            }\n            init {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>continue<!>\n            }\n        }\n    }\n}\n\nfun test7() {\n    while (true) {\n        class LocalClass {\n            val x: Int = if (true) {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!>\n            }\n            else {\n                <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>continue<!>\n            }\n        }\n    }\n}\n\nfun test8() {\n    while (true) {\n        class LocalClass(val x: Int) {\n            constructor() : this(if (true) { 42 } else { <!BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY!>break<!> })\n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n\nfun foo() {\n    var x: String\n    class A {\n        init {\n            x = \"\"\n        }\n    }\n    // Error! See KT-10042\n    <!UNINITIALIZED_VARIABLE!>x<!>.length\n}\n\nfun bar() {\n    var x: String\n    object: Any() {\n        init {\n            x = \"\"\n        }\n    }\n    // Ok\n    x.length\n}\n\nfun gav() {\n    val x: String\n    class B {\n        init {\n            // Error! See KT-10445\n            <!CAPTURED_VAL_INITIALIZATION!>x<!> = \"\"\n        }\n    }\n    // Error! See KT-10042\n    <!UNINITIALIZED_VARIABLE!>x<!>.length\n    val y: String\n    class C(val s: String) {\n        constructor(): this(\"\") {\n            // Error!\n            <!VAL_REASSIGNMENT!>y<!> = s\n        }\n    }\n    <!UNINITIALIZED_VARIABLE!>y<!>.length\n}\n\nopen class Gau(val s: String)\n\nfun gau() {\n    val x: String\n    object: Any() {\n        init {\n            // Ok\n            x = \"\"\n        }\n    }\n    // Ok\n    x.length\n    val y: String\n    fun local() {\n        object: Any() {\n            init {\n                // Error!\n                <!CAPTURED_VAL_INITIALIZATION!>y<!> = \"\"\n            }\n        }\n    }\n    val z: String\n    object: Gau(if (true) {\n        z = \"\"\n        z\n    }\n    else \"\") {}\n}\n\nclass My {\n    init {\n        val x: String\n        class Your {\n            init {\n                // Error! See KT-10445\n                <!CAPTURED_VAL_INITIALIZATION!>x<!> = \"\"\n            }\n        }\n    }\n}\n\n<!MUST_BE_INITIALIZED!>val top: Int<!>\n\nfun init() {\n    <!VAL_REASSIGNMENT!>top<!> = 1\n}\n"
        },
        {
            "code": "//KT-3501 Variable/parameter is highlighted as unused if it is used in member of local class\n\nfun f(p: String) { // \"p\" is marked as unused\n    class LocalClass {\n        fun f() {\n            <!UNUSED_EXPRESSION!>p<!>\n        }\n    }\n}"
        },
        {
            "code": "fun exc(flag: Boolean) {\n    if (flag) throw Exception()\n}\n\nfun f1(flag: Boolean) {\n    val n: Int\n    try {\n        if (flag) {\n            <!UNUSED_VALUE!>n =<!> 1\n            exc(flag)\n            return\n        }\n    }\n    catch (e: Exception) {\n        // KT-13612: reassignment\n        <!VAL_REASSIGNMENT!>n<!> = 3\n    }\n    <!UNINITIALIZED_VARIABLE!>n<!>.hashCode()\n}\n\nfun f2(flag: Boolean) {\n    while (true) {\n        val n: Int\n        try {\n            if (flag) {\n                <!UNUSED_VALUE!>n =<!> 1\n                exc(flag)\n                break\n            }\n        }\n        catch (e: Exception) {\n            // KT-13612: reassignment\n            <!VAL_REASSIGNMENT!>n<!> = 3\n        }\n        <!UNINITIALIZED_VARIABLE!>n<!>.hashCode()\n    }\n}\n\nfun f3(flag: Boolean) {\n    while (true) {\n        val n: Int\n        try {\n            if (flag) {\n                <!UNUSED_VALUE!>n =<!> 1\n                exc(flag)\n                continue\n            }\n        }\n        catch (e: Exception) {\n            // KT-13612: reassignment\n            <!VAL_REASSIGNMENT!>n<!> = 3\n        }\n        <!UNINITIALIZED_VARIABLE!>n<!>.hashCode()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var x: String\n\n    constructor() {\n        x = \"Foo\"\n    }\n\n    constructor(x: String, y: String): <!NONE_APPLICABLE!>this<!>(y.hashCode())\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var bar: String\n\n    constructor() {\n        bar = \"\"\n    }\n\n    constructor(a: Int) : <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(a) {\n        bar = \"a\"\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var bar: String\n\n    constructor() {\n        bar = \"\"\n    }\n\n    constructor(a: Int) : <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(a, 0, 0) {\n    }\n\n    constructor(a: Int, b: Int) : <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(a) {\n    }\n\n    constructor(a: Int, b: Int, c: Int) : <!CYCLIC_CONSTRUCTOR_DELEGATION_CALL!>this<!>(a, b) {\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var bar: String\n\n    constructor() {\n        bar = \"\"\n    }\n\n    constructor(baz: Int) {\n        bar = \"\"\n    }\n}"
        },
        {
            "code": "class Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var bar: String\n\n    init {\n        bar = \"\"\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var bar: String\n\n    constructor(baz: Int) {\n        bar = \"\"\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Foo {\n    <!UNNECESSARY_LATEINIT!>lateinit<!> var bar: String\n\n    constructor() {\n        bar = \"\"\n    }\n\n    constructor(a: Int) : this() {\n    }\n\n    constructor(a: Int, b: Int) : this(a) {\n    }\n}"
        },
        {
            "code": "fun foo(a: Int, b: Int) = a + b\n\nfun bar(i: Int) {\n    foo(1, 1, <!TOO_MANY_ARGUMENTS!>i<!>)\n}\n"
        },
        {
            "code": "// See KT-12809\nopen class A(val a: Any) {\n    override fun toString() = a.toString()\n}\n\nobject B : A(B.<!UNINITIALIZED_VARIABLE!>foo<!>) { // call B.foo should be not-allowed\n    val foo = 4\n}"
        },
        {
            "code": "class Outer {\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val outerProp: String<!>\n    inner class Inner(inner: Inner, outer: Outer) {\n        val innerProp: String\n        init {\n            outerProp // use of outerProp is ok because we're suppose that Outer instance should be initialized\n            this@Outer.outerProp\n\n            <!VAL_REASSIGNMENT!>this@Outer.outerProp<!> = \"1\"\n            outerProp = \"2\" // do not repeat the same diagnostic with this receiver of outer class\n            <!VAL_REASSIGNMENT!>outer.outerProp<!> = \"3\"\n\n            innerProp = \"4\" + inner.innerProp\n            <!VAL_REASSIGNMENT!>this@Inner.innerProp<!> = \"5\"\n            innerProp = \"6\" // do not repeat the same diagnostic with this receiver\n            this@Inner.innerProp = \"7\"\n\n            <!VAL_REASSIGNMENT!>inner.innerProp<!> = \"8\"\n        }\n    }\n}\n"
        },
        {
            "code": "//KT-1571 Frontend fails to check val reassigment for operator overloading.\npackage kt1571\n\nvar c0 = 0\nvar c1 = 0\nvar c2 = 0\n\nclass A() {\n    var p = 0\n    operator fun divAssign(<!UNUSED_PARAMETER!>a<!> : Int) {\n        c1++;\n    }\n    operator fun times(<!UNUSED_PARAMETER!>a<!> : Int) : A {\n        c2++;\n        return this;\n    }\n}\n\nval a : A = A()\nget() {\n    c0++\n    return field\n}\n\nfun box() : String {\n\n    a /= 3\n    if (c0 != 1) {\n        return \"1\"\n    }\n    if (c1 != 1) {\n        return \"2\"\n    }\n    <!VAL_REASSIGNMENT!>a<!> *= 3 // a = a * 3, shouldn't be able to do this on val\n    if (c0 != 2) {\n        return \"3\"\n    }\n    if (c2 != 1) {\n        return \"4\"\n    }\n    return \"OK\"\n}\n"
        },
        {
            "code": "package d\n\nval a: Int\n    get() {\n        val b: Int\n        val <!UNUSED_VARIABLE!>c<!>: Int\n        <!UNUSED_EXPRESSION!>42<!>\n\n        fun bar(): Int {\n            val d: Int\n            <!UNUSED_EXPRESSION!>42<!>\n            return <!UNINITIALIZED_VARIABLE!>d<!>\n        }\n\n        return <!UNINITIALIZED_VARIABLE!>b<!>\n    }\n\nclass A {\n    val a: Int\n        get() {\n            val b: Int\n            val <!UNUSED_VARIABLE!>c<!>: Int\n            <!UNUSED_EXPRESSION!>42<!>\n            return <!UNINITIALIZED_VARIABLE!>b<!>\n        }\n\n    fun foo() {\n        class B {\n            val a: Int\n                get() {\n                    val b: Int\n                    val <!UNUSED_VARIABLE!>c<!>: Int\n                    <!UNUSED_EXPRESSION!>42<!>\n                    return <!UNINITIALIZED_VARIABLE!>b<!>\n                }\n        }\n    }\n}"
        },
        {
            "code": "enum class A(val v: A) {\n    A1(<!UNINITIALIZED_ENUM_ENTRY!>A2<!>),\n    A2(A1)\n}\n\nenum class D(val x: Int) {\n    D1(<!UNINITIALIZED_ENUM_ENTRY!>D2<!>.x),\n    D2(D1.x)\n}\n\nenum class E(val v: Int) {\n    // KT-11769 related: there is no predictable initialization order for enum entry with non-companion object\n    E1(Nested.COPY);\n\n    object Nested {\n        val COPY = E1.v\n    }\n}\n// From KT-13322: cross reference should not be reported here\nobject Object1 {\n    val y: Any = Object2.z\n    object Object2 {\n        val z: Any = Object1.y\n    }\n}\n\n// From KT-6054\nenum class MyEnum {\n    A, B;\n    val x = when(<!DEBUG_INFO_LEAKING_THIS!>this<!>) {\n        <!UNINITIALIZED_ENUM_ENTRY!>A<!> -> 1\n        <!UNINITIALIZED_ENUM_ENTRY!>B<!> -> 2\n        <!REDUNDANT_ELSE_IN_WHEN!>else<!> -> 3\n    }\n}\n"
        },
        {
            "code": "fun bar(f: () -> Unit) = f()\n\nfun foo() {\n    var v: Any\n    bar { <!UNINITIALIZED_VARIABLE!>v<!>.hashCode() }\n}\n"
        },
        {
            "code": "// KT-13612 related tests (reassignment in try-catch-finally)\n\nfun f1() {\n    val n: Int\n    try {\n        <!UNUSED_VALUE!>n =<!> 1\n        throw Exception()\n    }\n    catch (e: Exception) {\n        // KT-13612: reassignment\n        <!VAL_REASSIGNMENT!>n<!> = 2\n    }\n    n.hashCode()\n}\n\nfun f2() {\n    val <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>n<!>: Int\n    try {\n        <!UNUSED_VALUE!>n =<!> 1\n        throw Exception()\n    }\n    finally {\n        <!UNUSED_VALUE!><!VAL_REASSIGNMENT!>n<!> =<!> 2\n    }\n    <!UNREACHABLE_CODE!>n.hashCode()<!>\n}\n\nfun g1(flag: Boolean) {\n    val n: Int\n    try {\n        if (flag) throw Exception()\n        n = 1\n    }\n    catch (e: Exception) {\n        // KT-13612: ? reassignment or definite assignment ?\n        <!VAL_REASSIGNMENT!>n<!> = 2\n    }\n    n.hashCode()\n}\n\nfun g2(flag: Boolean) {\n    val n: Int\n    try {\n        if (flag) throw Exception()\n        <!UNUSED_VALUE!>n =<!> 1\n    }\n    finally {\n        <!VAL_REASSIGNMENT!>n<!> = 2\n    }\n    n.hashCode()\n}\n\nfun h1(flag: Boolean) {\n    val n = try {\n        if (flag) throw Exception()\n        1\n    }\n    catch (e: Exception) {\n        2\n    }\n    n.hashCode()\n}\n\nfun h2(flag: Boolean) {\n    val n = try {\n        if (flag) throw Exception()\n        1\n    }\n    finally {\n        <!UNUSED_EXPRESSION!>2<!>\n    }\n    n.hashCode()\n}\n\nfun j(flag: Boolean) {\n    if (flag) throw Exception()\n}\n\nfun k1(flag: Boolean) {\n    val n: Int\n    try {\n        n = 1\n        j(flag)\n    }\n    catch (e: Exception) {\n        // KT-13612: reassignment\n        <!VAL_REASSIGNMENT!>n<!> = 2\n    }\n    n.hashCode()\n}\n\nfun k2(flag: Boolean) {\n    val n: Int\n    try {\n        <!UNUSED_VALUE!>n =<!> 1\n        j(flag)\n    }\n    finally {\n        <!VAL_REASSIGNMENT!>n<!> = 2\n    }\n    n.hashCode()\n}\n"
        },
        {
            "code": "public data class ProductGroup(val short_name: String, val parent: ProductGroup?) {\n    val name: String = if (parent == null) short_name else \"${<!DEBUG_INFO_SMARTCAST!>parent<!>.name} $short_name\"\n}\n"
        },
        {
            "code": "// Tests for KT-13597 (val assignment inside local object in constructor)\n\nclass Test {\n    val a: String\n\n    init {\n        val t = object {\n            fun some() {\n                // See KT-13597\n                <!CAPTURED_MEMBER_VAL_INITIALIZATION!>a<!> = \"12\"\n            }\n        }\n\n        a = \"2\"\n        t.some()\n    }\n}\n\nclass Test2 {\n    init {\n        val t = object {\n            fun some() {\n                <!VAL_REASSIGNMENT!>a<!> = \"12\"\n            }\n        }\n\n        <!INITIALIZATION_BEFORE_DECLARATION!>a<!> = \"2\"\n        t.some()\n    }\n\n    val a: String\n}\n\n// Tests for KT-14381 (val assignment inside lambda in constructor)\n\nfun <T> exec(f: () -> T): T = f()\n\nclass Test4 {\n    val a: String\n\n    init {\n        exec {\n            // See KT-14381\n            <!CAPTURED_MEMBER_VAL_INITIALIZATION!>a<!> = \"12\"\n        }\n        a = \"34\"\n    }\n}\n\n// Additional tests to prevent something broken\n\nclass Test5 {\n\n    val y: Int\n\n    val z: String\n\n    init {\n        val x: String\n        x = \"\"\n        z = x\n    }\n\n    constructor(y: Int) {\n        this.y = y\n    }\n}\n"
        },
        {
            "code": "fun test5() {\n    var a: Int\n    try {\n        <!UNUSED_VALUE!>a =<!> 3\n    }\n    finally {\n        a = 5\n    }\n    a.hashCode()\n}\n"
        },
        {
            "code": "class A(val next: A? = null) {\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val x: String<!>\n    init {\n        <!VAL_REASSIGNMENT!>next?.x<!> = \"a\"\n    }\n}\n\nclass B(val next: B? = null) {\n    var x: String = next?.x ?: \"default\" // it's ok to use `x` of next\n}\n"
        },
        {
            "code": "fun illegalWhenBlock(a: Any): Int {\n    when(a) {\n        is Int -> return <!DEBUG_INFO_SMARTCAST!>a<!>\n        is String -> return <!DEBUG_INFO_SMARTCAST!>a<!>.length\n    }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See KT-10913 Bogus unreachable code warning\n\nfun fn() : String? = null\nfun foo(): String {\n    val x = fn()?.let { throw Exception() } ?: \"unreachable?\"\n    return x\n}\nfun bar(): String {\n    val x = fn() ?: return \"\"\n    <!OI;UNREACHABLE_CODE!>val <!OI;UNUSED_VARIABLE!>y<!> =<!> x<!UNNECESSARY_SAFE_CALL!>?.<!>let { throw Exception() } <!OI;UNREACHABLE_CODE, OI;USELESS_ELVIS!>?: \"unreachable\"<!>\n    <!OI;UNREACHABLE_CODE!>return y<!>\n}"
        },
        {
            "code": "//KT-607 Val reassignment is not marked as an error\n\npackage kt607\n\nfun foo(a: A) {\n    val o = object {\n        val y : Int\n           get() = 42\n    }\n\n    <!VAL_REASSIGNMENT!>a.z<!> = 23\n    <!VAL_REASSIGNMENT!>o.y<!> = 11   //Should be an error here\n}\n\nclass A() {\n    val z : Int\n    get() = 3\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ReadDeserializedContracts -UseCallsInPlaceEffect\n// See KT-17479\n\nclass Test {\n    val str: String\n    init {\n        run {\n            <!CAPTURED_MEMBER_VAL_INITIALIZATION!>this@Test.str<!> = \"A\"\n        }\n\n        run {\n            // Not sure do we need diagnostic also here\n            this@Test.str = \"B\"\n        }\n\n        str = \"C\"\n    }\n}"
        },
        {
            "code": "//KT-2845 Wrong cf-analysys for variable initialization in try..finally\npackage h\n\nimport java.util.ArrayList\n\nprivate fun doTest() : Int {\n    var list : MutableList<Int>? ;\n    try {\n        list = ArrayList()\n        // Not-null was just assigned to the list\n        <!DEBUG_INFO_SMARTCAST!>list<!>.add(3)\n        return 0 ;\n    }\n    finally {\n        if(<!UNINITIALIZED_VARIABLE!>list<!> != null) { // Must be an ERROR\n        }\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ReadDeserializedContracts +UseCallsInPlaceEffect\n// See KT-17479\n\nclass Test {\n    val str: String\n    init {\n        run {\n            this@Test.str = \"A\"\n        }\n\n        run {\n            // Not sure do we need diagnostic also here\n            <!VAL_REASSIGNMENT!>this@Test.str<!> = \"B\"\n        }\n\n        str = \"C\"\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -RestrictionOfValReassignmentViaBackingField\n\npackage a\n\nimport java.util.HashSet\n\nval a: MutableSet<String>? = null\n    get() {\n        if (a == null) {\n            <!VAL_REASSIGNMENT_VIA_BACKING_FIELD!>field<!> = HashSet()\n        }\n        return a\n    }\n\nclass R {\n    val b: String? = null\n        get() {\n            if (b == null) {\n                <!VAL_REASSIGNMENT_VIA_BACKING_FIELD!>field<!> = \"b\"\n            }\n            return b\n        }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See KT-15566\n// NI_EXPECTED_FILE\n\nimport DefaultHttpClient.client\n\ninterface HttpClient\n\nclass HttpClientImpl : HttpClient\n\n// Below we should have initialization error for both (!) delegates\n\nobject DefaultHttpClient : HttpClient by <!UNINITIALIZED_VARIABLE!>client<!> {\n    val client = HttpClientImpl()\n}\n\nobject DefaultHttpClientWithGetter : HttpClient by client {\n    val client get() = HttpClientImpl()\n}\n\nobject DefaultHttpClientWithFun : HttpClient by fClient() {\n}\n\nprivate fun fClient() = HttpClientImpl()\n\nprivate fun <T> lazy(init: () -> T): kotlin.<!UNRESOLVED_REFERENCE!>Lazy<!><T> {\n    init()\n    null!!\n}\n\nobject DefaultHttpClientWithBy : HttpClient by client {\n    val client by lazy { HttpClientImpl() }\n}\n\nobject DefaultFqHttpClient : HttpClient by DefaultFqHttpClient.<!UNINITIALIZED_VARIABLE!>client<!> {\n    val client = HttpClientImpl()\n}"
        },
        {
            "code": "//KT-4405 Control-flow analysis is not performed for some local declarations\n\npackage d\n\nval closure = {\n    val <!UNUSED_VARIABLE!>x4<!> = \"\" // error: should be UNUSED_VARIABLE\n\n    fun g() {\n        val <!UNUSED_VARIABLE!>x6<!> = \"\" // error: should be UNUSED_VARIABLE\n    }\n\n    fun h(): Int { // error: should be NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\nclass A {\n    init {\n        fun foo(): Int {\n        <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n\n        val <!UNUSED_VARIABLE!>closure<!> = {\n            val <!UNUSED_VARIABLE!>x<!> = \"\"\n\n            fun local(): Int {\n            <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n        }\n\n        val <!UNUSED_VARIABLE!>y<!> = \"\"\n    }\n}"
        },
        {
            "code": "package a\n\nval a : Int = <!UNINITIALIZED_VARIABLE!>b<!>\nval b : Int = a"
        },
        {
            "code": "fun foo() {\n    var x: Int\n    fun bar() {\n        x = 42\n    }\n    <!UNINITIALIZED_VARIABLE!>x<!>.hashCode()\n    bar()\n}\n"
        },
        {
            "code": "// See KT-6665: unresolved reference (v.bar) should not produce \"unreachable code\" after it\n\nfun foo(): Int {\n    val v = 1\n    val <!UNUSED_VARIABLE!>c<!> = v.<!UNRESOLVED_REFERENCE!>bar<!> ?: return 0\n    return 42\n}\n\nfun foo2(): Int {\n    val v = 1\n    val c = if (true) v.<!UNRESOLVED_REFERENCE!>bar<!> else return 3\n    val <!UNUSED_VARIABLE!>b<!> = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>c<!>\n    return 42\n}\n\nfun foo3(): Int {\n    val v = 1\n    val c = when {\n        true -> v.<!UNRESOLVED_REFERENCE!>bar<!>\n        else -> return 3\n    }\n    val <!UNUSED_VARIABLE!>b<!> = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>c<!>\n    return 42\n}\n\n// Type + ErrorType should give Type, unless Type is Nothing\n\nfun bar(): Int {\n    val v = 1\n    val c = v.<!UNRESOLVED_REFERENCE!>bar<!> ?: 42\n    return c\n}\n\nfun bar2(): Int {\n    val v = 1\n    val c = if (true) v.<!UNRESOLVED_REFERENCE!>bar<!> else 3\n    val b = c\n    return b\n}\n\nfun bar3(): Int {\n    val v = 1\n    val c = when {\n        true -> v.<!UNRESOLVED_REFERENCE!>bar<!>\n        else -> 3\n    }\n    val b = c\n    return b\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See KT-8277\n// NI_EXPECTED_FILE\n\nval v = { true } <!USELESS_ELVIS!>?: ( { true } <!USELESS_ELVIS!>?:null!!<!> )<!>\n\nval w = if (true) {\n    { true }\n}\nelse {\n    { true } <!USELESS_ELVIS!>?: null!!<!>\n}\n\nval ww = if (true) {\n    <!OI;TYPE_MISMATCH!>{ true }<!> <!USELESS_ELVIS!>?: null!!<!>\n}\nelse if (true) {\n    <!OI;TYPE_MISMATCH!>{ true }<!> <!USELESS_ELVIS!>?: null!!<!>\n}\nelse {\n    null!!\n}\n\nval <!OI;IMPLICIT_NOTHING_PROPERTY_TYPE!>n<!> = null ?: (null ?: <!OI;TYPE_MISMATCH!>{ true }<!>)\n\nfun l(): (() -> Boolean)? = null\n\nval b = null ?: ( l() ?: false)\n\nval bb = null ?: ( l() ?: null!!)\n\nval bbb = null ?: ( l() <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>)\n\nval bbbb = ( l() <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>) ?: ( l() <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>)\n\nfun f(x : Long?): Long {\n    var a = x ?: (<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>fun() {}<!> <!USELESS_ELVIS!>?: <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, TYPE_MISMATCH!>fun() {}<!><!>)\n    return <!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>\n}\n"
        },
        {
            "code": "//KT-2369 Variable is not marked as uninitialized in 'finally' section\n\nfun main() {\n    var x : Int\n    try {\n        throw Exception()\n    }\n    finally {\n        doSmth(<!UNINITIALIZED_VARIABLE!>x<!> + 1)\n    }\n}\n\nfun doSmth(a: Any?) = a"
        },
        {
            "code": "fun test() {\n\n    l@ for (i in if (true) 1..10 else <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue@l<!>) {}\n    for (i in if (true) 1..10 else <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>) {}\n\n    while (<!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break<!>) {}\n    l@ while (<!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break@l<!>) {}\n\n    do {} while (<!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>)\n    l@ do {} while (<!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue@l<!>)\n\n    //KT-5704\n    var i = 0\n    while (if(i++ == 10) <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>break<!> else <!BREAK_OR_CONTINUE_OUTSIDE_A_LOOP!>continue<!>) {}\n}\n\nfun test2(b: Boolean) {\n    while (b) {\n        <!UNREACHABLE_CODE!>while (<!>break<!UNREACHABLE_CODE!>) {}<!>\n    }\n\n    do {\n        <!UNREACHABLE_CODE!>while (<!>continue<!UNREACHABLE_CODE!>) {}<!>\n    } while (b)\n\n    while (b) {\n        do {} while (break)\n    }\n\n    for (i in 1..10) {\n        for (j in if (true) 1..10 else continue) {\n        }\n    }\n}"
        },
        {
            "code": "fun test(cond1: Boolean) {\n    do {\n        if (cond1) continue\n        val cond2 = false\n    } while (<!UNINITIALIZED_VARIABLE!>cond2<!>) // cond2 may be not defined here\n}\n"
        },
        {
            "code": "package kt1977\n\n//KT-1977 Wrong 'unused expression' in catch\nfun strToInt(s : String) : Int? =\ntry {\n    Integer.parseInt(s)\n} catch(e : NumberFormatException) {\n    null\n}\n\n//more tests\nfun test1(s : String) : Int? {\n    return try {\n        <!UNUSED_EXPRESSION!>88<!>\n        Integer.parseInt(s)\n        22\n    }\n    catch (e: NumberFormatException) {\n        44\n    }\n    finally {\n        <!UNUSED_EXPRESSION!>22<!>\n    }\n}\n\nfun test2(s : String) : Int? {\n    return try {\n        <!UNUSED_EXPRESSION!>88<!>\n        Integer.parseInt(s)\n        22\n    } finally {\n            <!UNUSED_LAMBDA_EXPRESSION!>{\n            x : Int -> x\n            }<!>\n    }\n}\n\n\n//KT-2015 False \"Expression is unused\" warnings\nfun foo() {\n    val <!UNUSED_VARIABLE!>i<!> : Int = try{\n        bar()\n        1\n    }\n    catch(e : Exception){\n        0\n    }\n}\n\nfun bar() {\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\npackage o\n\nclass TestFunctionLiteral {\n    val sum: (Int) -> Int = { x: Int ->\n        <!UNINITIALIZED_VARIABLE!>sum<!>(x - 1) + x\n    }\n    val foo: () -> Unit = l@ ({ <!UNINITIALIZED_VARIABLE!>foo<!>() })\n}\n\nopen class A(val a: A)\n\nclass TestObjectLiteral {\n    val obj: A = object: A(<!UNINITIALIZED_VARIABLE!>obj<!>) {\n        init {\n            val x = <!UNINITIALIZED_VARIABLE!>obj<!>\n        }\n        fun foo() {\n            val y = <!UNINITIALIZED_VARIABLE!>obj<!>\n        }\n    }\n    val obj1: A = <!REDUNDANT_LABEL_WARNING!>l@<!> ( object: A(<!UNINITIALIZED_VARIABLE!>obj1<!>) {\n        init {\n            val x = <!UNINITIALIZED_VARIABLE!>obj1<!>\n        }\n        fun foo() = <!UNINITIALIZED_VARIABLE!>obj1<!>\n    })\n}\n\nclass TestOther {\n    val x: Int = <!UNINITIALIZED_VARIABLE!>x<!> + 1\n}\n"
        },
        {
            "code": "//KT-2330 Check visibility of getters and setters correspondingly\npackage a\n\nclass P {\n    var x : Int = 0\n        private set\n\n    var y : Int = 0\n\n    val other = P();\n\n    init {\n        x = 23\n        other.x = 4\n    }\n\n    val testInGetter : Int\n       get() {\n           x = 33\n           return 3\n       }\n}\n\nfun foo() {\n    val p = P()\n    <!INVISIBLE_SETTER!>p.x<!> = 34 //should be an error here\n    p.y = 23\n\n    fun inner() {\n        <!INVISIBLE_SETTER!>p.x<!> = 44\n    }\n}\n\nclass R {\n    val p = P();\n    init {\n        <!INVISIBLE_SETTER!>p.x<!> = 42\n    }\n\n    val testInGetterInOtherClass : Int\n        get() {\n            <!INVISIBLE_SETTER!>p.x<!> = 33\n            return 3\n        }\n}\n\nfun test() {\n    val <!UNUSED_VARIABLE!>o<!> = object {\n        fun run() {\n            <!UNRESOLVED_REFERENCE!>p<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> = 43\n        }\n    }\n}"
        },
        {
            "code": "class A(val next: A? = null) {\n    val x: String\n    init {\n        <!VAL_REASSIGNMENT!>next?.x<!> = \"a\"\n        this@A.x = \"b\"\n        <!VAL_REASSIGNMENT!>this.x<!> = \"c\"\n        x = \"d\" // don't repeat the same diagnostic again with this receiver\n        this@A.x = \"e\"\n\n        <!VAL_REASSIGNMENT!>next?.x<!> = \"f\"\n    }\n}\n"
        },
        {
            "code": "fun box() {\n    fun local():Int {\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}\n\ninterface X {\n    fun f(): Boolean\n}\n\nval m = object : X {\n    override fun f(): Boolean {\n    <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +RestrictionOfValReassignmentViaBackingField\n\npackage a\n\nimport java.util.HashSet\n\nval a: MutableSet<String>? = null\n    get() {\n        if (a == null) {\n            <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!> = HashSet()\n        }\n        return a\n    }\n\nclass R {\n    val b: String? = null\n        get() {\n            if (b == null) {\n                <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!> = \"b\"\n            }\n            return b\n        }\n}\n"
        },
        {
            "code": "//KT-1001 Argument 2 for @NotNull parameter of JetFlowInformationProvider.checkIsInitialized must not be null\n\npackage kt1001\n\nfun foo(<!UNUSED_PARAMETER!>c<!>: Array<Int>) {\n    return\n\n    <!UNREACHABLE_CODE!>for (i in c) {}<!>\n    <!UNREACHABLE_CODE!>for (i in c) {}<!>\n}\n\n//more tests\n\nfun t1() : Int {\n    try {\n        return 1\n    }\n    catch (e : Exception) {\n        return 2\n    }\n    <!UNREACHABLE_CODE!>return 3<!>\n}\n\nfun t2() : Int {\n    try {\n        return 1\n    }\n    finally {\n        doSmth()\n    }\n    <!UNREACHABLE_CODE!>return 2<!>\n}\n\nfun doSmth() {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage uninitialized_reassigned_variables\n\nfun doSmth(<!UNUSED_PARAMETER!>s<!>: String) {}\nfun doSmth(<!UNUSED_PARAMETER!>i<!>: Int) {}\n\n// ------------------------------------------------\n// uninitialized variables\n\nfun t1(b : Boolean) {\n    val v : Int\n    if (<!UNINITIALIZED_VARIABLE!>v<!> == 0) {}\n\n    var u: String\n    if (b) {\n        u = \"s\"\n    }\n    doSmth(<!UNINITIALIZED_VARIABLE!>u<!>)\n\n    var r: String\n    if (b) {\n        r = \"s\"\n    }\n    else {\n        r = \"tg\"\n    }\n    doSmth(r)\n\n    var t: String\n    if (b)\n        doSmth(<!UNINITIALIZED_VARIABLE!>t<!>)\n    else\n        t = \"ss\"\n    doSmth(t) //repeat for t\n\n    val i = 3\n    doSmth(i)\n    if (b) {\n        return;\n    }\n    doSmth(i)\n    if (<!USELESS_IS_CHECK!>i is Int<!>) {\n        return;\n    }\n}\n\nfun t2() {\n    val s = \"ss\"\n\n    for (i in 0..2) {\n        doSmth(s)\n    }\n}\n\nclass A() {}\n\nfun t4(<!UNUSED_PARAMETER!>a<!>: A) {\n    <!UNUSED_VALUE!><!VAL_REASSIGNMENT!>a<!> =<!> A()\n}\n\n// ------------------------------------------------\n// reassigned vals\n\nfun t1() {\n    val <!UNUSED_VARIABLE!>a<!> : Int = 1\n    <!UNUSED_VALUE!><!VAL_REASSIGNMENT!>a<!> =<!> 2\n\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>b<!> : Int = 1\n    <!UNUSED_VALUE!>b =<!> 3\n}\n\nenum class ProtocolState {\n  WAITING {\n    override fun signal() = ProtocolState.TALKING\n  },\n\n  TALKING {\n    override fun signal() = ProtocolState.WAITING\n  };\n\n  abstract fun signal() : ProtocolState\n}\n\nfun t3() {\n   val x: ProtocolState = ProtocolState.WAITING\n   <!VAL_REASSIGNMENT!>x<!> = x.signal()\n   x = x.signal() //repeat for x\n}\n\nfun t4() {\n    val x = 1\n    <!VAL_REASSIGNMENT!>x<!> += 2\n    val y = 3\n    <!VAL_REASSIGNMENT!>y<!> *= 4\n    var z = 5\n    z -= y\n}\n\nfun t5() {\n    for (i in 0..2) {\n        <!VAL_REASSIGNMENT!>i<!> += 1\n        fun t5() {\n            i += 3\n        }\n    }\n}\n\n// ------------------------------------------------\n// backing fields\n\nvar x = 10\nval y = 10\nval z = 10\n\nclass AnonymousInitializers(var a: String, val b: String) {\n    init {\n        a = \"30\"\n        a = \"s\"\n\n        <!VAL_REASSIGNMENT!>b<!> = \"3\"\n        b = \"tt\" //repeat for b\n    }\n\n    val i: Int\n    init {\n        i = 121\n    }\n\n    init {\n        x = 11\n        <!VAL_REASSIGNMENT!>z<!> = 10\n    }\n\n    val j: Int\n    get() = 20\n\n    init {\n        <!VAL_REASSIGNMENT!>i<!> = 13\n        <!VAL_REASSIGNMENT!>j<!> = 34\n    }\n\n    val k: String\n    init {\n        if (1 < 3) {\n            k = \"a\"\n        }\n        else {\n            k = \"b\"\n        }\n    }\n\n    val l: String\n    init {\n        if (1 < 3) {\n            l = \"a\"\n        }\n        else {\n            l = \"b\"\n        }\n    }\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val o: String<!>\n    init {\n        if (1 < 3) {\n            o = \"a\"\n        }\n    }\n\n    var m: Int = 30\n\n    init {\n        m = 400\n    }\n\n    val n: Int\n\n    init {\n        while (<!UNINITIALIZED_VARIABLE!>n<!> == 0) {\n        }\n        n = 10\n        while (n == 0) {\n        }\n    }\n\n    var p = 1\n    init {\n        p++\n    }\n}\n\nfun reassignFunParams(<!UNUSED_PARAMETER!>a<!>: Int) {\n    <!UNUSED_VALUE!><!VAL_REASSIGNMENT!>a<!> =<!> 1\n}\n\nopen class Open(<!UNUSED_PARAMETER!>a<!>: Int, <!UNUSED_PARAMETER!>w<!>: Int) {}\n\nclass LocalValsVsProperties(val a: Int, w: Int) : Open(a, w) {\n    val x : Int\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val y : Int<!>\n    init {\n        x = 1\n        val <!UNUSED_VARIABLE!>b<!> = x\n    }\n    val b = a\n\n    fun foo() {\n        val r : Int\n        doSmth(x)\n        doSmth(y)\n        doSmth(<!UNINITIALIZED_VARIABLE!>r<!>)\n        doSmth(a)\n    }\n    var xx = w\n    var yy : Int\n    init {\n        <!VAL_REASSIGNMENT!>w<!> += 1\n        yy = w\n    }\n}\n\nclass Outer() {\n    val a : Int\n    var b : Int\n\n    init {\n        a = 1\n        b = 1\n    }\n\n    inner class Inner() {\n        init {\n            <!VAL_REASSIGNMENT!>a<!>++\n            b++\n        }\n    }\n\n    fun foo() {\n        <!VAL_REASSIGNMENT!>a<!>++\n        b++\n    }\n}\n\nclass ForwardAccessToBackingField() { //kt-147\n    val a = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;UNINITIALIZED_VARIABLE, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!>a<!> // error\n    val b = <!UNINITIALIZED_VARIABLE!>c<!> // error\n    val c = 1\n}\n\nclass ClassObject() {\n    companion object {\n        val x : Int\n\n        init {\n            x = 1\n        }\n\n\n        fun foo() {\n            val a : Int\n            doSmth(<!UNINITIALIZED_VARIABLE!>a<!>)\n        }\n    }\n}\n\nfun foo() {\n    val <!UNUSED_VARIABLE!>a<!> = object {\n        val x : Int\n        <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val y : Int<!>\n        val z : Int\n        init {\n            x = 1\n            z = 3\n        }\n        fun foo() {\n            y = 10\n            <!VAL_REASSIGNMENT!>z<!> = 13\n        }\n    }\n}\n\nclass TestObjectExpression() {\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val a : Int<!>\n    fun foo() {\n        val <!UNUSED_VARIABLE!>a<!> = object {\n            val x : Int\n            <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val y : Int<!>\n            init {\n                if (true)\n                    x = 12\n                else\n                    x = 1\n            }\n            fun inner1() {\n                y = 101\n                <!VAL_REASSIGNMENT!>a<!> = 231\n            }\n            fun inner2() {\n                y = 101\n                a = 231\n            }\n        }\n    }\n}\n\n\n\nobject TestObjectDeclaration {\n    val x : Int\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val y : Int<!>\n    init {\n        x = 1\n    }\n\n    fun foo() {\n        <!VAL_REASSIGNMENT!>y<!> = 10\n        val i: Int\n        if (1 < 3) {\n            i = 10\n        }\n        doSmth(<!UNINITIALIZED_VARIABLE!>i<!>)\n    }\n}\n\nfun func() {\n    val b = 1\n    val <!UNUSED_VARIABLE!>a<!> = object {\n        val x = b\n        init {\n            <!VAL_REASSIGNMENT!>b<!> = 4\n        }\n    }\n}\n\n// ------------------------------------------------\n// dot qualifiers\nclass M() {\n    val x = 11\n    var y = 12\n}\n\nfun test(m : M) {\n    <!VAL_REASSIGNMENT!>m.x<!> = 23\n    m.y = 23\n}\n\nfun test1(m : M) {\n    <!VAL_REASSIGNMENT!>m.x<!>++\n    m.y--\n}\n"
        },
        {
            "code": "package f\n\nfun f() {\n    class LocalClass() {\n        init {\n            val <!UNUSED_VARIABLE!>x1<!> = \"\" // ok: unused\n\n            fun loc1(): Int {\n                val <!UNUSED_VARIABLE!>x1_<!> = \"\" // ok: unused\n            <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n        }\n\n        fun f() {\n            val <!UNUSED_VARIABLE!>x2<!> = \"\" // error: should be UNUSED_VARIABLE\n\n            fun loc2(): Int {\n                val <!UNUSED_VARIABLE!>x2_<!> = \"\" // error: should be UNUSED_VARIABLE\n            <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n        }\n\n        val v: String\n            get() {\n                val <!UNUSED_VARIABLE!>x3<!> = \"\" // ok: unused\n            <!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\n    }\n}\n"
        },
        {
            "code": "//KT-2960 Perform control flow checks for package property initializers\n\npackage b\n\nclass P {\n    var x : Int = 0\n        private set\n}\n\nval p = P()\nvar f = { -> <!INVISIBLE_SETTER!>p.x<!> = 32 }\n\nval o = object {\n    fun run() {\n        <!INVISIBLE_SETTER!>p.x<!> = 4\n\n        val z : Int\n        doSmth(<!UNINITIALIZED_VARIABLE!>z<!>)\n    }\n}\n\nval g = { ->\n    val x: Int\n    doSmth(<!UNINITIALIZED_VARIABLE!>x<!>)\n}\n\nclass A {\n    val a : Int = 1\n      get() {\n          val x : Int\n          doSmth(<!UNINITIALIZED_VARIABLE!>x<!>)\n          return field\n      }\n}\n\nfun doSmth(i: Int) = i"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// AssertionError for nested ifs with lambdas and Nothing as results\n// NI_EXPECTED_FILE\n\nval <!OI;IMPLICIT_NOTHING_PROPERTY_TYPE!>fn<!> = if (true) {\n    <!OI;TYPE_MISMATCH!>{ true }<!>\n} \nelse if (true) {\n    <!OI;TYPE_MISMATCH!>{ true }<!>\n}\nelse {\n    null!!\n}"
        },
        {
            "code": "// See KT-15334: incorrect reassignment in do...while\n\nfun test() {\n    do {\n        val s: String\n        s = \"\"\n    } while (s == \"\")\n}\n\nfun test2() {\n    do {\n        val s: String\n        s = \"1\"\n        <!VAL_REASSIGNMENT!>s<!> = s + \"2\"\n    } while (s == \"1\")\n}\n\nfun test3() {\n    val s: String\n    do {\n        <!VAL_REASSIGNMENT!>s<!> = \"\"\n    } while (s != \"\")\n}\n"
        },
        {
            "code": "//KT-610 Distinguish errors 'unused variable' and 'variable is assigned but never accessed'\n\npackage kt610\n\nfun foo() {\n    var <!UNUSED_VARIABLE!>j<!> = 9  //'unused variable' error\n\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>i<!> = 1  //should be an error 'variable i is assigned but never accessed'\n    <!UNUSED_VALUE!>i =<!> 2\n}\n"
        },
        {
            "code": "enum class B(val x: Int) {\n    B1(1),\n    B2(2);\n\n    companion object {\n        val SUM = B1.x + B2.x\n        val COPY = B1\n    }\n}\n\nenum class C(val x: Int) {\n    C1(<!UNINITIALIZED_VARIABLE!>SUM<!>),\n    C2(1);\n\n    companion object {\n        val COPY = C2\n        val SUM = C1.x + COPY.x\n    }\n}\n\n// From KT-11769\nenum class Fruit(personal: Int) {\n    APPLE(1);\n\n    companion object {\n        val common = 20\n    }\n\n    val score = personal + <!UNINITIALIZED_VARIABLE!>common<!>\n}\n\n// Another example from KT-11769\nenum class EnumCompanion1(val x: Int) {\n    INSTANCE(<!UNINITIALIZED_ENUM_COMPANION!>Companion<!>.foo()),\n    ANOTHER(foo());\n\n    companion object {\n        fun foo() = 42\n    }\n}\n// Also should be reported for implicit receiver\nenum class EnumCompanion2(val x: Int) {\n    INSTANCE(<!UNINITIALIZED_ENUM_COMPANION!>foo<!>());\n\n    companion object {\n        fun foo() = 42\n    }\n}\n// But not for another enum\nenum class EnumCompanion3(val x: Int) {\n    INSTANCE(EnumCompanion1.foo()),\n    ANOTHER(EnumCompanion2.foo());\n\n    companion object\n}\n"
        },
        {
            "code": "package c\n\nfun test() {\n    val x = 10\n    fun inner1() {\n        fun inner2() {\n            fun inner3() {\n                val <!UNUSED_VARIABLE!>y<!> = x\n            }\n        }\n    }\n}"
        },
        {
            "code": "open class X(s : String) {\n    public var n: String = s\n        private set\n\n}\n\nclass Z : X(\"subclass\") {\n    fun print(): String {\n        <!INVISIBLE_SETTER!>n<!> = n\n        return n;\n    }\n}\n\n\nfun box() : String {\n    return Z().print() //error\n}"
        },
        {
            "code": "// !LANGUAGE: +Coroutines\n// SKIP_TXT\n\nimport kotlin.reflect.KSuspendFunction0\n\nfun test(c: KSuspendFunction0<Unit>) {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>c<!>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Example {\n    public fun plus(o: Example) = o\n    public operator fun minus(o: Example) = o\n\n    public fun get(i: Int) = \"\"\n    public operator fun get(s: String) = \"\"\n\n    public fun set(i: Int, v: String) {}\n    public operator fun set(s: String, v: String) {}\n\n    public fun not() = false\n\n    public fun rangeTo(o: Example) = o\n    public fun contains(o: Example) = false\n    public fun compareTo(o: Example) = 0\n\n    public fun inc() = this\n    public fun dec() = this\n\n    public fun invoke() {}\n}\n\nclass Example2 {\n    public operator fun not() = true\n\n    public fun plusAssign(o: Example2) {}\n    public operator fun minusAssign(o: Example2) {}\n\n    public operator fun rangeTo(o: Example2) = o\n    public operator fun contains(o: Example2) = false\n    public operator fun compareTo(o: Example2) = 0\n\n    public operator fun inc() = this\n    public operator fun dec() = this\n\n    public operator fun invoke() {}\n}\n\nfun test() {\n    var a = Example()\n    var b = Example()\n    var c = Example2()\n    var d = Example2()\n\n    Example() == Example()\n\n    a == b\n    c != d\n\n    Example() <!OPERATOR_MODIFIER_REQUIRED!>+<!> Example()\n\n    a <!OPERATOR_MODIFIER_REQUIRED!>+<!> b\n    a - b\n    <!OPERATOR_MODIFIER_REQUIRED!>a[1]<!>\n    a[\"str\"]\n\n    <!OPERATOR_MODIFIER_REQUIRED!>a[1]<!> = \"A\"\n    a[\"str\"] = \"str\"\n\n    a.plus(b)\n    a.minus(b)\n    a.get(1)\n    a.get(\"str\")\n\n    c <!OPERATOR_MODIFIER_REQUIRED!>+=<!> d\n    c -= d\n\n    a<!OPERATOR_MODIFIER_REQUIRED!>..<!>b\n    c..d\n\n    Example()<!OPERATOR_MODIFIER_REQUIRED!>..<!>Example()\n    Example2()..Example2()\n\n    a <!OPERATOR_MODIFIER_REQUIRED!><<!> b\n    a <!OPERATOR_MODIFIER_REQUIRED!>>=<!> b\n    c > d\n\n    a <!OPERATOR_MODIFIER_REQUIRED!>in<!> b\n    c in d\n\n    a<!OPERATOR_MODIFIER_REQUIRED!>++<!>\n    a<!OPERATOR_MODIFIER_REQUIRED!>--<!>\n    c++\n    c--\n\n    <!OPERATOR_MODIFIER_REQUIRED!>!<!>a\n    !c\n\n    <!OPERATOR_MODIFIER_REQUIRED!>a<!>()\n    c()\n\n    <!OPERATOR_MODIFIER_REQUIRED!>Example()()<!>\n    Example2()()\n}\n\nabstract class Base {\n    abstract operator fun plus(o: Base): Base\n    abstract fun minus(o: Base): Base\n}\n\nopen class Anc : Base() {\n    override fun plus(o: Base) = o\n    override fun minus(o: Base) = o\n}\n\nclass Anc2 : Anc()\n\nfun test2() {\n    Anc() + Anc()\n    Anc() <!OPERATOR_MODIFIER_REQUIRED!>-<!> Anc()\n    Anc2() + Anc2()\n}"
        },
        {
            "code": "fun foo() {\n    <!WRONG_MODIFIER_TARGET!>sealed<!> class My\n}\n"
        },
        {
            "code": "sealed class Tree {\n    object Empty: Tree()\n    class Leaf(val x: Int): Tree()\n    class Node(val left: Tree, val right: Tree): Tree()\n\n    fun max(): Int = when(this) {\n        Empty -> -1\n        is Leaf  -> <!DEBUG_INFO_SMARTCAST!>this<!>.x\n        is Node  -> <!DEBUG_INFO_SMARTCAST!>this<!>.left.max()\n    }\n\n    fun maxIsClass(): Int = <!NO_ELSE_IN_WHEN!>when<!>(this) {\n        Empty -> -1\n        <!NO_COMPANION_OBJECT!>Leaf<!>  -> 0\n        is Node  -> <!DEBUG_INFO_SMARTCAST!>this<!>.left.max()\n    }\n\n    fun maxWithElse(): Int = when(this) {\n        is Leaf  -> <!DEBUG_INFO_SMARTCAST!>this<!>.x\n        is Node  -> <!DEBUG_INFO_SMARTCAST!>this<!>.left.max()\n        else -> -1\n    }\n}"
        },
        {
            "code": "<!INCOMPATIBLE_MODIFIERS!>open<!> <!INCOMPATIBLE_MODIFIERS!>sealed<!> class Base {\n\n}"
        },
        {
            "code": "class A {\n    sealed class Base\n}\n\nclass Derived : <!INVISIBLE_MEMBER, SEALED_SUPERTYPE!>A.Base<!>()\n\nfun test() {\n    class DerivedLocal : <!INVISIBLE_MEMBER, SEALED_SUPERTYPE!>A.Base<!>()\n}\n"
        },
        {
            "code": "sealed class Stmt\n\nclass ForStmt : Stmt()\n\nsealed class Expr : Stmt() {\n    object BinExpr : Expr()\n}\n\nfun test(x: Stmt): String =\n        when (x) {\n            is Expr -> \"expr\"\n            <!USELESS_IS_CHECK!>is Stmt<!> -> \"stmt\"\n        }\n\nfun test2(x: Stmt): String =\n        <!NO_ELSE_IN_WHEN!>when<!> (x) {\n            is Expr -> \"expr\"\n        }\n\nfun test3(x: Expr): String =\n        when (x) {\n            <!USELESS_IS_CHECK!>is Stmt<!> -> \"stmt\"\n        }"
        },
        {
            "code": "sealed class Sealed {\n    object First: Sealed()\n    open class NonFirst: Sealed() {\n        object Second: NonFirst()\n        object Third: NonFirst()\n    }\n}\n\nfun foo(s: Sealed): Int {\n    return <!NO_ELSE_IN_WHEN!>when<!>(s) {\n        is Sealed.First -> 1\n        <!USELESS_IS_CHECK!>!is Any<!> -> 0\n    }\n}\n\n"
        },
        {
            "code": "sealed class Tree {\n    object Empty: Tree()\n    class Leaf(val x: Int): Tree()\n    class Node(val left: Tree, val right: Tree): Tree()\n\n    fun max(): Int = when(this) {\n        is Empty -> -1\n        is Leaf  -> <!DEBUG_INFO_SMARTCAST!>this<!>.x\n        is Node  -> <!DEBUG_INFO_SMARTCAST!>this<!>.left.max()\n    }\n}\n"
        },
        {
            "code": "sealed class Sealed(val x: Int) {\n    interface ITuple {\n        val x: Int\n        val y: Int\n    }\n    class Tuple(override val x: Int, override val y: Int): ITuple\n    object First: Sealed(12)\n    open class NonFirst(tuple: Tuple): Sealed(tuple.x), ITuple {\n        override val y: Int = tuple.y\n        object Second: NonFirst(Tuple(34, 2))\n        class Third: NonFirst(Tuple(56, 3))\n    }\n}\n\nfun foo(s: Sealed): Int {\n    return <!NO_ELSE_IN_WHEN!>when<!>(s) {\n        is Sealed.First -> 1\n        !is Sealed.ITuple -> 0\n        // else required\n    }\n}\n\n"
        },
        {
            "code": "sealed class Sealed(val x: Int) {\n    object First: Sealed(12)\n    open class NonFirst(x: Int, val y: Int): Sealed(x) {\n        object Second: NonFirst(34, 2)\n        object Third: NonFirst(56, 3)\n    }\n}\n\nfun foo(s: Sealed): Int {\n    return <!NO_ELSE_IN_WHEN!>when<!>(s) {\n        !is Sealed.NonFirst -> 1\n    }\n}\n\n"
        },
        {
            "code": "sealed class Tree {\n    object Empty: Tree()\n    class Leaf(val x: Int): Tree()\n    class Node(val left: Tree, val right: Tree): Tree()\n\n    fun max(): Int {\n        <!DEBUG_INFO_IMPLICIT_EXHAUSTIVE!>when(this) {\n            is Empty -> return -1\n            is Leaf -> return <!DEBUG_INFO_SMARTCAST!>this<!>.x\n            is Node -> return <!DEBUG_INFO_SMARTCAST!>this<!>.left.max()\n        }<!>\n    }\n}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>sealed<!> interface Base {\n\n}\n"
        },
        {
            "code": "sealed class A\nsealed class B : A()\n\nclass C : B()\nclass D : B()\n\nfun test(a: A): Any {\n    return when (a) {\n        is C -> \"\"\n        is D -> \"\"\n    }\n}\n\nfun test2(a: A): Any {\n    return when (a) {\n        is B -> \"\"\n    }\n}\n\nfun test3(a: A): Any {\n    return <!NO_ELSE_IN_WHEN!>when<!> (a) {\n        is D -> \"\"\n    }\n}"
        },
        {
            "code": "sealed class Base {\n    fun foo() = <!SEALED_CLASS_CONSTRUCTOR_CALL!>Base()<!>\n}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>sealed<!> object Sealed {\n\n}\n"
        },
        {
            "code": "sealed class Base\n\nclass Derived: Base() {\n    class Derived2: <!INVISIBLE_MEMBER, SEALED_SUPERTYPE!>Base<!>()\n}\n\nfun test() {\n    class Local: <!INVISIBLE_MEMBER, SEALED_SUPERTYPE!>Base<!>()\n}\n\n"
        },
        {
            "code": "<!REDUNDANT_MODIFIER!>abstract<!> sealed class Base {\n\n}"
        },
        {
            "code": "sealed class Base {\n    sealed class A : Base() {\n        object A1 : A()\n        sealed class A2 : A()\n    }\n    sealed class B : Base() {\n        sealed class B1 : B()\n        object B2 : B()\n    }\n\n    fun foo() = when (this) {\n        is A -> 1\n        is B.B1 -> 2\n        B.B2 -> 3\n        // No else required\n    }\n\n    fun bar() = <!NO_ELSE_IN_WHEN!>when<!> (this) {\n        is A -> 1\n        is B.B1 -> 2\n    }\n\n    fun baz() = when (this) {\n        is A -> 1\n        B.B2 -> 3\n        // No else required (no possible B1 instances)\n    }\n\n    fun negated() = when (this) {\n        !is A -> 1\n        A.A1 -> 2\n        is A.A2 -> 3\n    }\n}"
        },
        {
            "code": "sealed class Sealed <!NON_PRIVATE_CONSTRUCTOR_IN_SEALED!>protected<!> constructor(val x: Int) {\n    object FIRST : Sealed()\n\n    <!NON_PRIVATE_CONSTRUCTOR_IN_SEALED!>public<!> constructor(): this(42)\n\n    constructor(y: Int, z: Int): this(y + z)\n}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>sealed<!> enum class SealedEnum {\n    FIRST, \n    SECOND;\n\n    class Derived: SealedEnum()\n}\n"
        },
        {
            "code": "sealed class Sealed(val x: Int) {\n    object First: Sealed(12)\n    open class NonFirst(x: Int, val y: Int): Sealed(x) {\n        object Second: NonFirst(34, 2)\n        object Third: NonFirst(56, 3)\n    }\n}\n\nfun foo(s: Sealed): Int {\n    return <!NO_ELSE_IN_WHEN!>when<!>(s) {\n        is Sealed.NonFirst -> 0\n    }\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\nsealed class Sealed {\n\n}\n\nfun foo(s: Sealed): Int {\n    return <!NO_ELSE_IN_WHEN!>when<!>(s) {\n        // We do not return anything, so else branch must be here\n    }\n}\n\n"
        },
        {
            "code": "sealed class Sealed() {\n    object First: Sealed()\n    open class NonFirst: Sealed() {\n        class NonSecond: NonFirst() {\n            object Third: Sealed()\n            class NonThird: Sealed() {\n                object Fourth: NonFirst()\n                class Fifth: Sealed()\n            }    \n        }\n        object Second: Sealed()\n    }    \n}\n\nfun foo(s: Sealed) = when(s) {\n    Sealed.First -> 1\n    is Sealed.NonFirst -> 2\n    Sealed.NonFirst.Second -> 4\n    Sealed.NonFirst.NonSecond.Third -> 6\n    is Sealed.NonFirst.NonSecond.NonThird -> 8\n    is Sealed.NonFirst.NonSecond.NonThird.Fifth -> 10\n    // no else required\n}\n\nfun fooWithElse(s: Sealed) = when(s) {\n    Sealed.First -> 1\n    Sealed.NonFirst.NonSecond.Third -> 6\n    is Sealed.NonFirst.NonSecond.NonThird.Fifth -> 10\n    else -> 0\n}\n\nfun fooWithoutElse(s: Sealed) = <!NO_ELSE_IN_WHEN!>when<!>(s) {\n    Sealed.First -> 1\n    is Sealed.NonFirst -> 2\n    Sealed.NonFirst.NonSecond.Third -> 6\n    is Sealed.NonFirst.NonSecond.NonThird -> 8\n    is Sealed.NonFirst.NonSecond.NonThird.Fifth -> 10\n}\n\nfun barWithoutElse(s: Sealed) = <!NO_ELSE_IN_WHEN!>when<!>(s) {\n    Sealed.First -> 1\n    is Sealed.NonFirst -> 2\n    Sealed.NonFirst.Second -> 4\n    is Sealed.NonFirst.NonSecond.NonThird -> 8\n    is Sealed.NonFirst.NonSecond.NonThird.Fifth -> 10\n}\n\n"
        },
        {
            "code": "// See KT-10648: Exhaustiveness check does not work with nested sealed hierarchy\nsealed class Base {\n    sealed class A : Base() {\n        class A1 : A()\n        class A2 : A()\n    }\n    sealed class B : Base() {\n        class B1 : B()\n        class B2 : B()\n    }\n}\n\nfun foo(b: Base) = when (b) {\n    is Base.A -> when(<!DEBUG_INFO_SMARTCAST!>b<!>) {\n        is Base.A.A1 -> 1\n        is Base.A.A2 -> 2\n    }\n    is Base.B -> when(<!DEBUG_INFO_SMARTCAST!>b<!>) {\n        is Base.B.B1 -> 3\n        is Base.B.B2 -> 4\n    }\n}\n\nfun bar(b: Base?) = if (b == null) 0 else when (<!DEBUG_INFO_SMARTCAST!>b<!>) {\n    is Base.A -> when(<!DEBUG_INFO_SMARTCAST!>b<!>) {\n        is Base.A.A1 -> 1\n        is Base.A.A2 -> 2\n    }\n    is Base.B -> when(<!DEBUG_INFO_SMARTCAST!>b<!>) {\n        is Base.B.B1 -> 3\n        is Base.B.B2 -> 4\n    }\n}\n\nfun gav(b: Base?) = when (b) {\n    null -> 0\n    is Base.A -> when(<!DEBUG_INFO_SMARTCAST!>b<!>) {\n        is Base.A.A1 -> 1\n        is Base.A.A2 -> 2\n    }\n    is Base.B -> when(<!DEBUG_INFO_SMARTCAST!>b<!>) {\n        is Base.B.B1 -> 3\n        is Base.B.B2 -> 4\n    }\n}\n"
        },
        {
            "code": "sealed class Sealed {\n    object First: Sealed()\n    open class NonFirst: Sealed() {\n        object Second: NonFirst()\n        object Third: NonFirst()\n        fun foo(): Int {\n            val s = object: <!SEALED_SUPERTYPE_IN_LOCAL_CLASS!>Sealed<!>() {}\n            class Local: <!SEALED_SUPERTYPE_IN_LOCAL_CLASS!>Sealed<!>() {}\n            return s.hashCode()\n        }\n    }\n    val p: Sealed = object: <!SEALED_SUPERTYPE_IN_LOCAL_CLASS!>Sealed<!>() {}\n}\n"
        },
        {
            "code": "<!INCOMPATIBLE_MODIFIERS!>final<!> <!INCOMPATIBLE_MODIFIERS!>sealed<!> class Base {\n\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun f(s: String, action: (String.() -> Unit)?) {\n    s.foo().bar().<!UNSAFE_IMPLICIT_INVOKE_CALL!>action<!>()\n}\n\nfun String.foo() = \"\"\n\nfun String.bar() = \"\"\n\n// --------------------------------------------------------\n\nval functions: Map<String, () -> Any> = TODO()\n\nfun run(name: String) = <!UNSAFE_IMPLICIT_INVOKE_CALL!>functions[name]<!>()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nfun test() = 3\n\nfun <T> proxy(t: T) = t\n\nclass A {\n    val test = test()\n}\n\nclass B {\n    val test = proxy(test())\n}\n\nclass C {\n    val bar = <!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!><!UNINITIALIZED_VARIABLE!>test<!>()<!>\n    val test = <!NI;TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!NI;DEBUG_INFO_MISSING_UNRESOLVED, OI;FUNCTION_EXPECTED!>bar<!>()<!>\n}"
        },
        {
            "code": "// !LANGUAGE: -AllowBreakAndContinueInsideWhen\n\nfun breakContinueInWhen(i: Int) {\n    for (y in 0..10) {\n        when(i) {\n            0 -> <!BREAK_OR_CONTINUE_IN_WHEN!>continue<!>\n            1 -> <!BREAK_OR_CONTINUE_IN_WHEN!>break<!>\n            2 -> {\n                for(z in 0..10) {\n                    break\n                }\n                for(w in 0..10) {\n                    continue\n                }\n            }\n        }\n    }\n}\n\n\nfun breakContinueInWhenWithWhile(i: Int, j: Int) {\n    while (i > 0) {\n        when (i) {\n            0 -> <!BREAK_OR_CONTINUE_IN_WHEN!>continue<!>\n            1 -> <!BREAK_OR_CONTINUE_IN_WHEN!>break<!>\n            2 -> {\n                while (j > 0) {\n                    break\n                }\n            }\n        }\n    }\n}\n\nfun breakContinueInWhenWithDoWhile(i: Int, j: Int) {\n    do {\n        when (i) {\n            0 -> <!BREAK_OR_CONTINUE_IN_WHEN!>continue<!>\n            1 -> <!BREAK_OR_CONTINUE_IN_WHEN!>break<!>\n            2 -> {\n                do {\n                    if (j == 5) break\n                    if (j == 10) continue\n                } while (j > 0)\n            }\n        }\n    } while (i > 0)\n}\n\nfun labeledBreakContinue(i: Int) {\n    outer@ for (y in 0..10) {\n        when (i) {\n            0 -> continue@outer\n            1 -> break@outer\n        }\n    }\n}\n"
        },
        {
            "code": "abstract class A {\n    abstract var x: Int;\n    abstract fun foo() : Int;\n}\n\nabstract class C : A() {\n    override abstract var x: <!VAR_TYPE_MISMATCH_ON_OVERRIDE!>String<!> =<!SYNTAX!><!> <!SYNTAX!>?<!>\n    override abstract fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String<!> =<!SYNTAX!><!> <!SYNTAX!>?<!>\n}\n"
        },
        {
            "code": "// No supertype at all\n\nfun Any.extension(<!UNUSED_PARAMETER!>arg<!>: Any?) {}\n\nclass A1 {\n    fun test() {\n        <!SUPER_CANT_BE_EXTENSION_RECEIVER!>super<!>.extension(null) // Call to an extension function\n    }\n}\n"
        },
        {
            "code": "// FILE: f.kt\nclass A() {\n  fun foo() : Unit {\n    <!UNUSED_EXPRESSION!>this@A<!>\n    this<!UNRESOLVED_REFERENCE!>@a<!>\n    <!UNUSED_EXPRESSION!>this<!>\n  }\n\n  val x = this@A.<!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n  val y = this.<!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n  val z = <!DEBUG_INFO_LEAKING_THIS!>foo<!>()\n}"
        },
        {
            "code": "interface Base {\n    fun foo()\n}\nval String.test: Base = <!EXTENSION_PROPERTY_WITH_BACKING_FIELD!>object: Base<!> {\n    override fun foo() {\n        this<!UNRESOLVED_REFERENCE!>@test<!>\n    }\n}"
        },
        {
            "code": "interface IBase<T> {\n    fun foo() {}\n    fun bar() {}\n}\n\ninterface IDerived<T> : IBase<T> {\n    override fun foo() {}\n    fun qux() {}\n}\n\nclass Test : IDerived<String>, IBase<String> {\n    fun test() {\n        super<<!QUALIFIED_SUPERTYPE_EXTENDED_BY_OTHER_SUPERTYPE!>IBase<!>>.foo()\n        super<<!QUALIFIED_SUPERTYPE_EXTENDED_BY_OTHER_SUPERTYPE!>IBase<!>>.bar()\n        super<IDerived>.foo()\n        super<IDerived>.bar()\n        super<IDerived>.qux()\n    }\n}"
        },
        {
            "code": "fun String.f() {\n    <!SUPER_NOT_AVAILABLE!>super@f<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>compareTo<!>(\"\")\n    <!SUPER_NOT_AVAILABLE!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>compareTo<!>(\"\")\n}"
        },
        {
            "code": "open class A {\n    open fun foo() {}\n}\n\ninterface ATrait : <!INTERFACE_WITH_SUPERCLASS!>A<!> {\n\n    override fun foo() {\n        <!SUPERCLASS_NOT_ACCESSIBLE_FROM_INTERFACE!>super<A><!>.foo()\n    }\n}"
        },
        {
            "code": "fun foo() {\n    <!SUPER_IS_NOT_AN_EXPRESSION!>super<!>\n    <!SUPER_NOT_AVAILABLE!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n    <!SUPER_NOT_AVAILABLE!>super<Nothing><!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nopen class A {\n    operator fun invoke() {}\n    operator fun invoke(f: () -> Unit) {}\n}\n\nclass B : A() {\n    fun bar() {\n        <!SUPER_IS_NOT_AN_EXPRESSION!>super<!>()\n        (<!SUPER_IS_NOT_AN_EXPRESSION!>super<!>)()\n        <!SUPER_IS_NOT_AN_EXPRESSION!>super<!> {}\n        (<!SUPER_IS_NOT_AN_EXPRESSION!>super<!>) {}\n    }\n}"
        },
        {
            "code": "interface IBase {\n    fun foo() {}\n    fun bar() {}\n}\n\ninterface IDerived1 : IBase {\n    override fun foo() {}\n    fun qux() {}\n}\n\ninterface IDerived2 : IBase {\n    override fun foo() {}\n}\n\nclass Test : IDerived1, IBase, IDerived2 {\n    override fun foo() {}\n\n    fun test() {\n        super<<!QUALIFIED_SUPERTYPE_EXTENDED_BY_OTHER_SUPERTYPE!>IBase<!>>.foo()\n        super<<!QUALIFIED_SUPERTYPE_EXTENDED_BY_OTHER_SUPERTYPE!>IBase<!>>.bar()\n\n        super<IDerived1>.foo()\n        super<IDerived1>.bar()\n        super<IDerived1>.qux()\n\n        super<IDerived2>.foo()\n        super<IDerived2>.bar()\n    }\n}"
        },
        {
            "code": "class Dup {\n  fun Dup() : Unit {\n    this<!AMBIGUOUS_LABEL!>@Dup<!>\n  }\n}"
        },
        {
            "code": "fun any(<!UNUSED_PARAMETER!>a<!> : Any) {}\n\nfun notAnExpression() {\n    any(<!SUPER_IS_NOT_AN_EXPRESSION!>super<!>) // not an expression\n    if (<!SUPER_IS_NOT_AN_EXPRESSION!>super<!>) {} else {} // not an expression\n    val <!UNUSED_VARIABLE!>x<!> = <!SUPER_IS_NOT_AN_EXPRESSION!>super<!> // not an expression\n    when (1) {\n        <!SUPER_IS_NOT_AN_EXPRESSION!>super<!> -> <!UNUSED_EXPRESSION!>1<!> // not an expression\n        else -> {}\n    }\n\n}"
        },
        {
            "code": "fun foo1() : Unit {\n  <!NO_THIS!>this<!>\n  this<!UNRESOLVED_REFERENCE!>@a<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nclass A(val a:Int) {\n\n  inner class B() {\n    val x = checkSubtype<B>(<!DEBUG_INFO_LEAKING_THIS!>this@B<!>)\n    val y = checkSubtype<A>(this@A)\n    val z = checkSubtype<B>(<!DEBUG_INFO_LEAKING_THIS!>this<!>)\n    val Int.xx : Int get() = checkSubtype<Int>(this)\n  }\n}"
        },
        {
            "code": "open class A {\n    open fun foo() {}\n}\n\ninterface B {\n    fun bar() {}\n}\n\ninterface Q {\n    fun qux() {}\n}\n\nclass C : A(), B {\n    override fun foo() {\n        super@C.foo()\n    }\n\n    override fun bar() {\n        super@C.bar()\n    }\n\n    inner class D : A(), Q {\n        override fun foo() {\n            super@C.foo()\n            super@D.foo()\n        }\n\n        override fun qux() {\n            super@C.<!UNRESOLVED_REFERENCE!>qux<!>()\n            super@D.qux()\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nopen class GenericBaseClass<T> {\n    open fun foo(x: T): T = x\n    open fun ambiguous(x: T): T = x\n}\n\ninterface GenericBaseInterface<T> {\n    fun bar(x: T): T = x\n    fun ambiguous(x: T): T = x\n}\n\nclass GenericDerivedClass<T> : GenericBaseClass<T>(), GenericBaseInterface<T> {\n    override fun foo(x: T): T = super.foo(x)\n    override fun bar(x: T): T = super.bar(x)\n\n    override fun ambiguous(x: T): T =\n            <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>(x)\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>SpecializedDerivedClass<!> : GenericBaseClass<Int>(), GenericBaseInterface<String> {\n    override fun foo(x: Int): Int = super.foo(x)\n    override fun bar(x: String): String = super.bar(x)\n\n    override fun ambiguous(x: String): String =\n            <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>(x)\n    override fun ambiguous(x: Int): Int =\n            <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>(x)\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>MixedDerivedClass<!><T> : GenericBaseClass<Int>(), GenericBaseInterface<T> {\n    override fun foo(x: Int): Int = super.foo(x)\n    override fun bar(x: T): T = super.bar(x)\n\n    override fun ambiguous(x: Int): Int =\n            <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>(x)\n    <!CONFLICTING_JVM_DECLARATIONS!>override fun ambiguous(x: T): T<!> =\n            <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>(x)\n}"
        },
        {
            "code": "//  Interface  AnotherInterface\n//          \\  /\n//           \\/\n//     DerivedInterface\n//\n\ninterface Interface {\n    fun foo() {}\n    fun ambiguous() {}\n    val ambiguousProp: Int\n        get() = 222\n}\n\ninterface AnotherInterface {\n    fun ambiguous() {}\n    val ambiguousProp: Int\n        get() = 333\n}\n\ninterface DerivedInterface: Interface, AnotherInterface {\n    override fun foo() { super.foo() }\n    override fun ambiguous() {\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>()\n    }\n    override val ambiguousProp: Int\n        get() = <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguousProp<!>\n}\n\n"
        },
        {
            "code": "// fun foo:     abstract in A,      unresolved in I\n// fun bar:     implemented in A,   abstract in I\n// fun qux:     abstract in A,      abstract in I\n// val x:       unresolved in A,    abstract in I\n// val y:       abstract in A,      implemented in I\n\nabstract class A {\n    abstract fun foo(): Int\n    open fun bar() {}\n    abstract fun qux()\n\n    abstract val y: Int\n}\n\ninterface I {\n    fun bar()\n    fun qux()\n\n    val x: Int\n    val y: Int get() = 111\n}\n\nclass B : A(), I {\n    override val x: Int = 12345\n    override val y: Int = super.y\n\n    override fun foo(): Int {\n        super.<!ABSTRACT_SUPER_CALL!>foo<!>()\n        return super.<!ABSTRACT_SUPER_CALL!>x<!>\n    }\n\n    override fun bar() {\n        super.bar()\n    }\n\n    override fun qux() {\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>qux<!>()\n    }\n}\n"
        },
        {
            "code": "// Check that unresolved super type doesn't interfere with unqualified super resolution.\n\nopen class Base() {\n    open fun foo() {}\n\n    open fun ambiguous() {}\n\n    open val prop: Int\n        get() = 1234\n\n    open val ambiguousProp: Int\n        get() = 111\n}\n\ninterface Interface {\n    fun bar() {}\n\n    fun ambiguous() {}\n\n    val ambiguousProp: Int\n        get() = 222\n}\n\nclass ClassDerivedFromUnresolved : Base(), Interface, <!UNRESOLVED_REFERENCE!>Unresolved<!> {\n    override fun foo() {}\n    override fun bar() {}\n\n    override fun ambiguous() {}\n\n    override val ambiguousProp: Int\n        get() = 333\n\n    override val prop: Int\n        get() = 4321\n\n    fun callsFunFromSuperClass() {\n        super.foo()\n    }\n\n    fun getSuperProp(): Int =\n            super.prop\n\n    fun getAmbiguousSuperProp(): Int =\n    <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguousProp<!>\n\n    fun callsFunFromSuperInterface() {\n        super.bar()\n    }\n\n    fun callsAmbiguousSuperFun() {\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// Ambiguity between fun and callable property\n\nopen class BaseWithCallableProp {\n    val fn = { \"fn.invoke()\" }\n\n    val bar = { \"bar.invoke()\"}\n    open fun bar(): String = \"bar()\"\n}\n\ninterface InterfaceWithFun {\n    fun fn(): String = \"fn()\"\n}\n\nclass DerivedUsingFun : BaseWithCallableProp(), InterfaceWithFun {\n    fun foo(): String =\n    <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>fn<!>()\n\n    override fun bar(): String =\n            super.bar()\n}"
        },
        {
            "code": "interface A {\n    fun foo() {}\n}\n\nabstract class C : A {\n    override abstract fun foo()\n}\n\ninterface Unrelated {\n    fun foo() {}\n}\n\nclass Test1 : C(), A {\n    override fun foo() {\n        // Abstract 'foo' defined in 'C' wins against non-abstract 'foo' defined in 'A',\n        // because 'C' is a subclass of 'A' (and 'C::foo' overrides 'A::foo'),\n        // even though 'A' is explicitly listed in supertypes list for 'D'.\n        super.<!ABSTRACT_SUPER_CALL!>foo<!>()\n    }\n}\n\nclass Test2 : C(), A, Unrelated {\n    override fun foo() {\n        // This is ok, because there's a non-abstract 'foo' in 'Unrelated',\n        // which is not overridden by abstract 'foo' in 'C'.\n        super.foo()\n        super<Unrelated>.foo()\n    }\n}"
        },
        {
            "code": "//  Base  Interface\n//     \\  /\n//      \\/\n//    Derived\n//\n\nopen class Base() {\n    open fun foo() {}\n\n    open fun ambiguous() {}\n\n    open val prop: Int\n        get() = 1234\n\n    open val ambiguousProp: Int\n        get() = 111\n}\n\ninterface Interface {\n    fun bar() {}\n\n    fun ambiguous() {}\n\n    val ambiguousProp: Int\n        get() = 222\n}\n\nclass Derived : Base(), Interface {\n    override fun foo() {}\n    override fun bar() {}\n\n    override fun ambiguous() {}\n\n    override val ambiguousProp: Int\n        get() = 333\n\n    override val prop: Int\n        get() = 4321\n\n    fun callsFunFromSuperClass() {\n        super.foo()\n    }\n\n    fun getSuperProp(): Int =\n            super.prop\n\n    fun getAmbiguousSuperProp(): Int =\n            <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguousProp<!>\n\n    fun callsFunFromSuperInterface() {\n        super.bar()\n    }\n\n    fun callsAmbiguousSuperFun() {\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>ambiguous<!>()\n    }\n}\n"
        },
        {
            "code": "interface Interface {\n    fun foo(x: Int): Int\n}\n\nfun withLocalClasses(param: Int): Interface {\n    open class LocalBase {\n        open val param: Int\n            get() = 100\n    }\n\n    <!LOCAL_INTERFACE_NOT_ALLOWED!>interface LocalInterface<!> : Interface {\n        override fun foo(x: Int): Int =\n                x + param\n    }\n\n    return object : LocalBase(), LocalInterface {\n        override fun foo(x: Int): Int =\n                x + super.param\n    }\n\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nclass A(val a:Int) {\n  inner class B() {\n    fun Byte.xx() : Double.() -> Any {\n      checkSubtype<Byte>(this)\n      val <!UNUSED_VARIABLE!>a<!>: Double.() -> Unit = {\n        checkSubtype<Double>(this)\n        checkSubtype<Byte>(this@xx)\n        checkSubtype<B>(this@B)\n        checkSubtype<A>(this@A)\n      }\n      val <!UNUSED_VARIABLE!>b<!>: Double.() -> Unit = a@{ checkSubtype<Double>(this@a) + checkSubtype<Byte>(this@xx) }\n      val <!UNUSED_VARIABLE!>c<!> = a@{ -> <!NO_THIS!>this@a<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> checkSubtype<Byte>(this@xx) }\n      return (a@{checkSubtype<Double>(this@a) + checkSubtype<Byte>(this@xx)})\n    }\n  }\n}"
        },
        {
            "code": "package example\n\ninterface T {\n    fun foo() {}\n}\nopen class C() {\n    fun bar() {}\n}\n\nclass A<E>() : C(), T {\n\n    fun test() {\n        <!SUPER_IS_NOT_AN_EXPRESSION!>super<!>\n        <!SUPER_IS_NOT_AN_EXPRESSION!>super<T><!>\n        super.foo()\n        super<T>.foo()\n        super<C>.bar()\n        super<T>@A.foo()\n        super<C>@A.bar()\n        super<<!NOT_A_SUPERTYPE!>E<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n        super<<!NOT_A_SUPERTYPE!>E<!>>@A.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n        super<<!NOT_A_SUPERTYPE!>Int<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n        super<<!SYNTAX!><!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n        super<<!NOT_A_SUPERTYPE!>() -> Unit<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n        super<<!NOT_A_SUPERTYPE!>Unit<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n        <!DEBUG_INFO_MISSING_UNRESOLVED!>super<!><T><!UNRESOLVED_REFERENCE!>@B<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n        <!DEBUG_INFO_MISSING_UNRESOLVED!>super<!><C><!UNRESOLVED_REFERENCE!>@B<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n    }\n\n    inner class B : T {\n        fun test() {\n            super<T>.foo();\n            super<<!NOT_A_SUPERTYPE!>C<!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n            super<C>@A.bar()\n            super<T>@A.foo()\n            super<T>@B.foo()\n            super<<!NOT_A_SUPERTYPE!>C<!>>@B.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>()\n            super.foo()\n            <!SUPER_IS_NOT_AN_EXPRESSION!>super<!>\n            <!SUPER_IS_NOT_AN_EXPRESSION!>super<T><!>\n        }\n    }\n}\n\ninterface G<T> {\n    fun foo() {}\n}\n\nclass CG : G<Int> {\n    fun test() {\n        super<G>.foo() // OK\n        super<G<!TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER!><Int><!>>.foo() // Warning\n        super<<!NOT_A_SUPERTYPE!>G<<!UNRESOLVED_REFERENCE!>E<!>><!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>() // Error\n        super<<!NOT_A_SUPERTYPE!>G<String><!>>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!>() // Error\n    }\n}\n\n// The case when no supertype is resolved\nclass ERROR<E>() : <!UNRESOLVED_REFERENCE!>UR<!> {\n\n    fun test() {\n        super.<!UNRESOLVED_REFERENCE!>foo<!>()\n    }\n}\n"
        },
        {
            "code": "data class D(val x: Int, val y: Int, val z: Int)\nfun foo(): Int {\n    val (<!UNUSED_VARIABLE!>x<!>, y, z) = D(1, 2, 3)\n    return y + z // x is not used, but we cannot do anything with it\n}\nfun bar(): Int {\n    val (x, y, <!UNUSED_VARIABLE!>z<!>) = D(1, 2, 3)\n    return y + x // z is not used\n}\n"
        },
        {
            "code": "//!LANGUAGE: -ProhibitTailrecOnVirtualMember\n\nopen class A {\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec open fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>internal tailrec open fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>protected tailrec open fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    private tailrec fun boo(y: Int) {\n        boo(y)\n    }\n\n    internal tailrec fun baa(y: Int) {\n        baa(y)\n    }\n}\n\nopen class B : A() {\n    final tailrec override fun foo(x: Int) {\n        foo(x)\n    }\n\n    final tailrec override fun bar(y: Int) {\n        bar(y)\n    }\n\n    final tailrec override fun baz(y: Int) {\n        baz(y)\n    }\n}\n\n\nopen class C : A() {\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec override fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec override fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec override fun baz(y: Int)<!> {\n        baz(y)\n    }\n}\n\nobject D : A() {\n    tailrec override fun foo(x: Int) {\n        foo(x)\n    }\n\n    tailrec override fun bar(y: Int) {\n        bar(y - 1)\n    }\n\n    tailrec override fun baz(y: Int) {\n        baz(y)\n    }\n}\n\nsealed class E : A() {\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec override fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec override fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec override fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    class E1 : E() {\n        tailrec override fun foo(x: Int) {\n            foo(x)\n        }\n\n        tailrec override fun bar(y: Int) {\n            bar(y)\n        }\n\n        tailrec override fun baz(y: Int) {\n            baz(y)\n        }\n    }\n}\n\nenum class F {\n    F0,\n    F1() {\n        tailrec override fun foo(x: Int) {\n            foo(x)\n        }\n\n        tailrec override fun bar(y: Int) {\n            bar(y)\n        }\n\n        tailrec override fun baz(y: Int) {\n            baz(y)\n        }\n    };\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec open fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>internal tailrec open fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>protected tailrec open fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    private tailrec fun boo(y: Int) {\n        boo(y)\n    }\n\n    internal tailrec fun baa(y: Int) {\n        baa(y)\n    }\n}\n\nenum class G {\n\n    G1;\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>tailrec open fun foo(x: Int)<!> {\n        foo(x)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>internal tailrec open fun bar(y: Int)<!> {\n        bar(y)\n    }\n\n    <!TAILREC_ON_VIRTUAL_MEMBER!>protected tailrec open fun baz(y: Int)<!> {\n        baz(y)\n    }\n\n    private tailrec fun boo(y: Int) {\n        boo(y)\n    }\n\n    internal tailrec fun baa(y: Int) {\n        baa(y)\n    }\n}\n\n\nval z = object : A() {\n    tailrec override fun foo(x: Int) {\n        foo(x)\n    }\n\n    tailrec override fun bar(y: Int) {\n        bar(y)\n    }\n\n    tailrec override fun baz(y: Int) {\n        baz(y)\n    }\n}"
        },
        {
            "code": "class A private <!MISSING_CONSTRUCTOR_BRACKETS!>constructor<!><!SYNTAX!><!> {\n}\n"
        },
        {
            "code": "// !LANGUAGE: -DivisionByZeroInConstantExpressions\n// !DIAGNOSTICS:-DIVISION_BY_ZERO\n\nconst val a = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1 / 0.0<!>\nconst val b = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1.0 / 0<!>\nconst val c = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.0 / 0<!>\nconst val d = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1.0 % 0<!>\nconst val e = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.0 % 0<!>\nconst val f = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.0.<!DEPRECATION_ERROR!>mod<!>(0)<!>\nconst val g = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.0.rem(0)<!>\nconst val h = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.0.div(0)<!>\n\nconst val i = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1 / 0<!>\n\nval nonConst1 = 1.0 / 0\nval nonConst2 = 1 / 0\nval nonConst3 = 1.0 % 0\nval nonConst4 = 1 % 0\nval nonConst5 = 1.<!DEPRECATION_ERROR!>mod<!>(0)\nval nonConst6 = 1.rem(0)\nval nonConst7 = 1.div(0)\n"
        },
        {
            "code": "const val aConst = 1\nconst val bConst = aConst + 1\n\nconst val boolVal = bConst > 1 || (B.boolVal && A.boolVal)\nconst val stringInterpolation = \"Result: ${B.boolVal}\"\n\nobject A {\n    const val boolVal = bConst + 3 == 5\n\n    const val recursive1: Int = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1 + B.recursive2<!>\n}\n\nclass B {\n    companion object {\n        const val boolVal = A.boolVal\n        const val recursive2: Int = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>A.recursive1 + 2<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nconst val intConst = 1\nconst val longConst: Long = 1\nconst val boolConst = true\nconst val stringConst = \"empty\"\n\nenum class MyEnum { A }\n\n<!TYPE_CANT_BE_USED_FOR_CONST_VAL!>const<!> val enumConst: MyEnum = MyEnum.A\n<!TYPE_CANT_BE_USED_FOR_CONST_VAL!>const<!> val arrayConst: Array<String> = arrayOf(\"1\")\n<!TYPE_CANT_BE_USED_FOR_CONST_VAL!>const<!> val intArrayConst: IntArray = intArrayOf()\n\nconst val unresolvedConst1 = <!UNRESOLVED_REFERENCE!>Unresolved<!>\n<!WRONG_MODIFIER_TARGET!>const<!> var unresolvedConst2 = <!UNRESOLVED_REFERENCE!>Unresolved<!>\nconst val unresolvedConst3 = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD, UNRESOLVED_REFERENCE!>Unresolved<!>\n<!CONST_VAL_WITH_GETTER!>get() = 10<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS:-UNUSED_VARIABLE,-CAST_NEVER_SUCCEEDS,-DIVISION_BY_ZERO\n\nimport kotlin.reflect.KProperty\n\nconst val topLevel: Int = 0\nconst val topLevelInferred = 1\n<!WRONG_MODIFIER_TARGET!>const<!> var topLeveLVar: Int = 2\n\nprivate val privateTopLevel = 3\n\nobject A {\n    const val inObject: Int = 4\n}\n\nclass B(<!CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT!>const<!> val constructor: Int = 5)\n\nabstract class C {\n    <!INCOMPATIBLE_MODIFIERS!>open<!> <!CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT, INCOMPATIBLE_MODIFIERS!>const<!> val x: Int = 6\n\n    <!INCOMPATIBLE_MODIFIERS!>abstract<!> <!CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT, INCOMPATIBLE_MODIFIERS!>const<!> val y: Int = <!ABSTRACT_PROPERTY_WITH_INITIALIZER!>7<!>\n\n    companion object {\n        const val inCompaionObject = 8\n    }\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>object D<!> : C() {\n    <!INCOMPATIBLE_MODIFIERS!>override<!> <!INCOMPATIBLE_MODIFIERS!>const<!> val x: Int = 9\n\n    const val inObject = 10\n\n    final const val final = 11\n\n    <!CONST_VAL_WITHOUT_INITIALIZER!>const<!> val withoutInitializer: Int\n\n    init {\n        withoutInitializer = 12\n    }\n}\n\nconst val delegated: Int <!CONST_VAL_WITH_DELEGATE!>by Delegate()<!>\n\n\nconst val withGetter: Int\n    <!CONST_VAL_WITH_GETTER!>get() = 13<!>\n\nconst val withExplicitDefaultGetter: Int = 1\n    <!CONST_VAL_WITH_GETTER!>get<!>\n\nfun foo(): Int {\n    <!WRONG_MODIFIER_TARGET!>const<!> val local: Int = 14\n    return 15\n}\n\nenum class MyEnum {\n    A {\n        <!CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT!>const<!> val inEnumEntry = 16\n    };\n    <!CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT!>const<!> val inEnum = 17\n}\n\nclass Outer {\n    inner class Inner {\n        <!NESTED_CLASS_NOT_ALLOWED(\"Object\")!>object C<!> {\n            const val a = 18\n        }\n    }\n}\n\nconst val defaultGetter = 19\n    <!CONST_VAL_WITH_GETTER!>get<!>\n\nconst val nonConstInitializer1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>foo()<!>\nconst val nonConstInitializer2 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1 as String<!>\nconst val nonConstInitializer3 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1.0 as String<!>\nconst val nonConstInitializer4 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1 as Double<!>\nconst val nonConstInitializer5 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>\"2\" as Int<!>\nconst val nonConstInitializer6 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1/0<!>\nconst val nonConstInitializer7 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>-1/0<!>\nconst val nonConstInitializer8 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1/0 - 1/0<!>\nconst val nonConstInitializer9 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1.0/0.0 - 1/0<!>\nconst val nonConstInitializer10 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0/0<!>\nconst val nonConstInitializer11 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>1 % 0<!>\nconst val nonConstInitializer12 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0 % 0<!>\nconst val nonConstInitializer13 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.<!DEPRECATION_ERROR!>mod<!>(0)<!>\nconst val nonConstInitializer14 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.rem(0)<!>\nconst val nonConstInitializer15 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER!>0.div(0)<!>\n\nconst val constInitializer1 = 1.0/0\nconst val constInitializer2 = 1/0.0\nconst val constInitializer3 = 1.0/0.0\nconst val constInitializer4 = -1.0/0\nconst val constInitializer5 = 0.0/0\nconst val constInitializer6 = 42 + 1.0/0\nconst val constInitializer7 = 42 - 1.0/0\nconst val constInitializer8 = 1.0/0 - 1.0/0\nconst val constInitializer9 = 0.0/0 + 1.0/0\nconst val constInitializer10 = 1.0 % 0\nconst val constInitializer11 = 0.0 % 0\nconst val constInitializer12 = (-1.0) % 0\nconst val constInitializer13 = 1.0.rem(0)\nconst val constInitializer14 = 1.0.<!DEPRECATION_ERROR!>mod<!>(0)\nconst val constInitializer15 = 1.0.div(0)\n\n// ------------------\nclass Delegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): Int = 1\n\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: Int) = Unit\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nannotation class Ann(val x: Int)\n\n@Ann(A.X)\nfun main1() {}\n\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>A.Y<!>)\nfun main2() {}\n\nval q = A()\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>q.z<!>)\nfun main3() {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nannotation class A(val a: IntArray = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(1)<!>)\nannotation class B(val a: IntArray = intArrayOf(1))"
        },
        {
            "code": "class My(protected val x: Int) {\n    class Her(protected val x: Int)\n\n    inner class Its(protected val x: Int)\n}\n\nobject Your {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> fun foo() = 3\n}\n\nannotation class His(<!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> val x: Int)\n\nenum class Our(protected val x: Int) {\n    FIRST(42) {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> fun foo() = 13\n    }\n}\n\ninterface Their {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> fun foo() = 7\n}"
        },
        {
            "code": "interface My {\n    <!REDUNDANT_OPEN_IN_INTERFACE!>open<!> fun foo()\n    open fun bar() {}\n    <!REDUNDANT_MODIFIER!>open<!> abstract fun baz(): Int\n\n    <!REDUNDANT_OPEN_IN_INTERFACE!>open<!> val x: Int\n    open val y: String\n        get() = \"\"\n    <!REDUNDANT_MODIFIER!>open<!> abstract val z: Double\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nannotation class Ann(val x: Int = 1)\nclass A <!MISSING_CONSTRUCTOR_KEYWORD!>private<!> (val x: Int) {\ninner class B <!MISSING_CONSTRUCTOR_KEYWORD!>@Ann(2)<!> (val y: Int)\n\nfun foo() {\n    class C <!MISSING_CONSTRUCTOR_KEYWORD!>private @Ann(3)<!> (args: Int)\n    }\n}\n"
        },
        {
            "code": "@<!UNRESOLVED_REFERENCE!><!SYNTAX!><!>myAnnotation<!> <!WRONG_MODIFIER_TARGET!>public<!>\npackage illegal_modifiers\n\nabstract class A() {\n    <!INCOMPATIBLE_MODIFIERS!>abstract<!> <!INCOMPATIBLE_MODIFIERS!>final<!> fun f()\n    abstract <!REDUNDANT_MODIFIER!>open<!> fun g()\n    <!INCOMPATIBLE_MODIFIERS!>final<!> <!INCOMPATIBLE_MODIFIERS!>open<!> fun h() {}\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>open var r: String<!>\n    get\n    <!WRONG_MODIFIER_TARGET!>abstract<!> protected set\n}\n\n<!WRONG_MODIFIER_TARGET!>final<!> interface T {}\n\nclass FinalClass() {\n    <!NON_FINAL_MEMBER_IN_FINAL_CLASS!>open<!> fun foo() {}\n    val i: Int = 1\n        <!WRONG_MODIFIER_TARGET!>open<!> get(): Int = field\n    var j: Int = 1\n        <!WRONG_MODIFIER_TARGET!>open<!> set(<!UNUSED_PARAMETER!>v<!>: Int) {}\n}\n\n<!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>public<!> class C\n<!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>public<!> object D\n\n//A sample annotation to check annotation usage in parameters.\nannotation class annotated(val text: String = \"not given\")\n\n//Check legal modifiers in constructor\nclass LegalModifier(val a: Int, @annotated private var b: String, @annotated vararg <!UNUSED_PARAMETER!>v<!>: Int)\n\n//Check illegal modifier in constructor parameters\nclass IllegalModifiers1(\n        <!WRONG_MODIFIER_TARGET!>in<!>\n        <!INCOMPATIBLE_MODIFIERS!>out<!>\n        <!WRONG_MODIFIER_TARGET!>reified<!>\n        <!WRONG_MODIFIER_TARGET!>enum<!>\n        <!WRONG_MODIFIER_TARGET!>private<!>\n        <!WRONG_MODIFIER_TARGET!>const<!>\n        <!UNUSED_PARAMETER!>a<!>: Int)\n\n//Check multiple illegal modifiers in constructor\nclass IllegalModifiers2(<!WRONG_MODIFIER_TARGET!>private<!> <!INCOMPATIBLE_MODIFIERS!>abstract<!> <!UNUSED_PARAMETER!>a<!>: Int)\n\n\n//Check annotations with illegal modifiers in constructor\nclass IllegalModifiers3(@annotated <!WRONG_MODIFIER_TARGET!>public<!> <!WRONG_MODIFIER_TARGET!>abstract<!> <!UNUSED_PARAMETER!>b<!>: String)\n\n//Check annotations and vararg with illegal modifiers in constructor\nclass IllegalModifiers4(val a: Int, @annotated(\"a text\") <!WRONG_MODIFIER_TARGET!>protected<!> vararg <!UNUSED_PARAMETER!>v<!>: Int)\n\n//Check illegal modifiers for functions and catch block\nabstract class IllegalModifiers5() {\n\n  //Check illegal modifier in function parameter\n  abstract fun foo(<!WRONG_MODIFIER_TARGET!>public<!> a: Int, vararg v: String)\n\n  //Check multiple illegal modifiers in function parameter\n  abstract fun bar(<!WRONG_MODIFIER_TARGET!>public<!> <!WRONG_MODIFIER_TARGET!>abstract<!> a: Int, vararg v: String)\n\n  //Check annotations with illegal modifiers\n  abstract fun baz(@annotated(\"a text\") <!WRONG_MODIFIER_TARGET!>public<!> <!WRONG_MODIFIER_TARGET!>abstract<!> a: Int)\n\n  private fun qux() {\n\n    //Check illegal modifier in catch block\n    try {} catch (<!WRONG_MODIFIER_TARGET!>in<!> <!INCOMPATIBLE_MODIFIERS!>out<!> <!WRONG_MODIFIER_TARGET!>reified<!> <!WRONG_MODIFIER_TARGET!>enum<!> <!WRONG_MODIFIER_TARGET!>public<!> e: Exception) {}\n\n    //Check multiple illegal modifiers in catch block\n    try {} catch (<!WRONG_MODIFIER_TARGET!>in<!> <!INCOMPATIBLE_MODIFIERS!>out<!> <!WRONG_MODIFIER_TARGET!>reified<!> <!WRONG_MODIFIER_TARGET!>enum<!> <!WRONG_MODIFIER_TARGET!>abstract<!> <!WRONG_MODIFIER_TARGET!>public<!> e: Exception) {}\n\n    //Check annotations with illegal modifiers\n    try {} catch (@annotated(\"a text\") <!WRONG_MODIFIER_TARGET!>abstract<!> <!WRONG_MODIFIER_TARGET!>public<!> e: Exception) {}\n  }\n}\n\n//Check illegal modifiers on anonymous initializers\nabstract class IllegalModifiers6() {\n    <!WRONG_MODIFIER_TARGET!>public<!> init {}\n    <!WRONG_MODIFIER_TARGET!>private<!> init {}\n    <!WRONG_MODIFIER_TARGET!>protected<!> init {}\n    <!WRONG_MODIFIER_TARGET!>vararg<!> init {}\n    <!WRONG_MODIFIER_TARGET!>abstract<!> init {}\n    <!WRONG_MODIFIER_TARGET!>open<!> init {}\n    <!WRONG_MODIFIER_TARGET!>final<!> init {}\n\n    <!WRONG_MODIFIER_TARGET!>public<!> <!WRONG_ANNOTATION_TARGET!>@annotated<!> init {}\n\n    <!WRONG_MODIFIER_TARGET!>private<!> <!NOT_AN_ANNOTATION_CLASS, WRONG_ANNOTATION_TARGET!>@IllegalModifiers6()<!> init {}\n}\n\n// strange inappropriate modifiers usages\n<!WRONG_MODIFIER_TARGET!>override<!>\n<!WRONG_MODIFIER_TARGET!>out<!>\n<!INCOMPATIBLE_MODIFIERS!>in<!>\n<!WRONG_MODIFIER_TARGET!>vararg<!>\n<!WRONG_MODIFIER_TARGET!>reified<!>\nclass IllegalModifiers7() {\n    <!WRONG_MODIFIER_TARGET!>enum<!>\n    <!WRONG_MODIFIER_TARGET!>inner<!>\n    <!WRONG_MODIFIER_TARGET!>annotation<!>\n    <!WRONG_MODIFIER_TARGET!>out<!>\n    <!INCOMPATIBLE_MODIFIERS!>in<!>\n    <!WRONG_MODIFIER_TARGET!>vararg<!>\n    <!WRONG_MODIFIER_TARGET!>reified<!>\n    val x = 1\n    <!WRONG_MODIFIER_TARGET!>enum<!>\n    <!WRONG_MODIFIER_TARGET!>inner<!>\n    <!WRONG_MODIFIER_TARGET!>annotation<!>\n    <!WRONG_MODIFIER_TARGET!>out<!>\n    <!INCOMPATIBLE_MODIFIERS!>in<!>\n    <!WRONG_MODIFIER_TARGET!>vararg<!>\n    <!WRONG_MODIFIER_TARGET!>reified<!>\n    <!WRONG_MODIFIER_TARGET!>const<!>\n    fun foo() {}\n}\n\n// Secondary constructors\nclass IllegalModifiers8 {\n    <!WRONG_MODIFIER_TARGET!>abstract<!>\n    enum\n    <!REDUNDANT_MODIFIER, WRONG_MODIFIER_TARGET!>open<!>\n    <!WRONG_MODIFIER_TARGET!>inner<!>\n    <!WRONG_MODIFIER_TARGET!>annotation<!>\n    <!WRONG_MODIFIER_TARGET!>override<!>\n    <!WRONG_MODIFIER_TARGET!>out<!>\n    <!INCOMPATIBLE_MODIFIERS!>in<!>\n    <!INCOMPATIBLE_MODIFIERS!>final<!>\n    <!WRONG_MODIFIER_TARGET!>vararg<!>\n    <!WRONG_MODIFIER_TARGET!>reified<!>\n    <!INCOMPATIBLE_MODIFIERS!>const<!><!SYNTAX!><!>\n    constructor() {}\n\n    constructor(<!WRONG_MODIFIER_TARGET!>private<!> <!WRONG_MODIFIER_TARGET!>enum<!> <!INCOMPATIBLE_MODIFIERS!>abstract<!> <!UNUSED_PARAMETER!>x<!>: Int) {}\n}\n\nclass IllegalModifiers9 {\n    <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>protected<!> constructor() {}\n    <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>internal<!> constructor(<!UNUSED_PARAMETER!>x<!>: Int) {}\n}\n\n// Illegal modifiers on primary constructor\n\nclass IllegalModifiers10\n<!WRONG_MODIFIER_TARGET!>abstract<!>\n<!WRONG_MODIFIER_TARGET!>enum<!>\n<!REDUNDANT_MODIFIER, WRONG_MODIFIER_TARGET!>open<!>\n<!WRONG_MODIFIER_TARGET!>inner<!>\n<!WRONG_MODIFIER_TARGET!>annotation<!>\n<!WRONG_MODIFIER_TARGET!>override<!>\n<!WRONG_MODIFIER_TARGET!>out<!>\n<!INCOMPATIBLE_MODIFIERS!>in<!>\n<!INCOMPATIBLE_MODIFIERS!>final<!>\n<!WRONG_MODIFIER_TARGET!>vararg<!>\n<!WRONG_MODIFIER_TARGET!>reified<!>\n<!INCOMPATIBLE_MODIFIERS!>const<!> constructor()\n\nclass IllegalModifiers11 <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>protected<!> constructor()\n\nclass Outer {\n    <!INCOMPATIBLE_MODIFIERS!>inner<!> <!INCOMPATIBLE_MODIFIERS!>sealed<!> class Inner\n}\n"
        },
        {
            "code": "interface My {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>internal<!> val x: Int\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>internal<!> val xxx: Int\n        get() = 0\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>internal<!> fun foo(): Int\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>internal<!> fun bar() = 42\n}\n"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>companion<!> class A {\n    companion object {\n\n    }\n}\n\nclass B {\n    companion object\n\n    val c: Int = 1\n}\n\nclass C {\n    companion object A {\n\n    }\n}\n\nclass D {\n    companion object A {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {\n        }\n    }\n}\n\n<!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object G {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object\n}\n\n<!WRONG_MODIFIER_TARGET!>companion<!> interface H {\n    companion object\n}\n\nclass J {\n    companion object C {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object\n    }\n}\n\n<!WRONG_MODIFIER_TARGET!>companion<!> enum class Enum {\n    E1,\n    E2;\n\n    companion object\n}\n\n<!WRONG_MODIFIER_TARGET!>companion<!> fun main() {\n\n}\n\n<!WRONG_MODIFIER_TARGET!>companion<!> var prop: Int = 1\n    <!WRONG_MODIFIER_TARGET!>companion<!> get\n    <!WRONG_MODIFIER_TARGET!>companion<!> set\n\nclass Z(<!WRONG_MODIFIER_TARGET!>companion<!> val c: Int)"
        },
        {
            "code": "abstract <!REPEATED_MODIFIER!>abstract<!> class Foo\npublic <!REPEATED_MODIFIER!>public<!> class Bar\n<!INCOMPATIBLE_MODIFIERS!>open<!> <!REPEATED_MODIFIER!>open<!> <!INCOMPATIBLE_MODIFIERS!>final<!> class Baz {\n    private <!REPEATED_MODIFIER!>private<!> fun foo() {}\n}\n\nclass Bzz(public <!REPEATED_MODIFIER!>public<!> val q: Int = 1) {\n    public <!REPEATED_MODIFIER!>public<!> val x: Int = 2\n\n    public val y: Int\n        <!REDUNDANT_MODIFIER_IN_GETTER!>public<!> <!REPEATED_MODIFIER!>public<!> get() = 3\n\n    val z: Int\n        <!WRONG_MODIFIER_TARGET!>open<!> <!INCOMPATIBLE_MODIFIERS!>final<!> get() = 4\n\n    public <!REPEATED_MODIFIER!>public<!> class B(public <!REPEATED_MODIFIER!>public<!> val z: Int = 1) {\n        public <!REPEATED_MODIFIER!>public<!> val y: Int = 2\n\n        public val x: Int\n            <!REDUNDANT_MODIFIER_IN_GETTER!>public<!> <!REPEATED_MODIFIER!>public<!> get() = 3\n    }\n\n    public <!REPEATED_MODIFIER!>public<!> object C {\n        public <!REPEATED_MODIFIER!>public<!> val y: Int = 1\n        public <!REPEATED_MODIFIER!>public<!> fun z(): Int = 1\n    }\n}\n\npublic <!REPEATED_MODIFIER!>public<!> val bar: Int = 1\n\npublic <!REPEATED_MODIFIER!>public<!> fun foo(): Int = 1\n\nfun test() {\n    <!WRONG_MODIFIER_TARGET!>public<!> <!REPEATED_MODIFIER!>public<!> class B(public <!REPEATED_MODIFIER!>public<!> val z: Int = 1) {\n        public <!REPEATED_MODIFIER!>public<!> val y: Int = 2\n\n        public val x: Int\n            <!REDUNDANT_MODIFIER_IN_GETTER!>public<!> <!REPEATED_MODIFIER!>public<!> get() = 3\n    }\n}\n\n"
        },
        {
            "code": "interface My {\n    <!PRIVATE_PROPERTY_IN_INTERFACE!>private<!> val x: Int\n    <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>abstract<!> val xx: Int\n    private val xxx: Int\n        get() = 0\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> val y: Int\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>final<!> val yy: Int\n        get() = 1\n    <!PRIVATE_FUNCTION_WITH_NO_BODY!>private<!> fun foo(): Int\n    // ok\n    private fun bar() = 42\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninterface Foo<T>\ninterface Foo1<<!INCOMPATIBLE_MODIFIERS!>in<!> <!INCOMPATIBLE_MODIFIERS!>out<!> T>\ninterface Foo2<in <!REPEATED_MODIFIER!>in<!> T>\n\nfun test1(foo: Foo<<!INCOMPATIBLE_MODIFIERS!>in<!> <!INCOMPATIBLE_MODIFIERS!>out<!> Int>) = foo\nfun test2(): Foo<in <!REPEATED_MODIFIER!>in<!> Int> = throw Exception()\n\nfun test3() {\n    val f: Foo<out <!REPEATED_MODIFIER!>out<!> <!REPEATED_MODIFIER!>out<!> <!REPEATED_MODIFIER!>out<!> Int>\n\n    class Bzz<in <!REPEATED_MODIFIER!>in<!> T>\n}\n\nclass A {\n    fun <<!VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED!>out<!> <!REPEATED_MODIFIER!>out<!> T> bar() {\n    }\n}\n\nfun test4(a: A) {\n    a.bar<<!PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT!>out<!> <!REPEATED_MODIFIER!>out<!> Int>()\n}\n"
        },
        {
            "code": "annotation class My(\n    public val x: Int,\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>protected<!> val y: Int,\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>internal<!> val z: Int,\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>private<!> val w: Int\n)\n\nopen class Your {\n    open val x: Int = 0\n}\n\nannotation class His(<!WRONG_MODIFIER_CONTAINING_DECLARATION!>override<!> val x: Int): <!SUPERTYPES_FOR_ANNOTATION_CLASS!>Your()<!>"
        },
        {
            "code": "<!REDUNDANT_MODIFIER_FOR_TARGET!>open<!> interface First\n// Now inspection\nabstract interface Second\n// Now inspection\nfinal enum class Third {\n    FOURTH, \n    FIFTH\n}\n// Now inspection\nfinal object Sixth"
        },
        {
            "code": "fun foo() {\n    <!WRONG_MODIFIER_TARGET!>public<!> class A\n    <!WRONG_MODIFIER_TARGET!>private<!> class B\n    <!WRONG_MODIFIER_TARGET!>protected<!> class C\n    <!WRONG_MODIFIER_TARGET!>internal<!> class D\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass Example\n\nfun Example.plus(other: Example) = 0\noperator infix fun Example.minus(other: Example) = 0\n\noperator infix fun Example.times(other: Example) = 0\nfun Example.div(other: Example) = 0\n\nfun a() {\n    with (Example()) {\n        operator infix fun Example.plus(other: Example) = \"\"\n        fun Example.minus(other: Example) = \"\"\n\n        operator infix fun Example.times(other: Example) = \"\"\n        fun Example.div(other: Example) = \"\"\n\n        with (Example()) {\n            val a = Example()\n            val b = Example()\n\n            consumeString(a + b)\n            consumeInt(a - b)\n\n            consumeString(a plus b)\n            consumeInt(a minus b)\n\n            a * b\n            a <!OPERATOR_MODIFIER_REQUIRED!>/<!> b\n\n            a times b\n            a <!INFIX_MODIFIER_REQUIRED!>div<!> b\n        }\n    }\n}\n\nfun consumeInt(i: Int) {}\nfun consumeString(s: String) {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -EXTENSION_SHADOWED_BY_MEMBER\n\nclass Example {\n    operator infix fun plus(other: Example) = 0\n    fun minus(other: Example) = 0\n\n    operator infix fun times(other: Example) = 0\n    fun div(other: Example) = 0\n}\n\nfun Example.plus(other: Example) = \"\"\noperator infix fun Example.minus(other: Example) = \"\"\n\noperator infix fun Example.times(other: Example) = \"\"\nfun Example.div(other: Example) = \"\"\n\nfun a() {\n    val a = Example()\n    val b = Example()\n\n    a + b\n    a - b\n    a * b\n    a <!OPERATOR_MODIFIER_REQUIRED!>/<!> b\n\n    a plus b\n    a minus b\n    a times b\n    a <!INFIX_MODIFIER_REQUIRED!>div<!> b\n\n    with (Example()) {\n        consumeInt(this + a)\n        consumeString(this - b)\n        consumeInt(this * a)\n        consumeInt(this <!OPERATOR_MODIFIER_REQUIRED!>/<!> b)\n\n        consumeInt(this plus a)\n        consumeString(this minus b)\n        consumeInt(this times a)\n        consumeInt(this <!INFIX_MODIFIER_REQUIRED!>div<!> b)\n    }\n}\n\nfun consumeInt(i: Int) {}\nfun consumeString(s: String) {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n<!NOTHING_TO_INLINE!>inline<!> fun foo(<!ILLEGAL_INLINE_PARAMETER_MODIFIER!>noinline<!> x: Int) {}\n\n<!NOTHING_TO_INLINE!>inline<!> fun bar(y: Int, <!ILLEGAL_INLINE_PARAMETER_MODIFIER!>crossinline<!> x: String) {}\n\nfun gav(<!ILLEGAL_INLINE_PARAMETER_MODIFIER!>noinline<!> x: (Int) -> Unit, <!ILLEGAL_INLINE_PARAMETER_MODIFIER!>crossinline<!> y: (String) -> Int) {}\n\ninline fun correct(noinline x: (Int) -> Unit, crossinline y: (String) -> Int) {}\n\n<!NOTHING_TO_INLINE!>inline<!> fun incompatible(<!INCOMPATIBLE_MODIFIERS!>noinline<!> <!INCOMPATIBLE_MODIFIERS!>crossinline<!> x: () -> String) {}\n\nclass FunctionSubtype : () -> Unit {\n    override fun invoke() {}\n}\n\n<!NOTHING_TO_INLINE!>inline<!> fun functionSubtype(\n        <!ILLEGAL_INLINE_PARAMETER_MODIFIER!>noinline<!> f: FunctionSubtype,\n        <!ILLEGAL_INLINE_PARAMETER_MODIFIER!>crossinline<!> g: FunctionSubtype\n) { }\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nfun f(vararg x: Int) {}\n\nval inVal: (<!UNSUPPORTED!>vararg<!> x: Int)->Unit = {}\n\nfun inParam(fn: (<!UNSUPPORTED!>vararg<!> x: Int)->Unit) {}\n\nfun inParamNested(fn1: (fn2: (<!UNSUPPORTED!>vararg<!> n: Int)->Unit)->Unit) {}\n\nfun inReturn(): (<!UNSUPPORTED!>vararg<!> x: Int)->Unit = {}\n\nclass A : (<!UNSUPPORTED!>vararg<!> Int)->Unit {\n    override fun invoke(p1: Int) {\n        var lambda: (<!UNSUPPORTED!>vararg<!> x: Int)->Unit = {}\n    }\n\n    val prop: (<!UNSUPPORTED!>vararg<!> x: Int)->Unit\n        get(): (<!UNSUPPORTED!>vararg<!> x: Int)->Unit = {}\n}\n\nval allProhibited: (<!UNSUPPORTED!>abstract<!>\n                    <!UNSUPPORTED!>annotation<!>\n                    <!UNSUPPORTED!>companion<!>\n                    <!UNSUPPORTED!>const<!>\n                    <!UNSUPPORTED!>crossinline<!>\n                    <!UNSUPPORTED!>data<!>\n                    <!UNSUPPORTED!>enum<!>\n                    <!UNSUPPORTED!>external<!>\n                    <!UNSUPPORTED!>final<!>\n                    <!UNSUPPORTED!>in<!>\n                    <!UNSUPPORTED!>inline<!>\n                    <!UNSUPPORTED!>inner<!>\n                    <!UNSUPPORTED!>internal<!>\n                    <!UNSUPPORTED!>lateinit<!>\n                    <!UNSUPPORTED!>noinline<!>\n                    <!UNSUPPORTED!>open<!>\n                    <!UNSUPPORTED!>operator<!>\n                    <!UNSUPPORTED!>out<!>\n                    <!UNSUPPORTED!>override<!>\n                    <!UNSUPPORTED!>private<!>\n                    <!UNSUPPORTED!>protected<!>\n                    <!UNSUPPORTED!>public<!>\n                    <!UNSUPPORTED!>reified<!>\n                    <!UNSUPPORTED!>sealed<!>\n                    <!UNSUPPORTED!>tailrec<!>\n                    <!UNSUPPORTED!>vararg<!>\n\n                    x: Int)->Unit = {}\n\nval valProhibited: (<!UNSUPPORTED!>val<!> x: Int)->Unit = {}\nval varProhibited: (<!UNSUPPORTED!>var<!> x: Int)->Unit = {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun foo() {\n    <!ILLEGAL_UNDERSCORE!>1_<!>\n    <!ILLEGAL_UNDERSCORE!>0x_f<!>\n    <!ILLEGAL_UNDERSCORE!>0X_f<!>\n    <!ILLEGAL_UNDERSCORE!>0b_1<!>\n    <!ILLEGAL_UNDERSCORE!>0B_1<!>\n    <!ILLEGAL_UNDERSCORE!>1.0_<!>\n    <!ILLEGAL_UNDERSCORE!>1_.1<!>\n    <!ILLEGAL_UNDERSCORE!>1.0_e1<!>\n    <!ILLEGAL_UNDERSCORE!>1.0E_1<!>\n    <!ILLEGAL_UNDERSCORE!>0Xe_<!>\n    <!ILLEGAL_UNDERSCORE!>1.1_e-1_23<!>\n    <!ILLEGAL_UNDERSCORE!>1.0e+_0<!>\n    <!ILLEGAL_UNDERSCORE!>1.0e-_0<!>\n}"
        },
        {
            "code": "// !LANGUAGE: -UnderscoresInNumericLiterals\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun foo() {\n    <!UNSUPPORTED_FEATURE!>100_1<!>\n    <!UNSUPPORTED_FEATURE!>3_.1<!>\n    <!UNSUPPORTED_FEATURE!>2___4<!>\n    <!UNSUPPORTED_FEATURE!>123_<!>\n}"
        },
        {
            "code": "package foo\n\nclass X {}\n\nval s = <!EXPRESSION_EXPECTED_PACKAGE_FOUND!>java<!>\nval ss = <!NO_COMPANION_OBJECT!>System<!>\nval sss = <!NO_COMPANION_OBJECT!>X<!>\nval x = \"${<!NO_COMPANION_OBJECT!>System<!>}\"\nval xs = java.<!EXPRESSION_EXPECTED_PACKAGE_FOUND!>lang<!>\nval xss = java.lang.<!NO_COMPANION_OBJECT!>System<!>\nval xsss = foo.<!NO_COMPANION_OBJECT!>X<!>\nval xssss = <!EXPRESSION_EXPECTED_PACKAGE_FOUND!>foo<!>\nval f = { <!NO_COMPANION_OBJECT!>System<!> }\n\nfun main() {\n    <!EXPRESSION_EXPECTED_PACKAGE_FOUND!>java<!> = null\n    <!NO_COMPANION_OBJECT!>System<!> = null\n    <!NO_COMPANION_OBJECT!>System<!>!!\n    java.lang.<!NO_COMPANION_OBJECT!>System<!> = null\n    java.lang.<!NO_COMPANION_OBJECT!>System<!>!!\n    <!NO_COMPANION_OBJECT!>System<!> is Int\n    <!INVISIBLE_MEMBER!>System<!>()\n    (<!NO_COMPANION_OBJECT!>System<!>)\n    <!REDUNDANT_LABEL_WARNING!>foo@<!> <!NO_COMPANION_OBJECT!>System<!>\n    null in <!NO_COMPANION_OBJECT!>System<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: b.kt\n\n\npackage foobar.a\n    import java.*\n\n    val a : <!PLATFORM_CLASS_MAPPED_TO_KOTLIN!>java.util.List<Int><!>? = null\n    val a2 : <!UNRESOLVED_REFERENCE!>util<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>List<!><Int>? = null\n    val a3 : <!UNRESOLVED_REFERENCE!>LinkedList<!><Int>? = null\n\n// FILE: b.kt\npackage foobar\n\nabstract class Foo<T>() {\n    abstract val x : T<!TYPE_ARGUMENTS_NOT_ALLOWED!><Int><!>\n}\n\n// FILE: b.kt\npackage foobar.a\n    import java.util.*\n\n    val b : List<Int>? = <!TYPE_MISMATCH!>a<!>\n    val b1 : <!UNRESOLVED_REFERENCE!>util<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>List<!><Int>? = a\n\n// FILE: b.kt\npackage foobar\nval x1 = <!UNRESOLVED_REFERENCE!>a<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>\nval x2 = foobar.a.a\n\nval y1 = foobar.a.b\n\n\n/////////////////////////////////////////////////////////////////////////\n\nfun <O> done(result : O) : Iteratee<Any?, O> = StrangeIterateeImpl<Any?, O>(result)\n\nabstract class Iteratee<in I, out O> {\n  abstract fun process(item : I) : Iteratee<I, O>\n  abstract val isDone : Boolean\n  abstract val result : O\n  abstract fun done() : O\n}\n\nclass StrangeIterateeImpl<in I, out O>(val obj: O) : Iteratee<I, O>() {\n    override fun process(item: I): Iteratee<I, O> = StrangeIterateeImpl<I, O>(obj)\n    override val isDone = true\n    override val result = obj\n    override fun done() = obj\n}\n\nabstract class Sum() : Iteratee<Int, Int>() {\n  override fun process(item : Int) : Iteratee<Int, Int> {\n    return foobar.done<Int>(item);\n  }\n  abstract override val isDone : Boolean\n  abstract override val result : Int\n  abstract override fun done() : Int\n}\n\nabstract class Collection<E> : Iterable<E> {\n  fun <O> iterate(iteratee : Iteratee<E, O>) : O {\n      var current = iteratee\n      for (x in this) {\n        val it = current.process(x)\n        if (it.isDone) return it.result\n        current = it\n      }\n      return current.done()\n  }\n}"
        },
        {
            "code": "// FILE: f.kt\nclass A {\n}\n\n// FILE: f.kt\npackage n\n  class B\n// FILE: f.kt\nabstract class XXX() {\n    abstract val a : Int\n    abstract val a2 : n.B\n    abstract val a3 : (A)\n    abstract val a31 : (n.B)\n    abstract val a4 : A?\n    abstract val a5 : (A)?\n    abstract val a6 : (A?)\n    abstract val a7 : (A) -> n.B\n    abstract val a8 : (A, n.B) -> n.B\n\n//val a9 : (A, B)\n//val a10 : (B)? -> B\n\n    val a11 : ((Int) -> Int)? = null\n    val a12 : ((Int) -> (Int))? = null\n    abstract val a13 : Int.(Int) -> Int\n    abstract val a14 : n.B.(Int) -> Int\n    abstract val a15 : Int? .(Int) -> Int\n    abstract val a152 : (Int?).(Int) -> Int\n//    abstract val a151 : Int?.(Int) -> Int\n    abstract val a16 : (Int) -> (Int) -> Int\n    abstract val a17 : ((Int) -> Int).(Int) -> Int\n    abstract val a18 : (Int) -> ((Int) -> Int)\n    abstract val a19 : ((Int) -> Int) -> Int\n}\n\nabstract class YYY() {\n    abstract val a7 : (a : A) -> n.B\n    abstract val a8 : (a : A, b : n.B) -> n.B\n//val a9 : (A, B)\n//val a10 : (B)? -> B\n    val a11 : ((a : Int) -> Int)? = null\n    val a12 : ((a : Int) -> (Int))? = null\n    abstract val a13 : Int.(a : Int) -> Int\n    abstract val a14 : n.B.(a : Int) -> Int\n    abstract val a15 : Int? .(a : Int) -> Int\n    abstract val a152 : (Int?).(a : Int) -> Int\n//abstract val a151 : Int?.(a : Int) -> Int\n    abstract val a16 : (a : Int) -> (a : Int) -> Int\n    abstract val a17 : ((a : Int) -> Int).(a : Int) -> Int\n    abstract val a18 : (a : Int) -> ((a : Int) -> Int)\n    abstract val a19 : (b : (a : Int) -> Int) -> Int\n}"
        },
        {
            "code": "fun demo() {\n  val abc = 1\n  val a = \"\"\n  val asd = 1\n  val bar = 5\n  fun map(<!UNUSED_PARAMETER!>f<!> :  () -> Any?) : Int  = 1\n  fun buzz(<!UNUSED_PARAMETER!>f<!> :  () -> Any?) : Int  = 1\n  val sdf = 1\n  val foo = 3;\n    <!UNUSED_EXPRESSION!>\"$abc\"<!>\n    <!UNUSED_EXPRESSION!>\"$\"<!>\n    <!UNUSED_EXPRESSION!>\"$.$.asdf$\\t\"<!>\n    <!UNUSED_EXPRESSION!>\"asd\\$\"<!>\n    <!UNUSED_EXPRESSION!>\"asd$a<!ILLEGAL_ESCAPE!>\\x<!>\"<!>\n    \"asd$a$asd$ $<!UNRESOLVED_REFERENCE!>xxx<!>\"\n    \"fosdfasdo${1 + bar + 100}}sdsdfgdsfsdf\"\n    \"foo${bar + map {foo}}sdfsdf\"\n    \"foo${bar + map { \"foo\" }}sdfsdf\"\n    \"foo${bar + map {\n      \"foo$sdf${ buzz{}}\" }}sdfsdf\"\n    <!UNUSED_EXPRESSION!>\"a<!ILLEGAL_ESCAPE!>\\u<!> <!ILLEGAL_ESCAPE!>\\u<!>0 <!ILLEGAL_ESCAPE!>\\u<!>00 <!ILLEGAL_ESCAPE!>\\u<!>000 \\u0000 \\u0AaA <!ILLEGAL_ESCAPE!>\\u<!>0AAz.length( ) + \\u0022b\"<!>\n}"
        },
        {
            "code": "interface A<H> {\n    fun foo() : Int = 1\n    fun foo2() : Int = 1\n    fun foo1() : Int = 1\n    val a : Int\n    val a1 : Int\n    val g : Iterator<H>\n\n    fun <T> g() : T\n    fun <T> g1() : T\n}\n\nabstract class B<H>() : A<H> {\n    override fun <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>foo<!>() {\n    }\n    override fun foo2() : <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>Unit<!> {\n    }\n\n    override val a : <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE!>Double<!> = 1.toDouble()\n    override val <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE!>a1<!> = 1.toDouble()\n\n    abstract override fun <X> g() : <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>Int<!>\n    abstract override fun <X> g1() : <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>List<X><!>\n\n    abstract override val g : <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE!>Iterator<Int><!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\ninterface A\ninterface B : A\ninterface C : B\n\nfun test(b: B) {\n    b checkType { _<B>() }\n    b checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><A>() }\n    b checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><C>() }\n}\n"
        },
        {
            "code": "//!LANGUAGE: -ProperComputationOrderOfTailrecDefaultParameters\n\nimport kotlin.reflect.KClass\n\nfun withEffects(): String = \"OK\"\n\nconst val Z = \"123\"\n\nenum class EnumA {\n    A\n}\n\ntailrec fun foo(i: Int = 1, c: Char = '2', s: String = \"1234\", b: Boolean = true, d: Double = 1.0,  l: Long =  1L,  y: String = withEffects()) {\n    foo(i, c, s, b, d, l, y)\n}\n\ntailrec fun foo2(x: Int = 1, y: String = withEffects(), z: String = Z) {\n    foo2(x, y, z)\n}\n\ntailrec fun foo3(y: String = withEffects()) {\n    foo3(y)\n}\n\n<!TAILREC_WITH_DEFAULTS!>tailrec fun foo4(x: String = withEffects(), y: String = withEffects())<!> {\n    foo4(x, y)\n}\n\n<!TAILREC_WITH_DEFAULTS!>tailrec fun foo5(x: String = withEffects(), y: String = withEffects(), z: String = withEffects())<!> {\n    foo5(x, y, z)\n}\n\n<!TAILREC_WITH_DEFAULTS!>tailrec fun foo6(x: String = withEffects(), y: EnumA = EnumA.A)<!> {\n    foo6(x, y)\n}\n\n<!TAILREC_WITH_DEFAULTS!>tailrec fun foo7(x: String = withEffects(), y: KClass<out EnumA> = EnumA.A::class)<!> {\n    foo7(x, y)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nopen class A() {\n  fun foo() {}\n}\n\nclass B() : A() {\n  fun bar() {}\n}\n\nfun f9(init : A?) {\n  val a : A? = init\n  a?.foo()\n  a?.<!UNRESOLVED_REFERENCE!>bar<!>()\n  if (a is B) {\n    <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n  }\n  a?.foo()\n  a?.<!UNRESOLVED_REFERENCE!>bar<!>()\n  if (!(a is B)) {\n    a?.<!UNRESOLVED_REFERENCE!>bar<!>()\n    a?.foo()\n  }\n  if (!(a is B) || <!DEBUG_INFO_SMARTCAST!>a<!>.bar() == Unit) {\n      a?.<!UNRESOLVED_REFERENCE!>bar<!>()\n  }\n  if (!(a is B)) {\n    return;\n  }\n  <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n  <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n}\n\nfun f10(init : A?) {\n  val a : A? = init\n  if (!(a is B)) {\n    return;\n  }\n  if (!(<!USELESS_IS_CHECK!>a is B<!>)) {\n    return;\n  }\n}\n\nclass C() : A() {\n  fun bar() {\n\n  }\n}\n\nfun f101(a : A?) {\n    if (a is C) {\n      <!DEBUG_INFO_SMARTCAST!>a<!>.bar();\n    }\n}\n\nfun f11(a : A?) {\n  when (a) {\n    is B -> <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n    is A -> <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    is Any -> <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    <!USELESS_IS_CHECK!>is Any?<!> -> a.<!UNRESOLVED_REFERENCE!>bar<!>()\n    else -> a?.foo()\n  }\n}\n\nfun f12(a : A?) {\n  when (a) {\n    is B -> <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n    is A -> <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    is Any -> <!DEBUG_INFO_SMARTCAST!>a<!>.foo();\n    <!USELESS_IS_CHECK!>is Any?<!> -> a.<!UNRESOLVED_REFERENCE!>bar<!>()\n    is C -> <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n    else -> a?.foo()\n  }\n\n  if (<!USELESS_IS_CHECK!>a is Any?<!>) {\n    a?.<!UNRESOLVED_REFERENCE!>bar<!>()\n  }\n  if (a is B) {\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n  }\n}\n\nfun f13(a : A?) {\n  if (a is B) {\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n  }\n  else {\n    a?.foo()\n    <!UNRESOLVED_REFERENCE!>c<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n  }\n\n  a?.foo()\n  if (!(a is B)) {\n    a?.foo()\n    <!UNRESOLVED_REFERENCE!>c<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n  }\n  else {\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    <!UNRESOLVED_REFERENCE!>c<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n  }\n\n  a?.foo()\n  if (a is B && <!DEBUG_INFO_SMARTCAST!>a<!>.foo() == Unit) {\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n  }\n  else {\n    a?.foo()\n    <!UNRESOLVED_REFERENCE!>c<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>bar<!>()\n  }\n\n  if (!(a is B) || !(a is C)) {\n  }\n  else {\n  }\n\n  if (!(a is B) || !(a is C)) {\n  }\n\n  if (!(a is B)) return\n  <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n}\n\nfun f14(a : A?) {\n  while (!(a is B)) {\n  }\n  <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n}\nfun f15(a : A?) {\n  do {\n  } while (!(a is B))\n  <!DEBUG_INFO_SMARTCAST!>a<!>.bar()\n}\n\nfun getStringLength(obj : Any) : Char? {\n  if (obj !is String)\n    return null\n  return <!DEBUG_INFO_SMARTCAST!>obj<!>.get(0) // no cast to String is needed\n}\n\nfun toInt(i: Int?): Int = if (i != null) <!DEBUG_INFO_SMARTCAST!>i<!> else 0\nfun illegalWhenBody(a: Any): Int = <!NI;TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!>(a) {\n    is Int -> <!DEBUG_INFO_SMARTCAST!>a<!>\n    is String -> <!OI;TYPE_MISMATCH!>a<!>\n}<!>\nfun illegalWhenBlock(a: Any): Int {\n    when(a) {\n        is Int -> return <!DEBUG_INFO_SMARTCAST!>a<!>\n        is String -> return <!TYPE_MISMATCH!>a<!>\n    }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY!>}<!>\nfun declarations(a: Any?) {\n    if (a is String) {\n       val <!UNUSED_VARIABLE!>p4<!>: String = <!DEBUG_INFO_SMARTCAST!>a<!>\n    }\n    if (a is String?) {\n        if (a != null) {\n            val <!UNUSED_VARIABLE!>s<!>: String = <!DEBUG_INFO_SMARTCAST!>a<!>\n        }\n    }\n    if (a != null) {\n        if (a is String?) {\n            val <!UNUSED_VARIABLE!>s<!>: String = <!DEBUG_INFO_SMARTCAST!>a<!>\n        }\n    }\n}\nfun vars(a: Any?) {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>b<!>: Int = 0\n    if (a is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>a<!>\n    }\n}\nfun returnFunctionLiteralBlock(a: Any?): Function0<Int> {\n    if (a is Int) return { <!DEBUG_INFO_SMARTCAST!>a<!> }\n    else return { 1 }\n}\nfun returnFunctionLiteral(a: Any?): Function0<Int> {\n    if (a is Int) return { -> <!DEBUG_INFO_SMARTCAST!>a<!> }\n    else return { -> 1 }\n}\n\nfun returnFunctionLiteralExpressionBody(a: Any?): Function0<Int> =\n        if (a is Int) { -> <!DEBUG_INFO_SMARTCAST!>a<!> }\n        else { -> 1 }\n\n\nfun mergeSmartCasts(a: Any?) {\n  if (a is String || a is Int) {\n    a.<!UNRESOLVED_REFERENCE!>compareTo<!>(\"\")\n    <!DEBUG_INFO_SMARTCAST!>a<!>.toString()\n  }\n  if (a is Int || a is String) {\n    a.<!UNRESOLVED_REFERENCE!>compareTo<!>(\"\")\n  }\n  when (a) {\n    is String, is Any -> a.<!UNRESOLVED_REFERENCE!>compareTo<!>(\"\")\n  }\n  if (a is String && <!USELESS_IS_CHECK!>a is Any<!>) {\n    val <!UNUSED_VARIABLE!>i<!>: Int = <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"\")\n  }\n  if (a is String && <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"\") == 0) {}\n  if (a is String || a.<!UNRESOLVED_REFERENCE!>compareTo<!>(\"\") <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>==<!> 0) {}\n}\n\n//mutability\nfun f(): String {\n    var a: Any = 11\n    if (a is String) {\n        // a is a string, despite of being a variable\n        val <!UNUSED_VARIABLE!>i<!>: String = <!DEBUG_INFO_SMARTCAST!>a<!>\n        <!DEBUG_INFO_SMARTCAST!>a<!>.compareTo(\"f\")\n        // Beginning from here a is captured in a closure but nobody modifies it\n        val <!UNUSED_VARIABLE!>f<!>: Function0<String> = { <!DEBUG_INFO_SMARTCAST!>a<!> }\n        return <!DEBUG_INFO_SMARTCAST!>a<!>\n    }\n    return \"\"\n}\n\nfun foo(aa: Any?): Int {\n    var a = aa\n    if (a is Int?) {\n        return <!TYPE_MISMATCH!>a<!>\n    }\n    return 1\n}\n"
        },
        {
            "code": "abstract class Test() {\n    abstract val x : Int\n    abstract val x1 : Int get\n    abstract val x2 : Int <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = 1<!>\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val a : Int<!>\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val b : Int<!> get\n    val c = 1\n\n    val c1 = 1\n      get\n    val c2 : Int\n        get() = 1\n    val c3 : Int\n        get() { return 1 }\n    val c4 : Int\n        get() = 1\n    <!MUST_BE_INITIALIZED!>val c5 : Int<!>\n        get() = field + 1\n\n    abstract var y : Int\n    abstract var y1 : Int get\n    abstract var y2 : Int set\n    abstract var y3 : Int set get\n    abstract var y4 : Int set <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = 1<!>\n    abstract var y5 : Int <!ABSTRACT_PROPERTY_WITH_SETTER!>set(<!UNUSED_PARAMETER!>x<!>) {}<!> <!ABSTRACT_PROPERTY_WITH_GETTER!>get() = 1<!>\n    abstract var y6 : Int <!ABSTRACT_PROPERTY_WITH_SETTER!>set(<!UNUSED_PARAMETER!>x<!>) {}<!>\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var v : Int<!>\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var v1 : Int<!> get\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var v2 : Int<!> get set\n    <!MUST_BE_INITIALIZED!>var v3 : Int<!> get() = 1; set\n    var v4 : Int get() = 1; set(<!UNUSED_PARAMETER!>x<!>){}\n\n    <!MUST_BE_INITIALIZED!>var v5 : Int<!> get() = 1; set(x){field = x}\n    <!MUST_BE_INITIALIZED!>var v6 : Int<!> get() = field + 1; set(<!UNUSED_PARAMETER!>x<!>){}\n\n  abstract val v7 : Int get\n  abstract var v8 : Int get set\n  <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var v9 : Int<!> set\n  <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>var v10 : Int<!>  get\n  abstract val v11 : Int <!WRONG_MODIFIER_TARGET!>abstract<!> get\n  abstract var v12 : Int <!WRONG_MODIFIER_TARGET!>abstract<!> get <!WRONG_MODIFIER_TARGET!>abstract<!> set\n\n}\n\nopen class Super(<!UNUSED_PARAMETER!>i<!> : Int)\n\nclass TestPCParameters(w : Int, <!UNUSED_PARAMETER!>x<!> : Int, val y : Int, var z : Int) : Super(w) {\n\n  val xx = w\n\n  init {\n    w + 1\n  }\n\n  fun foo() = <!UNRESOLVED_REFERENCE!>x<!>\n\n}"
        },
        {
            "code": "// See KT-10325: private setters are allowed for overridden properties in final class\n\ninterface A {\n    val a: Int\n\n    var b: Int\n}\n\nabstract class AA {\n    abstract val c: Int\n\n    abstract var d: Int\n}\n\nclass B : A, AA() {\n    override var a: Int = 0\n        // Ok\n        private set\n\n    override var b: Int = 1\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>private<!> set\n\n    override var c: Int = 2\n        // Ok\n        private set\n\n    override var d: Int = 3\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE!>private<!> set\n}\n\nopen class C : A, AA() {\n    override var a: Int = 0\n        // Errors here and below\n        <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n\n    override var b: Int = 1\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE, PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n\n    override var c: Int = 2\n        <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n\n    override var d: Int = 3\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE, PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n}\n\nabstract class D : A, AA() {\n    override var a: Int = 0\n        // Errors here and below\n        <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n\n    override var b: Int = 1\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE, PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n\n    override var c: Int = 2\n        <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n\n    override var d: Int = 3\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE, PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set\n}\n\ninterface E : A {\n    override var a: Int\n        get() = 0\n        // Errors here and below\n        <!PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set(<!UNUSED_PARAMETER!>arg<!>) {}\n\n    override var b: Int\n        get() = 0\n        <!CANNOT_WEAKEN_ACCESS_PRIVILEGE, PRIVATE_SETTER_FOR_OPEN_PROPERTY!>private<!> set(<!UNUSED_PARAMETER!>arg<!>) {}\n}"
        },
        {
            "code": "// !LANGUAGE: -NestedClassesInEnumEntryShouldBeInner\n\npackage a\n\n\nenum class C {\n    E1, E2, E3 {\n        <!NESTED_CLASS_DEPRECATED!>object O_O<!>\n\n        fun b() {\n            O_O\n        }\n\n        <!NESTED_CLASS_DEPRECATED!>class G<!>\n    },\n\n    E4 {\n        fun c() {\n            this.B()\n\n            C.A()\n            A()\n            //TODO: should be resolved with error\n            this.<!UNRESOLVED_REFERENCE!>A<!>()\n        }\n    };\n\n    class A\n    inner class B\n    object O {\n        object InO\n    }\n}\n\nfun f() {\n    C.E1.<!UNRESOLVED_REFERENCE!>A<!>\n    C.E1.<!UNRESOLVED_REFERENCE!>A<!>()\n    C.E2.B()\n\n    C.E2.<!UNRESOLVED_REFERENCE!>O<!>\n    C.E3.<!UNRESOLVED_REFERENCE!>O<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>InO<!>\n\n    C.O\n    C.O.InO\n    C.A()\n    C.<!RESOLUTION_TO_CLASSIFIER!>B<!>()\n\n    C.E3.<!UNRESOLVED_REFERENCE!>O_O<!>\n    C.E3.<!UNRESOLVED_REFERENCE!>G<!>()\n}\n"
        },
        {
            "code": "package test\n\nclass Test {\n  fun test(): Int = 12\n\n  companion object {\n    val a = <!UNRESOLVED_REFERENCE!>test<!>() // Check if resolver will be able to infer type of a variable\n  }\n}"
        },
        {
            "code": "open class C {\n}\n\nfun C.foo() {}\n\nopen class X {\n    companion object : C() {}\n}\n\nopen class Y {\n    companion object : C() {}\n}\n\nfun bar() {\n    val x = X\n    x.foo()\n    X.foo()\n    (X as C).foo()\n    ((if (1<2) X else Y) <!USELESS_CAST!>as C<!>).foo()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInEnumEntryShouldBeInner\n\npackage a\n\n\nenum class C {\n    E1, E2, E3 {\n        <!NESTED_CLASS_NOT_ALLOWED!>object O_O<!>\n\n        fun b() {\n            O_O\n        }\n\n        <!NESTED_CLASS_NOT_ALLOWED!>class G<!>\n    },\n\n    E4 {\n        fun c() {\n            this.B()\n\n            C.A()\n            A()\n            //TODO: should be resolved with error\n            this.<!UNRESOLVED_REFERENCE!>A<!>()\n        }\n    };\n\n    class A\n    inner class B\n    object O {\n        object InO\n    }\n}\n\nfun f() {\n    C.E1.<!UNRESOLVED_REFERENCE!>A<!>\n    C.E1.<!UNRESOLVED_REFERENCE!>A<!>()\n    C.E2.B()\n\n    C.E2.<!UNRESOLVED_REFERENCE!>O<!>\n    C.E3.<!UNRESOLVED_REFERENCE!>O<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>InO<!>\n\n    C.O\n    C.O.InO\n    C.A()\n    C.<!RESOLUTION_TO_CLASSIFIER!>B<!>()\n\n    C.E3.<!UNRESOLVED_REFERENCE!>O_O<!>\n    C.E3.<!UNRESOLVED_REFERENCE!>G<!>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -DUPLICATE_CLASS_NAMES\npackage Jet86\n\nclass A {\n  companion <!REDECLARATION!>object<!> {\n    val x = 1\n  }\n  <!MANY_COMPANION_OBJECTS!>companion<!> <!REDECLARATION!>object<!> {\n    val x = 1\n  }\n}\n\nclass AA {\n  companion object {\n    val x = 1\n  }\n  <!MANY_COMPANION_OBJECTS!>companion<!> object A {\n    val x = 1\n  }\n    <!MANY_COMPANION_OBJECTS!>companion<!> object AA {\n    val x = 1\n  }\n}\n\nclass B() {\n  val x = 12\n}\n\nobject b {\n  <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {\n    val x = 1\n  } // error\n}\n\nval a = A.x\nval c = B.<!UNRESOLVED_REFERENCE!>x<!>\nval d = b.<!UNRESOLVED_REFERENCE!>x<!>\n\nval s = <!NO_COMPANION_OBJECT!>System<!>  // error\nfun test() {\n  System.out.println()\n  java.lang.System.out.println()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -DUPLICATE_CLASS_NAMES\npackage test\n\nclass A {\n    object <!REDECLARATION!>Companion<!>\n\n    companion <!REDECLARATION!>object<!>\n}\n\nclass B {\n    companion object <!REDECLARATION!>Named<!>\n\n    object <!REDECLARATION!>Named<!>\n}\n\nclass C {\n    class <!REDECLARATION!>Named<!>\n\n    companion object <!REDECLARATION!>Named<!>\n}"
        },
        {
            "code": "class A {\n    inner class I {\n        companion <!NESTED_CLASS_NOT_ALLOWED(\"Companion object\")!>object A<!>\n\n        <!MANY_COMPANION_OBJECTS!>companion<!> <!NESTED_CLASS_NOT_ALLOWED(\"Companion object\")!>object B<!>\n\n        <!MANY_COMPANION_OBJECTS!>companion<!> <!NESTED_CLASS_NOT_ALLOWED(\"Companion object\")!>object C<!>\n    }\n}\n\nobject O {\n    <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object A\n\n    <!MANY_COMPANION_OBJECTS, WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object B\n\n    <!MANY_COMPANION_OBJECTS, WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object C\n}\n"
        },
        {
            "code": "package foo\n\nfun test() {\n  A.d\n  A.Companion.<!INVISIBLE_MEMBER!>f<!>\n  B.<!INVISIBLE_MEMBER!>D<!>\n  <!INVISIBLE_MEMBER!>CCC<!>\n  CCC.<!INVISIBLE_MEMBER!>classObjectVar<!>\n}\n\nclass A() {\n  public companion object {\n    val d = 3\n    private object f {\n\n    }\n  }\n}\n\nclass B {\n    class D {\n        private companion object\n    }\n}\n\nclass CCC() {\n  private companion object {\n    val classObjectVar = 3\n  }\n}"
        },
        {
            "code": "//FILE:a.kt\npackage a\n\nclass A {\n    companion object {\n        fun foo() {}\n    }\n}\n\nprivate class B {\n    companion object {\n        fun bar() {}\n    }\n}\n\nclass C {\n    private companion object {\n        fun baz() {}\n    }\n}\n\nprivate class D {\n    private companion object {\n        fun quux() {}\n    }\n}\n\n//FILE:b.kt\npackage b\n\nimport a.A\nimport a.<!INVISIBLE_REFERENCE!>B<!>\nimport a.C\nimport a.<!INVISIBLE_REFERENCE!>D<!>\n\nfun test() {\n    f(A)\n    f(<!INVISIBLE_MEMBER!>B<!>)\n    f(<!INVISIBLE_MEMBER!>C<!>)\n    f(<!INVISIBLE_MEMBER!>D<!>)\n\n    A.foo()\n    <!INVISIBLE_REFERENCE!>B<!>.<!INVISIBLE_MEMBER!>bar<!>()\n    C.<!INVISIBLE_MEMBER!>baz<!>()\n    <!INVISIBLE_REFERENCE!>D<!>.<!INVISIBLE_MEMBER!>quux<!>()\n\n    a.A.foo()\n    a.C.<!INVISIBLE_MEMBER!>baz<!>()\n}\n\nfun f(<!UNUSED_PARAMETER!>unused<!>: Any) {}"
        },
        {
            "code": "package test\n\nopen class ToResolve<SomeClass>(<!UNUSED_PARAMETER!>f<!> : (Int) -> Int)\nfun testFun(<!UNUSED_PARAMETER!>a<!> : Int) = 12\n\nclass TestSome<P> {\n    companion object : ToResolve<<!UNRESOLVED_REFERENCE!>P<!>>({testFun(it)}) {\n    }\n}"
        },
        {
            "code": "// http://youtrack.jetbrains.net/issue/KT-449\n\nclass A {\n    inner class B {\n        companion <!NESTED_CLASS_NOT_ALLOWED(\"Companion object\")!>object<!> { }\n    }\n}\n\nclass B {\n    companion object {\n        class B {\n            companion object {\n                class C {\n                    companion object { }\n                }\n            }\n        }\n    }\n}\n\nclass C {\n    class D {\n        companion object { }\n    }\n}\n"
        },
        {
            "code": "// http://youtrack.jetbrains.net/issue/KT-20\n\nclass A() {\n    val x = 1\n\n    companion object {\n        val y = <!UNRESOLVED_REFERENCE!>x<!>\n    }\n}"
        },
        {
            "code": "package a\n\nclass A {\n    class Nested\n    inner class Inner\n\n\n    companion object {\n\n        class Nested2\n\n        val c: Int = 1\n\n        object Obj2 {\n            val c: Int = 1\n        }\n    }\n\n    object Obj\n}\n\nobject O {\n    class A\n\n    object O\n}\n\nfun f() {\n    A.c\n    A.hashCode()\n    A().<!NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE, NO_COMPANION_OBJECT!>Nested<!>\n    A.Nested()\n    A().Inner()\n    A.Companion.<!UNRESOLVED_REFERENCE!>Nested<!>\n    A.Companion.<!UNRESOLVED_REFERENCE!>Inner<!>\n    A.<!NO_COMPANION_OBJECT!>Inner<!>\n    A.Companion.c\n    A.Companion.Obj2\n    A.Companion.Obj2.c\n\n    A.Companion.Nested2()\n    A.Companion.c\n    A.Obj\n    A.Companion.Obj2\n    A.<!UNRESOLVED_REFERENCE!>Obj2<!>\n    A.<!UNRESOLVED_REFERENCE!>Obj2<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>c<!>\n    A.<!UNRESOLVED_REFERENCE!>Nested2<!>\n\n    O.O\n    O.A()\n}"
        },
        {
            "code": "fun test() {\n    class A {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {}\n    }\n\n    object {\n        <!WRONG_MODIFIER_CONTAINING_DECLARATION!>companion<!> object {}\n    }\n}"
        },
        {
            "code": "object A<!TYPE_PARAMETERS_IN_OBJECT!><T><!>\nobject B<!TYPE_PARAMETERS_IN_OBJECT!><in T, out R><!>\nobject C<!TYPE_PARAMETERS_IN_OBJECT!><T : Comparable<T>><!>\n\nclass D {\n    companion object<!TYPE_PARAMETERS_IN_OBJECT!><T><!>\n}\n\nclass E {\n    companion object<!TYPE_PARAMETERS_IN_OBJECT!><in T, out R><!>\n}\n\nclass F {\n    companion object C<!TYPE_PARAMETERS_IN_OBJECT!><T : Comparable<T>><!>\n}\n\nclass G {\n    companion object F<!TYPE_PARAMETERS_IN_OBJECT!><T><!>\n}\n\nobject H<!TYPE_PARAMETERS_IN_OBJECT!><T, R><!><!CONSTRUCTOR_IN_OBJECT!>()<!>\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE!\n// ISSUE: KT-28999\n\nfun case_1() {\n    val x = object<!TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT!><T><!> { } // type of x is <anonymous object><T>\n}\n\nfun case_2() {\n    val x = object<!TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT!><T : Number, K: Comparable<K>><!> { }\n}\n\nfun case_3() {\n    val x = object<!TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT!><T><!> <!SYNTAX!>where <!DEBUG_INFO_MISSING_UNRESOLVED!>T<!> : <!DEBUG_INFO_MISSING_UNRESOLVED!>Comparable<!><<!DEBUG_INFO_MISSING_UNRESOLVED!>T<!>><!> { } // ERROR: Where clause is not allowed for objects\n}\n\nval x = object<!TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT!><T, K: Comparable<K>><!> {\n    fun test() = 10 <!UNCHECKED_CAST!>as T<!> // OK\n}\n\nfun case_4() {\n    val x = object<!TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT!><T><!> {\n        fun test() = 10 <!UNCHECKED_CAST!>as T<!>\n    }\n\n    val y = x.test() // type y is T\n}\n\ninline fun <reified T> case_5() {\n    val x = object<!TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT!><T><!> {\n        fun test() = 10 <!UNCHECKED_CAST!>as T<!>\n    }\n\n    val z = x.test()\n\n    if (z is T) {\n        // z is {T!! & T!!} (smart cast from T)\n        <!UNRESOLVED_REFERENCE!>println<!>(z)\n    }\n}"
        },
        {
            "code": "class A {\n    private companion object {\n        class B {\n            class C {\n                companion object {\n                    fun foo() {}\n                }\n            }\n        }\n    }\n}\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>f1<!>() = A.<!INVISIBLE_REFERENCE!>Companion<!>.<!INVISIBLE_REFERENCE!>B<!>.<!INVISIBLE_MEMBER!>C<!>\n\nfun f2() = A.<!INVISIBLE_REFERENCE!>Companion<!>.<!INVISIBLE_REFERENCE!>B<!>.<!INVISIBLE_REFERENCE!>C<!>.<!INVISIBLE_MEMBER!>foo<!>()"
        },
        {
            "code": "// !LANGUAGE: +ProhibitTypeParametersInAnonymousObjects\n// !DIAGNOSTICS: -UNUSED_VARIABLE!\n// ISSUE: KT-28999\n\nfun case_1() {\n    val x = object<!TYPE_PARAMETERS_IN_OBJECT!><T><!> { } // type of x is <anonymous object><T>\n}\n\nfun case_2() {\n    val x = object<!TYPE_PARAMETERS_IN_OBJECT!><T : Number, K: Comparable<K>><!> { }\n}\n\nfun case_3() {\n    val x = object<!TYPE_PARAMETERS_IN_OBJECT!><T><!> <!SYNTAX!>where <!DEBUG_INFO_MISSING_UNRESOLVED!>T<!> : <!DEBUG_INFO_MISSING_UNRESOLVED!>Comparable<!><<!DEBUG_INFO_MISSING_UNRESOLVED!>T<!>><!> { } // ERROR: Where clause is not allowed for objects\n}\n\nval x = object<!TYPE_PARAMETERS_IN_OBJECT!><T, K: Comparable<K>><!> {\n    fun test() = 10 <!UNCHECKED_CAST!>as T<!> // OK\n}\n\nfun case_4() {\n    val x = object<!TYPE_PARAMETERS_IN_OBJECT!><T><!> {\n        fun test() = 10 <!UNCHECKED_CAST!>as T<!>\n    }\n\n    val y = x.test() // type y is T\n}\n\ninline fun <reified T> case_5() {\n    val x = object<!TYPE_PARAMETERS_IN_OBJECT!><T><!> {\n        fun test() = 10 <!UNCHECKED_CAST!>as T<!>\n    }\n\n    val z = x.test()\n\n    if (z is T) {\n        // z is {T!! & T!!} (smart cast from T)\n        <!UNRESOLVED_REFERENCE!>println<!>(z)\n    }\n}"
        },
        {
            "code": "package test\n\nfun use() {\n    Default.create()\n\n    Explicit.<!INVISIBLE_MEMBER!>create<!>()\n}\n\nprivate class Default {\n    companion object {\n        fun create() = Default()\n    }\n}\n\nprivate class Explicit {\n    private companion object {\n        fun create() = Explicit()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\npackage a\n\nfun <T> id(t: T): T = t\n\nfun <T> either(t1: T, <!UNUSED_PARAMETER!>t2<!>: T): T = t1\n\nfun other(<!UNUSED_PARAMETER!>s<!>: String) {}\n\nfun <T> otherGeneric(<!UNUSED_PARAMETER!>l<!>: List<T>) {}\n\nfun test() {\n    val a: Byte = id(1)\n\n    val b: Byte = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>id(300)<!>\n\n    val c: Int = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>id(9223372036854775807)<!>\n\n    val d = id(22)\n    checkSubtype<Int>(d)\n\n    val e = id(9223372036854775807)\n    e checkType { _<Long>() }\n\n    val f: Byte = either(1, 2)\n\n    val g: Byte = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>either(1, 300)<!>\n\n    other(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>11<!>)\n\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>otherGeneric<!>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n\n    val r = either(1, \"\")\n    r checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Any>() }\n\n    use(a, b, c, d, e, f, g, r)\n}\n\nfun use(vararg a: Any?) = a\n\ninterface Inv<T>\n\nfun <T> exactBound(t: T, l: Inv<T>): T = throw Exception(\"$t $l\")\n\nfun testExactBound(invS: Inv<String>, invI: Inv<Int>, invB: Inv<Byte>) {\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>exactBound<!>(1, <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>invS<!>)\n    exactBound(1, invI)\n\n    val b = exactBound(1, invB)\n    b checkType { _<Byte>() }\n}\n\ninterface Cov<out T>\n\nfun <T> lowerBound(t: T, l : Cov<T>): T = throw Exception(\"$t $l\")\n\nfun testLowerBound(cov: Cov<String>, covN: Cov<Number>) {\n    val r = lowerBound(1, cov)\n    r checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Any>() }\n\n    val n = lowerBound(1, covN)\n    n checkType { _<Number>() }\n}\n\ninterface Contr<in T>\n\nfun <T> upperBound(t: T, l: Contr<T>): T = throw Exception(\"$t $l\")\n\nfun testUpperBound(contrS: Contr<String>, contrB: Contr<Byte>, contrN: Contr<Number>) {\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>upperBound<!>(1, <!NI;TYPE_MISMATCH!>contrS<!>)\n\n    val n = upperBound(1, contrN)\n    n checkType { _<Int>() }\n\n    val b = upperBound(1, contrB)\n    b checkType { _<Byte>() }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\npackage a\n\nfun <T> id(t: T): T = t\n\nfun <T> either(t1: T, <!UNUSED_PARAMETER!>t2<!>: T): T = t1\n\nfun test() {\n    val <!UNUSED_VARIABLE!>a<!>: Float = id(2.0.toFloat())\n\n    val b = id(2.0)\n    checkSubtype<Double>(b)\n\n    val c = either<Number>(1, 2.3)\n    checkSubtype<Number>(c)\n\n    val d = either(11, 2.3)\n    checkSubtype<Any>(d)\n\n    val <!UNUSED_VARIABLE!>e<!>: Float = <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>id(1)<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun foo(n: Number) = n\n\nfun test() {\n    foo(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>'a'<!>)\n    \n    val c = 'c'\n    foo(<!TYPE_MISMATCH!>c<!>)\n\n    val d: Char? = 'd'\n    foo(<!NI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>d<!>!!<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\npackage a\n\nfun foo(i: Int) = i\n\nfun bar(l: Long) = l\n\nfun main() {\n    val <!UNUSED_VARIABLE!>i<!> = <!INT_LITERAL_OUT_OF_RANGE!>111111111111111777777777777777<!>\n\n    //todo add diagnostic text messages\n    //report only 'The value is out of range'\n    //not 'An integer literal does not conform to the expected type Int/Long'\n    val <!UNUSED_VARIABLE!>l<!>: Long = <!INT_LITERAL_OUT_OF_RANGE!>1111111111111117777777777777777<!>\n    foo(<!INT_LITERAL_OUT_OF_RANGE!>11111111111111177777777777777<!>)\n    bar(<!INT_LITERAL_OUT_OF_RANGE, NI;TYPE_MISMATCH!>11111111111111177777777777777<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -CONFLICTING_JVM_DECLARATIONS -UNUSED_PARAMETER\nfun <T> f1(l: <!UNRESOLVED_REFERENCE!>List1<!><T>): T {throw Exception()} // ERROR type here\nfun <T> f1(l: <!UNRESOLVED_REFERENCE!>List2<!><T>): T {throw Exception()} // ERROR type here\nfun <T> f1(c: Collection<T>): T{throw Exception()}\n\nfun <T> test(l: List<T>) {\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>f1<!>(l)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: foo.kt\npackage foo\n\nfun <T> f(<!UNUSED_PARAMETER!>l<!>: List<T>) {}\n\n// FILE: bar.kt\npackage bar\n\nfun <T> f(<!UNUSED_PARAMETER!>l<!>: List<T>) {}\n\n// FILE: main.kt\n\nimport foo.*\nimport bar.*\n\nfun <T> test(l: List<T>) {\n    <!NI;OVERLOAD_RESOLUTION_AMBIGUITY, OI;CANNOT_COMPLETE_RESOLVE!>f<!>(l)\n}"
        },
        {
            "code": "package h\n\npublic class MyClass<S, T>(<!UNUSED_PARAMETER!>param<!>: MyClass<S, T>) {\n    fun test() {\n        val result: MyClass<Any, Any>? = null\n        MyClass<S, Any>(result <!UNCHECKED_CAST!>as MyClass<S, Any><!>)\n    }\n}"
        },
        {
            "code": "fun <E> List<*>.toArray(ar: Array<E>): Array<E> = ar\n\nfun testArrays(ci : List<Int>) {\n    ci.toArray<Int>(<!UNRESOLVED_REFERENCE!>x<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n\ninterface A<R, T: A<R, T>> {\n    fun r(): R\n    fun t(): T\n}\n\nfun testA(a: A<*, *>) {\n    a.r().checkType { _<Any?>() }\n    a.t().checkType { _<A<*, *>>() }\n}\n\ninterface B<R, T: B<List<R>, <!UPPER_BOUND_VIOLATED!>T<!>>> {\n    fun r(): R\n    fun t(): T\n}\n\nfun testB(b: B<*, *>) {\n    <!OI;TYPE_MISMATCH!>b<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>r<!>().<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!NI;UNRESOLVED_REFERENCE!>_<!><Any?>() }\n    <!OI;TYPE_MISMATCH!>b<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>t<!>().<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!NI;UNRESOLVED_REFERENCE!>_<!><B<List<*>, *>>() }\n\n    <!OI;TYPE_MISMATCH!><!OI;TYPE_MISMATCH!>b<!>.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>t<!>()<!>.<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>r<!>().<!NI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>size<!>\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun foo() {\n    <!LOCAL_INTERFACE_NOT_ALLOWED!>interface a<!> {}\n    val b = object {\n        <!NESTED_CLASS_NOT_ALLOWED!>interface c<!> {}\n    }\n    class A {\n        <!NESTED_CLASS_NOT_ALLOWED!>interface d<!> {}\n    }\n    val f = {\n        <!LOCAL_INTERFACE_NOT_ALLOWED!>interface e<!> {}\n    }\n}"
        },
        {
            "code": "fun foo() {}\n\nval x: Unit? = <!NO_ELSE_IN_WHEN!>when<!> (\"A\") {\n    \"B\" -> foo()\n}\n"
        },
        {
            "code": "internal open class My\n\n// valid, internal from internal\ninternal open class Your: My() {\n    // valid, effectively internal\n    fun foo() = My()\n}\n\n// error, public from internal\nopen class His: <!EXPOSED_SUPER_CLASS!>Your()<!> {\n    protected open class Nested\n    // error, public from internal\n    val <!EXPOSED_PROPERTY_TYPE!>x<!> = My()\n    // valid, private from internal\n    private fun bar() = My()\n    // valid, internal from internal\n    internal var y: My? = null\n    // error, protected from internal\n    protected fun <!EXPOSED_FUNCTION_RETURN_TYPE!>baz<!>() = Your()\n}\n\ninternal class Their: His() {\n    // error, effectively internal from protected\n    class InnerDerived: <!EXPOSED_SUPER_CLASS!>His.Nested()<!>\n}"
        },
        {
            "code": "// From KT-10753\nobject My : <!EXPOSED_SUPER_CLASS!>Inter()<!> {\n    fun <!EXPOSED_FUNCTION_RETURN_TYPE!>foo<!>(<!EXPOSED_PARAMETER_TYPE!>arg: Inter<!>): Inter = arg\n    val <!EXPOSED_PROPERTY_TYPE!>x<!>: Inter? = null\n}\n\ninternal open class Inter\n\n// From KT-10799\nopen class Test {\n    protected class Protected\n\n    fun <!EXPOSED_FUNCTION_RETURN_TYPE!>foo<!>(<!EXPOSED_PARAMETER_TYPE!>x: Protected<!>) = x\n\n    interface NestedInterface {\n        fun create(<!EXPOSED_PARAMETER_TYPE!>x: Protected<!>)\n    }\n\n    class NestedClass {\n        fun <!EXPOSED_FUNCTION_RETURN_TYPE!>create<!>(<!EXPOSED_PARAMETER_TYPE!>x: Protected<!>) = x\n    }\n\n    object NestedObject {\n        fun <!EXPOSED_FUNCTION_RETURN_TYPE!>create<!>(<!EXPOSED_PARAMETER_TYPE!>x: Protected<!>) = x\n    }\n\n    companion object {\n        fun <!EXPOSED_FUNCTION_RETURN_TYPE!>create<!>(<!EXPOSED_PARAMETER_TYPE!>x: Protected<!>) = x\n    }\n}\n"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: test/My.java\n\npackage test;\n\nclass Internal {}\n\npublic class My {\n    static public Internal foo() { return new Internal(); }\n}\n\n// FILE: test/His.kt\n\npackage test\n\nclass His {\n    // Ok: private vs package-private\n    private fun private() = My.foo()\n    // Ok: internal vs package-private in same package\n    internal fun internal() = My.foo()\n    // Error: protected vs package-private\n    protected fun <!EXPOSED_FUNCTION_RETURN_TYPE!>protected<!>() = My.foo()\n    // Error: public vs package-private\n    fun <!EXPOSED_FUNCTION_RETURN_TYPE!>public<!>() = My.foo()\n}\n\n// FILE: other/Your.kt\n\npackage other\n\nimport test.My\n\nclass Your {\n    internal fun bar() = <!INACCESSIBLE_TYPE!>My.foo()<!>\n}\n"
        },
        {
            "code": "open class A {\n    // protected relative to A\n    protected open class B { \n        fun foo() {}\n    }\n    public open class C {\n        // protected relative to C, must be an error\n        protected open class D : <!EXPOSED_SUPER_CLASS!>B()<!>\n    }\n}\n\nclass E : A.C() {\n    // F has invisible grandparent class B (E does not inherit from A)\n    class F : <!EXPOSED_SUPER_CLASS!>A.C.D()<!> {\n        init {\n            // Invoke function from invisible grandparent\n            foo() \n        }\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -USELESS_CAST -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\n// FILE: j/Base.java\npackage j;\npublic interface Base {\n    void foo();\n}\n\n// FILE: j/Impl.java\npackage j;\n\n/* package */ abstract class Impl implements Base {\n    public void foo() {}\n}\n\n// FILE: j/Derived1.java\npackage j;\n\npublic class Derived1 extends Impl {}\n\n// FILE: j/Derived2.java\npackage j;\n\npublic class Derived2 extends Impl {}\n\n// FILE: k/Client.kt\npackage k\n\nimport j.*\n\nval d1 = Derived1()\nval d2 = Derived2()\n\nfun <T> select(x1: T, x2: T) = x1\nfun <T> selectn(vararg xx: T) = xx[0]\nfun <T : Base> foo(x: T) = x.foo()\nfun <T> listOf2(x1: T, x2: T): List<T> = null!!\nfun <T> arrayOf2(x1: T, x2: T): Array<T> = null!!\n\nfun test() {\n    val test1: Base = <!NI;INACCESSIBLE_TYPE!>if (true) d1 else d2<!>\n\n    val test2 = <!INACCESSIBLE_TYPE!>if (true) d1 else d2<!>\n\n    val test3 = <!INACCESSIBLE_TYPE!>when {\n        true -> d1\n        else -> d2\n    }<!>\n\n    val test4: Base = <!NI;INACCESSIBLE_TYPE!>when {\n        true -> d1\n        else -> d2\n    }<!>\n\n    val test5 = <!INACCESSIBLE_TYPE!>select(d1, d2)<!>\n\n    val test6 = select<Base>(d1, d2)\n\n    val test7 = select(d1 as Base, d2)\n\n    val test8 = <!INACCESSIBLE_TYPE!>selectn(d1, d2)<!>\n\n    val test9 = selectn<Base>(d1, d2)\n\n    val test10 = <!INACCESSIBLE_TYPE!>listOf2(d1, d2)<!>\n\n    val test11: List<Base> = <!INACCESSIBLE_TYPE!>listOf2(d1, d2)<!>\n    // NB Inferred type is List<Impl> because List is covariant.\n\n    val test12 = listOf2<Base>(d1, d2)\n\n    val test13 = <!INACCESSIBLE_TYPE!>arrayOf2(d1, d2)<!>\n\n    val test14: Array<Base> = arrayOf2(d1, d2)\n    // NB Inferred type is Array<Base> because Array is invariant.\n\n    val test15 = arrayOf2<Base>(d1, d2)\n\n    for (test16 in <!INACCESSIBLE_TYPE!>listOf2(d1, d2)<!>) {}\n}\n\nfun testOkInJava() {\n    // The following is Ok in Java, but is an error in Kotlin.\n    // TODO do not generate unneeded CHECKCASTs.\n    // TODO do not report INACCESSIBLE_TYPE for corresponding cases.\n    <!INACCESSIBLE_TYPE!>select(d1, d2)<!>\n    foo(<!INACCESSIBLE_TYPE!>select(d1, d2)<!>)\n}\n"
        },
        {
            "code": "private enum class Foo { A, B }\n\nclass Bar(<!EXPOSED_PARAMETER_TYPE!>val foo: Foo<!>)"
        },
        {
            "code": "private enum class Foo { A, B }\n\nclass Bar private constructor(<!EXPOSED_PROPERTY_TYPE_IN_CONSTRUCTOR!>val foo: Foo<!>)"
        },
        {
            "code": "private interface My\n\nprivate open class Base\n\npublic interface Your: <!EXPOSED_SUPER_INTERFACE!>My<!> {\n    fun <T: Base> foo(): T\n}\n\npublic class Derived<<!EXPOSED_TYPE_PARAMETER_BOUND!>T: My<!>>(<!EXPOSED_PARAMETER_TYPE!>val x: My<!>): <!EXPOSED_SUPER_CLASS!>Base()<!> {\n\n    constructor(<!EXPOSED_PARAMETER_TYPE!>xx: My?<!>, <!EXPOSED_PARAMETER_TYPE!>x: My<!>): this(xx ?: x)\n\n    val <!EXPOSED_PROPERTY_TYPE!>y<!>: Base? = null\n\n    val <!EXPOSED_RECEIVER_TYPE!>My<!>.z: Int\n        get() = 42\n\n    fun <!EXPOSED_FUNCTION_RETURN_TYPE!>foo<!>(<!EXPOSED_PARAMETER_TYPE!>m: My<!>): My = m\n\n    fun <!EXPOSED_RECEIVER_TYPE!>My<!>.<!EXPOSED_FUNCTION_RETURN_TYPE!>bar<!>(): My = this\n}\n\n\n"
        },
        {
            "code": "// KT-14469: SOE during effective visibility evaluation\n\nabstract class Base(private val v: String)\n\nfun bar(arg: String) = arg\n\nclass Derived : Base(\"123\") {\n\n    private <!NOTHING_TO_INLINE!>inline<!> fun foo() {\n        bar(<!INVISIBLE_MEMBER!>v<!>)\n    }\n}\n"
        },
        {
            "code": "interface Your\n\nclass My {\n    internal val x = object : Your {}\n\n    internal fun <!EXPOSED_FUNCTION_RETURN_TYPE!>foo<!>() = {\n        class Local\n        Local()\n    }()\n}"
        },
        {
            "code": "class My<T>(val value: T)\n\nopen class Base\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>invalid1<!>() = run {\n    class Local\n    My(Local())\n}\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>invalid2<!>() = My(object {})\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>invalid3<!>() = My(object : Base() {})\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>invalid4<!>() = run {\n    class Local\n    My(My(Local()))\n}\n\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>invalid5<!>() = run {\n    fun invalid5a() = run {\n        class Local\n        Local()\n    }\n    My(invalid5a())\n}\n\n// Valid: effectively Any\nfun valid1() = object {}\n\n// Valid: effectively Base\nfun valid2() = object : Base() {}\n\n// Valid: explicit type argument\nfun valid3() = My<Base>(object : Base() {})\n\n// Valid: explicit type specified\nfun valid4() : My<Base> = My(object : Base() {})\n\n// Valid: local class denotable in local scope\nfun valid5() = run {\n    class Local\n    fun valid5a() = My(Local())\n    My<Any>(valid5a())\n}\n\n// Valid: local class denotable in local scope\nfun valid6() = run {\n    class Local\n    fun valid6a() = run {\n        fun valid6b() = My(Local())\n        valid6b()\n    }\n    My<Any>(valid6a())\n}\n\n// Valid: effectively My<Any>\nfun valid7() = run {\n    class Local\n    My<My<*>>(My(Local()))\n}\n"
        },
        {
            "code": "internal class My\n\nclass Your\n\n// Both arguments should be exposed\nfun foo(<!EXPOSED_PARAMETER_TYPE!>my: My<!>, <!EXPOSED_PARAMETER_TYPE!>f: (My) -> Unit<!>) = f(my)\n\n// Ok\nfun bar(your: Your, f: (Your) -> Unit) = f(your)\n\n// Exposed, returns My\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>gav<!>(<!EXPOSED_PARAMETER_TYPE!>f: () -> My<!>) = f()"
        },
        {
            "code": "class Something {\n    public val publicVal1 = object { override fun toString() = \"!\" }\n    protected val protectedVal1 = object { override fun toString() = \"!\" }\n    internal val internalVal1 = object { override fun toString() = \"!\" }\n    private val privateVal1 = object { override fun toString() = \"!\" }\n\n    public val <!EXPOSED_PROPERTY_TYPE!>publicVal2<!> = run { class A; A() }\n    protected val <!EXPOSED_PROPERTY_TYPE!>protectedVal2<!> = run { class A; A() }\n    internal val <!EXPOSED_PROPERTY_TYPE!>internalVal2<!> = run { class A; A() }\n    private val privateVal2 = run { class A; A() }\n\n    public fun publicFun1() = object { override fun toString() = \"!\" }\n    protected fun protectedFun1() = object { override fun toString() = \"!\" }\n    internal fun internalFun1() = object { override fun toString() = \"!\" }\n    private fun privateFun1() = object { override fun toString() = \"!\" }\n\n    public fun <!EXPOSED_FUNCTION_RETURN_TYPE!>publicFun2<!>() = run { class A; A() }\n    protected fun <!EXPOSED_FUNCTION_RETURN_TYPE!>protectedFun2<!>() = run { class A; A() }\n    internal fun <!EXPOSED_FUNCTION_RETURN_TYPE!>internalFun2<!>() = run { class A; A() }\n    private fun privateFun2() = run { class A; A() }\n}"
        },
        {
            "code": "internal open class My\n\nabstract class Your {\n    // invalid, List<My> is effectively internal\n    abstract fun <!EXPOSED_FUNCTION_RETURN_TYPE!>give<!>(): List<My>\n}\n\n// invalid, List<My> is effectively internal\ninterface His: <!EXPOSED_SUPER_INTERFACE!>List<My><!>\n\n// invalid, My is internal\ninterface Generic<<!EXPOSED_TYPE_PARAMETER_BOUND!>E: My<!>>\n\ninterface Our {\n    // invalid, Generic<My> is effectively internal\n    fun <!EXPOSED_FUNCTION_RETURN_TYPE!>foo<!>(): Generic<*>\n}"
        },
        {
            "code": "class My<T>(val value: T)\n\nopen class Base\n\nval <!EXPOSED_PROPERTY_TYPE!>invalid1<!> = run {\n    class Local\n    My(Local())\n}\n\nval <!EXPOSED_PROPERTY_TYPE!>invalid2<!> = My(object {})\n\nval <!EXPOSED_PROPERTY_TYPE!>invalid3<!> = My(object : Base() {})\n\nval <!EXPOSED_PROPERTY_TYPE!>invalid4<!> = run {\n    class Local\n    My(My(Local()))\n}\n\nval <!EXPOSED_PROPERTY_TYPE!>invalid5<!> = run {\n    fun invalid5a() = run {\n        class Local\n        Local()\n    }\n    My(invalid5a())\n}\n\n// Valid: effectively Any\nval valid1 = object {}\n\n// Valid: effectively Base\nval valid2 = object : Base() {}\n\n// Valid: explicit type argument\nval valid3 = My<Base>(object : Base() {})\n\n// Valid: explicit type specified\nval valid4 : My<Base> = My(object : Base() {})\n\n// Valid: local class denotable in local scope\nval valid5 = run {\n    class Local\n    fun valid5a() = My(Local())\n    My<Any>(valid5a())\n}\n\n// Valid: local class denotable in local scope\nval valid6 = run {\n    class Local\n    fun valid6a() = run {\n        fun valid6b() = My(Local())\n        valid6b()\n    }\n    My<Any>(valid6a())\n}\n\n// Valid: effectively My<Any>\nval valid7 = run {\n    class Local\n    My<My<*>>(My(Local()))\n}"
        },
        {
            "code": "// See KT-9540 \n\n// all protected should have lower bound that is more permissive than private\n// protected and internal should have lower bound that is more permissive than private\nopen class A {\n    private interface B\n    protected open class C {\n        protected interface D : <!EXPOSED_SUPER_INTERFACE!>B<!>\n        internal interface E : <!EXPOSED_SUPER_INTERFACE!>B<!>, <!EXPOSED_SUPER_INTERFACE!>D<!>\n    }\n}\n\n"
        },
        {
            "code": "// invalid, depends on local class\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>foo<!>() = run {\n    class A\n    A()\n}\n\n// invalid, depends on local class\nfun <!EXPOSED_FUNCTION_RETURN_TYPE!>gav<!>() = {\n    class B\n    B()\n}\n\nabstract class My\n\n// valid, object literal here is effectively My\nfun bar() = run {\n    object: My() {}\n}"
        },
        {
            "code": "package Jet87\n\nopen class A() {\n  fun foo() : Int = 1\n}\n\ninterface B {\n  fun bar() : Double = 1.0;\n}\n\ninterface G<X> {\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>X<!>> boo: Double  where X : A, X : B\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>A<!>> bal: Double  where A : B\n    val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>Y<!>> bas: Double where Y : B, <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>X<!> : B\n}\n\nclass C() : A(), B\n\nclass D() {\n  companion object : A(), B {}\n}\n\nclass Test1<T>()\n  where\n    T : A,\n    T : B,\n    <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>B<!> : T // error\n  {\n\n  fun test(t : T) {\n    <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>foo<!>()\n    <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>bar<!>()\n    t.foo()\n    t.bar()\n  }\n}\n\nfun test() {\n  Test1<<!UPPER_BOUND_VIOLATED!>B<!>>()\n  Test1<<!UPPER_BOUND_VIOLATED!>A<!>>()\n  Test1<C>()\n}\n\nclass Foo() {}\n\nclass Bar<T : <!FINAL_UPPER_BOUND!>Foo<!>>\n\nclass Buzz<T> where T : <!FINAL_UPPER_BOUND!>Bar<<!UPPER_BOUND_VIOLATED!>Int<!>><!>, T : <!UNRESOLVED_REFERENCE!>nioho<!>\n\nclass X<T : <!FINAL_UPPER_BOUND!>Foo<!>>\nclass Y<<!CONFLICTING_UPPER_BOUNDS!>T<!>> where T : <!FINAL_UPPER_BOUND!>Foo<!>, T : <!FINAL_UPPER_BOUND, ONLY_ONE_CLASS_BOUND_ALLOWED!>Bar<Foo><!>\n\nfun <T> test2(t : T)\n  where\n    T : A,\n    T : B,\n    <!NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER!>B<!> : T\n{\n  <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>foo<!>()\n  <!TYPE_PARAMETER_ON_LHS_OF_DOT!>T<!>.<!UNRESOLVED_REFERENCE!>bar<!>()\n  t.foo()\n  t.bar()\n}\n\nval t1 = test2<<!UPPER_BOUND_VIOLATED!>A<!>>(A())\nval t2 = test2<<!UPPER_BOUND_VIOLATED!>B<!>>(C())\nval t3 = test2<C>(C())\n\nval <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T<!>, <!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>B : T<!>> x : Int = 0"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// FILE: 1.kt\ninterface K {\n    fun foo1(r: Runnable)\n    fun foo2(r1: Runnable, r2: Runnable)\n}\nfun test(k: K, r: Runnable) {\n    k.foo1(r)\n    k.foo1(<!TYPE_MISMATCH!>{}<!>)\n\n    k.foo2(r, r)\n    k.foo2(<!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>)\n    k.foo2(r, <!TYPE_MISMATCH!>{}<!>)\n    k.foo2(<!TYPE_MISMATCH!>{}<!>, r)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference +SamConversionForKotlinFunctions +SamConversionPerArgument\n// !CHECK_TYPE\n// FILE: 1.kt\ninterface K {\n    fun foo(f: Fn<String, Any>): String\n    fun foo(f: Fn<Any, Any>): Int\n\n    fun bas(f: Fn<Any, Any>): String\n    fun bas(f: Fn<Any, String>): Int\n\n    fun bar(f: Fn<String, Any>): String\n    fun bar(f: Fn2<String, Any>): Int\n}\n\nfun test(k: K) {\n    k.foo { it checkType { _<Any>() }; \"\" } checkType { _<Int>() }\n\n    k.bas { it checkType { _<Any?>() }; \"\" } checkType { _<Int>() }\n\n    // NI: TODO\n    k.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!> { <!UNRESOLVED_REFERENCE!>it<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><Any>() }; \"\" } <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><Int>() }\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// FILE: 1.kt\nfun test(j: J<Runnable>, r: Runnable) {\n    j.foo(r, r)\n    j.foo(r, <!TYPE_MISMATCH!>{}<!>)\n    j.foo(<!TYPE_MISMATCH!>{}<!>, r)\n    j.foo(<!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !CHECK_TYPE\n// FILE: 1.kt\nfun test(j: J) {\n    j.foo({ it checkType { _<Any>() }; \"\" }, \"\") checkType { _<Int>() }\n\n    j.bas({ it checkType { _<Any>() }; \"\" }, \"\") checkType { _<Int>() }\n\n    // NI: TODO\n    j.<!OVERLOAD_RESOLUTION_AMBIGUITY!>bar<!> { <!UNRESOLVED_REFERENCE!>it<!> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><Any>() }; \"\" } <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>checkType<!> { <!UNRESOLVED_REFERENCE!>_<!><Int>() }\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference +SamConversionForKotlinFunctions\n// FILE: 1.kt\ninterface K<T> {\n    fun foo(t1: T, t2: T)\n}\n\nfun test(k: K<Runnable>, r: Runnable) {\n    k.foo(r, r)\n    k.foo(r, <!TYPE_MISMATCH!>{}<!>)\n    k.foo(<!TYPE_MISMATCH!>{}<!>, r)\n    k.foo(<!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// FILE: 1.kt\n\ninterface K {\n    fun foo1(r: Runnable)\n    fun foo2(r1: Runnable, r2: Runnable)\n    fun foo3(r1: Runnable, r2: Runnable, r3: Runnable)\n}\nfun test(k: K, r: Runnable) {\n    k.foo1(r)\n    k.foo1(<!TYPE_MISMATCH!>{}<!>)\n\n    k.foo2(r, r)\n    k.foo2(<!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>)\n    k.foo2(r, <!TYPE_MISMATCH!>{}<!>)\n    k.foo2(<!TYPE_MISMATCH!>{}<!>, r)\n\n    k.foo3(r, r, r)\n    k.foo3(r, r, <!TYPE_MISMATCH!>{}<!>)\n    k.foo3(r, <!TYPE_MISMATCH!>{}<!>, r)\n    k.foo3(r, <!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>)\n    k.foo3(<!TYPE_MISMATCH!>{}<!>, r, r)\n    k.foo3(<!TYPE_MISMATCH!>{}<!>, r, <!TYPE_MISMATCH!>{}<!>)\n    k.foo3(<!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>, r)\n    k.foo3(<!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>, <!TYPE_MISMATCH!>{}<!>)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -USELESS_CAST\n\ninfix fun Any?.foo(a: Any) {}\ninfix fun Any?.zoo(a: Any) {}\ninfix fun Any?.Loo(a: Any) {}\ninfix fun Any?.doo(a: Any) {}\ninfix fun Any?.ddoo(a: Any) {}\noperator fun Any?.contains(a: Any): Boolean = true\n\nfun test(a: Any) {\n    1f<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    1f<!UNSUPPORTED!>foo<!> a\n    1<!UNSUPPORTED!>doo<!> a\n    1<!UNSUPPORTED!>ddoo<!> a\n    1<!INFIX_MODIFIER_REQUIRED, UNSUPPORTED!>contains<!> a\n\n    1L<!UNSUPPORTED!>foo<!> a\n    1L<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    1L<!UNSUPPORTED!>Loo<!> a\n\n    0b1<!UNSUPPORTED!>foo<!> a\n    0b1L<!UNSUPPORTED!>foo<!> a\n    0b1L<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    0b1L<!UNSUPPORTED!>Loo<!> a\n\n    0xf<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    0xff<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    0xfL<!UNSUPPORTED!>Loo<!> a\n\n    1.0f<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    1.0f<!UNSUPPORTED!>foo<!> a\n    1.0<!UNSUPPORTED!>doo<!> a\n    1.0<!UNSUPPORTED!>ddoo<!> a\n\n    .0f<!UNRESOLVED_REFERENCE, UNSUPPORTED!>oo<!> a\n    .0f<!UNSUPPORTED!>foo<!> a\n    .0<!UNSUPPORTED!>doo<!> a\n    .0<!UNSUPPORTED!>ddoo<!> a\n\n    1<!UNSUPPORTED!>in<!> a\n    1.0<!UNSUPPORTED!>in<!> a\n    1.0f<!UNSUPPORTED!>in<!> a\n    1.0<!UNRESOLVED_REFERENCE, UNSUPPORTED!>din<!> a\n    .0<!UNSUPPORTED!>in<!> a\n    .0f<!UNSUPPORTED!>in<!> a\n    .0<!UNRESOLVED_REFERENCE, UNSUPPORTED!>din<!> a\n\n    <!USELESS_IS_CHECK!>1<!UNSUPPORTED!>is<!> Any<!>\n    1<!UNSUPPORTED!>as<!> Any\n    1<!UNSUPPORTED!>as?<!> Any\n\n    <!USELESS_IS_CHECK!>1<!UNSUPPORTED!>!is<!> Any<!>\n    1<!UNSUPPORTED!>!in<!> a\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun import() {\n    <!FUNCTION_CALL_EXPECTED!>import<!> <!UNRESOLVED_REFERENCE!>a<!><!SYNTAX!>.<!><!DEBUG_INFO_MISSING_UNRESOLVED!>*<!><!SYNTAX!><!>\n}\n\nfun composite() {\n    val <!UNUSED_VARIABLE!>s<!> = 13+<!SYNTAX!>~<!><!DEBUG_INFO_MISSING_UNRESOLVED!>/<!>12\n}\n\nfun html() {\n    <!SYNTAX!><<!><!FUNCTION_CALL_EXPECTED!>html<!><!UNRESOLVED_REFERENCE!>><!><!SYNTAX!><<!><!DEBUG_INFO_MISSING_UNRESOLVED!>/<!><!DEBUG_INFO_MISSING_UNRESOLVED!>html<!><!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>><!><!SYNTAX!><!>\n}\n\nfun html1() {\n    <!SYNTAX!><<!><!FUNCTION_CALL_EXPECTED!>html<!><!UNRESOLVED_REFERENCE!>><!><!SYNTAX!><<!><!DEBUG_INFO_MISSING_UNRESOLVED!>/<!><!DEBUG_INFO_MISSING_UNRESOLVED!>html<!><!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>><!><!FUNCTION_CALL_EXPECTED!>html<!>\n}"
        },
        {
            "code": "// JAVAC_SKIP\n// FILE: p/Nameless.java\n\npackage p;\n\npublic class Nameless {\n    void () {}\n    int ;\n}\n\n// FILE: k.kt\n\nimport p.*\n\nclass K : Nameless() {\n    <!FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {}\n    val<!SYNTAX!><!> : Int = 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -REDECLARATION -DUPLICATE_CLASS_NAMES\n\nclass C {\n    <!FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {\n\n    }\n\n    val<!SYNTAX!><!> : Int = 1\n\n    class<!SYNTAX!><!> {}\n\n    enum class<!SYNTAX!><!> {}\n}\n\nclass C1<<!SYNTAX!>in<!>> {}\n\nclass C2(val<!SYNTAX!><!>) {}"
        },
        {
            "code": "// !DIAGNOSTICS: -REDECLARATION\n\npackage<!SYNTAX!><!>\n\n<!CONFLICTING_OVERLOADS, FUNCTION_DECLARATION_WITH_NO_NAME!>fun ()<!> {\n\n}\n\nval<!SYNTAX!><!> : Int = 1\n\n\nclass<!SYNTAX!><!> {\n\n}\n\ninterface<!SYNTAX!><!> {\n\n}\n\nobject<!SYNTAX!><!> {\n\n}\n\nenum class<!SYNTAX!><!> {}\n\nannotation class<!SYNTAX!><!> {}\n"
        },
        {
            "code": "fun main(args: Array<String>) {\n    args is Array<<!SYNTAX!><!>>\n}"
        },
        {
            "code": "open class Var() {\n  open var v : Int = 1\n}\n\ninterface VarT {\n  var v : Int\n}\n\nclass Val() : Var(), VarT {\n  override <!VAR_OVERRIDDEN_BY_VAL!>val<!> v : Int = 1\n}\n\nclass Var2() : Var() {\n  override var v : Int = 1\n}\n"
        },
        {
            "code": "class Foo(val a: Int, b: Int) {\n    val c = a + b\n\n    val d: Int\n        get() = a\n\n    val e: Int\n        get() = <!UNRESOLVED_REFERENCE!>b<!>\n}"
        },
        {
            "code": "// FILE: p/I.java\n\npackage p;\n\nimport p.J.Param;\n\npublic interface I {\n    String s();\n}\n\n// FILE: p/J.java\n\npackage p;\n\npublic class J implements I {\n    public String s() { return null; }\n}\n\n// FILE: k.kt\nimport p.*\n\nfun test() {\n    val s = J().s()\n    s.get(0)\n    s!!.get(0)\n}\n"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public static J j() { return null; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun foo(): J? = null\n\nfun main() {\n    val v = foo() ?: J.j()\n    if (v != null) {\n\n    }\n}"
        },
        {
            "code": "// FILE: p/Utils.java\n\npackage p;\n\npublic class Utils {\n    public static String str() { return null; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun <T : Any> T.foo() {}\n\nfun <D> test(b: Boolean) {\n    val str = if (b) Utils.str() else null\n\n    str?.foo()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE\n\n// FILE: p/Rec.java\n\npackage p;\n\npublic interface Rec<T> {\n\n}\n\n// FILE: p/A.java\n\npackage p;\n\npublic interface A extends Rec<A> {\n\n}\n\n// FILE: p/B.java\n\npackage p;\n\npublic interface B extends Rec<B> {\n\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(a: A, b: B, c: Boolean) {\n    var ab = if (c) a else b\n    ab = a\n    ab = b\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// JAVAC_SKIP\n// NI_EXPECTED_FILE\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public static J j() { return null; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\ninterface Out<out T1>\n\nfun <T> f(a: Out<T>, b: Out<T>, c: Out<T>): T = null!!\nfun <T> out(t: T): Out<MutableList<T>> = null!!\n\nfun test(a: Out<Nothing>, b: Out<MutableList<J>>) {\n    val v = f(a, b, out(J.j()))\n    v checkType { _<MutableList<J>>() }\n    v checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><MutableList<J?>>() }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: p/Super.java\n\npackage p;\n\npublic interface Super {\n\n}\n\n// FILE: p/Sub.java\n\npackage p;\n\npublic interface Sub extends Super {}\n\n// FILE: p/Other.java\n\npackage p;\n\nimport java.util.*;\n\npublic class Other {\n\n    public static Sub sub;\n\n    public static Collection<Sub> subs;\n    public static Collection<Super> supers;\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test() {\n    val col = if (1 < 2) Other.subs else Other.supers\n    col.foo()\n}\n\nfun <T: Super> Collection<T>.foo(): T = null!!\nfun <T> listOf(t: T): List<T> = null!!"
        },
        {
            "code": "// FILE: p/Utils.java\n\npackage p;\n\npublic class Utils {\n    public static java.util.Collection<String> c() { return null; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun <T : Any> T.foo() {}\n\nfun <D> test(b: Boolean) {\n    val c = if (b) Utils.c() else null\n\n    c?.foo()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !CHECK_TYPE\n// FILE: p/J.java\n\npackage p;\n\npublic class J<G> {\n    public static J<String> j() { return null; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun foo(j: J<String>) {\n    val v = if (true) j else J.j()\n    val js: J<String> = v\n    // TODO: fix with dominance\n//    v checkType { it : _<J<String>>}\n//    v checkType { it : _<J<String?>>}\n}"
        },
        {
            "code": "// FILE: main.kt\n\nfun test() {\n    C.create().foo(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    C.create().foo(\"\")\n\n    C<String>().foo(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    C<String?>().foo(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    C<String?>().foo(\"\")\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nfun test() {\n    A.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>bar<!>(<!NULL_FOR_NONNULL_TYPE!>null<!>, \"\")\n\n    A.bar<String>(<!NULL_FOR_NONNULL_TYPE!>null<!>, \"\")\n    A.bar<String?>(<!NULL_FOR_NONNULL_TYPE!>null<!>, \"\")\n    A.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>bar<!>(<!NULL_FOR_NONNULL_TYPE!>null<!>, A.platformString())\n}\n"
        },
        {
            "code": "// FILE: k.kt\n\nfun test(a: A<out CharSequence>) {\n    a.bar()<!UNNECESSARY_SAFE_CALL!>?.<!>length\n    a.bar()<!UNNECESSARY_SAFE_CALL!>?.<!>length\n}\n"
        },
        {
            "code": "// FILE: k.kt\n\nfun test() {\n    A.create().bar(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    A.create().bar(\"\")\n\n    A<String>().bar(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    A<String?>().bar(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    A<String?>().bar(\"\")\n}\n"
        },
        {
            "code": "// FILE: k.kt\n\nclass C1 : A<String?>() {\n    override fun bar(x: String) {}\n}\n\nclass C2 : A<String?>() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun bar(x: String?) {}\n}\n\nfun test() {\n    B1().bar(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    B2().bar(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n\n    C1().bar(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n}\n\n"
        },
        {
            "code": "// FILE: k.kt\n\nfun test() {\n    A.create().bar()<!UNNECESSARY_SAFE_CALL!>?.<!>length\n    A<String?>().bar()<!UNNECESSARY_SAFE_CALL!>?.<!>length\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n// FILE: foo/Base.java\n\npackage foo;\n\npublic interface Base<T> {}\n\n// FILE: foo/HS.java\n\npackage foo;\n\npublic class HS<T> extends Base<T> {}\n\n// FILE: k.kt\n\nimport foo.*;\n\nfun <T, C: Base<T>> convert(src: HS<T>, dest: C): C = throw Exception(\"$src $dest\")\n\nfun test(l: HS<Int>) {\n    //todo should be inferred\n    val r = convert(l, HS())\n    r checkType { _<HS<Int>>() }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public interface A {}\n    public static A foo(int s);\n\n    public interface B {}\n    public static B foo(Integer s);\n\n    public static Integer getInteger();\n}\n\n// FILE: k.kt\n\nimport p.*\nimport p.J.*\n\nclass C\n\nfun foo(i: Int?) : C = null!!\n\nfun test(i: Int, ni: Int?) {\n    checkSubtype<C>(foo(2))\n    checkSubtype<J.A>(J.foo(2))\n    checkSubtype<J.A>(J.foo(i))\n    checkSubtype<J.B>(J.foo(ni))\n    checkSubtype<C>(foo(ni))\n    checkSubtype<J.B>(J.foo(ni))\n\n    foo(J.getInteger())\n    J.foo(J.getInteger())\n}\n\n"
        },
        {
            "code": "// FILE: main.kt\nfun test() {\n    B.bar() { it<!UNSAFE_CALL!>.<!>hashCode() > 0 }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public J j() {return null;}\n\n    public <T> T foo() {return null;}\n    public <T extends J> T foo1() {return null;}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(j: J) {\n    checkSubtype<J>(j.j())\n    j.j().j()\n    j.j()!!.j()\n\n    val ann = j.foo<String>()\n    ann!!.length\n    ann.length\n\n    val a = j.foo<J>()\n    a!!.j()\n    a.j()\n}"
        },
        {
            "code": "import java.util.HashMap\n\ninterface ModuleDescriptorImpl\ninterface ModuleInfo\ninterface ResolverForModule\ninterface ResolverForProject<M1, R1>\n\nclass ResolverForProjectImpl<M : ModuleInfo, R : ResolverForModule>(\n        <!UNUSED_PARAMETER!>descriptorByModule<!>: Map<M, ModuleDescriptorImpl>,\n        <!UNUSED_PARAMETER!>delegateResolver<!>: ResolverForProject<M, R>\n) : ResolverForProject<M, R>\n\nfun <M2: ModuleInfo, A: ResolverForModule> foo(delegateResolver: ResolverForProject<M2, A>): ResolverForProject<M2, A> {\n    val descriptorByModule = HashMap<M2, ModuleDescriptorImpl>()\n    return ResolverForProjectImpl(descriptorByModule, delegateResolver)\n}\n\n// M = M2\n// HashMap<M2, MDI> :< Map<M, MDI> => M = M2!\n// R = A\n// RFP<M2, A> :< RFP<M, R>"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: p/Visitor.java\n\npackage p;\n\npublic interface Visitor<D> {\n\n}\n\n// FILE: p/Element.java\n\npackage p;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class Element {\n    public <D, R> R accept(@NotNull Visitor<R> visitor, D data) {return null;}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(v: Visitor<Nothing>, e: Element) {\n    e.accept(v, null)\n}\n"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\nimport java.util.ArrayList;\n\npublic class J {\n    public ArrayList<String> list() { return null; }\n    public void takeList(ArrayList<String> list) { }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(j: J) {\n    j.takeList(j.list())\n    val l = j.list()\n    j.takeList(l)\n}"
        },
        {
            "code": "// FILE: p/SAM.java\n\npackage p;\n\npublic interface SAM<R> {\n    R foo();\n}\n\n// FILE: p/Util.java\n\npackage p;\n\npublic class Util {\n\n    public static void sam(SAM<Void> sam) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test() {\n    Util.sam {\n        null\n    }\n}"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public void str(J s) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test() {\n    J().str(J())\n    J().str(null)\n}"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public void intArr(int[] s) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(ia: IntArray) {\n    J().intArr(ia)\n    J().intArr(null)\n}"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public void _int(int s) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test() {\n    J()._int(1)\n    J()._int(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n}"
        },
        {
            "code": "// JAVAC_EXPECTED_FILE\n// FILE: main.kt\n\ninterface ResolverForProject<M1> {\n    val exposeM: M1 get() = null!!\n}\n\nclass ResolverForProjectImpl<M>(\n        <!UNUSED_PARAMETER!>descriptorByModule<!>: Map<M, String>,\n        <!UNUSED_PARAMETER!>delegateResolver<!>: ResolverForProject<M>\n) : ResolverForProject<M>\n\ninterface WithFoo {\n    fun foo()\n}\n\nfun <M2: WithFoo> foo(delegateResolver: ResolverForProject<M2?>): ResolverForProject<M2?> {\n    val descriptorByModule = MyMap<M2, String>()\n    val result = ResolverForProjectImpl(descriptorByModule, delegateResolver)\n    result.exposeM.foo() // M is not M2?\n    result.exposeM?.foo() // no warning, M is not M2, hense M is M2!\n\n    return ResolverForProjectImpl(descriptorByModule, delegateResolver) // another bound check\n}\n\n// MyMap<M2, String> :< Map<M, String> => M = M2!\n// RFP<M2?> :< RFP<M> => M = M2?"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public void list(java.util.List<String> s) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(ls: List<String>, mls: MutableList<String>, lsn: List<String?>, mlsn: MutableList<String?>?) {\n    J().list(ls)\n    J().list(mls)\n    J().list(lsn)\n    J().list(mlsn)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\ninterface Foo\n\nfun test() {\n    var nullable: Foo? = null\n    val foo: Collection<Foo> = java.util.Collections.<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>singleton(nullable)<!>\n    val foo1: Collection<Foo> = java.util.Collections.singleton(nullable!!)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public J j() { return this; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun takeJ(j: J) {}\n\nfun test() {\n    takeJ(J().j())\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public void arr(Object[] s) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(\n        aa: Array<Any>,\n        sa: Array<String>,\n        san: Array<String?>\n) {\n    J().arr(null)\n    J().arr(aa)\n    J().arr(sa)\n    J().arr(san)\n}"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J<T> {\n    public void foo(Ref<T[]> r) {}\n}\n\n// FILE: p/Ref.java\n\npackage p;\n\npublic class Ref<T> {\n    public static <T> Ref<T> create() { return null; }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun main(j: J<String>) {\n    val r = Ref.create<Array<String>>()\n    j.foo(r)\n}\n"
        },
        {
            "code": "// FILE: p/Super.java\npackage p;\n\npublic interface Super {}\n\n// FILE: p/Sub.java\npackage p;\n\npublic interface Sub extends Super {}\n\n// FILE: p/Util.java\n\npackage p;\n\npublic abstract class Util {\n    public abstract void foo(String s, Super sup);\n    public void foo(String s, Sub sub) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nclass C: Util() {\n    override fun foo(s: String, sub: Super) {}\n}\n\nfun foo(sub: Sub) {\n    C().foo(\"\", sub)\n}\n"
        },
        {
            "code": "// FILE: p/MultiMap.java\n\npackage p;\n\nimport java.util.*;\n\npublic class MultiMap<K, V> {\n    public Set<Collection<V>> entrySet() {\n        return null;\n    }\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test() {\n    val map = MultiMap<Int, String>()\n    val set = map.entrySet()\n    set.iterator()\n\n    val set1 = map.entrySet()!!\n    set1.iterator()\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public String s() { return null; }\n}\n\n// FILE: k.kt\nimport p.*\n\nfun test(j: J) {\n    j.s()?.length ?: \"\"\n}\n"
        },
        {
            "code": "import java.util.ArrayList\n\nfun foo() {\n    val list = ArrayList<String?>()\n\n    for (s in list) {\n        s<!UNSAFE_CALL!>.<!>length\n    }\n}"
        },
        {
            "code": "// FILE: main.kt\n\nclass E : D(), B {\n    override fun foo(x: Any, y: List<Any?>): String = \"\"\n    override fun bar(x: CharSequence?, y: List<*>?): String = \"\"\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class E2<!> : B {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: Any, y: List<String?>): String = \"\"\n}\n\n\nclass F : D()\n"
        },
        {
            "code": "// !EXPLICIT_FLEXIBLE_TYPES\n\ninterface A<T>\ninterface B<T>: A<ft<T, T?>>\n\ninterface C: A<String>, B<String>\ninterface D: B<String>, A<String>\ninterface E: A<String?>, B<String?>\ninterface F: A<String?>, B<String>\n\ninterface G: <!INCONSISTENT_TYPE_PARAMETER_VALUES!>A<String>, B<String?><!>\ninterface H: <!INCONSISTENT_TYPE_PARAMETER_VALUES!>A<Int>, B<String><!>\ninterface I: <!INCONSISTENT_TYPE_PARAMETER_VALUES!>B<Int>, A<String><!>"
        },
        {
            "code": "// FILE: p/PsiElement.java\n\npackage p;\n\npublic interface PsiElement {}\n\n// FILE: p/JetExpression.java\n\npackage p;\n\npublic interface JetExpression extends PsiElement {}\n\n// FILE: p/Util.java\n\npackage p;\n\npublic class Util {\n\n    public static <T extends PsiElement> T getParentOfType(@Nullable PsiElement element, @NotNull Class<T> aClass) {\n        return null;\n    }\n\n    public static void on(JetExpression e) {}\n}\n\n// FILE: k.kt\n\nimport p.*\n\nfun test(e: JetExpression) {\n    Util.on(\n        Util.getParentOfType(e, javaClass<JetExpression>()) ?: e\n    )\n}\n\nfun <T> javaClass(): Class<T> = null!!"
        },
        {
            "code": "// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public static void c(java.util.Comparator<Integer> c) {}\n\n}\n\n// FILE: k.kt\n\nimport java.util.*\nimport p.*\n\nfun test() {\n    J.c(Comparator { a, b -> b - a })\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    val a: Any? = null\n\n    if (<!SENSELESS_COMPARISON!>platformNN !== null<!>) {}\n    if (<!SENSELESS_COMPARISON!>null !== platformNN<!>) {}\n    if (<!SENSELESS_COMPARISON!>platformNN === null<!>) {}\n    if (<!SENSELESS_COMPARISON!>null === platformNN<!>) {}\n\n    if (platformN !== null) {}\n    if (platformN === null) {}\n    if (a === null && platformN === <!DEBUG_INFO_CONSTANT!>a<!>) {}\n\n    if (platformJ !== null) {}\n    if (platformJ === null) {}\n    if (a === null && platformJ === <!DEBUG_INFO_CONSTANT!>a<!>) {}\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    platformNN.foo()\n    platformN<!UNSAFE_CALL!>.<!>foo()\n    platformJ.foo()\n\n    with(platformNN) {\n        foo()\n    }\n    with(platformN) {\n        <!UNSAFE_CALL!>foo<!>()\n    }\n    with(platformJ) {\n        foo()\n    }\n\n    platformNN.bar()\n    platformN.bar()\n    platformJ.bar()\n}\n\nfun J.foo() {}\nfun J?.bar() {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// KT-6829 False warning on map to @Nullable\n\n// FILE: k.kt\n\nfun foo(collection: Collection<J>) {\n    val mapped = collection.map { it.method() }\n    mapped[0]<!UNSAFE_CALL!>.<!>length\n}\n\npublic fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    null!!\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nclass A : List<String> by J.staticNN\nclass B : List<String> by <!TYPE_MISMATCH!>J.staticN<!>\nclass C : List<String> by J.staticJ"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n\n    foo(platformNN<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    val bar = Bar()\n    bar(platformNN<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n}\n\nfun foo(a: Any) {}\n\nclass Bar {\n    operator fun invoke(a: Any) {}\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nfun test() {\n    throw J.staticNN\n}\n\nfun test1() {\n    throw <!TYPE_MISMATCH!>J.staticN<!>\n}\n\nfun test2() {\n    throw J.staticJ\n}"
        },
        {
            "code": "// FILE: k.kt\n\nvar A by J.staticNN\nvar B by <!DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE, DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE!>J.staticN<!>\nvar C by J.staticJ"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    val a: Any? = null\n\n    if (<!SENSELESS_COMPARISON!>platformNN != null<!>) {}\n    if (<!SENSELESS_COMPARISON!>null != platformNN<!>) {}\n    if (<!SENSELESS_COMPARISON!>platformNN == null<!>) {}\n    if (<!SENSELESS_COMPARISON!>null == platformNN<!>) {}\n\n    if (a != null && platformNN != a) {}\n\n    if (platformN != null) {}\n    if (platformN == null) {}\n    if (a == null && platformN == <!DEBUG_INFO_CONSTANT!>a<!>) {}\n\n    if (platformJ != null) {}\n    if (platformJ == null) {}\n    if (a == null && platformJ == <!DEBUG_INFO_CONSTANT!>a<!>) {}\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -SENSELESS_COMPARISON, -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    val v0 = platformNN <!USELESS_ELVIS!>?: J()<!>\n    platformNN <!USELESS_ELVIS!>?: J()<!>\n    platformN ?: J()\n    platformJ ?: J()\n\n    if (platformNN != null) {\n        platformNN <!USELESS_ELVIS!>?: J()<!>\n    }\n\n    if (platformN != null) {\n        platformN <!USELESS_ELVIS!>?: J()<!>\n    }\n\n    if (platformJ != null) {\n        platformJ <!USELESS_ELVIS!>?: J()<!>\n    }\n\n    takeNotNull(J.staticNN <!USELESS_ELVIS!>?: J()<!>)\n    takeNotNull(J.staticN ?: J())\n    takeNotNull(J.staticJ ?: J())\n    takeNotNull(J.getAny() ?: J())\n    takeNotNull(J.getNNAny() <!USELESS_ELVIS!>?: J()<!>)\n    takeNotNull(J.getNAny() ?: J())\n\n    val x = <!UNRESOLVED_REFERENCE!>unresolved<!> ?: null\n    <!UNREACHABLE_CODE!>val y =<!> <!UNRESOLVED_REFERENCE!>unresolved<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>foo<!> ?: return\n}\n\nfun takeNotNull(s: J) {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    val a = J.staticN <!USELESS_ELVIS_RIGHT_IS_NULL!>?: null<!>\n    foo(a)\n    val b = JJ.staticNN ?: null\n    foo(b)\n    val c = JJJ.staticNNN <!USELESS_ELVIS!>?: null<!>\n    foo(c)\n}\n\nfun foo(a: Any?) {\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    platformNN.foo()\n    platformN<!UNSAFE_CALL!>.<!>foo()\n    platformJ.foo()\n\n    with(platformNN) {\n        foo()\n    }\n    with(platformN) {\n        <!UNSAFE_CALL!>foo<!>()\n    }\n    with(platformJ) {\n        foo()\n    }\n}\n"
        },
        {
            "code": "// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    platformNN[0]\n    <!UNSAFE_CALL!>platformN[0]<!>\n    platformJ[0]\n\n    platformNN[0] = 1\n    <!UNSAFE_CALL!>platformN[0]<!>  = 1\n    platformJ[0]  = 1\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    if (platformNN) {}\n    if (<!TYPE_MISMATCH, TYPE_MISMATCH!>platformN<!>) {}\n    if (platformJ) {}\n\n    while (platformNN) {}\n    while (<!TYPE_MISMATCH, TYPE_MISMATCH!>platformN<!>) {}\n    while (platformJ) {}\n\n    do {} while (platformNN)\n    do {} while (<!TYPE_MISMATCH, TYPE_MISMATCH!>platformN<!>)\n    do {} while (platformJ)\n\n    platformNN && false\n    <!TYPE_MISMATCH!>platformN<!> && false\n    platformJ && false\n\n    platformNN || false\n    <!TYPE_MISMATCH!>platformN<!> || false\n    platformJ || false\n\n    !platformNN\n    <!UNSAFE_CALL!>!<!>platformN\n    !platformJ\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nfun test(n: J?, nn: J) {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    J.staticNN = <!TYPE_MISMATCH!>n<!>\n    J.staticNN = <!TYPE_MISMATCH!>platformN<!>\n    J.staticNN = nn\n    J.staticNN = platformNN\n    J.staticNN = platformJ\n\n    J.staticN = n\n    J.staticN = platformN\n    J.staticN = nn\n    J.staticN = platformNN\n    J.staticN = platformJ\n\n    J.staticJ = n\n    J.staticJ = platformN\n    J.staticJ = nn\n    J.staticJ = platformNN\n    J.staticJ = platformJ\n\n    J.staticSet(nn, nn, nn)\n    J.staticSet(platformNN, platformNN, platformNN)\n    J.staticSet(<!TYPE_MISMATCH!>n<!>, n, n)\n    J.staticSet(<!TYPE_MISMATCH!>platformN<!>, platformN, platformN)\n    J.staticSet(platformJ, platformJ, platformJ)\n\n    J().nn = <!TYPE_MISMATCH!>n<!>\n    J().nn = <!TYPE_MISMATCH!>platformN<!>\n    J().nn = nn\n    J().nn = platformNN\n    J().nn = platformJ\n\n    J().n = n\n    J().n = platformN\n    J().n = nn\n    J().n = platformNN\n    J().n = platformJ\n\n    J().j = n\n    J().j = platformN\n    J().j = nn\n    J().j = platformNN\n    J().j = platformJ\n\n    J().set(nn, nn, nn)\n    J().set(platformNN, platformNN, platformNN)\n    J().set(<!TYPE_MISMATCH!>n<!>, n, n)\n    J().set(<!TYPE_MISMATCH!>platformN<!>, platformN, platformN)\n    J().set(platformJ, platformJ, platformJ)\n\n    J(nn, nn, nn)\n    J(platformNN, platformNN, platformNN)\n    J(<!TYPE_MISMATCH!>n<!>, n, n)\n    J(<!TYPE_MISMATCH!>platformN<!>, platformN, platformN)\n    J(platformJ, platformJ, platformJ)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    fun foo(p: J = platformNN, p1: J = <!TYPE_MISMATCH!>platformN<!>, p2: J = platformJ) {}\n\n    fun foo1(p: J? = platformNN, p1: J? = platformN, p2: J? = platformJ) {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -SENSELESS_COMPARISON -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    if (platformNN != null) {\n        platformNN<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n\n    if (platformN != null) {\n        platformN<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n\n    if (platformJ != null) {\n        platformJ<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    }\n\n    platformNN<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n    platformN!!\n    platformJ!!\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: k.kt\n\nfun test() {\n    val n = J.staticN\n    foo(<!TYPE_MISMATCH!>n<!>)\n    J.staticNN = <!TYPE_MISMATCH!>n<!>\n    if (n != null) {\n        foo(<!DEBUG_INFO_SMARTCAST!>n<!>)\n        J.staticNN = <!DEBUG_INFO_SMARTCAST!>n<!>\n    }\n\n    val x: J? = null\n    J.staticNN = <!TYPE_MISMATCH!>x<!>\n    if (x != null) {\n        J.staticNN = <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n}\n\nfun foo(j: J) {}"
        },
        {
            "code": "// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    platformNN[0]\n    <!UNSAFE_CALL!>platformN[0]<!>\n    platformJ[0]\n\n    platformNN[0] = 1\n    <!UNSAFE_CALL!>platformN[0]<!>  = 1\n    platformJ[0]  = 1\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: k.kt\n\nfun test() {\n    foo(J.staticNN)\n    foo(<!TYPE_MISMATCH!>J.staticN<!>)\n    foo(J.staticJ)\n\n    bar(J.staticNN)\n    bar(J.staticN)\n    bar(J.staticJ)\n}\n\nfun foo(j: J) {}\nfun bar(j: J?) {}"
        },
        {
            "code": "// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    for (x in platformNN) {}\n    for (x in <!ITERATOR_ON_NULLABLE!>platformN<!>) {}\n    for (x in platformJ) {}\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nvar v: J = J()\nvar n: J? = J()\n\nfun test() {\n    v = J.staticNN\n    v = <!TYPE_MISMATCH!>J.staticN<!>\n    v = J.staticJ\n\n    n = J.staticNN\n    n = J.staticN\n    n = J.staticJ\n}"
        },
        {
            "code": "// FILE: k.kt\n\nfun list(j: J): Any {\n    val a = j.n()!!\n\n    a<!UNNECESSARY_SAFE_CALL!>?.<!>get(0)\n    if (<!SENSELESS_COMPARISON!>a == null<!>) {}\n    a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>\n\n    a.get(0)\n    return a\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -SENSELESS_COMPARISON\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    platformNN<!UNNECESSARY_SAFE_CALL!>?.<!>foo()\n    platformN?.foo()\n    platformJ?.foo()\n\n    if (platformNN != null) {\n        platformNN<!UNNECESSARY_SAFE_CALL!>?.<!>foo()\n    }\n\n    if (platformN != null) {\n        platformN<!UNNECESSARY_SAFE_CALL!>?.<!>foo()\n    }\n\n    if (platformJ != null) {\n        platformJ<!UNNECESSARY_SAFE_CALL!>?.<!>foo()\n    }\n}\n\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    checkSubtype<J>(platformNN)\n    checkSubtype<J>(<!TYPE_MISMATCH!>platformN<!>)\n    checkSubtype<J>(platformJ)\n\n    checkSubtype<J?>(platformNN)\n    checkSubtype<J?>(platformN)\n    checkSubtype<J?>(platformJ)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n    // @Nullable platform type\n    val platformN = J.staticN\n    // platform type with no annotation\n    val platformJ = J.staticJ\n\n    val (a1, b1) = platformNN\n    val (a2, b2) = <!COMPONENT_FUNCTION_ON_NULLABLE, COMPONENT_FUNCTION_ON_NULLABLE!>platformN<!>\n    val (a3, b3) = platformJ\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nfun test() {\n    J.staticNN()\n    J<!NI;UNSAFE_CALL!>.<!><!OI;UNSAFE_IMPLICIT_INVOKE_CALL!>staticN<!>()\n    J.staticJ()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    var platformNN = J.staticNN\n    // @Nullable platform type\n    var platformN = J.staticN\n    // platform type with no annotation\n    var platformJ = J.staticJ\n\n    +platformNN\n    <!UNSAFE_CALL!>+<!>platformN\n    +platformJ\n\n    ++platformNN\n    <!UNSAFE_CALL!>++<!>platformN\n    ++platformJ\n\n    platformNN++\n    platformN<!UNSAFE_CALL!>++<!>\n    platformJ++\n\n    1 + platformNN\n    1 + <!TYPE_MISMATCH!>platformN<!>\n    1 + platformJ\n\n    platformNN + 1\n    platformN <!UNSAFE_OPERATOR_CALL!>+<!> 1\n    platformJ + 1\n\n    1 <!INFIX_MODIFIER_REQUIRED!>plus<!> platformNN\n    1 <!INFIX_MODIFIER_REQUIRED!>plus<!> <!TYPE_MISMATCH!>platformN<!>\n    1 <!INFIX_MODIFIER_REQUIRED!>plus<!> platformJ\n\n    platformNN <!INFIX_MODIFIER_REQUIRED!>plus<!> 1\n    platformN <!INFIX_MODIFIER_REQUIRED, UNSAFE_INFIX_CALL!>plus<!> 1\n    platformJ <!INFIX_MODIFIER_REQUIRED!>plus<!> 1\n\n    platformNN += 1\n    platformN <!UNSAFE_OPERATOR_CALL!>+=<!> 1\n    platformJ += 1\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: k.kt\n\nfun test() {\n    // @NotNull platform type\n    val platformNN = J.staticNN\n\n    foo(platformNN <!USELESS_ELVIS!>?: \"\"<!>)\n\n    val bar = Bar()\n    bar(platformNN <!USELESS_ELVIS!>?: \"\"<!>)\n}\n\nfun foo(a: Any) {}\n\nclass Bar {\n    operator fun invoke(a: Any) {}\n}"
        },
        {
            "code": "// FILE: main.kt\n\n// fake_override fun foo(/*0*/ org.jetbrains.annotations.NotNull() x: kotlin.String, /*1*/ org.jetbrains.annotations.Nullable() y: kotlin.String?): kotlin.Unit\ninterface C1 : A<String>\n\n// fake_override fun foo(/*0*/ org.jetbrains.annotations.NotNull() x: kotlin.String?, /*1*/ org.jetbrains.annotations.Nullable() y: kotlin.String?): kotlin.Unit\ninterface C2 : A<String?>\n\ninterface C3 : B1 {\n    // inconsistent override\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: String?, y: String?);\n}\n"
        },
        {
            "code": "// FILE: A.kt\nopen class A {\n    open fun String.foo(y: String?): Int = 1\n    open fun String?.bar(y: String): Int = 1\n}\n\nclass E : B1() {\n    fun baz() {\n        val x: String? = \"\"\n\n        x<!UNSAFE_CALL!>.<!>foo(x)\n        x<!UNSAFE_CALL!>.<!>foo(\"\")\n        x.bar(<!TYPE_MISMATCH!>x<!>)\n        x.bar(\"\")\n    }\n\n    override fun String.foo(y: String?): Int = 1\n    override fun String?.bar(y: String): Int = 1\n}\n\n"
        },
        {
            "code": "// FILE: C.kt\n\nclass C1 : A, B {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String?<!> = \"\"\n}\n\nclass C2 : A, B {\n    override fun foo(): String = \"\"\n}\n\ninterface I : A, B\n\nclass C3 : I {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String?<!> = \"\"\n}\n\nclass C4 : I {\n    override fun foo(): String = \"\"\n}\n"
        },
        {
            "code": "// FILE: C.kt\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class C1<!> : A, B {\n    <!ACCIDENTAL_OVERRIDE!>override fun foo(x: String)<!> {}\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class C2<!> : A, B {\n    <!ACCIDENTAL_OVERRIDE!>override fun foo(x: String?)<!> {}\n}\n\ninterface <!CONFLICTING_INHERITED_JVM_DECLARATIONS!>I<!> : A, B\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class C3<!> : I {\n    <!ACCIDENTAL_OVERRIDE!>override fun foo(x: String)<!> {}\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class C4<!> : I {\n    <!ACCIDENTAL_OVERRIDE!>override fun foo(x: String?)<!> {}\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nfun main(a: A, ml: MutableList<String>, l: List<String>) {\n    a.foo(ml)\n    a.foo(<!TYPE_MISMATCH!>l<!>)\n\n    a.bar(<!TYPE_MISMATCH!>ml<!>)\n    a.bar(<!TYPE_MISMATCH!>l<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nfun main(a: A, ml: Any) {\n    if (ml is <!CANNOT_CHECK_FOR_ERASED!>MutableList<String><!>) {\n        a.foo(<!DEBUG_INFO_SMARTCAST, JAVA_TYPE_MISMATCH!>ml<!>)\n        a.foo(ml <!UNCHECKED_CAST!>as List<Any><!>)\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nfun main(\n        a: A,\n        ml: MutableList<String>, l: List<String>,\n        ms: MutableSet<String>, s: Set<String>,\n        mm: MutableMap<Any, String>, m: Map<Any, String>,\n        mme: MutableMap.MutableEntry<Any, String>, me: Map.Entry<Any, String>,\n        mll: MutableList<MutableList<String>>, ll: List<List<String>>\n) {\n    // Lists\n    a.foo(<!JAVA_TYPE_MISMATCH!>ml<!>)\n    a.foo(l)\n    a.foo(ml <!UNCHECKED_CAST!>as MutableList<Any><!>)\n    a.foo(l as List<Any>)\n\n    // Iterables\n    val mit: MutableIterable<String> = ml\n    val it: Iterable<String> = ml\n    a.foo(mit)\n    a.foo(it)\n\n    // Iterators\n    a.foo(ml.iterator())\n    a.foo(l.iterator())\n\n    // Sets\n    a.foo(<!JAVA_TYPE_MISMATCH!>ms<!>)\n    a.foo(s)\n    a.foo(ms <!UNCHECKED_CAST!>as MutableSet<Any><!>)\n    a.foo(s as Set<Any>)\n\n    // Maps\n    a.foo(<!JAVA_TYPE_MISMATCH!>mm<!>)\n    a.foo(m)\n    a.foo(mm <!UNCHECKED_CAST!>as MutableMap<Any, Any><!>)\n    a.foo(m as Map<Any, Any>)\n\n    // Map entries\n    a.foo(<!JAVA_TYPE_MISMATCH!>mme<!>)\n    a.foo(me)\n    a.foo(mme <!UNCHECKED_CAST!>as MutableMap.MutableEntry<Any, Any><!>)\n    a.foo(me as Map.Entry<Any, Any>)\n\n    // Lists of lists\n    a.foo(<!JAVA_TYPE_MISMATCH!>mll<!>)\n    a.foo(ll)\n    a.foo(mll <!UNCHECKED_CAST!>as MutableList<MutableList<Any>><!>)\n    a.foo(ll as List<List<Any>>)\n\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nabstract class B : MutableList<String>\n\nfun main(a: A, b: B) {\n    a.foo(<!JAVA_TYPE_MISMATCH!>b<!>)\n    a.foo(b as List<Any>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nfun main(a: A) {\n    a.foo(<!JAVA_TYPE_MISMATCH!>a.bar()<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// FILE: p/J.java\n\npackage p;\n\npublic class J {\n    public String s() { return null; }\n}\n\n// FILE: k.kt\nimport p.*\n\nfun test(j: J) {\n    j.s()?.length.checkType { _<Int?>() }\n}\n"
        },
        {
            "code": "// (failed) attempt to reproduce exception in\n// http://stackoverflow.com/questions/42571812/unsupportedoperationexception-while-building-a-kotlin-project-in-idea\n\n// FILE: main.kt\nclass E1 : C.D(), B {\n    override fun foo(x: Any, y: Fun<Any?>) {}\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class E2<!> : B {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: Any, y: Fun<String?>) {}\n}\n"
        },
        {
            "code": "// FILE: main.kt\n\nval doubleList: List<Double?> = null!!\n\nfun main() {\n    Test.rawField.foo(\"\", doubleList)\n    Test.rawField.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>, doubleList)\n    Test.DerivedRawA().foo(<!NULL_FOR_NONNULL_TYPE!>null<!>, doubleList)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nval strList: List<String> = null!!\n\nfun main() {\n    val rawB = Test.rawAField.b;\n    // Raw(A).b is not erased because it have no type parameters\n    var rawInner = rawB.bar(<!TYPE_MISMATCH(\"(Mutable)List<Double!>!\", \"List<String>\")!>strList<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nfun <T> arrayOf(): Array<T> = null!!\n\nfun main() {\n    val raw = Test.rawAField\n\n    raw.charSequences = arrayOf<String>()\n    raw.charSequences = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>arrayOf<Double>()<!>\n\n    raw.maps = arrayOf<Map<Int, Int>>()\n    raw.maps = arrayOf<MutableMap<Int, Int>>()\n    raw.maps = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>arrayOf<List<String>>()<!>\n\n    raw.arraysOfLists = arrayOf<Array<List<*>>>()\n    raw.arraysOfLists = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>arrayOf<List<String>>()<!>\n    raw.arraysOfLists = <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>arrayOf<Array<Array<String>>>()<!>\n\n    raw.arraysOfAny = arrayOf<Array<Array<String>>>()\n\n    raw.erasedLists = arrayOf<List<String>>()\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\nimport java.util.*;\n\nclass B1 : RawADerived() {\n    override fun foo(x: CharSequence, y: Map<Any?, Any?>, z: HashMap<Any, Any>): A<*> = null!!\n\n    override fun bar(d: Array<Array<List<*>>>) {}\n}\n\nclass B2 : RawADerived() {\n    override fun foo(x: CharSequence?, y: MutableMap<Any?, Any?>, z: HashMap<Any?, Any?>): A<String> = null!!\n\n    override fun bar(d: Array<Array<MutableList<*>>>) {}\n}\n\nclass B3 : RawADerived() {\n    // Type of second parameter (y) is not equal to overridden\n    // RawADerived.foo.y --- (MutableMap<Any?, Any?>..Map<out Any?, out Any?>) is not a subtype of Map<Any?, Any>\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: CharSequence, y: Map<Any?, Any>, z: HashMap<Any, Any>): A<*> = null!!\n}\n\nclass B4 : RawADerived() {\n    // Type of first parameter is not equal to overridden\n    <!NOTHING_TO_OVERRIDE!>override<!> fun bar(d: Array<Array<MutableList<Array<Double>>>>) {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\n\nfun main() {\n    fun println() {}\n    // All parameters in SAM adapter of `foo` have functional types\n    B().foo(<!TYPE_MISMATCH!>{ println() }<!>, B.bar())\n    // So you should use SAM constructors when you want to use mix lambdas and Java objects\n    B().foo(Runnable { println() }, B.bar())\n    B().foo({ println() }, { it: Any? -> it == null } )\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: main.kt\nval strList: List<String> = null!!\n\nfun main() {\n    val rawA = Test.rawAField\n    rawA.first = Test.rawAField.second\n    Test.rawAField.second = rawA.first.second\n\n    rawA.listOfDoubles = strList\n    rawA.listOfDoubles = <!TYPE_MISMATCH!>\"\"<!> // first should be List\n}\n"
        },
        {
            "code": "interface Runnable {\n    fun run()\n}\n\nclass C {\n    fun f() {\n        <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class MyRunnable<!>(): Runnable {\n        }\n    }\n}"
        },
        {
            "code": "class Foo {\n    <!NON_FINAL_MEMBER_IN_FINAL_CLASS!>open<!> fun openFoo() {}\n    fun finalFoo() {}\n}\n\nclass Bar : <!FINAL_SUPERTYPE!>Foo<!>() {\n    override fun openFoo() {}\n    <!OVERRIDING_FINAL_MEMBER!>override<!> fun finalFoo() {}\n}\n\n\nopen class A1 {\n    open fun foo() {}\n}\n\nclass B1 : A1()\nclass C1 : <!FINAL_SUPERTYPE!>B1<!>() {\n    override fun foo() {}\n}\n\nabstract class A2 {\n    abstract fun foo()\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class B2<!> : A2()\nclass C2 : <!FINAL_SUPERTYPE!>B2<!>() {\n    override fun foo() {}\n}"
        },
        {
            "code": "package test\n\nopen class A {\n  open fun foo(a: <!UNRESOLVED_REFERENCE!>E<!>) {}\n}\n\nclass B : A() {\n  override fun foo(a: <!UNRESOLVED_REFERENCE!>E<!>) {}\n}"
        },
        {
            "code": "open class Aaa() {\n    open fun foo() = 1\n}\n\nopen class Bbb() : Aaa() {\n    override fun foo() = 2\n}\n\ninterface Ccc : <!INTERFACE_WITH_SUPERCLASS!>Aaa<!>\n\nclass Ddd() : Bbb(), Ccc"
        },
        {
            "code": "open class Aaa() {\n    fun foo() = 1\n}\n\nopen class Bbb() : Aaa() {\n    <!CONFLICTING_OVERLOADS!>fun <T> foo()<!> = 2\n}\n"
        },
        {
            "code": "interface Some {\n    fun test()\n}\n\nclass SomeImpl : Some  {\n    <!CONFLICTING_OVERLOADS!>override fun test()<!> {}\n    <!CONFLICTING_OVERLOADS!>override fun test()<!> {}\n}"
        },
        {
            "code": "interface X {\n    fun foo(a : Int = 1)\n}\n\ninterface Y {\n    fun foo(a : Int = 1)\n}\n\nclass Z : X, Y {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>foo<!>(a : Int) {}\n}\n\nobject ZO : X, Y {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>foo<!>(a : Int) {}\n}"
        },
        {
            "code": "class C : <!DELEGATION_NOT_TO_INTERFACE, UNRESOLVED_REFERENCE!>Base1<!> by <!UNRESOLVED_REFERENCE!>Base2<!>(1) {\n  fun test() { }\n}"
        },
        {
            "code": "interface A {\n    fun f(): String = \"string\"\n}\n\nopen class B {\n    open fun f(): CharSequence = \"charSequence\"\n}\n\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class C<!> : B(), A\n\nval obj: A = <!MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : B(), A {}\n"
        },
        {
            "code": "interface D {\n    fun foo()\n}\n\ninterface E {\n    fun foo() {}\n}\n\nobject Impl : D, E {\n    override fun foo() {}\n}\n\nval obj: D = <!DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE, MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>object<!> : D by Impl, E by Impl {}"
        },
        {
            "code": "interface A {\n    fun <T> foo() where T : Any, T : Cloneable?\n}\n\ninterface B : A {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun <T> foo() where T : Any?, T : Cloneable\n}\n"
        },
        {
            "code": "abstract class A {\n    abstract fun foo(): Int\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class B<!>() : A() {\n}"
        },
        {
            "code": "open class A {\n    open fun foo(a : Int) {}\n}\n\nclass C : A() {\n    override fun foo(a : Int = <!DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE!>1<!>) {\n    }\n}\n\nclass D : A() {\n    override fun foo(a : Int = <!DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE!>1<!>) {\n    }\n}\n"
        },
        {
            "code": "// KT-880 Overload resolution ambiguity\n\npublic interface I {\n    <!REDUNDANT_OPEN_IN_INTERFACE!>open<!> fun test() : Unit\n}\n\nabstract public class A() {\n    open public fun test() : Unit {\n    }\n}\n\npublic open class T() : A(), I {\n    open fun main() : Unit {\n        test() // Test no \"Overload resolution ambiguity\" is here\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER\npackage override.generics\n\nabstract class MyAbstractClass<T> {\n    abstract val pr : T\n}\n\nabstract class MyLegalAbstractClass2<T>(t : T) : MyAbstractClass<Int>() {\n    <!CONFLICTING_OVERLOADS!>val <R> pr : T<!> = t\n}"
        },
        {
            "code": "interface A {\n    fun foo() {}\n}\n\ninterface B : A {\n    abstract override fun foo()\n}\n\ninterface C {\n    abstract fun foo()\n}\n\n// Fake override Z#foo should be abstract\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Z<!> : B, C\n"
        },
        {
            "code": "interface A {\n    fun foo() {}\n}\n\ninterface B : A {\n    abstract override fun foo()\n}\n\ninterface C : A {\n    abstract override fun foo()\n}\n\ninterface D : A\n\n// Fake override Z#foo should be abstract\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Z<!> : B, C, D\n"
        },
        {
            "code": "interface A {\n    fun test() {\n    }\n}\n\ninterface B : A {\n    override fun test()\n}\n\ninterface C : A\n\ninterface D : C, B\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class K<!> : D\n"
        },
        {
            "code": "package d\n\ninterface A {\n    fun foo() = 1\n}\n\ninterface B {\n    fun foo() = 2\n}\n\nopen <!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class C<!> : A, B {}\n\ninterface E {\n    fun foo(): Int\n}\n\nclass D : C() {}\n"
        },
        {
            "code": "package override.generics\n\ninterface MyTrait<T> {\n    fun foo(t: T) : T\n}\n\nabstract class MyAbstractClass<T> {\n    abstract fun bar(t: T) : T\n    abstract val pr : T\n}\n\ninterface MyProps<T> {\n    val p : T\n}\n\nopen class MyGenericClass<T>(t : T) : MyTrait<T>, MyAbstractClass<T>(), MyProps<T> {\n    override fun foo(t: T) = t\n    override fun bar(t: T) = t\n    override val p : T = t\n    override val pr : T = t\n}\n\nclass MyChildClass() : MyGenericClass<Int>(1) {}\nclass MyChildClass1<T>(t : T) : MyGenericClass<T>(t) {}\nclass MyChildClass2<T>(t : T) : MyGenericClass<T>(t) {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>foo<!>(t: T) = t\n    val <!VIRTUAL_MEMBER_HIDDEN!>pr<!> : T = t\n    override fun bar(t: T) = t\n    override val p : T = t\n}\n\nopen class MyClass() : MyTrait<Int>, MyAbstractClass<String>() {\n    override fun foo(t: Int) = t\n    override fun bar(t: String) = t\n    override val pr : String = \"1\"\n}\n\nabstract class MyAbstractClass1 : MyTrait<Int>, MyAbstractClass<String>() {\n    override fun foo(t: Int) = t\n    override fun bar(t: String) = t\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalGenericClass1<!><T> : MyTrait<T>, MyAbstractClass<T>() {}\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalGenericClass2<!><T, R>(r : R) : MyTrait<T>, MyAbstractClass<R>() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(r: R) = r\n    <!CONFLICTING_OVERLOADS!><!NOTHING_TO_OVERRIDE!>override<!> val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>T<!>> pr : R<!> = r\n}\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalClass1<!> : MyTrait<Int>, MyAbstractClass<String>() {}\nabstract class MyLegalAbstractClass1 : MyTrait<Int>, MyAbstractClass<String>() {}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalClass2<!><T>(t : T) : MyTrait<Int>, MyAbstractClass<Int>() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo(t: T)<!> = t\n    <!ACCIDENTAL_OVERRIDE!>fun bar(t: T)<!> = t\n    <!CONFLICTING_OVERLOADS!>val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>R<!>> pr : T<!> = t\n}\nabstract class MyLegalAbstractClass2<T>(t : T) : MyTrait<Int>, MyAbstractClass<Int>() {\n    <!ACCIDENTAL_OVERRIDE!>fun foo(t: T)<!> = t\n    <!ACCIDENTAL_OVERRIDE!>fun bar(t: T)<!> = t\n    <!CONFLICTING_OVERLOADS!>val <<!TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER!>R<!>> pr : T<!> = t\n}"
        },
        {
            "code": "interface A {\n    fun f(): String\n}\n\nopen class B {\n    open fun f(): CharSequence = \"charSequence\"\n}\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class C<!> : B(), A\n\nval d: A = <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>object<!> : B(), A {}\n"
        },
        {
            "code": "interface A {\n    fun foo(x: Int = 42): Int\n}\n\nopen class B {\n    fun foo(x: Int = 239) = x\n}\n\ninterface C {\n    fun foo(y: Int): Int\n}\n\n// TODO DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES reported twice\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES, MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE!>class Z<!> : A, B(), C"
        },
        {
            "code": "// !DIAGNOSTICS: -TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER\nopen class Aaa() {\n    val bar = 1\n}\n\nopen class Bbb() : Aaa() {\n    <!CONFLICTING_OVERLOADS!>val <T> bar<!> = \"aa\"\n}"
        },
        {
            "code": "abstract class A {\n    abstract override fun toString(): String\n}\n\ninterface B\n\nabstract class C : A(), B\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class Test<!> : C()\n"
        },
        {
            "code": "interface A {\n    fun test(): String = \"A\"\n}\n\ninterface B : A {\n    override fun test(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>Unit<!> = <!TYPE_MISMATCH!>\"B\"<!>\n}\n\nopen class C : A\n\nclass D : C(), B\n"
        },
        {
            "code": "open class A {\n    final fun foo() {}\n}\n\nclass B : A() {\n    <!OVERRIDING_FINAL_MEMBER!>override<!> fun foo() {}\n}\n"
        },
        {
            "code": "// FILE: Super.kt\n\ninterface Super {\n    fun foo(superName: Int)\n}\n\n// FILE: SubSub.kt\n\nclass SubSub : Sub {\n    override fun foo(<!PARAMETER_NAME_CHANGED_ON_OVERRIDE!>subName<!>: Int) {}\n}\n"
        },
        {
            "code": "class Function1Impl : (String) -> Unit {\n    override fun invoke(myParamName: String) {}\n}\n\nfun test1(f: Function1Impl) {\n    f(\"\")\n    f(<!NAMED_PARAMETER_NOT_FOUND!>p0<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    f(myParamName = \"\")\n    f.invoke(\"\")\n    f.invoke(<!NAMED_PARAMETER_NOT_FOUND!>p0<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    f.invoke(myParamName = \"\")\n}\n\nfun test2(f: (String) -> Unit) {\n    f(\"\")\n    f(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>p0<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    f(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>myParamName<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    f.invoke(\"\")\n    f.invoke(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>p0<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    f.invoke(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>myParamName<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n\nfun test3(f: String.(String) -> Unit) {\n    \"\".f(\"\")\n    \"\".f(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>p0<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n    \"\".f(<!NAMED_ARGUMENTS_NOT_ALLOWED, NAMED_PARAMETER_NOT_FOUND!>zzz<!> = \"\"<!NO_VALUE_FOR_PARAMETER!>)<!>\n}\n"
        },
        {
            "code": "interface C {\n    fun foo(a : Int)\n}\n\ninterface D {\n    fun foo(b : Int)\n}\n\n<!DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES!>interface E<!> : C, D\n\ninterface F : C, D {\n    override fun foo(<!PARAMETER_NAME_CHANGED_ON_OVERRIDE!>a<!> : Int) {\n        throw UnsupportedOperationException()\n    }\n}"
        },
        {
            "code": "// FILE: kotlin.kt\n\ninterface KotlinTrait {\n    public fun foo(someOtherName: Int) {}\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class BothTraitsSubclass<!> : JavaInterface, KotlinTrait"
        },
        {
            "code": "interface A {\n    fun b(a : Int)\n}\n\ninterface B : A {}\n\nclass C1 : A {\n    override fun b(<!PARAMETER_NAME_CHANGED_ON_OVERRIDE!>b<!> : Int) {}\n}\n\nclass C2 : B {\n    override fun b(<!PARAMETER_NAME_CHANGED_ON_OVERRIDE!>b<!> : Int) {}\n}"
        },
        {
            "code": "interface T {\n    fun foo()\n}\n\nopen class C {\n    protected fun foo() {}\n}\n\nclass <!CANNOT_INFER_VISIBILITY!>E<!> : C(), T\n\nval z: T = <!CANNOT_INFER_VISIBILITY!>object<!> : C(), T {}\n"
        },
        {
            "code": "// http://youtrack.jetbrains.com/issue/KT-1996\n\ninterface Foo {\n    fun foo(): Unit\n}\n\ninterface Bar {\n    fun foo(): Unit\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Baz<!> : Foo, Bar"
        },
        {
            "code": "interface X {\n    fun foo(a : Int = 1)\n}\n\ninterface Y {\n    fun foo(a : Int = 1)\n}\n\nclass Z : X, Y {\n    override fun foo(<!MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES!>a : Int<!>) {}\n}\n\nobject ZO : X, Y {\n    override fun foo(<!MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES!>a : Int<!>) {}\n}"
        },
        {
            "code": "abstract class A {\n    abstract var i: Int\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class B<!>() : A() {\n}\n"
        },
        {
            "code": "interface A {\n    fun foo() {}\n}\n\ninterface B : A {\n    abstract override fun foo()\n}\n\ninterface C : A {\n    abstract override fun foo()\n}\n\ninterface D : A {\n    override fun foo() = super.foo()\n}\n\n// Fake override Z#foo should be open\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class Z<!> : B, C, D\n"
        },
        {
            "code": "package override.normal\n\ninterface MyTrait {\n    fun foo()\n    val pr : Unit\n}\n\nabstract class MyAbstractClass {\n    abstract fun bar()\n    abstract val prr : Unit\n\n}\n\nopen class MyClass() : MyTrait, MyAbstractClass() {\n    override fun foo() {}\n    override fun bar() {}\n\n    override val pr : Unit = Unit\n    override val prr : Unit = Unit\n}\n\nclass MyChildClass() : MyClass() {}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalClass<!> : MyTrait, MyAbstractClass() {}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalClass2<!>() : MyTrait, MyAbstractClass() {\n    override fun foo() {}\n    override val pr : Unit = Unit\n    override val prr : Unit = Unit\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class MyIllegalClass3<!>() : MyTrait, MyAbstractClass() {\n    override fun bar() {}\n    override val pr : Unit = Unit\n    override val prr : Unit = Unit\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class MyIllegalClass4<!>() : MyTrait, MyAbstractClass() {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>foo<!>() {}\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val <!VIRTUAL_MEMBER_HIDDEN!>pr<!> : Unit<!>\n    <!NOTHING_TO_OVERRIDE!>override<!> fun other() {}\n    <!NOTHING_TO_OVERRIDE!>override<!> val otherPr : Int = 1\n}\n\nclass MyChildClass1() : MyClass() {\n    fun <!VIRTUAL_MEMBER_HIDDEN!>foo<!>() {}\n    val <!VIRTUAL_MEMBER_HIDDEN!>pr<!> : Unit = Unit\n    override fun bar() {}\n    override val prr : Unit = Unit\n}\n"
        },
        {
            "code": "package test\n\ninterface A {\n    private val a: String\n      get() = \"AAAA!\"\n}\n\nopen class C {\n    private val a: String = \"\"\n}\n\nclass Subject : C(), A {\n    val c = <!INVISIBLE_MEMBER!>a<!>\n}"
        },
        {
            "code": "interface P {\n    var f: Number\n}\n\nopen class Q {\n    val x: Int = 42\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class R<!> : P, Q()\n\nval s: Q = <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>object<!> : Q(), P {}\n"
        },
        {
            "code": "interface IBase {\n    fun copy(): IBase\n}\n\ninterface ILeft : IBase {\n    override fun copy(): ILeft\n}\n\nopen class CLeft : ILeft {\n    override fun copy(): ILeft = CLeft()\n}\n\ninterface IRight : IBase {\n    override fun copy(): IRight\n}\n\ninterface IDerived : ILeft, IRight {\n    override fun copy(): IDerived\n}\n\n// Error: ILeft::copy and IRight::copy have unrelated return types\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED, RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class CDerivedInvalid1<!> : ILeft, IRight\n\n// Error: CLeft::copy and IRight::copy have unrelated return types\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class CDerivedInvalid2<!> : CLeft(), IRight\n\n// OK: CDerived1::copy overrides both ILeft::copy and IRight::copy\nclass CDerived1 : ILeft, IRight {\n    override fun copy(): CDerived1 = CDerived1()\n}\n\n// Although ILeft::copy and IRight::copy return types are unrelated, IDerived::copy return type is the most specific of three.\nabstract class CDerived2 : ILeft, IRight, IDerived\n\nclass CDerived2a : ILeft, IRight, IDerived {\n    override fun copy(): IDerived = CDerived2a()\n}"
        },
        {
            "code": "open class A {\n    open val foo: Boolean = true\n}\n\ninterface IA {\n    val foo: String\n}\n\ninterface IAA {\n    val foo: Int\n}\n\ninterface IGA<T> {\n    val foo: T\n}\n\n<!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class B1<!>: A(), IA\n\n<!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class B2<!>: A(), IA, IAA\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class B3<!>: IA, IAA\n\nclass BS1: A(), IGA<Boolean>\n\nclass BS2: A(), IGA<Any>\n\n<!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class BS3<!>: A(), IGA<String>\n\n<!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class BG1<!><T>: A(), IGA<T>\n"
        },
        {
            "code": "open class A {\n    open fun foo(): Boolean = true\n}\n\ninterface IA {\n    fun foo(): String\n}\n\ninterface IAA {\n    fun foo(): Int\n}\n\ninterface IGA<T> {\n    fun foo(): T\n}\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class B1<!>: A(), IA\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class B2<!>: A(), IA, IAA\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class B3<!>: IA, IAA\n\nclass BS1: A(), IGA<Boolean>\n\nclass BS2: A(), IGA<Any>\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class BS3<!>: A(), IGA<String>\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class BG1<!><T>: A(), IGA<T>\n"
        },
        {
            "code": "interface IA {\n    fun method(): String\n    val propVal: String\n    var propVar: String\n}\n\ninterface IB1 : IA\ninterface IB2 : IA\n\ninterface IGA<T> {\n    fun method(): T\n    val propVal: T\n    var propVar: T\n}\n\ninterface IGB1Str : IGA<String>\ninterface IGB2Str : IGA<String>\ninterface IGB3Int : IGA<Int>\n\ninterface IGB4T<T> : IGA<T>\ninterface IGB5T<T> : IGA<T>\n\ninterface IC : IB1, IB2\n\ninterface IGC1 : IGB1Str, IGB2Str\n\ninterface IGC2 : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>IGB1Str, IGB3Int<!>\n\ninterface IGC3<T> : IGB4T<T>, IGB5T<T>\n\ninterface IGC4<T> : <!INCONSISTENT_TYPE_PARAMETER_VALUES!>IGB4T<T>, IGB5T<String><!>\n\ninterface IGC5 : IGB4T<String>, IGB5T<String>"
        },
        {
            "code": "interface IFooAny {\n    val foo: Any\n}\n\ninterface IFooStr : IFooAny {\n    override val foo: String\n}\n\nabstract class BaseAny(override val foo: Any): IFooAny\n\nabstract <!PROPERTY_TYPE_MISMATCH_ON_INHERITANCE!>class BaseStr<!> : BaseAny(42), IFooStr\n\nclass C : BaseStr()"
        },
        {
            "code": "interface A {\n    fun <T> foo()\n    fun <T> bar()\n}\n\ninterface B {\n    fun foo()\n    fun bar()\n}\n\n<!CONFLICTING_INHERITED_MEMBERS!>interface C1<!> : A, B {\n    <!CONFLICTING_OVERLOADS!>override fun bar()<!>\n}\n"
        },
        {
            "code": "// FILE: K.kt\ninterface ILNS {\n    fun foo(): List<String?>\n}\n\ninterface IMLS {\n    fun foo(): MutableList<String>\n}\n\ninterface IMLNS {\n    fun foo(): MutableList<String?>\n}\n\ninterface ILS {\n    fun foo(): List<String>\n}\n\ninterface Test1 : ILNS, J\ninterface Test2 : J, ILNS\n\ninterface Test3 : IMLS, J\ninterface Test4 : J, IMLS\n\ninterface Test5 : ILNS, IMLS, J\ninterface Test6 : ILNS, J, IMLS\ninterface Test7 : J, ILNS, IMLS\n\n// Return types of ILS::foo and IMLNS::foo are incompatible themselves.\n// However, return type of J::foo is (Mutable)List<String!>!,\n// which is subtype of both List<String> and MutalbeList<String?>.\n// Thus, inheriting from J, IMLNS, and ILS is Ok,\n// but inheriting from IMLNS and ILS is not.\n\ninterface Test8 : J, IMLNS, ILS\ninterface Test9 : IMLNS, J, ILS\ninterface Test10 : IMLNS, ILS, J\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>interface Test11<!> : IMLNS, ILS"
        },
        {
            "code": "open class A {\n    open var foo: Boolean = true\n}\n\ninterface IA {\n    var foo: String\n}\n\ninterface IAA {\n    var foo: Int\n}\n\ninterface IGA<T> {\n    var foo: T\n}\n\n<!VAR_TYPE_MISMATCH_ON_INHERITANCE!>class B1<!>: A(), IA\n\n<!VAR_TYPE_MISMATCH_ON_INHERITANCE!>class B2<!>: A(), IA, IAA\n\nabstract <!VAR_TYPE_MISMATCH_ON_INHERITANCE!>class B3<!>: IA, IAA\n\nclass BS1: A(), IGA<Boolean>\n\n<!VAR_TYPE_MISMATCH_ON_INHERITANCE!>class BS2<!>: A(), IGA<Any>\n\n<!VAR_TYPE_MISMATCH_ON_INHERITANCE!>class BS3<!>: A(), IGA<String>\n\n<!VAR_TYPE_MISMATCH_ON_INHERITANCE!>class BG1<!><T>: A(), IGA<T>\n"
        },
        {
            "code": "// FILE: K.kt\nabstract class ATest1 : TestNN.JNullVsNotNull()\n\nabstract <!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class ATest2<!> : TestNN.JUnknownImpl(), TestNN.JNotNull\n\nabstract class ATest3 : TestNN.JUnknownVsNotNull()\n\nclass CTest1 : TestNN.JNullVsNotNull()\n\n<!RETURN_TYPE_MISMATCH_ON_INHERITANCE!>class CTest2<!> : TestNN.JUnknownImpl(), TestNN.JNotNull\n\nclass CTest3 : TestNN.JUnknownVsNotNull()\n\n"
        },
        {
            "code": "package test\n\ninterface A {\n    val a: String\n}\n\ninterface B {\n    val a: String\n}\n\nopen class C {\n    private val a: String = \"\"\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Subject<!> : C(), A, B {\n    val c = a\n}"
        },
        {
            "code": "package extendFunctionClass\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class A<!> : Function1<Int, Int> {\n\n}\n\nclass B : Function1<Int, Int> {\n    override fun invoke(p1 : Int) = p1\n}\n"
        },
        {
            "code": "interface X {\n    fun foo(a : Int = 1)\n}\n\ninterface Y {\n    fun foo(a : Int = 1)\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED, MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE!>class Z1<!> : X, Y {} // BUG\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED, MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE!>object Z1O<!> : X, Y {} // BUG"
        },
        {
            "code": "abstract class A {\n    abstract val i: Int\n}\n\n<!ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED!>class B<!>() : A() {\n}\n"
        },
        {
            "code": "interface T {\n    public fun foo()\n}\n\nopen class C {\n    protected fun foo() {}\n}\n\nclass <!CANNOT_INFER_VISIBILITY!>D<!> : C(), T\n\nval obj: C = <!CANNOT_INFER_VISIBILITY!>object<!> : C(), T {}"
        },
        {
            "code": "package test\n\ninterface X {\n    fun foo(): String? {\n        return null\n    }\n}\n\ninterface Y {\n    fun foo(): String {\n        return \"foo\"\n    }\n}\n\ninterface Incompatible {\n    fun foo(): Int {\n        return 3\n    }\n}\n\nclass Test1(val x: X) : X by x, Y {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String?<!> {\n        return null\n    }\n}\n\nclass Test2(val x: X) : X by x, Y {\n    override fun foo(): String {\n        return \"foo\"\n    }\n}\n\nclass Test3(val y: Y) : X, Y by y {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String?<!> {\n        return null\n    }\n}\n\nclass Test4(val y: Y) : X, Y by y {\n    override fun foo(): String {\n        return \"foo\"\n    }\n}\n\nclass Test5(val y: Y, val x: X) : X by x, Y by y, Incompatible {\n    override fun foo(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>Int<!> {\n        return 3\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: -CallableReferencesToClassMembersWithEmptyLHS\n\nclass A {\n    fun memberFunction() {}\n    val memberProperty: Int get() = 42\n\n    fun test() {\n        (::<!UNSUPPORTED_FEATURE!>memberFunction<!>)()\n        (::<!UNSUPPORTED_FEATURE!>extensionFunction<!>)()\n        (::<!UNSUPPORTED_FEATURE!>memberProperty<!>)()\n        (::<!UNSUPPORTED_FEATURE!>extensionProperty<!>)()\n    }\n\n    inner class B {\n        fun memberFunction() { }\n        val memberProperty: Int get() = 43\n\n        fun test() {\n            (::<!UNSUPPORTED_FEATURE!>memberFunction<!>)()\n            (::<!UNSUPPORTED_FEATURE!>extensionFunction<!>)()\n            (::<!UNSUPPORTED_FEATURE!>memberProperty<!>)()\n            (::<!UNSUPPORTED_FEATURE!>extensionProperty<!>)()\n        }\n    }\n}\n\nfun A.extensionFunction() {}\nval A.extensionProperty: Int get() = 44\n"
        },
        {
            "code": "// !LANGUAGE: -InlineProperties\nvar value: Int = 0\n\n<!UNSUPPORTED_FEATURE!>inline<!> var z: Int\n    get() = ++value\n    set(p: Int) { value = p }\n\n\nvar z2: Int\n    <!UNSUPPORTED_FEATURE!>inline<!> get() = ++value\n    <!UNSUPPORTED_FEATURE!>inline<!> set(p: Int) { value = p }\n"
        },
        {
            "code": "// !LANGUAGE: -LocalDelegatedProperties\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(t: Any?, p: KProperty<*>): Int = 1\n}\n\nfun foo(): Int {\n    val prop: Int <!UNSUPPORTED_FEATURE!>by Delegate()<!>\n\n    val prop2: Int <!UNSUPPORTED_FEATURE!>by <!DELEGATE_SPECIAL_FUNCTION_MISSING!>123<!><!>\n\n    val obj = object {\n        fun v(): Int {\n            val prop3: Int <!UNSUPPORTED_FEATURE!>by Delegate()<!>\n            return prop3\n        }\n    }\n\n    return prop + prop2 + obj.v()\n}\n"
        },
        {
            "code": "// !LANGUAGE: -FunctionTypesWithBigArity\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nclass A\n\nfun foo(\n    p00: A, p01: A, p02: A, p03: A, p04: A, p05: A, p06: A, p07: A, p08: A, p09: A,\n    p10: A, p11: A, p12: A, p13: A, p14: A, p15: A, p16: A, p17: A, p18: A, p19: A,\n    p20: A, p21: A, p22: A, p23: A, p24: A, p25: A, p26: A, p27: A, p28: A, p29: A\n) {}\n\nfun bar(x: Any) {}\n\nfun test(\n    w: <!UNSUPPORTED_FEATURE!>(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A) -> Unit<!>,\n    vararg x: <!UNSUPPORTED_FEATURE!>Function30<!><*, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, Unit>\n) {\n    bar(<!UNSUPPORTED_FEATURE!>::foo<!>)\n    bar(x)\n}\n"
        },
        {
            "code": "<!UNSUPPORTED_FEATURE!>expect<!> fun foo1()\n<!UNSUPPORTED_FEATURE!>expect<!> val bar1 = <!EXPECTED_PROPERTY_INITIALIZER!>42<!>\n<!UNSUPPORTED_FEATURE!>expect<!> class Baz1\n\n<!UNSUPPORTED_FEATURE!>actual<!> fun foo2() = 42\n<!MUST_BE_INITIALIZED!><!UNSUPPORTED_FEATURE!>actual<!> val bar2: Int<!>\n<!UNSUPPORTED_FEATURE!>actual<!> interface Baz2\n"
        },
        {
            "code": "// !LANGUAGE: -DataClassInheritance\n\ninterface Allowed\n\nopen class NotAllowed\n\n<!INCOMPATIBLE_MODIFIERS!>abstract<!> <!INCOMPATIBLE_MODIFIERS!>data<!> class Base(val x: Int)\n\nclass Derived: Base(42)\n\n<!DATA_CLASS_OVERRIDE_CONFLICT!>data<!> class Nasty(val z: Int, val y: Int): <!DATA_CLASS_CANNOT_HAVE_CLASS_SUPERTYPES!>Base<!>(z)\n\ndata class Complex(val y: Int): Allowed, <!DATA_CLASS_CANNOT_HAVE_CLASS_SUPERTYPES!>NotAllowed<!>()\n\n\n\ninterface AbstractEqualsHashCodeToString {\n    override fun equals(other: Any?): Boolean\n    override fun hashCode(): Int\n    override fun toString(): String\n}\n\ndata <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class ImplInterface<!>(val s: String) : AbstractEqualsHashCodeToString\n"
        },
        {
            "code": "// !LANGUAGE: -TopLevelSealedInheritance\n\nsealed class Base\n\nclass Derived : <!SEALED_SUPERTYPE!>Base<!>()\n"
        },
        {
            "code": "// !LANGUAGE: -BoundCallableReferences\n// !DIAGNOSTICS: -UNCHECKED_CAST\n\nimport kotlin.reflect.KClass\n\nval <T : Any> KClass<T>.java: Class<T> get() = null!!\n\nval <T : Any> KClass<T>.javaObjectType: Class<T>\n    get() {\n        return java.<!UNRESOLVED_REFERENCE!>lang<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>Class<!>::class.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>java<!> <!USELESS_CAST!>as Class<T><!>\n    }\n"
        },
        {
            "code": "// !LANGUAGE: -BoundCallableReferences\n\nclass C { companion object }\nval ok1 = C::hashCode\nval fail1 = <!UNSUPPORTED_FEATURE!>C.Companion<!>::hashCode\n\nobject O {\n    class Y {\n        companion object\n    }\n}\nval fail2 = <!UNSUPPORTED_FEATURE!>O<!>::hashCode\nval ok2 = O::Y\nval ok3 = O.Y::hashCode\n\nenum class E {\n    Entry\n}\nval ok4 = E.Entry::hashCode\n\nfun hashCode() {}\n\nval fail3 = <!UNSUPPORTED_FEATURE!>\"\"<!>::hashCode\nval fail4 = <!UNSUPPORTED_FEATURE!>(C)<!>::hashCode\nval fail5 = <!UNSUPPORTED_FEATURE!>(C.Companion)<!>::hashCode\n"
        },
        {
            "code": "// !LANGUAGE: -BoundCallableReferences\n\nimport kotlin.reflect.KClass\n\nval <T : Any> KClass<T>.java: Class<T> get() = null!!\n\nval <T : Any> KClass<T>.foo: Any?\n    get() {\n        return <!UNSUPPORTED_FEATURE!>java.<!UNRESOLVED_REFERENCE!>lang<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>Integer<!><!>::<!OVERLOAD_RESOLUTION_AMBIGUITY!>hashCode<!>\n    }\n"
        },
        {
            "code": "// !LANGUAGE: -BoundCallableReferences\n\nclass C { companion object }\nval ok1 = C::class\nval ok2 = C.Companion::class\n\nobject O\nval ok3 = O::class\n\nenum class E {\n    Entry\n}\nval ok4 = E.Entry::class\n\nval fail1 = <!UNSUPPORTED_FEATURE!>\"\"<!>::class\nval fail2 = <!NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>String?::class<!>\nval fail3 = <!UNSUPPORTED_FEATURE!>(C)<!>::class\nval fail4 = <!UNSUPPORTED_FEATURE!>(C.Companion)<!>::class\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n// FILE: test.kt\n\ninterface I10 {\n    @SinceKotlin(\"1.0\")\n    fun foo()\n}\n\ninterface I11 {\n    @SinceKotlin(\"1.1\")\n    fun foo()\n}\n\nfun f1(x: I10) = x.foo()\nfun f2(x: I11) = x.<!UNRESOLVED_REFERENCE!>foo<!>()\nfun f3(x: J) = x.foo()\n\ninterface BothI1 : I10, I11\nfun f4(x: BothI1) = x.foo()\n\ninterface BothI2 : I11, I10\nfun f5(x: BothI2) = x.foo()\n\ninterface JAndI10 : J, I10\nfun f6(x: JAndI10) = x.foo()\n\ninterface JAndI11 : J, I11\nfun f7(x: JAndI11) = x.foo()\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n\nclass C {\n    @SinceKotlin(\"1.1\")\n    companion object {\n        val x = 42\n    }\n}\n\ntypealias CA = C\n\nval test1 = <!NO_COMPANION_OBJECT!>CA<!>\nval test2 = CA.<!UNRESOLVED_REFERENCE!>Companion<!>\nval test3 = <!API_NOT_AVAILABLE!>CA<!>.x\nval test4 = CA.<!UNRESOLVED_REFERENCE!>Companion<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n@SinceKotlin(\"1.1\")\nopen class Foo\n\nclass Bar @SinceKotlin(\"1.1\") constructor()\n\n@SinceKotlin(\"1.0\")\nclass Baz @SinceKotlin(\"1.1\") constructor()\n\n@SinceKotlin(\"1.1\")\nclass Quux @SinceKotlin(\"1.0\") constructor()\n\nfun t1(): <!API_NOT_AVAILABLE!>Foo<!> = <!UNRESOLVED_REFERENCE!>Foo<!>()\n\n// TODO: do not report API_NOT_AVAILABLE twice\nfun t2() = object : <!API_NOT_AVAILABLE, API_NOT_AVAILABLE, DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>Foo<!>() {}\n\nfun t3(): Bar? = <!UNRESOLVED_REFERENCE!>Bar<!>()\n\nfun t4(): Baz = <!UNRESOLVED_REFERENCE!>Baz<!>()\n\nfun t5(): <!API_NOT_AVAILABLE!>Quux<!> = <!UNRESOLVED_REFERENCE!>Quux<!>()\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n// FILE: a.kt\npackage a\n\n@SinceKotlin(\"1.1\")\nclass Since_1_1\n\ntypealias Since_1_1_Alias = <!API_NOT_AVAILABLE!>Since_1_1<!>\n\n@SinceKotlin(\"1.1\")\ntypealias Alias_1_1 = String\n\n// FILE: b.kt\npackage b\n\nimport a.<!API_NOT_AVAILABLE!>Since_1_1_Alias<!>\nimport a.<!API_NOT_AVAILABLE!>Alias_1_1<!>"
        },
        {
            "code": "// !API_VERSION: 1.0\n\nval v1: String\n    @SinceKotlin(\"1.1\")\n    get() = \"\"\n\n@SinceKotlin(\"1.1\")\nval v2 = \"\"\n\nvar v3: String\n    @SinceKotlin(\"1.1\")\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\nvar v4: String\n    get() = \"\"\n    @SinceKotlin(\"1.1\")\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\nvar v5: String\n    @SinceKotlin(\"1.1\")\n    get() = \"\"\n    @SinceKotlin(\"1.1\")\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\n@SinceKotlin(\"1.1\")\nvar v6: String\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>value<!>) {}\n\n@SinceKotlin(\"1.0\")\nval v7: String\n    @SinceKotlin(\"1.1\")\n    get() = \"\"\n\nfun test() {\n    <!API_NOT_AVAILABLE!>v1<!>\n    <!UNRESOLVED_REFERENCE!>v2<!>\n    <!API_NOT_AVAILABLE!>v3<!>\n    v3 = \"\"\n    v4\n    <!API_NOT_AVAILABLE!>v4<!> = \"\"\n    <!API_NOT_AVAILABLE!>v5<!>\n    <!API_NOT_AVAILABLE!>v5<!> = \"\"\n    <!UNRESOLVED_REFERENCE!>v6<!>\n    <!UNRESOLVED_REFERENCE!>v6<!> = \"\"\n    <!API_NOT_AVAILABLE!>v7<!>\n}\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n@SinceKotlin(\"1.1\")\nfun f() {}\n\n@SinceKotlin(\"1.1\")\nvar p = Unit\n\n@SinceKotlin(\"1.1.2\")\nfun z() {}\n\n\nfun t1() = <!UNRESOLVED_REFERENCE!>f<!>()\n\nfun t2() = <!UNRESOLVED_REFERENCE!>p<!>\n\nfun t3() { <!UNRESOLVED_REFERENCE!>p<!> = Unit }\n\nfun t4() { <!UNRESOLVED_REFERENCE!>z<!>() }\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n@SinceKotlin(\"1.1\")\nopen class C1\n\ntypealias C1_Alias = <!API_NOT_AVAILABLE!>C1<!>\n\nopen class C2(val x: Int) {\n    @SinceKotlin(\"1.1\")\n    constructor() : this(0)\n}\n\ntypealias C2_Alias = C2\n\nval test1 = <!UNRESOLVED_REFERENCE!>C1_Alias<!>()\nval test2 = C2_Alias(<!NO_VALUE_FOR_PARAMETER!>)<!>\n\nclass Test3 : <!API_NOT_AVAILABLE, DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>C1_Alias<!>()\n\nclass Test4 : C2_Alias(<!NO_VALUE_FOR_PARAMETER!>)<!>"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n@SinceKotlin(\"1.1\")\nclass Since_1_1\n\nclass C\n\ntypealias Since_1_1_Alias = <!API_NOT_AVAILABLE!>Since_1_1<!>\n\ntypealias L = List<<!API_NOT_AVAILABLE!>Since_1_1<!>>\n\n@SinceKotlin(\"1.1\")\ntypealias C_1_1_Alias = C\n\nfun test1(x: <!API_NOT_AVAILABLE!>Since_1_1_Alias<!>) = x\n\nfun test2(x: <!API_NOT_AVAILABLE!>C_1_1_Alias<!>) = x\n\nfun test3(x: List<<!API_NOT_AVAILABLE!>C_1_1_Alias<!>>) = x\n\nfun test4(x: L) = x"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n@SinceKotlin(\"1.1\")\nannotation class Anno1(val s: String)\n\nannotation class Anno2 @SinceKotlin(\"1.1\") constructor()\n\n\n@<!API_NOT_AVAILABLE, DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>Anno1<!>(\"\")\n@<!DEBUG_INFO_UNRESOLVED_WITH_TARGET, UNRESOLVED_REFERENCE!>Anno2<!>\nfun t1() {}\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n\n@SinceKotlin(\"1.1\")\nobject Since_1_1 {\n    val x = 42\n}\n\ntypealias Since_1_1_Alias = <!API_NOT_AVAILABLE!>Since_1_1<!>\n\nval test1 = <!API_NOT_AVAILABLE!>Since_1_1_Alias<!>\nval test2 = <!API_NOT_AVAILABLE!>Since_1_1_Alias<!>.x"
        },
        {
            "code": "class My {\n    // No initialization needed because no backing field\n    val two: Int\n        get() {\n            val <!NAME_SHADOWING!>field<!> = 2\n            return field\n        }\n}\n"
        },
        {
            "code": "abstract class My(val v: Int) {\n    // Ok: variable is just abstract\n    abstract var x: Int\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>open var y: Int<!>\n\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>open var z: Int<!>\n\n    // Ok: initializer available\n    open var w: Int = v\n        set(arg) { field = arg }    \n\n    // Ok: no backing field, no initializer possible\n    open var u: Int\n        get() = w\n        set(arg) { w = 2 * arg }\n\n    constructor(): this(0) {\n        <!DEBUG_INFO_LEAKING_THIS!>z<!> = v\n    }\n\n    init {\n        <!DEBUG_INFO_LEAKING_THIS!>x<!> = 1\n        <!DEBUG_INFO_LEAKING_THIS!>y<!> = 2\n        <!DEBUG_INFO_LEAKING_THIS!>u<!> = 3\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +RestrictionOfValReassignmentViaBackingField\n\nval my: Int = 1\n    get() {\n        <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++\n        return field\n    }"
        },
        {
            "code": "var y: Int = 1\n\n// No backing field!\n<!MUST_BE_INITIALIZED!>var x: Int<!>\n    get() = y\n    set(<!ACCESSOR_PARAMETER_NAME_SHADOWING, UNUSED_PARAMETER!>field<!>) {\n        y = field\n    }"
        },
        {
            "code": "class My(val v: Int) {\n    // Ok: setter is just private\n    var x: Int\n        private set\n\n    <!MUST_BE_INITIALIZED!>var y: Int<!>\n        set(arg) { field = arg }\n\n    <!MUST_BE_INITIALIZED!>var z: Int<!>\n        set(arg) { field = arg }\n\n    // Ok: initializer available\n    var w: Int = v\n        set(arg) { field = arg }\n\n    // Ok: no backing field\n    var u: Int\n        get() = w\n        set(arg) { w = 2 * arg }\n\n    constructor(): this(0) {\n        z = v        \n    }\n\n    init {\n        x = 1\n        y = 2\n        u = 3\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -RestrictionOfValReassignmentViaBackingField\n\nval my: Int = 1\n    get() {\n        <!VAL_REASSIGNMENT_VIA_BACKING_FIELD!>field<!>++\n        return field\n    }"
        },
        {
            "code": "// See KT-9303: synthetic field variable does not exist for extension properties\nval String.foo: Int\n    get() {\n        // No shadowing here\n        val field = 42\n        return field\n    }\n\nval String.bar: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>13<!>\n    // Error\n    get() = <!UNRESOLVED_REFERENCE!>field<!>\n\nclass My {\n    val String.x: Int = <!PROPERTY_INITIALIZER_NO_BACKING_FIELD!>7<!>\n        // Error\n        get() = <!UNRESOLVED_REFERENCE!>field<!>\n}"
        },
        {
            "code": "// KT-7042 Providing return type for property setter is not reported as error\n\nvar x: Int = 1\n\n// No backing field!\nvar y: Int\n    get() = x\n    set(value): <!WRONG_SETTER_RETURN_TYPE!>Any<!> {\n        x = value\n    }\n\nvar z: Int\n    get() = x\n    set(value): Unit {\n        x = value\n    }\n\nvar u: String = \"\"\n    set(value): Unit {\n        field = value\n    }\n\nvar v: String = \"\"\n    set(value): <!WRONG_SETTER_RETURN_TYPE!>String<!> {\n        field = value\n    }"
        },
        {
            "code": "interface My {\n    <!BACKING_FIELD_IN_INTERFACE!>val x: Int<!> = <!PROPERTY_INITIALIZER_IN_INTERFACE!>0<!>\n        get() = field\n}\n"
        },
        {
            "code": "fun ff(<!UNUSED_PARAMETER!>a<!>: String) = 1\n\nfun gg() {\n    val a: String? = \"\"\n\n    if (a != null) {\n        ff(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\noperator fun Int.component1() = \"a\"\n\nfun foo(a: Number) {\n    val (x) = a as Int\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    checkSubtype<String>(x)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A\n\ninterface B : A\noperator fun B.plus(b: B) = if (this == b) b else this\n\nfun foo(a: A): B {\n    val result = (a as B) + <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<B>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n\nfun bar(a: A, b: B): B {\n    val result = b + (a as B)\n    checkSubtype<B>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Int?): Boolean {\n    val result = ((x!! == 0) && (checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>) == 0))\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    return result\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    if (x != null) {\n        when (<!DEBUG_INFO_SMARTCAST!>x<!>) {\n            0 -> bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n            else -> {}\n        }\n    }\n\n    when (x) {\n        0 -> { if (<!SENSELESS_COMPARISON!>x == null<!>) return }\n        else -> { if (x == null) return }\n    }\n    bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Number): Boolean {\n    val result = (x as Int) in 1..5\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    return result\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun simpleDoWhile(x: Int?, y0: Int) {\n    var y = y0\n    do {\n        checkSubtype<Int?>(x)\n        y++\n    } while (x!! == y)\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun doWhileWithBreak(x: Int?, y0: Int) {\n    var y = y0\n    do {\n        checkSubtype<Int?>(x)\n        y++\n        if (y > 0) break\n    } while (x!! == y)\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n    \n    bar(<!TYPE_MISMATCH!>x<!>)\n    if (x == null) return\n    try {\n        bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    catch (e: Exception) {\n        bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A\ninterface B : A\n\nfun foo1(a: A, b: B): Boolean {\n    val result = (a as B) == b\n    checkSubtype<B>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n\nfun foo2(a: A, b: B): Boolean {\n    val result = b == (a as B)\n    checkSubtype<B>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun bar1(x: Number, y: Int) {\n    var yy = y\n    yy += x as Int\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun bar2(x: Number) {\n    <!UNRESOLVED_REFERENCE!>y<!> <!UNRESOLVED_REFERENCE!>+=<!> x as Int\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun bar3(x: Number, y: Array<Int>) {\n    y[0] += x as Int\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n    while (x == null) {\n        bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>)\n    }\n    bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    \n    val y: Int? = null\n    while (y != null) {\n        bar(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    }\n    bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>y<!>)\n    \n    val z: Int? = null\n    while (z == null) {\n        bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>z<!>)\n        break\n    }\n    bar(<!TYPE_MISMATCH!>z<!>)\n}\n"
        },
        {
            "code": "open class Base {\n    fun bar(x: Int): Int = x + 1\n}\n\nclass Derived : Base() {\n    fun baz(x: Int): Int = x + 1\n\n    fun foo() {\n        val x: Int? = null\n\n        super.bar(<!TYPE_MISMATCH!>x<!>)\n        this.baz(<!TYPE_MISMATCH!>x<!>)\n        if (x == null) return\n        super.bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        this.baz(<!DEBUG_INFO_SMARTCAST!>x<!>)\n\n        val y: Int? = null\n        if (y != null) super.bar(this.baz(<!DEBUG_INFO_SMARTCAST!>y<!>))\n        else this.baz(super.bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>y<!>))\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Number, y: Int) {\n    when (x) {\n        x as Int -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        y -> {}\n        else -> {}\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun bar(x: Number) {\n    when (x) {\n        x as Int -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        else -> {}\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun whenWithoutSubject(x: Number) {\n    when {\n        (x as Int) == 42 -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        else -> {}\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(arr: Array<Int>?) {\n    for (x in arr!!) {\n        checkSubtype<Array<Int>>(<!DEBUG_INFO_SMARTCAST!>arr<!>)\n    }\n    checkSubtype<Array<Int>>(<!DEBUG_INFO_SMARTCAST!>arr<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\nfun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    if (x != null && bar(x) == 0) bar(bar(x))\n    bar(<!TYPE_MISMATCH!>x<!>)\n    if (x == null || bar(x) == 0) bar(bar(<!TYPE_MISMATCH!>x<!>))\n    bar(<!TYPE_MISMATCH!>x<!>)\n    if (x is Int && bar(x)*bar(x) == bar(x)) bar(x)\n    bar(<!TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n    val a = Array<Int>(3, {0})\n\n    for (p in a) {\n        bar(<!TYPE_MISMATCH!>x<!>)\n        if (x == null) continue\n        bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        for (q in a) {\n            bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n            if (<!SENSELESS_COMPARISON!>x == null<!>) bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        }\n    }\n\n    for (p in a) {\n        bar(<!TYPE_MISMATCH!>x<!>)\n        if (x == null) break\n        bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun arrayAccessRHS(a: Int?, b: Array<Int>) {\n    b[0] = a!!\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun arrayAccessLHS(a: Int?, b: Array<Int>) {\n    b[a!!] = <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface G {\n    operator fun get(x: Int, y: Int): Int = x + y\n    operator fun set(x: Int, y: Int, value: Int) {}\n}\n\nfun foo1(a: Int?, b: G) {\n    b[a!!, a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>] = <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun foo2(a: Int?, b: G) {\n    b[0, a!!] = <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun foo3(a: Int?, b: G) {\n    val r = b[a!!, <!DEBUG_INFO_SMARTCAST!>a<!>]\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    checkSubtype<Int>(r)\n}\n\nfun foo4(a: Int?, b: G) {\n    val r = b[0, a!!]\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    checkSubtype<Int>(r)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nfun bar(x: Int) = x + 1\n\nfun f1(x: Int?) {\n    bar(<!TYPE_MISMATCH!>x<!>)\n    if (x != null) bar(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n    if (x == null) <!UNREACHABLE_CODE!>bar(<!><!ALWAYS_NULL!>x<!>!!<!UNREACHABLE_CODE!>)<!>\n}\n\nfun f2(x: Int?) {    \n    if (x != null) else <!ALWAYS_NULL!>x<!>!!\n}\n\nfun f3(x: Int?) {    \n    if (x != null) bar(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>) else <!ALWAYS_NULL!>x<!>!!\n}\n    \nfun f4(x: Int?) {    \n    if (x == null) <!ALWAYS_NULL!>x<!>!! else bar(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n}\n\nfun f5(x: Int?) {    \n    if (x == null) else bar(x<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int) = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    fun baz() = bar(<!TYPE_MISMATCH!>x<!>)\n    fun quux() = if (x != null) bar(<!DEBUG_INFO_SMARTCAST!>x<!>) else baz()\n    fun quuux() = bar(if (x == null) 0 else <!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    val <!UNUSED_VARIABLE!>a<!> = object {\n        fun baz() = bar(if (x == null) 0 else <!DEBUG_INFO_SMARTCAST!>x<!>)\n        fun quux(): Int = <!NI;TYPE_MISMATCH!>if (x == null) <!DEBUG_INFO_CONSTANT, OI;TYPE_MISMATCH!>x<!> else <!DEBUG_INFO_SMARTCAST!>x<!><!>\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninfix fun Int.compareTo(<!UNUSED_PARAMETER!>o<!>: Int) = 0\n\nfun foo(a: Number): Int {\n    val result = (a as Int) compareTo <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n\nfun bar(a: Number): Int {\n    val result = 42 compareTo (a as Int)\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(arr: Array<out Number>): Int {\n    @Suppress(\"UNCHECKED_CAST\")\n    val result = (arr as Array<Int>)[0]\n    checkSubtype<Array<Int>>(<!DEBUG_INFO_SMARTCAST!>arr<!>)\n    return result\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Number, y: Int) {\n    when (x) {\n        is Int -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        y -> {}\n        else -> {}\n    }\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n}\n\nfun bar(x: Number) {\n    when (x) {\n        is Int -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        else -> {}\n    }\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n}\n\nfun whenWithoutSubject(x: Number) {\n    when {\n        (x is Int) -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        else -> {}\n    }\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo1(x: Number, cond: Boolean): Boolean {\n    val result = cond && ((x as Int) == 42)\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n    return result\n}\n\nfun foo2(x: Number, cond: Boolean): Boolean {\n    val result = ((x as Int) == 42) && cond\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    return result\n}\n\nfun foo3(x: Number, cond: Boolean): Boolean {\n    val result = cond || ((x as Int) == 42)\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n    return result\n}\n\nfun foo4(x: Number, cond: Boolean): Boolean {\n    val result = ((x as Int) == 42) || cond\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    return result\n}\n"
        },
        {
            "code": "// KT-2825  DataFlowInfo is not retained after assignment\n\ninterface A\n\ninterface B : A {\n    fun foo()\n}\n\nfun baz(b: B) = b\n\nfun bar1(a: A) {\n    val b = a as B\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    b.foo()\n}\n\nfun bar2(a: A) {\n    val b = baz(a as B)\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    b.foo()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\nfun bar(x: Int): Int = x + 1\n\nfun foo(): Int {\n    val x: Int? = null\n\n    bar(<!TYPE_MISMATCH!>x<!>)\n    if (x != null) return x\n    \n    val y: Int? = null\n    if (y == null) return <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>if (<!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>y<!> != null<!>) y else <!DEBUG_INFO_CONSTANT, OI;TYPE_MISMATCH!>y<!><!>\n    \n    val z: Int? = null\n    if (z != null) return if (<!SENSELESS_COMPARISON!>z == null<!>) z else z\n    \n    return <!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>z<!>\n}\n"
        },
        {
            "code": "//KT-4332 when/smartcast underperforms\n\nfun testWhen(t: String?, x: String?): Int {\n    return when {\n        t == null -> 0\n        x == null -> <!DEBUG_INFO_SMARTCAST!>t<!>.length // Wrong error report here. t can be inferred as not-null. (And it actually does if you replace when with if/else if)\n        else -> (<!DEBUG_INFO_SMARTCAST!>t<!> + x).length\n    }\n}\n"
        },
        {
            "code": "fun baz(x: Int): Int = x + 1\n\nclass A {\n    fun bar(x: Int) = baz(x)\n}\n\nfun foo() {\n    val x: Int? = null\n\n    A().bar(<!TYPE_MISMATCH!>x<!>)\n    if (x == null) return\n    A().bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A\n\ninterface B : A\noperator fun B.compareTo(b: B) = if (this == b) 0 else 1\n\nfun foo(a: A): Boolean {\n    val result = (a as B) < <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<B>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n\nfun bar(a: A, b: B): Boolean {\n    val result = b < (a as B)\n    checkSubtype<B>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n    return result\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n    val a = Array<Int>(3, {0})\n\n    if (x != null) bar(a[<!DEBUG_INFO_SMARTCAST!>x<!>]) else bar(a[<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>])\n    bar(a[if (x == null) 0 else <!DEBUG_INFO_SMARTCAST!>x<!>])\n    bar(a[<!TYPE_MISMATCH!>x<!>])\n    \n    \"123\"[<!TYPE_MISMATCH!>x<!>];\n    if (x != null) \"123\"[<!DEBUG_INFO_SMARTCAST!>x<!>];\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    bar(<!TYPE_MISMATCH!>x<!>)\n    if (x != 2) {\n        if (x == null) return\n        2<!OVERLOAD_RESOLUTION_AMBIGUITY!>+<!><!SYNTAX!><!>\n    }\n    else {\n        if (<!SENSELESS_COMPARISON!>x == null<!>) return\n        2<!OVERLOAD_RESOLUTION_AMBIGUITY!>+<!><!SYNTAX!><!>\n    }\n    bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\nfun baz(b: Boolean): Boolean = !b\n\nfun foo() {\n    val x: Int? = null\n\n    bar(<!UNSAFE_CALL!>-<!>x)\n    if (x != null) bar(-<!DEBUG_INFO_SMARTCAST!>x<!>)\n    bar(<!UNSAFE_CALL!>-<!>x)\n\n    val b: Boolean? = null\n    baz(<!UNSAFE_CALL!>!<!>b)\n    if (b != null) baz(!<!DEBUG_INFO_SMARTCAST!>b<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    bar(if (x == null) 0 else <!DEBUG_INFO_SMARTCAST!>x<!>)\n\n    if (x == null) {\n        bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>)\n        return\n    } else {\n        bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n\n    val y: Int? = null\n    if (y is Int) {\n        bar(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    } else {\n        bar(<!TYPE_MISMATCH!>y<!>)\n        return\n    }\n    bar(<!DEBUG_INFO_SMARTCAST!>y<!>)\n\n    val z: Int? = null\n    if (z != null) bar(<!DEBUG_INFO_SMARTCAST!>z<!>)\n    bar(<!TYPE_MISMATCH!>z<!>)\n    bar(z!!)\n    if (<!SENSELESS_COMPARISON!>z != null<!>) bar(z<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>)\n}\n"
        },
        {
            "code": "interface B {\n  fun bar() {}\n}\n\nclass C() {\n  fun bar() {\n  }\n}\n\nfun test(a : Any?) {\n  if (a is B) {\n      if (a is C) {\n          <!DEBUG_INFO_SMARTCAST!>a<!>.bar();\n      }\n  }\n}\n"
        },
        {
            "code": "// FILE: a.kt\npackage example.ns\n\nval y : Any? = 2\n\n// FILE: b.kt\npackage example\n\nimport example.ns.y\n\nobject Obj {\n    val y : Any? = 2\n}\n\nclass AClass() {\n    companion object {\n        val y : Any? = 2\n    }\n}\n\nval x : Any? = 1\n\nfun Any?.vars(<!UNUSED_PARAMETER!>a<!>: Any?) : Int {\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>b<!>: Int = 0\n    if (example.ns.y is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>y<!>\n    }\n    if (example.ns.y is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>example.ns.y<!>\n    }\n    if (Obj.y is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>Obj.y<!>\n    }\n    if (example.Obj.y is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>Obj.y<!>\n    }\n    if (AClass.y is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>AClass.y<!>\n    }\n    if (example.AClass.y is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>AClass.y<!>\n    }\n    if (x is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n    if (example.x is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>x<!>\n    }\n    if (example.x is Int) {\n        <!UNUSED_VALUE!>b =<!> <!DEBUG_INFO_SMARTCAST!>example.x<!>\n    }\n    return 1\n}\n\nfun Any?.foo() : Int {\n    if (this is Int)\n      return <!DEBUG_INFO_SMARTCAST!>this<!>\n    if (this@foo is Int)\n      return <!DEBUG_INFO_SMARTCAST!>this<!>\n    if (this@foo is Int)\n      return <!DEBUG_INFO_SMARTCAST!>this@foo<!>\n    if (this is Int)\n      return <!DEBUG_INFO_SMARTCAST!>this@foo<!>\n    return 1\n}\n\n\ninterface T {}\n\nopen class C {\n    fun foo() {\n       var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>t<!> : T? = null\n       if (this is T) {\n          <!UNUSED_VALUE!>t =<!> <!DEBUG_INFO_SMARTCAST!>this<!>\n       }\n       if (this is T) {\n          <!UNUSED_VALUE!>t =<!> <!DEBUG_INFO_SMARTCAST!>this@C<!>\n       }\n       if (this@C is T) {\n          <!UNUSED_VALUE!>t =<!> <!DEBUG_INFO_SMARTCAST!>this<!>\n       }\n       if (this@C is T) {\n          <!UNUSED_VALUE!>t =<!> <!DEBUG_INFO_SMARTCAST!>this@C<!>\n       }\n    }\n}\n"
        },
        {
            "code": "//KT-5155 Auto-casts do not work with when\n\nfun foo(s: String?) {\n    when {\n        s == null -> <!UNUSED_EXPRESSION!>1<!>\n        <!DEBUG_INFO_SMARTCAST!>s<!>.foo() -> <!UNUSED_EXPRESSION!>2<!>\n        else -> <!UNUSED_EXPRESSION!>3<!>\n    }\n}\n\nfun String.foo() = true"
        },
        {
            "code": "fun bar(x: Int): RuntimeException = RuntimeException(x.toString())\n\nfun foo() {\n    val x: Int? = null\n\n    if (x == null) throw bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>)\n    throw bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    <!UNREACHABLE_CODE!>throw bar(<!DEBUG_INFO_SMARTCAST!>x<!>)<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun whileLoop(x: Int?) {\n    outer@ while (x != 0) {\n        while (x != 1) {\n            if (x == 2) continue@outer\n        }\n        checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun doWhileLoop(x: Int?) {\n    outer@ while (x != 0) {\n        do {\n            if (x == 2) continue@outer\n        } while (x == null)\n        checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun whileLoopContinueInnerOuter(x: Int?) {\n    outer@ while (x != 0) {\n        inner@ while (x != 1) {\n            while (x != 2) {\n                if (x == 3) continue@inner\n            }\n            checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n        }\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\nfun bar(x: Int) = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    if (x != null) {\n        bar(x)\n        if (<!SENSELESS_COMPARISON!>x != null<!>) {\n            bar(x)\n            if (1 < 2) bar(x)\n            if (1 > 2) bar(x)\n        }\n        if (<!SENSELESS_COMPARISON!>x == null<!>) {\n            bar(x)\n        }\n        if (<!SENSELESS_COMPARISON!>x == null<!>) bar(x) else bar(x)\n        bar(bar(x))\n    } else if (<!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>x<!> == null<!>) {\n        bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>)\n        if (<!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>x<!> != null<!>) {\n            bar(x)\n            if (<!SENSELESS_COMPARISON!>x == null<!>) bar(x)\n            if (<!SENSELESS_COMPARISON!>x == null<!>) bar(x) else bar(x)\n            bar(bar(x) + bar(x))\n        } else if (<!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>x<!> == null<!>) {\n            bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>x<!>)\n        }\n    }\n\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun noUselessDataFlowInfoCreation(x: Number) {\n    if (x is Int) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) {\n    if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) {\n    if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) {\n    if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) {\n    if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) { if (<!USELESS_IS_CHECK!>x is Int<!>) {\n    } } } } } } } } } } } } } } } } } } } } } } } } }\n}\n\nfun dataFlowInfoAnd(a: Array<Number>) {\n    if (a[0] is Int) { if (a[1] is Int) { if (a[2] is Int) { if (a[3] is Int) { if (a[4] is Int) {\n    if (a[5] is Int) { if (a[6] is Int) { if (a[7] is Int) { if (a[8] is Int) { if (a[9] is Int) {\n    if (a[10] is Int) { if (a[11] is Int) { if (a[12] is Int) { if (a[13] is Int) { if (a[14] is Int) {\n    if (a[15] is Int) { if (a[16] is Int) { if (a[17] is Int) { if (a[18] is Int) { if (a[19] is Int) {\n    if (a[20] is Int) { if (a[21] is Int) { if (a[22] is Int) { if (a[23] is Int) { if (a[24] is Int) {\n    if (a[25] is Int) { if (a[26] is Int) { if (a[27] is Int) { if (a[28] is Int) { if (a[29] is Int) {\n        checkSubtype<Int>(<!TYPE_MISMATCH!>a[0]<!>)\n    } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }\n}\n\nfun dataFlowInfoOr(a: Array<Number>) {\n    if (a[0] is Int || a[1] is Int || a[2] is Int || a[3] is Int || a[4] is Int || a[5] is Int || a[6] is Int || a[7] is Int || a[8] is Int || a[9] is Int || \n        a[10] is Int || a[11] is Int || a[12] is Int || a[13] is Int || a[14] is Int || a[15] is Int || a[16] is Int || a[17] is Int || a[18] is Int || a[19] is Int || \n        a[20] is Int || a[21] is Int || a[22] is Int || a[23] is Int || a[24] is Int || a[25] is Int || a[26] is Int || a[27] is Int || a[28] is Int || a[29] is Int || \n        a[30] is Int || a[31] is Int || a[32] is Int || a[33] is Int || a[34] is Int || a[35] is Int || a[36] is Int || a[37] is Int || a[38] is Int || a[39] is Int || \n        a[40] is Int || a[41] is Int || a[42] is Int || a[43] is Int || a[44] is Int || a[45] is Int || a[46] is Int || a[47] is Int || a[48] is Int || a[49] is Int || \n        a[50] is Int || a[51] is Int || a[52] is Int || a[53] is Int || a[54] is Int || a[55] is Int || a[56] is Int || a[57] is Int || a[58] is Int || a[59] is Int) {\n        checkSubtype<Int>(<!TYPE_MISMATCH!>a[0]<!>)\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo1(a: Int?, b: Array<Array<Int>>) {\n    b[a!!][a<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>] = <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n\nfun foo2(a: Int?, b: Array<Array<Int>>) {\n    b[0][a!!] = <!DEBUG_INFO_SMARTCAST!>a<!>\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>a<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    bar(x ?: 0)\n    if (x != null) bar(x <!USELESS_ELVIS!>?: <!DEBUG_INFO_SMARTCAST!>x<!><!>)\n    bar(<!TYPE_MISMATCH!>x<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST\nfun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    bar(1 + (if (x == null) 0 else x))\n    bar(<!NI;TYPE_MISMATCH!>if (x == null) <!DEBUG_INFO_CONSTANT, OI;TYPE_MISMATCH!>x<!> else x<!>)\n    if (x != null) bar(x + x/(x-x*x))\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Int, list: List<Int>?) {\n    when (x) {\n        in list!! -> checkSubtype<List<Int>>(<!DEBUG_INFO_SMARTCAST!>list<!>)\n        else -> {}\n    }\n}\n\nfun whenWithoutSubject(x: Int, list: List<Int>?) {\n    when {\n        x in list!! -> checkSubtype<List<Int>>(<!DEBUG_INFO_SMARTCAST!>list<!>)\n        else -> {}\n    }\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Number, y: String?): String {\n    val result = \"abcde $x ${x as Int} ${y!!} $x $y\"\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    checkSubtype<String>(<!DEBUG_INFO_SMARTCAST!>y<!>)\n    return result\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun tryFinally(x: Int?) {\n    try {\n    } finally {\n        x!!\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun tryCatchFinally(x: Int?) {\n    try {\n        x!!\n    } catch (e: Exception) {\n        x!!\n    } finally {\n        checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n        x!!\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Number) {\n    when (x as Int) {\n        else -> checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun ifThen(x: Int?) {\n    if (x!! == 0) {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun ifElse(x: Int?) {\n    if (x!! == 0) else {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun ifThenElse(x: Int?) {\n    if (x!! == 0) {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    } else {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun ifIs(x: Int?, cond: Boolean) {\n    if ((x is Int) == cond) {\n        checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n    }\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun simpleWhile(x: Int?, y0: Int) {\n    var y = y0\n    while (x!! == y) {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        y++\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun whileWithBreak(x: Int?, y0: Int) {\n    var y = y0\n    while (x!! == y) {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n        break\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n\nfun whileWithNoCondition(x: Int?) {\n    while (<!SYNTAX!><!>) {\n        x!!\n    }\n    checkSubtype<Int>(<!TYPE_MISMATCH!>x<!>)\n}\n"
        },
        {
            "code": "interface A\ninterface B : A {\n    fun foo()\n}\n\nfun bar1(a: A) {\n    var b: B = a as B\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    b.foo()\n}\n\nfun id(b: B) = b\nfun bar2(a: A) {\n    var b: B = id(a as B)\n    <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n    b.foo()\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Int?): Int = x!!\n\nfun elvis(x: Number?): Int {\n    val result = (x as Int?) ?: foo(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    checkSubtype<Int?>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    return result\n}\n\n\nfun elvisWithRHSTypeInfo(x: Number?): Any? {\n    val result = x ?: x!!\n    checkSubtype<Int?>(<!TYPE_MISMATCH!>x<!>)\n    return result\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun foo(x: Number) {\n    if (<!USELESS_IS_CHECK!>(x as Int) is Int<!>) {\n        checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    }\n    checkSubtype<Int>(<!DEBUG_INFO_SMARTCAST!>x<!>)\n}\n"
        },
        {
            "code": "fun bar(x: Int): Int = x + 1\n\nfun foo() {\n    val x: Int? = null\n\n    do {\n        bar(<!TYPE_MISMATCH!>x<!>)\n    } while (x == null)\n    bar(<!DEBUG_INFO_SMARTCAST!>x<!>)\n    \n    val y: Int? = null\n    do {\n        bar(<!TYPE_MISMATCH!>y<!>)\n    } while (y != null)\n    bar(<!DEBUG_INFO_CONSTANT, TYPE_MISMATCH!>y<!>)\n}\n"
        },
        {
            "code": "//KT-5182 Data flow info is lost for 'when' branches\n\nopen class A\n\nclass B: A() {\n    fun foo() = 1\n}\n\nfun foo(a: A) = when {\n    a !is B -> 2\n    true -> <!DEBUG_INFO_SMARTCAST!>a<!>.foo() //'foo' is unresolved, smart cast doesn't work\n    else -> <!DEBUG_INFO_SMARTCAST!>a<!>.foo()\n}"
        },
        {
            "code": "package test\n\nannotation class `__`(val value: String)\n\n@<!UNDERSCORE_USAGE_WITHOUT_BACKTICKS!>__<!>(\"\") class TestAnn\n@`__`(\"\") class TestAnn2"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nimport kotlin.reflect.KProperty\n\nclass CustomDelegate {\n    operator fun get(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun set(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\nclass OkDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\nclass CustomDelegate2 {\n    operator fun get(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun set(thisRef: Any?, prop: KProperty<*>, value: String) {}\n\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): Int = 5\n    operator fun setValue(thisRef: Any?, prop: KProperty<*>, value: Int) {}\n}\n\nclass CustomDelegate3 {\n    operator fun get(thisRef: Any?, prop: KProperty<*>): String = prop.name\n    operator fun set(thisRef: Any?, prop: KProperty<*>, value: String) {}\n}\n\noperator fun OkDelegate.get(thisRef: Any?, prop: KProperty<*>): Int = 4\noperator fun OkDelegate.set(thisRef: Any?, prop: KProperty<*>, value: Int) {}\n\noperator fun CustomDelegate3.getValue(thisRef: Any?, prop: KProperty<*>): Int = 4\noperator fun CustomDelegate3.setValue(thisRef: Any?, prop: KProperty<*>, value: Int) {}\n\nclass Example {\n\n    var a by <!DELEGATE_SPECIAL_FUNCTION_MISSING, DELEGATE_SPECIAL_FUNCTION_MISSING!>CustomDelegate()<!>\n    val aval by <!DELEGATE_SPECIAL_FUNCTION_MISSING!>CustomDelegate()<!>\n    var b by OkDelegate()\n    var c by CustomDelegate2()\n    var d by CustomDelegate3()\n\n    fun test() {\n        requireString(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>)\n        requireString(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>aval<!>)\n        requireString(b)\n        requireInt(c)\n        requireInt(d)\n    }\n\n    fun requireString(s: String) {}\n    fun requireInt(n: Int) {}\n\n}\n"
        },
        {
            "code": "// FILE: a.kt\n\n/**\n * This is an example of a Type-Safe Groovy-style Builder\n *\n * Builders are good for declaratively describing data in your code.\n * In this example we show how to describe an HTML page in Kotlin.\n *\n * See this page for details:\n * http://confluence.jetbrains.net/display/Kotlin/Type-safe+Groovy-style+builders\n */\npackage html\n\nimport java.util.*\n\nfun main(args : Array<String>) {\n  val result =\n    html {\n      head {\n        title {+\"XML encoding with Kotlin\"}\n      }\n      body {\n        h1 {+\"XML encoding with Kotlin\"}\n        p {+\"this format can be used as an alternative markup to XML\"}\n\n        // an element with attributes and text content\n        a(href = \"https://jetbrains.com/kotlin\") {+\"Kotlin\"}\n\n        // mixed content\n        p {\n          +\"This is some\"\n          b {+\"mixed\"}\n          +\"text. For more see the\"\n          a(href = \"https://jetbrains.com/kotlin\") {+\"Kotlin\"}\n          +\"project\"\n        }\n        p {+\"some text\"}\n\n        // content generated from command-line arguments\n        p {\n          +\"Command line arguments were:\"\n          ul {\n            for (arg in args)\n              li {+arg}\n          }\n        }\n      }\n    }\n  println(result)\n}\n\nabstract class Element {\n  abstract fun render(builder : StringBuilder, indent : String)\n\n  override fun toString() : String {\n    val builder = StringBuilder()\n    render(builder, \"\")\n    return builder.toString()\n  }\n}\n\nclass TextElement(val text : String) : Element() {\n  override fun render(builder : StringBuilder, indent : String) {\n    builder.append(\"$indent$text\\n\")\n  }\n}\n\nabstract class Tag(val name : String) : Element() {\n  val children = ArrayList<Element>()\n  val attributes = HashMap<String, String>()\n\n  protected fun <T : Element> initTag(tag : T, init : T.() -> Unit) : T {\n    tag.init()\n    children.add(tag)\n    return tag\n  }\n\n  override fun render(builder : StringBuilder, indent : String) {\n    builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n    for (c in children) {\n      c.render(builder, indent + \"  \")\n    }\n    builder.append(\"$indent</$name>\\n\")\n  }\n\n  private fun renderAttributes() : String? {\n    val builder = StringBuilder()\n    for (a in attributes.keys) {\n      builder.append(\" $a=\\\"${attributes[a]}\\\"\")\n    }\n    return builder.toString()\n  }\n}\n\nabstract class TagWithText(name : String) : Tag(name) {\n  operator fun String.unaryPlus() {\n    children.add(TextElement(this))\n  }\n}\n\nclass HTML() : TagWithText(\"html\") {\n  fun head(init : Head.() -> Unit) = initTag(Head(), init)\n\n  fun body(init : Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head() : TagWithText(\"head\") {\n  fun title(init : Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title() : TagWithText(\"title\")\n\nabstract class BodyTag(name : String) : TagWithText(name) {\n  fun b(init : B.() -> Unit) = initTag(B(), init)\n  fun p(init : P.() -> Unit) = initTag(P(), init)\n  fun h1(init : H1.() -> Unit) = initTag(H1(), init)\n  fun ul(init : UL.() -> Unit) = initTag(UL(), init)\n  fun a(href : String, init : A.() -> Unit) {\n    val a = initTag(A(), init)\n    a.href = href\n  }\n}\n\nclass Body() : BodyTag(\"body\")\nclass UL() : BodyTag(\"ul\") {\n  fun li(init : LI.() -> Unit) = initTag(LI(), init)\n}\n\nclass B() : BodyTag(\"b\")\nclass LI() : BodyTag(\"li\")\nclass P() : BodyTag(\"p\")\nclass H1() : BodyTag(\"h1\")\nclass A() : BodyTag(\"a\") {\n  public var href : String?\n    get() = attributes[\"href\"]\n    set(value) {\n       if (value != null) {\n           attributes.put(\"href\", <!DEBUG_INFO_SMARTCAST!>value<!>)\n//         attributes[\"href\"] = value //doesn't work: KT-1355\n       }\n    }\n}\n\nfun html(init : HTML.() -> Unit) : HTML {\n  val html = HTML()\n  html.init()\n  return html\n}\n\n// An excerpt from the Standard Library\noperator fun <K, V> MutableMap<K, V>.set(key : K, value : V) = this.put(key, value)\n\nfun println(message : Any?) {\n  System.out.println(message)\n}\n\nfun print(message : Any?) {\n  System.out.print(message)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\nfun varargByte(vararg v: Byte) = v\n\nfun varargShort(vararg v: Short) = v\n\nfun varargInt(vararg v: Int) = v\n\nfun varargLong(vararg v: Long) = v\n\nfun varargFloat(vararg v: Float) = v\n\nfun varargDouble(vararg v: Double) = v\n\nfun <T> testFun(<!UNUSED_PARAMETER!>p<!>: T) {}\n\nfun test() {\n    checkSubtype<Byte>(1)\n    checkSubtype<Short>(1)\n    checkSubtype<Int>(1)\n    checkSubtype<Long>(1)\n\n    checkSubtype<Long>(0x001)\n    checkSubtype<Int>(0b001)\n\n    checkSubtype<Double>(0.1)\n    checkSubtype<Float>(0.1.toFloat())\n\n    checkSubtype<Double>(1e5)\n    checkSubtype<Float>(1e-5.toFloat())\n\n    checkSubtype<Double>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    checkSubtype<Float>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    \n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Byte\n    1 <!USELESS_CAST!>as Int<!>\n    0xff <!CAST_NEVER_SUCCEEDS!>as<!> Long\n    \n    1.1 <!CAST_NEVER_SUCCEEDS!>as<!> Int\n    checkSubtype<Int>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.1<!>)\n\n    varargByte(0x77, 1, 3, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>200<!>, 0b111)\n    varargShort(0x777, 1, 2, 3, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>200000<!>, 0b111)\n    varargInt(0x77777777, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>0x7777777777<!>, 1, 2, 3, 2000000000, 0b111)\n    varargLong(0x777777777777, 1, 2, 3, 200000, 0b111)\n    varargFloat(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>, <!TYPE_MISMATCH!>-0.1<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1e4<!>, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1e-4<!>, <!TYPE_MISMATCH!>-1e4<!>)\n    varargDouble(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, 1.0, -0.1, 1e4, 1e-4, -1e4)\n\n    testFun(1.0)\n    testFun<Float>(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1.0<!>)\n    testFun(1.0.toFloat())\n    testFun<Float>(1.0.toFloat())\n}"
        },
        {
            "code": "open class RecA<T>: <!CYCLIC_INHERITANCE_HIERARCHY!>RecB<T><!>()\nopen class RecB<T>: <!CYCLIC_INHERITANCE_HIERARCHY!>RecA<T><!>()\nopen class SelfR<T>: <!CYCLIC_INHERITANCE_HIERARCHY!>SelfR<T><!>()\n\nfun test(f: SelfR<String>) = f is <!CANNOT_CHECK_FOR_ERASED!>RecA<String><!>\nfun test(f: RecB<String>) = f is <!CANNOT_CHECK_FOR_ERASED!>RecA<String><!>"
        },
        {
            "code": "\nfun ff(l: Any) = l is <!CANNOT_CHECK_FOR_ERASED!>MutableList<String><!>\n"
        },
        {
            "code": "open class A\nopen class B: A()\nopen class D\n\nopen class Base<out T, out U>\nopen class Derived<out S>: Base<S, S>()\n\nfun test(a: Base<D, B>) = a is <!CANNOT_CHECK_FOR_ERASED!>Derived<A><!>"
        },
        {
            "code": "open class A\nopen class B: A()\n\nopen class Base<out T>\nopen class SubBase<T> : Base<T>()\n\n\nfun ff(l: Base<B>) = l is <!CANNOT_CHECK_FOR_ERASED!>SubBase<A><!>\n"
        },
        {
            "code": "fun asCall() {\n    1 <!USELESS_CAST!>as Int<!>\n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Byte\n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Short\n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Long\n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Char\n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Double\n    1 <!CAST_NEVER_SUCCEEDS!>as<!> Float\n\n    1.0 <!CAST_NEVER_SUCCEEDS!>as<!> Int\n    1.0 <!CAST_NEVER_SUCCEEDS!>as<!> Byte\n    1.0 <!CAST_NEVER_SUCCEEDS!>as<!> Short\n    1.0 <!CAST_NEVER_SUCCEEDS!>as<!> Long\n    1.0 <!CAST_NEVER_SUCCEEDS!>as<!> Char\n    1.0 <!USELESS_CAST!>as Double<!>\n    1.0 <!CAST_NEVER_SUCCEEDS!>as<!> Float\n\n    1f <!CAST_NEVER_SUCCEEDS!>as<!> Int\n    1f <!CAST_NEVER_SUCCEEDS!>as<!> Byte\n    1f <!CAST_NEVER_SUCCEEDS!>as<!> Short\n    1f <!CAST_NEVER_SUCCEEDS!>as<!> Long\n    1f <!CAST_NEVER_SUCCEEDS!>as<!> Char\n    1f <!CAST_NEVER_SUCCEEDS!>as<!> Double\n    1f <!USELESS_CAST!>as Float<!>\n}\n\nfun asSafe() {\n    1 <!USELESS_CAST!>as? Int<!>\n    1 <!CAST_NEVER_SUCCEEDS!>as?<!> Byte\n    1 <!CAST_NEVER_SUCCEEDS!>as?<!> Short\n    1 <!CAST_NEVER_SUCCEEDS!>as?<!> Long\n    1 <!CAST_NEVER_SUCCEEDS!>as?<!> Char\n    1 <!CAST_NEVER_SUCCEEDS!>as?<!> Double\n    1 <!CAST_NEVER_SUCCEEDS!>as?<!> Float\n\n    1.0 <!CAST_NEVER_SUCCEEDS!>as?<!> Int\n    1.0 <!CAST_NEVER_SUCCEEDS!>as?<!> Byte\n    1.0 <!CAST_NEVER_SUCCEEDS!>as?<!> Short\n    1.0 <!CAST_NEVER_SUCCEEDS!>as?<!> Long\n    1.0 <!CAST_NEVER_SUCCEEDS!>as?<!> Char\n    1.0 <!USELESS_CAST!>as? Double<!>\n    1.0 <!CAST_NEVER_SUCCEEDS!>as?<!> Float\n\n    1f <!CAST_NEVER_SUCCEEDS!>as?<!> Int\n    1f <!CAST_NEVER_SUCCEEDS!>as?<!> Byte\n    1f <!CAST_NEVER_SUCCEEDS!>as?<!> Short\n    1f <!CAST_NEVER_SUCCEEDS!>as?<!> Long\n    1f <!CAST_NEVER_SUCCEEDS!>as?<!> Char\n    1f <!CAST_NEVER_SUCCEEDS!>as?<!> Double\n    1f <!USELESS_CAST!>as? Float<!>\n}"
        },
        {
            "code": "interface Tr\ninterface G<T>\n\nfun test(tr: Tr): Any {\n    return tr as G<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>>\n}\n\nfun test1(tr: Tr): Any {\n    return tr as <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>.(<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>) -> <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface Tr\ninterface G<T>\n\nfun test(tr: Tr) {\n    val v = tr as <!NO_TYPE_ARGUMENTS_ON_RHS!>G<!>\n    checkSubtype<G<*>>(v)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\nclass G<T>\n\nfun foo(p: <!UNRESOLVED_REFERENCE!>P<!>) {\n    val v = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>p<!> as <!NO_TYPE_ARGUMENTS_ON_RHS!>G?<!>\n    checkSubtype<G<*>>(v!!)\n}"
        },
        {
            "code": "class P\n\nfun foo(p: P): Any {\n    val v = p as <!UNRESOLVED_REFERENCE!>G<!>\n    return <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v<!>\n}"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface Tr\ninterface G<T>\n\nfun test(tr: Tr?) {\n    val v = tr as <!NO_TYPE_ARGUMENTS_ON_RHS!>G<!>\n    checkSubtype<G<*>>(v)\n}"
        },
        {
            "code": "interface Tr\ninterface G<T>\n\nfun test(tr: Tr) = tr is <!NO_TYPE_ARGUMENTS_ON_RHS!>G<!>"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface B<T>\ninterface G<T>: B<T>\n\nfun f(p: B<<!UNRESOLVED_REFERENCE!>Foo<!>>): Any {\n    val v = <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>p<!> as G\n    return checkSubtype<G<*>>(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>v<!>)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// NI_EXPECTED_FILE\n\ninterface Tr\ninterface G<T>\n\nfun test(tr: Tr) = checkSubtype<<!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>G<!>>(tr)"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface Tr\ninterface G<T>\n\nfun test(tr: Tr) {\n    val v = tr as <!NO_TYPE_ARGUMENTS_ON_RHS!>G?<!>\n    // If v is not nullable, there will be a warning on this line:\n    checkSubtype<G<*>>(v!!)\n}"
        },
        {
            "code": "interface B<T>\nclass G<T>: B<T>\n\nfun f(b: B<String>?) = b is G?<!REDUNDANT_NULLABLE!>?<!>"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface Tr\ninterface G<T>\n\nfun test(tr: Tr?) {\n    val v = tr as <!NO_TYPE_ARGUMENTS_ON_RHS!>G?<!>\n    checkSubtype<G<*>>(v!!)\n}"
        },
        {
            "code": "fun f(a: MutableList<in String>) = a is <!CANNOT_CHECK_FOR_ERASED!>MutableList<CharSequence><!>"
        },
        {
            "code": "fun f(a: MutableList<out Number>) = <!USELESS_IS_CHECK!>a is MutableList<out Any><!>\n"
        },
        {
            "code": "\nfun ff(a: Any) = a <!UNCHECKED_CAST!>as MutableList<String><!>\n"
        },
        {
            "code": "\nfun f(a : MutableList<out Any>) = a is <!CANNOT_CHECK_FOR_ERASED!>MutableList<out Int><!>\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE\n\nfun test(x: Int?) {\n    val a1 = x <!USELESS_CAST!>as? Int<!>\n    val a2 = x <!USELESS_CAST!>as? Int?<!>\n    val a3 = x as? Number\n    val a4 = x as? Number?\n    val a5: Int? = x <!USELESS_CAST!>as? Int<!>\n    val a6: Number? = x <!USELESS_CAST!>as? Int<!>\n    val a7: Number? = 1 <!USELESS_CAST!>as? Number<!>\n\n    run { x <!USELESS_CAST!>as? Int<!> }\n    run { x <!NI;USELESS_CAST!>as? Number<!> }\n\n    foo(x as? Number)\n\n    if (x is Int) {\n        val b = x as? Int\n    }\n}\n\nfun foo(x: Number?) {}"
        },
        {
            "code": "fun f(a: MutableList<String>) = <!USELESS_IS_CHECK!>a is MutableList<out CharSequence><!>\n"
        },
        {
            "code": "open class A\nopen class B: A()\n\nopen class Base<in T>\nclass SubBase: Base<A>()\n\n// f is SubBase => f is Base<A> => (Base<Contravariant T>, B <: A) f is Base<B>\nfun test(f: SubBase) = <!USELESS_IS_CHECK!>f is Base<B><!>"
        },
        {
            "code": "interface A\ninterface B: A\n\ninterface Base<T>\n\nfun <T> test(a: Base<B>) where T: Base<A> = a is <!CANNOT_CHECK_FOR_ERASED!>T<!>"
        },
        {
            "code": "open class Base<A>\nclass Some: Base<Int>()\n\n// a is Some => a is Base<Int>\nfun f(a: Some) = <!USELESS_IS_CHECK!>a is Base<Int><!>"
        },
        {
            "code": "fun f(a: MutableList<String>) = a is <!CANNOT_CHECK_FOR_ERASED!>MutableList<CharSequence><!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNREACHABLE_CODE\n\nfun TODO(): Nothing = throw java.lang.IllegalStateException()\n\nopen class OpenClass\nclass FinalClass : OpenClass()\nabstract class AbstractClass\ninterface Interface\n\nfun test() {\n    TODO() <!USELESS_CAST!>as Any<!>\n    TODO() <!USELESS_CAST!>as Any?<!>\n    TODO() <!USELESS_CAST!>as OpenClass<!>\n    TODO() <!USELESS_CAST!>as FinalClass<!>\n    TODO() <!USELESS_CAST!>as AbstractClass<!>\n    TODO() <!USELESS_CAST!>as Interface<!>\n\n    val a = TODO() as Any\n    val b = TODO() as Any?\n    val c = TODO() as OpenClass\n    val d = TODO() as FinalClass\n    val e = TODO() as AbstractClass\n    val f = TODO() as Interface\n}\n\nfun a() = TODO() as Any\nfun b() = TODO() as Any?\nfun c() = TODO() as OpenClass\nfun d() = TODO() as FinalClass\nfun e() = TODO() as AbstractClass\nfun f() = TODO() as Interface\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun test() {\n    val a = 1 as Any?\n    val b: Number = 1 <!USELESS_CAST!>as Number<!>\n    val c = null as String?\n    val d: Number = 1 <!USELESS_CAST!>as Int<!>\n}\n\nval c1 get() = 1 as Number\nval c2: Number get() = 1 <!USELESS_CAST!>as Number<!>\n\nval d: Number\n    get() {\n        1 <!USELESS_CAST!>as Number<!>\n        return 1 <!USELESS_CAST!>as Number<!>\n    }"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\nclass Array<E>(e: E) {\n    val k = Array(1) {\n        1 <!USELESS_CAST!>as Any<!>\n        e <!NI;USELESS_CAST!>as Any?<!>\n    }\n}"
        },
        {
            "code": "fun f(a: Collection<*>) = a is List<*><!USELESS_NULLABLE_CHECK!>?<!>"
        },
        {
            "code": "open class A\nopen class B: A()\n\nopen class Base<out T>\nclass SubBase: Base<B>()\n\n// f is SubBase => (SubBase <: Base<B>) f is Base<B> => (B <: A, Base<Covariant T> => SubBase <: Base<A>) f is Base<A>\nfun test(f: SubBase) = <!USELESS_IS_CHECK!>f is Base<A><!>"
        },
        {
            "code": "// Nothing can be cast to Nothing\nfun foo(x: String) {\n    x <!CAST_NEVER_SUCCEEDS!>as<!> Nothing\n}\n\nfun gav(y: String?) {\n    y <!CAST_NEVER_SUCCEEDS!>as<!> Nothing\n}\n\n// Only nullable can be cast to Nothing?\nfun bar(x: String, y: String?) {\n    x <!CAST_NEVER_SUCCEEDS!>as<!> Nothing?\n    y as Nothing?\n}"
        },
        {
            "code": "// See also: KT-6611 (cast can never succeed: Class<T> -> Class<Any>)\n\nclass Class<T>(val name: String, val instance: T)\n\nfun <T> test(clazz: Class<T>) {\n    println((clazz <!UNCHECKED_CAST!>as Class<Any><!>).name)\n}\n\nfun use() {\n    test(Class(\"String\", \"\"))\n}\n\nfun checkArrays(): Array<Any> {\n    val someArray = arrayOfNulls<Any>(5)\n    someArray <!UNCHECKED_CAST!>as Array<Int><!>\n    return someArray <!UNCHECKED_CAST!>as Array<Any><!>\n}\n\nclass Wrapper<T>(val x: T)\n\nfun checkArrays2(): Array<Wrapper<String>> {\n    val someArray = arrayOf(Wrapper(1), Wrapper(2))\n    return someArray <!UNCHECKED_CAST!>as Array<Wrapper<String>><!>\n}\n\nfun checkArrays3() {\n    val someArray = arrayOfNulls<String>(1)\n    someArray <!UNCHECKED_CAST!>as Array<Any><!>\n    val intArray = arrayOfNulls<Int>(1)\n    intArray <!UNCHECKED_CAST!>as Array<Any><!>\n}\n\nfun println(s: String) = s\n\n"
        },
        {
            "code": "typealias MyString = String\n\nval x: MyString = \"\"\nval y = x as Any\n\ninterface Base\nclass Derived : Base\ninterface Other : Base\ntypealias IBase = Base\ntypealias IOther = Other\n\nval ib: IBase = Derived()\nval d = ib as Derived\nval o = ib as Other\nval io = ib as IOther\nval s = d <!CAST_NEVER_SUCCEEDS!>as<!> String\nval ms = d <!CAST_NEVER_SUCCEEDS!>as<!> MyString\n\n"
        },
        {
            "code": "fun <T, S : T> test(x: T?, y: S, z: T) {\n    x is <!CANNOT_CHECK_FOR_ERASED!>T<!>\n    <!USELESS_IS_CHECK!>x is T?<!>\n\n    <!USELESS_IS_CHECK!>y is T<!>\n    <!USELESS_IS_CHECK!>y is S<!>\n    <!USELESS_IS_CHECK!>y is T?<!>\n    <!USELESS_IS_CHECK!>y is S?<!>\n\n    <!USELESS_IS_CHECK!>z is T<!>\n    <!USELESS_IS_CHECK!>z is T?<!>\n\n    null <!UNCHECKED_CAST!>as T<!>\n    null <!USELESS_CAST!>as T?<!>\n    null <!UNCHECKED_CAST!>as S<!>\n}\n\ninline fun <reified T> test(x: T?) {\n    x is T\n    null as T\n    null <!USELESS_CAST!>as T?<!>\n}\n\nfun <T> foo(x: List<T>, y: List<T>?) {\n    <!USELESS_IS_CHECK!>x is List<T><!>\n    y is List<T>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface Base\n\nclass Impl1 : Base\n\nclass Impl2 : Base\n\noperator fun Base.plus(arg: Base) = Impl1()\n\noperator fun Impl2.plus(arg: Base) = Impl2()\n\noperator fun Base.plus(arg: Impl2) = Impl2()\n\noperator fun Base.unaryMinus() = Impl1()\n\noperator fun Impl2.unaryMinus() = Impl2()\n\n// See also KT-10384: in non-error functions, as is necessary!\nfun add1(x: Impl2, y: Base): Impl1 = x as Base + y\n\nfun error1(x: Impl2, y: Base): Impl1 = <!TYPE_MISMATCH!>x + y<!>\n\nfun add2(x: Base, y: Impl2): Impl1 = x + y as Base\n\nfun error2(x: Base, y: Impl2): Impl1 = <!TYPE_MISMATCH!>x + y<!>\n\nfun minus3(x: Impl2): Impl1 = -(x as Base)\n\nfun error3(x: Impl2): Impl1 = <!TYPE_MISMATCH!>-x<!>\n"
        },
        {
            "code": "fun testing(a: Any) = a is <!UNRESOLVED_REFERENCE!>UnresolvedType<!><Int>\n"
        },
        {
            "code": "fun f(a: List<Any>) = a is <!CANNOT_CHECK_FOR_ERASED!>List<Number><!>\n"
        },
        {
            "code": "interface A<T>\nclass B : A<String> {}\n\nfun <T, U : A<T>> test1(a: U) {\n    a is B\n}\n\nfun <T, S : A<T>, U : S> test2(a: U) {\n    a is B\n}\n\nfun <T : A<String>, V : A<Int>> test3(a: T, b: V) {\n    a is B\n    b is <!INCOMPATIBLE_TYPES!>B<!>\n}\n\nfun <T, V : A<out T>> test4(a: T, b: V) {\n    a is B\n    b is B\n}\n\ninterface Out<out T>\nclass OutNothing : Out<Nothing>\n\nfun <T, S : Out<T>> test5(a: S) {\n    a is OutNothing\n}\n\ninterface In<in T>\nclass InNothing : In<Nothing>\n\nfun <T, S : In<T>> test6(a: S) {\n    a is InNothing\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -WARNING +CAST_NEVER_SUCCEEDS\ninterface T1\ninterface T2\ninterface T3\nopen class OC1: T1\nopen class OC2: OC1(), T2\nclass FC1: OC2(), T3\ninterface T4: <!INTERFACE_WITH_SUPERCLASS!>OC1<!>\ninterface T5: T2\n\nfun <TP1: OC1, TP2: T2, TP3: OC2> test(\n    t2: T2,\n    t4: T4,\n    fc1: FC1,\n    oc1: OC1,\n    oc2: OC2,\n    tp1: TP1,\n    tp2: TP2\n) {\n  fc1 as FC1\n  fc1 as OC1\n  fc1 as T1\n  fc1 as TP1\n\n  oc1 as FC1\n  oc1 as OC2\n  oc2 as OC1\n  oc1 as T2\n  oc1 as T1\n  oc1 as TP1\n  oc1 as TP2\n\n  t2 as FC1\n  t2 as OC2\n  t4 as OC1\n  t2 as T2\n  t2 as T5\n  t2 as TP2\n\n  tp1 as FC1\n  tp1 as OC1\n  tp1 as OC2\n  tp2 as T2\n  tp2 as T5\n  tp1 as TP3\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -WARNING +CAST_NEVER_SUCCEEDS\nimport java.lang.String as JString\nimport java.lang.CharSequence as JCS\n\nfun test(\n  s: String,\n  js: JString,\n  cs: CharSequence,\n  jcs: JCS\n) {\n  s as JString\n  s as JCS\n  s as CharSequence\n  s as String\n\n  js as JString\n  js as JCS\n  js as CharSequence\n  js as String\n\n  cs as JString\n  cs as JCS\n  cs as CharSequence\n  cs as String\n\n  jcs as JString\n  jcs as JCS\n  jcs as CharSequence\n  jcs as String\n\n  jcs <!CAST_NEVER_SUCCEEDS!>as<!> Int\n  s <!CAST_NEVER_SUCCEEDS!>as<!> java.lang.Integer\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -WARNING +CAST_NEVER_SUCCEEDS -ABSTRACT_MEMBER_NOT_IMPLEMENTED\nimport java.lang.CharSequence as JCS\n\nclass JSub: JCS\nclass Sub: CharSequence\n\nfun test(\n  s: Sub,\n  js: JSub,\n  cs: CharSequence,\n  jcs: JCS\n) {\n  // js as CharSequence // - this case is not supported due to limitation in PlatformToKotlinClassMap\n  js as JCS\n\n  s as CharSequence\n  s as JCS\n\n  js <!CAST_NEVER_SUCCEEDS!>as<!> Sub\n  s <!CAST_NEVER_SUCCEEDS!>as<!> JSub\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -WARNING +CAST_NEVER_SUCCEEDS\ninterface Trait1\ninterface Trait2\nopen class OClass1\nopen class OClass2\nclass FClass1\nclass FClass2\n\nfun <TP1: OClass1, TP2: OClass2> test(\n  t1: Trait1,\n  oc1: OClass1,\n  fc1: FClass1,\n  tp1: TP1\n) {\n  t1 as Trait2\n  t1 as OClass2\n  t1 <!CAST_NEVER_SUCCEEDS!>as<!> FClass2\n  t1 as TP2\n\n  oc1 as Trait2\n  oc1 <!CAST_NEVER_SUCCEEDS!>as<!> OClass2\n  oc1 <!CAST_NEVER_SUCCEEDS!>as<!> FClass2\n  oc1 as TP2\n\n  fc1 <!CAST_NEVER_SUCCEEDS!>as<!> Trait2\n  fc1 <!CAST_NEVER_SUCCEEDS!>as<!> OClass2\n  fc1 <!CAST_NEVER_SUCCEEDS!>as<!> FClass2\n  fc1 as TP2\n\n  tp1 as Trait2\n  tp1 as OClass2\n  tp1 as FClass2\n  tp1 as TP2\n}"
        },
        {
            "code": "fun f(a: List<Number>) = <!USELESS_IS_CHECK!>a is List<Any><!>\n"
        },
        {
            "code": "\nfun ff(l: Any) = when(l) {\n    is <!CANNOT_CHECK_FOR_ERASED!>MutableList<String><!> -> 1\n    else <!SYNTAX!>2<!>\n}\n"
        },
        {
            "code": "// FILE: sample.kt\n\nfun test() {\n    Foo.create() as Foo\n    Foo.createN() as Foo\n    Foo.createNN() <!USELESS_CAST!>as Foo<!>\n\n    Foo.create() <!USELESS_CAST!>as Foo?<!>\n    Foo.createN() <!USELESS_CAST!>as Foo?<!>\n    Foo.createNN() <!USELESS_CAST!>as Foo?<!>\n}"
        },
        {
            "code": "fun <T> id(x: T): T = x\n\nfun foo() = 1 as Any\nfun bar() = id(1) as Any\nfun baz() = (1 + 1) as Any\n\nval functionLiteral1 = fun() = 1 as Any\nval functionLiteral2 = fun() = id(1) as Any\nval functionLiteral3 = fun() = (1 + 1) as Any\n\n// TODO: this and more complex cases are not supported yet\nfun baz(b: Boolean) = if (b) 1 <!USELESS_CAST!>as Any<!> else 42 <!USELESS_CAST!>as Any?<!>"
        },
        {
            "code": "open class A\nopen class B: A()\nopen class D\n\nopen class Base<out T, out U>\nopen class Derived<out S>: Base<S, S>()\n\nfun test(a: Base<B, D>) = a is <!CANNOT_CHECK_FOR_ERASED!>Derived<A><!>"
        },
        {
            "code": "interface A\ninterface B: A\ninterface D\n\ninterface BaseSuper<out T>\ninterface BaseImpl: BaseSuper<D>\ninterface DerivedSuper<out S>: <!INCONSISTENT_TYPE_PARAMETER_VALUES!>BaseSuper<S>, BaseImpl<!>\n\nfun test(t: BaseSuper<B>) = t is DerivedSuper<A>"
        },
        {
            "code": "interface Map<K, out V>\ninterface MutableMap<K, V>: Map<K, V> {\n  operator fun set(k: K, v: V)\n}\n\nfun p(p: Map<String, Int>) {\n    if (p is MutableMap<String, Int>) {\n        <!DEBUG_INFO_SMARTCAST!>p<!>[\"\"] = 1\n    }\n}"
        },
        {
            "code": "\nfun ff(c: MutableCollection<String>) = c <!UNCHECKED_CAST!>as MutableList<Int><!>\n"
        },
        {
            "code": "// FILE: test.kt\n\nfun <T, S: Any> test(x1: T, x2: T?, y1: S, y2: S?) {\n    <!USELESS_IS_CHECK!>x1 is T?<!>\n    <!USELESS_IS_CHECK!>x2 is T?<!>\n    <!USELESS_IS_CHECK!>y1 is S<!USELESS_NULLABLE_CHECK!>?<!><!>\n    <!USELESS_IS_CHECK!>y2 is S?<!>\n\n    val f1 = JavaClass.foo()\n    <!USELESS_IS_CHECK!>f1 is Int?<!>\n\n    val f2 = JavaClass.fooN()\n    <!USELESS_IS_CHECK!>f2 is Int?<!>\n\n    val f3 = JavaClass.fooNN()\n    <!USELESS_IS_CHECK!>f3 is Int<!USELESS_NULLABLE_CHECK!>?<!><!>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun runWithoutReturn(r: () -> Unit) = r()\n\nfun testRun() {\n    run {\n        1 <!USELESS_CAST!>as Any<!>\n        1 <!NI;USELESS_CAST!>as Any<!>\n    }\n\n    run<Any> {\n        1 <!USELESS_CAST!>as Any<!>\n        1 <!USELESS_CAST!>as Any<!>\n    }\n\n    fun foo(): Int = 1\n\n    run {\n        foo() <!NI;USELESS_CAST!>as Any<!>\n    }\n\n    run {\n        (if (true) 1 else 2) <!NI;USELESS_CAST!>as Any<!>\n    }\n\n    run<Int?> {\n        1 <!USELESS_CAST!>as Int<!>\n        1 <!USELESS_CAST!>as Int<!>\n    }\n\n    runWithoutReturn {\n        1 <!USELESS_CAST!>as Any<!>\n        1 <!USELESS_CAST!>as Any<!>\n    }\n}\n\nfun testReturn(): Number {\n    run { 1 <!NI;USELESS_CAST!>as Number<!> }\n    return run { 1 <!USELESS_CAST!>as Number<!> }\n}\n\nfun <T> testDependent() {\n    listOf(1).map {\n        it <!USELESS_CAST!>as Any<!>\n        it <!NI;USELESS_CAST!>as Any<!>\n    }\n\n    listOf<T>().map { it <!NI;USELESS_CAST!>as Any?<!> }\n}\n\nfun <T> listOf(vararg elements: T): List<T> = TODO()\nfun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> = TODO()"
        },
        {
            "code": "fun <T> testing(a: T) = <!USELESS_IS_CHECK!>a is T<!>\n"
        },
        {
            "code": "fun f(x: Any) = x <!UNCHECKED_CAST!>as Array<String><!>"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninterface A {\n    val goodSize: Int\n}\n\ninterface B {\n    val badSize: Int\n}\n\ninline class Foo(val x: Int) : A, B {\n    val a0\n        get() = 0\n\n    <!PROPERTY_WITH_BACKING_FIELD_INSIDE_INLINE_CLASS!>val a1<!> = 0\n\n    var a2: Int\n        get() = 1\n        set(value) {}\n\n    <!PROPERTY_WITH_BACKING_FIELD_INSIDE_INLINE_CLASS!>var a3: Int<!> = 0\n        get() = 1\n        set(value) {\n            field = value\n        }\n\n    override val goodSize: Int\n        get() = 0\n\n    <!PROPERTY_WITH_BACKING_FIELD_INSIDE_INLINE_CLASS!>override val badSize: Int<!> = 0\n\n    <!PROPERTY_WITH_BACKING_FIELD_INSIDE_INLINE_CLASS!>lateinit var lateinitProperty: String<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline class X(val x: Int)\ninline class Z(val x: Int)\n\nclass TestOk1(val a: Int, val b: Int) {\n    constructor(x: X) : this(x.x, 1)\n}\n\nclass TestErr1(val a: Int) {\n    <!CONFLICTING_JVM_DECLARATIONS!>constructor(x: X)<!> : this(x.x)\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>TestErr2(val a: Int, val b: Int)<!> {\n    <!CONFLICTING_JVM_DECLARATIONS!>constructor(x: X)<!> : this(x.x, 1)\n    <!CONFLICTING_JVM_DECLARATIONS!>constructor(z: Z)<!> : this(z.x, 2)\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\ninline class Foo<T>(val x: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>T<!>)\ninline class FooNullable<T>(val x: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>T?<!>)\n\ninline class FooGenericArray<T>(val x: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>Array<T><!>)\ninline class FooGenericArray2<T>(val x: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>Array<Array<T>><!>)\n\ninline class FooStarProjectedArray(val x: Array<*>)\ninline class FooStarProjectedArray2(val x: Array<Array<*>>)\n\ninline class Bar(val u: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>Unit<!>)\ninline class BarNullable(val u: Unit?)\n\ninline class Baz(val u: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>Nothing<!>)\ninline class BazNullable(val u: Nothing?)\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\nclass Val {\n    operator fun getValue(thisRef: Any?, kProp: Any?) = 1\n}\n\nclass Var {\n    operator fun getValue(thisRef: Any?, kProp: Any?) = 2\n    operator fun setValue(thisRef: Any?, kProp: Any?, value: Int) {}\n}\n\n\nobject ValObject {\n    operator fun getValue(thisRef: Any?, kProp: Any?) = 1\n}\n\nobject VarObject {\n    operator fun getValue(thisRef: Any?, kProp: Any?) = 2\n    operator fun setValue(thisRef: Any?, kProp: Any?, value: Int) {}\n}\n\ninline class Z(val data: Int) {\n    val testVal <!DELEGATED_PROPERTY_INSIDE_INLINE_CLASS!>by Val()<!>\n    var testVar <!DELEGATED_PROPERTY_INSIDE_INLINE_CLASS!>by Var()<!>\n\n    val testValBySingleton <!DELEGATED_PROPERTY_INSIDE_INLINE_CLASS!>by ValObject<!>\n    var testVarBySingleton <!DELEGATED_PROPERTY_INSIDE_INLINE_CLASS!>by VarObject<!>\n}"
        },
        {
            "code": "val u1 = <!UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH!>1u<!>\nval u2 = <!UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH!>0xFu<!>\nval u3 = <!UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH!>0b1u<!>"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline class A0(val x: Int)\n\n<!ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_INLINE_CLASS!>inline<!> class A1\ninline class A2<!INLINE_CLASS_CONSTRUCTOR_WRONG_PARAMETERS_SIZE!>()<!>\ninline class A3(<!INLINE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER!>x: Int<!>)\ninline class A4(<!INLINE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER!>var x: Int<!>)\ninline class A5<!INLINE_CLASS_CONSTRUCTOR_WRONG_PARAMETERS_SIZE!>(val x: Int, val y: Int)<!>\ninline class A6<!INLINE_CLASS_CONSTRUCTOR_WRONG_PARAMETERS_SIZE!>(x: Int, val y: Int)<!>\ninline class A7(<!INLINE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER!>vararg val x: Int<!>)\ninline class A8(<!INLINE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER!><!NON_FINAL_MEMBER_IN_FINAL_CLASS!>open<!> val x: Int<!>)\ninline class A9(final val x: Int)\n\nclass B1 {\n    companion object {\n        <!INLINE_CLASS_NOT_TOP_LEVEL!>inline<!> class C1(val x: Int)\n    }\n\n    <!INLINE_CLASS_NOT_TOP_LEVEL!>inline<!> class C2(val x: Int)\n}\n\nobject B2 {\n    <!INLINE_CLASS_NOT_TOP_LEVEL!>inline<!> class C3(val x: Int)\n}\n\nfinal inline class D0(val x: Int)\n<!INLINE_CLASS_NOT_FINAL!>open<!> inline class D1(val x: Int)\n<!INLINE_CLASS_NOT_FINAL!>abstract<!> inline class D2(val x: Int)\n<!INLINE_CLASS_NOT_FINAL!>sealed<!> inline class D3(val x: Int)\n\n<!INCOMPATIBLE_MODIFIERS!>inline<!> <!INCOMPATIBLE_MODIFIERS!>data<!> class <!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>D4(val x: String)<!>\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline class IC1(val x: Any) {\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>box<!>() {}\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>box<!>(x: Any) {}\n\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>unbox<!>() {}\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>unbox<!>(x: Any) {}\n\n    override fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>equals<!>(other: Any?): Boolean = true\n    override fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>hashCode<!>(): Int = 0\n}\n\ninline class IC2(val x: Any) {\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>box<!>(x: Any) {}\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>box<!>(): Any = TODO()\n\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>unbox<!>(x: Any) {}\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>unbox<!>(): Any = TODO()\n\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>equals<!>(my: Any, other: Any): Boolean = true\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>hashCode<!>(a: Any): Int = 0\n}\n\ninline class IC3(val x: Any) {\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>box<!>(x: Any): Any = TODO()\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>unbox<!>(x: Any): Any = TODO()\n\n    fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>equals<!>(): Boolean = true\n}\n\ninterface WithBox {\n    fun box(): String\n}\n\ninline class IC4(val s: String) : WithBox {\n    override fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS!>box<!>(): String = \"\"\n}\n\ninline class IC5(val a: String) {\n    constructor(i: Int) : this(i.toString()) <!SECONDARY_CONSTRUCTOR_WITH_BODY_INSIDE_INLINE_CLASS!>{<!>\n        TODO(\"something\")\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\nimport kotlin.reflect.KClass\n\ninline class MyInt(val x: Int)\ninline class MyString(val x: String)\n\nannotation class Ann1(val a: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>MyInt<!>)\nannotation class Ann2(val a: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Array<MyString><!>)\nannotation class Ann3(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> val a: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>MyInt<!>)\n\nannotation class Ann4(val a: KClass<MyInt>)"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE, -UNUSED_ANONYMOUS_PARAMETER\n\ninline class Foo(val x: Int)\n\nfun f1(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> a: Foo) {}\nfun f2(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> a: Foo?) {}\n\nclass A {\n    fun f3(a0: Int, <!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> a1: Foo) {\n        fun f4(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> a: Foo) {}\n\n        val g = fun (<!USELESS_VARARG_ON_PARAMETER!><!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> v: Foo<!>) {}\n    }\n}\n\nclass B(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> val s: Foo) {\n    constructor(a: Int, <!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> s: Foo) : this(*s)\n}\n\nannotation class Ann(<!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> val f: <!INVALID_TYPE_OF_ANNOTATION_MEMBER!>Foo<!>)"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\ninline class Foo(val x: Int)\n\n<!WRONG_MODIFIER_TARGET!>inline<!> interface InlineInterface\n<!WRONG_MODIFIER_TARGET!>inline<!> annotation class InlineAnn\n<!WRONG_MODIFIER_TARGET!>inline<!> object InlineObject\n<!WRONG_MODIFIER_TARGET!>inline<!> enum class InlineEnum\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninline class Foo(val x: Int) {\n    <!INLINE_CLASS_WITH_INITIALIZER!>init<!> {}\n\n    <!INLINE_CLASS_WITH_INITIALIZER!>init<!> {\n        val f = 1\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\ninterface IFoo\n\nobject FooImpl : IFoo\n\ninline class Test1(val x: Any) : <!INLINE_CLASS_CANNOT_IMPLEMENT_INTERFACE_BY_DELEGATION!>IFoo by FooImpl<!>\n\ninline class Test2(val x: IFoo) : <!INLINE_CLASS_CANNOT_IMPLEMENT_INTERFACE_BY_DELEGATION!>IFoo by x<!>"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninline class Foo(val x: Int)\ninline class Bar(val y: String)\n\nfun test(f1: Foo, f2: Foo, b1: Bar, fn1: Foo?, fn2: Foo?) {\n    val a1 = <!FORBIDDEN_IDENTITY_EQUALS!>f1 === f2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>f1 !== f2<!>\n    val a2 = <!FORBIDDEN_IDENTITY_EQUALS!>f1 === f1<!>\n    val a3 = <!EQUALITY_NOT_APPLICABLE!>f1 === b1<!> || <!EQUALITY_NOT_APPLICABLE!>f1 !== b1<!>\n\n    val c1 = <!FORBIDDEN_IDENTITY_EQUALS!>fn1 === fn2<!> || <!FORBIDDEN_IDENTITY_EQUALS!>fn1 !== fn2<!>\n    val c2 = f1 === fn1 || f1 !== fn1\n    val c3 = <!EQUALITY_NOT_APPLICABLE!>b1 === fn1<!> || <!EQUALITY_NOT_APPLICABLE!>b1 !== fn1<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\ninline class ConstructorWithDefaultVisibility(val x: Int)\ninline class PublicConstructor public constructor(val x: Int)\ninline class InternalConstructor <!NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS!>internal<!> constructor(val x: Int)\ninline class ProtectedConstructor <!NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS!>protected<!> constructor(val x: Int)\ninline class PrivateConstructor <!NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS!>private<!> constructor(val x: Int)\n"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n\ninline class Foo(val x: Int)\n\n<!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var a: Foo\n\nfun foo() {\n    <!INAPPLICABLE_LATEINIT_MODIFIER!>lateinit<!> var b: Foo\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline class X(val x: Int)\ninline class Z(val x: Int)\ninline class Str(val str: String)\ninline class Name(val name: String)\ninline class NStr(val str: String?)\n\nfun testSimple(x: X) {}\nfun testSimple(z: Z) {}\n\nfun testMixed(x: Int, y: Int) {}\nfun testMixed(x: X, y: Int) {}\nfun testMixed(x: Int, y: X) {}\nfun testMixed(x: X, y: X) {}\n\nfun testNewType(s: Str) {}\nfun testNewType(name: Name) {}\n\nfun testNullableVsNonNull1(s: Str) {}\nfun testNullableVsNonNull1(s: Str?) {}\n\nfun testNullableVsNonNull2(ns: NStr) {}\nfun testNullableVsNonNull2(ns: NStr?) {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun testFunVsExt(x: X)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun X.testFunVsExt()<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun testNonGenericVsGeneric(x: X, y: Number)<!> {}\n<!CONFLICTING_JVM_DECLARATIONS!>fun <T : Number> testNonGenericVsGeneric(x: X, y: T)<!> {}\n\nclass C<TC : Number> {\n    <!CONFLICTING_JVM_DECLARATIONS!>fun testNonGenericVsGeneric(x: X, y: Number)<!> {}\n    <!CONFLICTING_JVM_DECLARATIONS!>fun <T : Number> testNonGenericVsGeneric(x: X, y: T)<!> {}\n    <!CONFLICTING_JVM_DECLARATIONS!>fun testNonGenericVsGeneric(x: X, y: TC)<!> {}\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\nabstract class AbstractBaseClass\n\nopen class OpenBaseClass\n\ninterface BaseInterface\n\ninline class TestExtendsAbstractClass(val x: Int) : <!INLINE_CLASS_CANNOT_EXTEND_CLASSES!>AbstractBaseClass<!>()\n\ninline class TestExtendsOpenClass(val x: Int) : <!INLINE_CLASS_CANNOT_EXTEND_CLASSES!>OpenBaseClass<!>()\n\ninline class TestImplementsInterface(val x: Int) : BaseInterface"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n\ninline class Test1(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>Test1<!>)\n\ninline class Test2A(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>Test2B<!>)\ninline class Test2B(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>Test2A<!>)\n\ninline class Test3A(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>Test3B<!>)\ninline class Test3B(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>Test3C<!>)\ninline class Test3C(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>Test3A<!>)\n\ninline class TestNullable(val x: <!INLINE_CLASS_CANNOT_BE_RECURSIVE!>TestNullable?<!>)\n\ninline class TestRecursionInTypeArguments(val x: List<TestRecursionInTypeArguments>)\n\ninline class TestRecursionInArray(val x: Array<TestRecursionInArray>)\n\ninline class TestRecursionInUpperBounds<T : TestRecursionInUpperBounds<T>>(val x: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>T<!>)\n\ninline class Id<T>(val x: <!INLINE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE!>T<!>)\ninline class TestRecursionThroughId(val x: Id<TestRecursionThroughId>)"
        },
        {
            "code": "// !LANGUAGE: -InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n<!UNSUPPORTED_FEATURE!>inline<!> class Foo(val x: Int)\n\n<!WRONG_MODIFIER_TARGET!>inline<!> annotation class InlineAnn\n<!WRONG_MODIFIER_TARGET!>inline<!> object InlineObject\n<!WRONG_MODIFIER_TARGET!>inline<!> enum class InlineEnum\n\n<!UNSUPPORTED_FEATURE!>inline<!> class NotVal(<!INLINE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER!>x: Int<!>)"
        },
        {
            "code": "// See also KT-4285\nopen class A {\n    open fun foo(x: Int = 0) {}\n\n    open fun gav(y: Int = 1, z: Int = 2) {}\n}\n\nclass B: A() {\n    <!NO_TAIL_CALLS_FOUND!>tailrec override fun foo(x: Int)<!> {\n        foo()\n    }\n\n    <!NO_TAIL_CALLS_FOUND!>tailrec override fun gav(y: Int, z: Int)<!> {\n        gav(y)\n    }\n\n    tailrec fun bar(y: Double): Double = bar(y * 2.0)\n}\n\nclass C: A() {\n    tailrec override fun foo(x: Int) {\n        foo(0)\n    }\n\n    tailrec override fun gav(y: Int, z: Int) {\n        gav(y - 1, z - 1)\n    }\n\n    tailrec fun bar(<!UNUSED_PARAMETER!>y<!>: Int = 1, z: Int = 2) {\n        bar(z)\n    }\n}"
        },
        {
            "code": "fun testEquals(x: Int) {\n    if (<!SENSELESS_COMPARISON!>x == null<!>) {}\n    if (<!SENSELESS_COMPARISON!>x == (null)<!>) {}\n    if (<!SENSELESS_COMPARISON!>x == <!REDUNDANT_LABEL_WARNING!>foo@<!> null<!>) {}\n}\n\nfun testEqualsFlipped(x: Int) {\n    if (<!SENSELESS_COMPARISON!>null == x<!>) {}\n    if (<!SENSELESS_COMPARISON!>(null) == x<!>) {}\n    if (<!SENSELESS_COMPARISON!><!REDUNDANT_LABEL_WARNING!>foo@<!> null == x<!>) {}\n}\n\nfun testNotEquals(x: Int) {\n    if (<!SENSELESS_COMPARISON!>x != null<!>) {}\n    if (<!SENSELESS_COMPARISON!>x != (null)<!>) {}\n    if (<!SENSELESS_COMPARISON!>x != <!REDUNDANT_LABEL_WARNING!>foo@<!> null<!>) {}\n}\n\nfun testNotEqualsFlipped(x: Int) {\n    if (<!SENSELESS_COMPARISON!>null != x<!>) {}\n    if (<!SENSELESS_COMPARISON!>(null) != x<!>) {}\n    if (<!SENSELESS_COMPARISON!><!REDUNDANT_LABEL_WARNING!>foo@<!> null != x<!>) {}\n}"
        },
        {
            "code": "fun readLine() = \"x\"\n\nfun foo() {\n    var line = \"\"\n\n    while (<!SENSELESS_COMPARISON!>line != null<!>) {\n        line = readLine()\n\n        if (<!SENSELESS_COMPARISON!>line != null<!>) {\n            bar()\n        }\n    }\n}\n\nfun bar() {}"
        },
        {
            "code": "open class bar()\n\ninterface Foo<!CONSTRUCTOR_IN_INTERFACE!>()<!> : <!INTERFACE_WITH_SUPERCLASS!>bar<!><!SUPERTYPE_INITIALIZED_IN_INTERFACE!>()<!>, <!MANY_CLASSES_IN_SUPERTYPE_LIST!>bar<!>, <!MANY_CLASSES_IN_SUPERTYPE_LIST, SUPERTYPE_APPEARS_TWICE!>bar<!> {\n}\n\ninterface Foo2 : <!INTERFACE_WITH_SUPERCLASS!>bar<!>, Foo {\n}\n\nopen class Foo1() : bar(), <!MANY_CLASSES_IN_SUPERTYPE_LIST, SUPERTYPE_APPEARS_TWICE, SUPERTYPE_NOT_INITIALIZED!>bar<!>, Foo, <!SUPERTYPE_APPEARS_TWICE!>Foo<!>() {}\nopen class Foo12 : bar(), <!MANY_CLASSES_IN_SUPERTYPE_LIST, SUPERTYPE_APPEARS_TWICE, SUPERTYPE_NOT_INITIALIZED!>bar<!> {}"
        },
        {
            "code": "interface AnyTrait : <!INTERFACE_WITH_SUPERCLASS!>Any<!>\n\nclass Foo : AnyTrait\n\nclass Bar : AnyTrait, Any()\n"
        },
        {
            "code": "class My {\n    var x: Int = 0\n        // Ok\n        private set\n    \n    private var y: Int = 1\n        // Error: better\n        <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>public<!> set\n\n    protected var z: Int = 2\n        // Ok\n        private set\n\n    protected var w: Int = 3\n        // Error: incompatible\n        <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>internal<!> set\n\n    internal var v: Int = 4\n        // Error: incompatible\n        <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>protected<!> set\n\n    internal var t: Int = 5\n        // Error: better\n        <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>public<!> set\n}"
        },
        {
            "code": "// !LANGUAGE: -RestrictRetentionForExpressionAnnotations\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\npackage foo\n\n@Retention(AnnotationRetention.SOURCE)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\nannotation class AnnotationWithSourceRetention\n\n<!RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_WARNING!>@Retention(AnnotationRetention.BINARY)<!>\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\nannotation class AnnotationWithBinaryRetention\n\n<!RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_WARNING!>@Retention(AnnotationRetention.RUNTIME)<!>\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\nannotation class AnnotationWithRuntimeRetention\n\n@AnnotationWithSourceRetention\nclass TestSource {\n    @AnnotationWithSourceRetention\n    fun baz(@AnnotationWithSourceRetention foo : Int) : Int {\n        return (@AnnotationWithSourceRetention 1)\n    }\n}\n\n@AnnotationWithBinaryRetention\nclass TestBinary {\n    @AnnotationWithBinaryRetention\n    fun baz(@AnnotationWithBinaryRetention foo : Int) : Int {\n        return (<!NOT_SUPPORTED!>@AnnotationWithBinaryRetention 1<!>)\n    }\n}\n\n<!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@AnnotationWithRuntimeRetention<!>\nclass TestRuntime {\n    <!RUNTIME_ANNOTATION_NOT_SUPPORTED!>@AnnotationWithRuntimeRetention<!>\n    fun baz(@AnnotationWithRuntimeRetention foo : Int) : Int {\n        return (<!NOT_SUPPORTED!>@AnnotationWithRuntimeRetention 1<!>)\n    }\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n\ninline fun f(): Unit = <!INLINE_CALL_CYCLE!>g()<!>\n\ninline fun g(): Unit = run { <!INLINE_CALL_CYCLE!>f()<!> }\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n\npublic inline fun f():Unit = <!INLINE_CALL_CYCLE!>g()<!>\n\npublic inline fun g(): Unit = <!INLINE_CALL_CYCLE!>h()<!>\n\npublic inline fun h(): Unit = <!INLINE_CALL_CYCLE!>f()<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n\ninline fun f(): Unit = <!INLINE_CALL_CYCLE!>g()<!>\n\ninline fun g(): Unit = <!INLINE_CALL_CYCLE!>h()<!>\n\ninline fun h(): Unit = <!INLINE_CALL_CYCLE!>f()<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE\n\ninline fun f(): Unit = <!INLINE_CALL_CYCLE!>g()<!>\n\ninline fun g(): Unit = h { <!INLINE_CALL_CYCLE!>f()<!> }\n\ninline fun h(fn: ()->Unit): Unit = fn()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// FILE: s/SamConstructor.java\npackage s;\n\npublic class SamConstructor {\n    public SamConstructor(Runnable r) {\n    }\n\n    public static void foo(Runnable r) {}\n}\n\n// FILE: 1.kt\npackage a\n\nfun SamConstructor(a: () -> Unit) {}\n\n// FILE: 2.kt\n\npackage b\n\nimport s.SamConstructor\nimport a.*\n\nfun test() {\n    val a: s.SamConstructor = SamConstructor {  }\n\n    val b: s.SamConstructor = SamConstructor(null)\n\n    SamConstructor.foo(null)\n}"
        },
        {
            "code": "// !LANGUAGE: -RefinedSamAdaptersPriority\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// !WITH_NEW_INFERENCE\n\n// FILE: 1.kt\nfun bar() {\n    Foo().test {} checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Int>() }\n}"
        },
        {
            "code": "// FILE: test.kt\nfun ff() {\n    val a = Test.FOO\n    val b = <!NO_COMPANION_OBJECT!>Test<!><!UNEXPECTED_SAFE_CALL!>?.<!>FOO\n    System.out.println(a + b)\n    <!NO_COMPANION_OBJECT!>System<!><!UNEXPECTED_SAFE_CALL!>?.<!>out.println(a + b)\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\nclass A {\n    fun forEach() = this\n    fun forEach(i: Int) = this\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.HidesMembers\nfun A.forEach(i: Int) = i\n\nclass B {\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n    @kotlin.internal.HidesMembers\n    fun A.forEach() = this@B\n\n    fun test(a: A) {\n        a.forEach() checkType { _<A>() } // todo\n\n        with(a) {\n            forEach() checkType { _<A>() } // todo\n        }\n    }\n}\n\nfun test2(a: A) {\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n    @kotlin.internal.HidesMembers\n    fun A.forEach() = \"\"\n\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n    @kotlin.internal.HidesMembers\n    fun A.forEach(i: Int) = \"\"\n\n    a.forEach() checkType { _<String>() }\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>forEach<!>(1)\n\n    with(a) {\n        forEach() checkType { _<String>() }\n        <!OVERLOAD_RESOLUTION_AMBIGUITY!>forEach<!>(1)\n    }\n}"
        },
        {
            "code": "// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: 2.kt\npackage b\n\nimport a.A\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.HidesMembers\nfun A.forEach(i: Int) = i\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.HidesMembers\nfun A.forEach(s: String) {}\n\n\n// FILE: 1.kt\npackage a\n\nimport b.*\n\nclass A {\n    fun forEach() = this\n    fun forEach(i: Int) = this\n    fun forEach(i: String) = this\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.HidesMembers\nfun A.forEach() = \"\"\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.HidesMembers\nfun A.forEach(s: String) {}\n\nfun test(a: A) {\n    a.forEach() checkType { _<String>() }\n\n    a.forEach(1) checkType { _<Int>() }\n\n    a.<!OVERLOAD_RESOLUTION_AMBIGUITY!>forEach<!>(\"\")\n\n    with(a) {\n        forEach() checkType { _<String>() }\n\n        forEach(1) checkType { _<Int>() }\n\n        <!OVERLOAD_RESOLUTION_AMBIGUITY!>forEach<!>(\"\")\n    }\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: -RefinedSamAdaptersPriority\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// !WITH_NEW_INFERENCE\n\n// FILE: 1.kt\nfun test() {\n    Foo().foo {} checkType { _<Int>() }\n    Foo().bar {} checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER!>_<!><Int>() }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n//KT-4711 Error type with no error reported from type inference\n\nfun main() {\n    val n = 100\n    val delta = 1.0 / n\n    val startTimeNanos = System.nanoTime()\n\n    // the problem sits on the next line:\n    val pi = 4.0.toDouble() * delta <!OI;OVERLOAD_RESOLUTION_AMBIGUITY!>*<!> (1..n).<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>reduce<!>(\n            {t, i ->\n                val x = (i - 0.5) * delta\n                <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>t + 1.0 / (1.0 + x * x)<!>\n\n            })\n    // !!! pi has error type here\n\n    val elapseTime = (System.nanoTime() - startTimeNanos) / 1e9\n\n    println(\"pi_sequential_reduce $<!OI;DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>pi<!> $n $elapseTime\")\n}\n"
        },
        {
            "code": "// See KT-10107: 'Variable must be initialized' for delegate with private set\n\nclass My {\n    var delegate: String by kotlin.properties.Delegates.notNull()\n        private set\n\n    // Error: Variable 'delegate' must be initialized\n    val another: String = <!DEBUG_INFO_LEAKING_THIS!>delegate<!>\n\n    var delegateWithBackingField: String by kotlin.properties.Delegates.notNull()\n        <!ACCESSOR_FOR_DELEGATED_PROPERTY!>private set(arg) { field = arg }<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +TypeAliases\n// !API_VERSION: 1.0\n// FILE: test.kt\nval fooException = Exception(\"foo\")\nval barException = kotlin.<!UNRESOLVED_REFERENCE!>Exception<!>(\"bar\")\n"
        },
        {
            "code": "// !LANGUAGE: -TypeAliases\n// FILE: test.kt\nval fooException = Exception(\"foo\")\nval barException = kotlin.<!UNRESOLVED_REFERENCE!>Exception<!>(\"bar\")\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.ExperimentalStdlibApi\n\nimport kotlin.reflect.typeOf\n\ninline fun <X, reified Y, Z : Y> test1() {\n    <!UNSUPPORTED!>typeOf<!><<!TYPE_PARAMETER_AS_REIFIED!>X<!>>()\n    <!UNSUPPORTED!>typeOf<!><List<X>>()\n    <!UNSUPPORTED!>typeOf<!><Array<X?>>()\n\n    typeOf<Y>()\n\n    <!UNSUPPORTED!>typeOf<!><<!TYPE_PARAMETER_AS_REIFIED!>Z<!>>()\n    <!UNSUPPORTED!>typeOf<!><List<Z>?>()\n    <!UNSUPPORTED!>typeOf<!><Array<Z>>()\n}\n\n\nclass Test2<W> {\n    fun test2() {\n        <!UNSUPPORTED!>typeOf<!><<!TYPE_PARAMETER_AS_REIFIED!>W<!>>()\n        <!UNSUPPORTED!>typeOf<!><List<W?>>()\n        <!UNSUPPORTED!>typeOf<!><Array<W>>()\n    }\n}\n\n\ninline fun <reified U> f() {\n    typeOf<U>()\n}\n\nfun <T> test3() {\n    // We don't report anything here because we can't know in frontend how the corresponding type parameter is used in f\n    f<List<T>>()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\n// FILE: Test.kt\n\nfun foo(c: P): MutableList<Int> {\n    // Error should be here: see KT-8168 Typechecker fails for platform collection type\n    return <!NI;TYPE_MISMATCH!>c.getList() ?: <!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH, OI;TYPE_MISMATCH!>listOf()<!><!>\n}"
        },
        {
            "code": "// Reproduces exception in TypeResolver.kt: EA-66870\n\nimport java.util.ArrayList\n\nabstract class J {\n    public abstract fun <T : Collection<S>, S : List<<!WRONG_MODIFIER_TARGET!>out<!> *>> foo(x: T)\n    fun bar() {\n        val s = ArrayList<ArrayList<Int>>()\n        foo(s)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNCHECKED_CAST -USELESS_CAST\nclass A<T>\n\nfun test1(\n    a: <!UNSUPPORTED!>Array<Nothing><!>,\n    b: <!UNSUPPORTED!>Array<Nothing?><!>,\n    c: <!UNSUPPORTED!>Array<in Nothing><!>,\n    d: <!UNSUPPORTED!>Array<in Nothing?><!>,\n    e: <!UNSUPPORTED!>Array<out Nothing><!>,\n    f: <!UNSUPPORTED!>Array<out Nothing?><!>\n) {}\n\nfun test2(\n    a: <!UNSUPPORTED!>Array<Nothing><!>?,\n    b: <!UNSUPPORTED!>Array<Nothing?><!>?,\n    c: <!UNSUPPORTED!>Array<in Nothing><!>?,\n    d: <!UNSUPPORTED!>Array<in Nothing?><!>?,\n    e: <!UNSUPPORTED!>Array<out Nothing><!>?,\n    f: <!UNSUPPORTED!>Array<out Nothing?><!>?\n) {}\n\nfun test3(\n    a: A<<!UNSUPPORTED!>Array<Nothing><!>>,\n    b: A<<!UNSUPPORTED!>Array<Nothing?><!>>,\n    c: A<<!UNSUPPORTED!>Array<in Nothing><!>>,\n    d: A<<!UNSUPPORTED!>Array<in Nothing?><!>>,\n    e: A<<!UNSUPPORTED!>Array<out Nothing><!>>,\n    f: A<<!UNSUPPORTED!>Array<out Nothing?><!>>\n) {}\n\nfun test4(\n    a: Array<A<Nothing>>,\n    b: Array<A<Nothing?>>,\n    c: Array<A<in Nothing>>,\n    d: Array<A<in Nothing?>>,\n    e: Array<A<out Nothing>>,\n    f: Array<A<out Nothing?>>\n) {}\n\nfun test5() {\n    <!UNSUPPORTED!>arrayOf<!><<!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>Nothing<!>>()\n    <!UNSUPPORTED!>Array<!><<!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>Nothing<!>>(10) { throw Exception() }\n}\n\nfun <T> foo(): Array<T> = (object {} as Any) as Array<T>\n\nfun test6() = <!UNSUPPORTED!>foo<!><Nothing>()\n\n\nclass B<T>(val array: Array<T>)\n\nfun <T> bar() = B<Array<T>>(arrayOf())\n\nfun test7() = <!UNSUPPORTED!>bar<!><Nothing>()\n"
        },
        {
            "code": "package test\n\nclass A {\n    companion object\n}\n\nobject O\n\nenum class E {\n    ENTRY\n}\n\n\nval a0 = A.<!JAVA_CLASS_ON_COMPANION!>javaClass<!>\nval a1 = test.A.<!JAVA_CLASS_ON_COMPANION!>javaClass<!>\nval a2 = A.Companion.<!JAVA_CLASS_ON_COMPANION!>javaClass<!>\nval a3 = A::class.java\nval a4 = test.A::class.java\nval a5 = A.Companion::class.java\n\nval o0 = O.javaClass\nval o1 = O::class.java\n\nval e0 = E.<!UNRESOLVED_REFERENCE!>javaClass<!>\nval e1 = E::class.java\nval e2 = E.ENTRY.javaClass\n\nval int0 = Int.<!JAVA_CLASS_ON_COMPANION!>javaClass<!>\nval int1 = Int::class.java\n\nval string0 = String.<!JAVA_CLASS_ON_COMPANION!>javaClass<!>\nval string1 = String::class.java\n"
        },
        {
            "code": "// KT-9078 (NPE in control flow analysis); EA-71535\nabstract class KFunctionKt9005WorkAround<out R: Any?>(private val _functionInstance: Function<R>) {\n    private val _reflectedFunction: kotlin.reflect.KFunction<R> = _functionInstance.<!UNRESOLVED_REFERENCE!>reflect<!>() ?: throw IllegalStateException(\"\")\n\n    private val _parameters: List<kotlin.reflect.KParameter> = run {\n        _functionInstance.javaClass.methods.first().<!UNRESOLVED_REFERENCE!>parameters<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>map<!> {\n            <!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>object<!> : kotlin.reflect.KParameter {\n                override val index: Int = 0\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "// FILE: a.kt\n@file:JvmName(\"Util\")\n@file:JvmMultifileClass\n\n<!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>fun main()<!> {}\n\n// FILE: b.kt\n@file:JvmName(\"Util\")\n@file:JvmMultifileClass\n\n<!CONFLICTING_JVM_DECLARATIONS, CONFLICTING_JVM_DECLARATIONS!>fun main()<!> {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n\nopen class Foo1(x: Int = 10, y: Float = 0f<!UNSUPPORTED_FEATURE!>,<!>)\n\nclass Foo2(\n    val x: Int = 10,\n    var y: Float<!UNSUPPORTED_FEATURE!>,<!>\n): Foo1(x, y<!UNSUPPORTED_FEATURE!>,<!>) {\n    constructor(\n        x: Float,\n        y: Int = 10<!UNSUPPORTED_FEATURE!>,<!>\n    ): this(1, 1f<!UNSUPPORTED_FEATURE!>,<!>) {}\n\n    var x1: Int\n        get() = 10\n        set(value<!UNSUPPORTED_FEATURE!>,<!>) {\n\n        }\n\n    var x2: Int\n        get() = 10\n        set(\n            x2<!UNSUPPORTED_FEATURE!>,<!>\n        ) {}\n\n    var x3: (Int) -> Unit\n        get() = {}\n        set(x2: (Int) -> Unit<!UNSUPPORTED_FEATURE!>,<!>) {}\n\n    var x4: (Int) -> Unit\n        get() = {}\n        set(x2: (Int) -> Unit<!UNSUPPORTED_FEATURE!>,<!>/**/) {}\n}\n\nenum class Foo3(x: Int<!UNSUPPORTED_FEATURE!>,<!> )\n\nfun foo4(x: Int, y: Comparable<Float><!UNSUPPORTED_FEATURE!>,<!>) {}\n\nfun foo5(x: Int = 10<!UNSUPPORTED_FEATURE!>,<!>) {}\n\nfun foo6(vararg x: Int<!UNSUPPORTED_FEATURE!>,<!>) {}\n\nfun foo7(y: Float, vararg x: Int<!UNSUPPORTED_FEATURE!>,<!>) {}\n\nval foo8: (Int, Int<!UNSUPPORTED_FEATURE!>,<!>) -> Int = fun(\n    x,\n    y<!UNSUPPORTED_FEATURE!>,<!>\n    ): Int {\n    return x + y\n}\n\nval foo9: (Int, Int, Int<!UNSUPPORTED_FEATURE!>,<!>) -> Int =\n    fun (x, y: Int, z<!UNSUPPORTED_FEATURE!>,<!>): Int {\n        return x + y\n    }\n\nopen class Foo10(x: Int = 10, y: Float = 0f)\n\nclass Foo11: Foo10 {\n    constructor(\n        x: Float\n    ): super(1, 1f<!UNSUPPORTED_FEATURE!>,<!>)\n}\n\nclass Foo12: Foo10 {\n    constructor(\n        x: Float\n    ): super(1, 1f<!UNSUPPORTED_FEATURE!>,<!>/**/)\n}\n\nfun main() {\n    val x1 = {\n            x: Comparable<Comparable<Number>>,\n            y: Iterable<Iterable<Number>><!UNSUPPORTED_FEATURE!>,<!>\n        ->\n        println(\"1\")\n    }\n    val x2 = { x: Comparable<Comparable<Number>><!UNSUPPORTED_FEATURE!>,<!>\n        -> println(\"1\")\n    }\n    val x3: ((Int<!UNSUPPORTED_FEATURE!>,<!>) -> Int) -> Unit = { x: (Int<!UNSUPPORTED_FEATURE!>,<!>) -> Int<!UNSUPPORTED_FEATURE!>,<!> -> println(\"1\") }\n    val x4: ((Int<!UNSUPPORTED_FEATURE!>,<!>) -> Int) -> Unit = { x<!UNSUPPORTED_FEATURE!>,<!> -> println(\"1\") }\n\n    fun foo10(x:Int,y:Int<!UNSUPPORTED_FEATURE!>,<!>) {\n        fun foo10(x:Int,y:Int<!UNSUPPORTED_FEATURE!>,<!>) {}\n    }\n    fun foo101(x:Int,y:Int<!UNSUPPORTED_FEATURE!>,<!>/**/) {\n        fun foo10(x:Int,y:Int<!UNSUPPORTED_FEATURE!>,<!>/**/) {}\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception<!UNSUPPORTED_FEATURE!>,<!>) {\n\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception<!UNSUPPORTED_FEATURE!>,<!>) {\n\n    } catch (e: Exception<!UNSUPPORTED_FEATURE!>,<!>) {\n\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception<!UNSUPPORTED_FEATURE!>,<!>) {\n\n    } finally {\n\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception<!UNSUPPORTED_FEATURE!>,<!>/**/) {\n\n    } finally {\n\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_TYPEALIAS_PARAMETER, -CAST_NEVER_SUCCEEDS\n\nclass Foo1<T1> {}\n\ninterface Foo2<T1<!UNSUPPORTED_FEATURE!>,<!>>\n\nfun <T1, T2, T3>foo3() {}\n\ntypealias Foo4<T1,T2,T3,T4> = Int\n\nclass Foo5<T, K: T<!UNSUPPORTED_FEATURE!>,<!>>: Foo2<K<!UNSUPPORTED_FEATURE!>,<!>>\n\nfun <T> foo() {\n    val x1 = Foo1<Int,>()\n    val x2: Foo2<Int<!UNSUPPORTED_FEATURE!>,<!>>? = null\n    val x21: Foo2<Int<!UNSUPPORTED_FEATURE!>,<!>/**/>? = null\n    val x3 = foo3<\n            Int,\n            String,\n            Float,\n            >()\n    val x4: Foo4<Comparable<Int<!UNSUPPORTED_FEATURE!>,<!>>, Iterable<Comparable<Float<!UNSUPPORTED_FEATURE!>,<!>><!UNSUPPORTED_FEATURE!>,<!>>, Double, T<!UNSUPPORTED_FEATURE!>,<!>\n            >? = null as Foo4<Comparable<Int<!UNSUPPORTED_FEATURE!>,<!>>, Iterable<Comparable<Float<!UNSUPPORTED_FEATURE!>,<!>><!UNSUPPORTED_FEATURE!>,<!>>, Double, T<!UNSUPPORTED_FEATURE!>,<!>>\n    val x5: (Float<!UNSUPPORTED_FEATURE!>,<!>) -> Unit = {}\n    val x6: Pair<(Float, Comparable<T<!UNSUPPORTED_FEATURE!>,<!>><!UNSUPPORTED_FEATURE!>,<!>) -> Unit, (Float<!UNSUPPORTED_FEATURE!>,<!>) -> Unit<!UNSUPPORTED_FEATURE!>,<!>>? = null\n    val x61: Pair<(Float, Comparable<T<!UNSUPPORTED_FEATURE!>,<!>/**/><!UNSUPPORTED_FEATURE!>,<!>/**/) -> Unit, (Float<!UNSUPPORTED_FEATURE!>,<!>/**/) -> Unit<!UNSUPPORTED_FEATURE!>,<!>/**/>? = null\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -NAME_SHADOWING\n// !LANGUAGE: +TrailingCommas\n\nfun foo1(x: Any) = when (x) {\n    Comparable::class,\n    Iterable::class,\n    String::class,\n        -> println(1)\n    else -> println(3)\n}\n\nfun foo2(x: Any) {\n    val z = when (val y: Int = x as Int) {\n        1, -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo3(x: (Any) -> Any) {\n    val z = when (val y: (Any) -> Any = x) {\n        {x: Any, -> x}, {y: Any, -> y}, -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo4(x: Any) {\n    val z = when (x) {\n        is Int, is Double, -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo5(x: Int, y: IntArray, z: IntArray) {\n    val u = when (x) {\n        in y,\n        in z,\n            -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo6(x: Boolean?) = when (x) {\n    true, false, -> println(1)\n    null, -> println(1)\n}\n\nfun foo7(x: Boolean?) = when (x) {\n    true, false,/**/ -> println(1)\n    null,/**/ -> println(1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_PARAMETER\n// !LANGUAGE: +TrailingCommas\n\nfun foo(vararg x: Int) = false\nfun foo() = true\n\nfun main() {\n    val x = foo()\n    val y = foo(<!SYNTAX!>,<!><!SYNTAX!><!>)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_ANONYMOUS_PARAMETER, -UNUSED_VARIABLE\n// !LANGUAGE: +TrailingCommas\n\nopen class Foo1(x: Int = 10, y: Float = 0f,)\n\nclass Foo2(\n    val x: Int = 10,\n    var y: Float,\n): Foo1(x, y) {\n    constructor(\n        x: Float,\n        y: Int = 10,\n        ): this(1, 1f,) {\n\n    }\n}\n\nenum class Foo3(x: Int, )\n\nfun foo4(x: Int, y: Comparable<Float>,) {}\n\nfun foo5(x: Int = 10,) {}\n\nfun foo6(vararg x: Int,) {}\n\nfun foo61(vararg x: Int,/**/) {}\n\nfun foo7(y: Float, vararg x: Int,) {}\n\nval foo8: (Int, Int,) -> Int = fun(\n    x,\n    y,\n    ): Int {\n    return x + y\n}\n\nval foo9: (Int, Int, Int,) -> Int =\n    fun (x, y: Int, z,): Int {\n        return x + y\n    }\n\nopen class Foo10(x: Int = 10, y: Float = 0f)\n\nclass Foo11: Foo10 {\n    constructor(\n        x: Float\n    ): super(1, 1f,)\n}\n\nclass Foo12: Foo10 {\n    constructor(\n        x: Float\n    ): super(1, 1f,/**/)\n}\n\nfun main() {\n    val x1 = {\n            x: Comparable<Comparable<Number>>,\n            y: Iterable<Iterable<Number>>,\n        ->\n        println(\"1\")\n    }\n    val x11 = {\n            x: Comparable<Comparable<Number>>,\n            y: Iterable<Iterable<Number>>,/**/\n        ->\n        println(\"1\")\n    }\n    val x2 = { x: Comparable<Comparable<Number>>,\n        -> println(\"1\")\n    }\n    val x3: ((Int,) -> Int) -> Unit = { x: (Int,) -> Int, -> println(\"1\") }\n    val x4: ((Int,) -> Int) -> Unit = { x, -> println(\"1\") }\n\n    try {\n        println(1)\n    } catch (e: Exception,) {\n\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception,) {\n\n    } catch (e: Exception,) {\n\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception,) {\n\n    } finally {\n\n    }\n\n    try {\n        println(1)\n    } catch (e: Exception,/**/) {\n\n    } finally {\n\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_DESTRUCTURED_PARAMETER_ENTRY, -UNUSED_ANONYMOUS_PARAMETER\n\ndata class Foo1(val x: String, val y: String, val z: String = \"\")\n\nfun main() {\n    val (x1,y1<!UNSUPPORTED_FEATURE!>,<!>) = Pair(1,2)\n    val (x2, y2: Number<!UNSUPPORTED_FEATURE!>,<!>) = Pair(1,2)\n    val (x3,y3,z3<!UNSUPPORTED_FEATURE!>,<!>) = Foo1(\"\", \"\"<!UNSUPPORTED_FEATURE!>,<!> )\n    val (x4,y4: CharSequence<!UNSUPPORTED_FEATURE!>,<!>) = Foo1(\"\", \"\", \"\"<!UNSUPPORTED_FEATURE!>,<!>)\n    val (x41,y41: CharSequence<!UNSUPPORTED_FEATURE!>,<!>/**/) = Foo1(\"\", \"\", \"\"<!UNSUPPORTED_FEATURE!>,<!>)\n\n    val x5: (Pair<Int, Int>, Int) -> Unit = { (x,y<!UNSUPPORTED_FEATURE!>,<!>),z<!UNSUPPORTED_FEATURE!>,<!> -> }\n    val x6: (Foo1, Int) -> Any = { (x,y,z: CharSequence<!UNSUPPORTED_FEATURE!>,<!>), z1: Number<!UNSUPPORTED_FEATURE!>,<!> -> 1 }\n    val x61: (Foo1, Int) -> Any = { (x,y,z: CharSequence<!UNSUPPORTED_FEATURE!>,<!>/**/), z1: Number<!UNSUPPORTED_FEATURE!>,<!>/**/ -> 1 }\n\n    for ((i, j<!UNSUPPORTED_FEATURE!>,<!>) in listOf(Pair(1,2))) {}\n    for ((i: Any<!UNSUPPORTED_FEATURE!>,<!>) in listOf(Pair(1,2))) {}\n    for ((i: Any<!UNSUPPORTED_FEATURE!>,<!>/**/) in listOf(Pair(1,2))) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE, -UNUSED_ANONYMOUS_PARAMETER\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno1(val x: IntArray)\n\n@Target(AnnotationTarget.TYPEALIAS)\nannotation class Anno2(val x: DoubleArray)\n\nfun foo1(vararg x: Any) {}\nfun foo2(x: (Any, Any) -> Unit) {}\nfun foo3(x: Any, y: () -> Unit) {}\n\nopen class A1(vararg x: Any) {\n    operator fun get(x: Any, y: Any) = 10\n}\n\nopen class A2(x: Int, y: () -> Unit) {}\n\nclass B(): A1({}<!UNSUPPORTED_FEATURE!>,<!>) {\n\n}\n\n@Anno2(\n    [\n        0.4,\n        .1<!UNSUPPORTED_FEATURE!>,<!>\n    ]\n)\ntypealias A3 = B\n\nfun main1() {\n    foo1(1, 2, 3<!UNSUPPORTED_FEATURE!>,<!>)\n    foo1({}<!UNSUPPORTED_FEATURE!>,<!>)\n    foo3(10<!UNSUPPORTED_FEATURE!>,<!>) {}\n    foo3(10<!UNSUPPORTED_FEATURE!>,<!>/**/) {}\n\n    val x1 = A1(1, 2, 3<!UNSUPPORTED_FEATURE!>,<!>)\n    val y1 = A1({}<!UNSUPPORTED_FEATURE!>,<!>)\n    val z1 = A2(10<!UNSUPPORTED_FEATURE!>,<!>) {}\n\n    foo2({ x, y -> kotlin.Unit }<!UNSUPPORTED_FEATURE!>,<!>)\n    foo2({ x, y -> kotlin.Unit }<!UNSUPPORTED_FEATURE!>,<!>/**/)\n\n    val foo = listOf(\n        println(1),\n        \"foo bar something\"<!UNSUPPORTED_FEATURE!>,<!>\n        )\n\n    val x2 = x1[\n            1,\n            2<!UNSUPPORTED_FEATURE!>,<!>\n    ]\n\n    val x3 = x1[{},{}<!UNSUPPORTED_FEATURE!>,<!>]\n    val x31 = x1[{},{}<!UNSUPPORTED_FEATURE!>,<!>/**/]\n\n    val x4: @Anno1([\n                      1, 2<!UNSUPPORTED_FEATURE!>,<!>\n                  ]) Float = 0f\n\n    foo1(object {}<!UNSUPPORTED_FEATURE!>,<!>)\n    foo1(object {}<!UNSUPPORTED_FEATURE!>,<!>/**/)\n    foo1(fun () {}<!UNSUPPORTED_FEATURE!>,<!>)\n    foo1(if (true) 1 else 2<!UNSUPPORTED_FEATURE!>,<!>)\n\n    <!UNREACHABLE_CODE!>foo1(<!>return<!UNSUPPORTED_FEATURE!>,<!><!UNREACHABLE_CODE!>)<!>\n}\n\nfun main2(x: A1) {\n    <!UNREACHABLE_CODE!>val x1 =<!> x[object {}, return<!UNSUPPORTED_FEATURE!>,<!> ]\n    <!UNREACHABLE_CODE!>val x2 = x[fun () {}, throw Exception()<!UNSUPPORTED_FEATURE!>,<!> ]<!>\n    <!UNREACHABLE_CODE!>val x3 = x[fun () {}, throw Exception()<!UNSUPPORTED_FEATURE!>,<!>/**/ ]<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_TYPEALIAS_PARAMETER, -CAST_NEVER_SUCCEEDS\n// !LANGUAGE: +TrailingCommas\n\nclass Foo1<T1> {}\n\ninterface Foo2<T1,>\n\nfun <T1, T2, T3>foo3() {}\n\ntypealias Foo4<T1,T2,T3,T4> = Int\n\nclass Foo5<T, K: T,>: Foo2<K,>\n\nfun <T>foo () {\n    val x1 = Foo1<Int,>()\n    val x2: Foo2<Int,>? = null\n    val x21: Foo2<Int,/**/>? = null\n    val x3 = foo3<\n            Int,\n            String,\n            Float,\n            >()\n    val x4: Foo4<Comparable<Int,>, Iterable<Comparable<Float,>,>, Double, T,\n            >? = null as Foo4<Comparable<Int,>, Iterable<Comparable<Float,>,>, Double, T,>\n    val x5: (Float,) -> Unit = {}\n    val x6: Pair<(Float, Comparable<T,>,) -> Unit, (Float,) -> Unit,>? = null\n    val x61: Pair<(Float, Comparable<T,/**/>,/**/) -> Unit, (Float,/**/) -> Unit,/**/>? = null\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_TYPEALIAS_PARAMETER\n// !LANGUAGE: +TrailingCommas\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno\n\nclass Foo1<T1,>\n\nclass Foo2<\n        T1,\n        T2: T1,\n        > {\n    fun <T1,\n            T2, > foo2() {}\n\n    internal inner class B<T,T2,>\n}\n\ninterface A<T,>\n\ninterface A1<T,/**/>\n\nfun <T,> foo1() {}\n\nfun <T,/**/> foo11() {}\n\ninline fun <reified T1, T2, reified T3,> foo2() {}\n\nfun <T1,\n        T2,\n        > T2?.foo3() {}\n\nval <T,> T.bar1 get() = null\n\nvar <\n        T4,\n        > T4?.bar2\n    get() = null\n    set(value) {\n\n    }\n\ntypealias Foo3<T1, @Anno T2,> = List<T2>\n\ntypealias Foo4<T1, @Anno T2,/**/> = List<T2>\n\nfun main() {\n    fun <T,> foo10() {\n        fun <T1,T2,T3,> foo10() {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_VARIABLE, -UNUSED_ANONYMOUS_PARAMETER\n// !LANGUAGE: +TrailingCommas\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno1(val x: IntArray)\n\n@Target(AnnotationTarget.TYPEALIAS)\nannotation class Anno2(val x: DoubleArray)\n\nfun foo1(vararg x: Any) {}\nfun foo2(x: (Any, Any) -> Unit) {}\nfun foo3(x: Any, y: () -> Unit) {}\n\nopen class A1(vararg x: Any) {\n    operator fun get(x: Any, y: Any) = 10\n}\n\nopen class A2(x: Any, y: () -> Unit)\n\nclass B(): A1({},) {\n\n}\n\n@Anno2(\n    [\n        0.4,\n        .1,\n    ]\n)\ntypealias A3 = B\n\nfun main1() {\n    foo1(1, 2, 3,/**/)\n    foo1({},)\n    foo3(10,/**/) {}\n\n    val x1 = A1(1, 2, 3,)\n    val y1 = A1({},)\n    val z1 = A2(10,) {}\n\n    foo2({ x, y -> kotlin.Unit },/**/)\n\n    val foo = listOf(\n        println(1),\n        \"foo bar something\",\n    )\n\n    val x2 = x1[\n        1,\n        2,\n    ]\n\n    val x3 = x1[{},{},/**/]\n\n    val x4: @Anno1([\n                  1, 2,/**/\n                  ]) Float = 0f\n\n    foo1(object {},)\n    foo1(fun () {},)\n    foo1(if (true) 1 else 2,/**/)\n\n    <!UNREACHABLE_CODE!>foo1(<!>return,<!UNREACHABLE_CODE!>)<!>\n}\n\nfun main2(x: A1) {\n    <!UNREACHABLE_CODE!>val x1 =<!> x[object {}, return, ]\n    <!UNREACHABLE_CODE!>val x2 = x[fun () {}, throw Exception(), /**/]<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_TYPEALIAS_PARAMETER\n\n@Target(AnnotationTarget.TYPE)\nannotation class Anno\n\nclass Foo1<T1<!UNSUPPORTED_FEATURE!>,<!>>\n\nclass Foo2<\n        T1,\n        T2: T1<!UNSUPPORTED_FEATURE!>,<!>\n        > {\n    fun <T1,\n            T2<!UNSUPPORTED_FEATURE!>,<!> > foo2() {}\n\n    internal inner class B<T,T2<!UNSUPPORTED_FEATURE!>,<!>>\n}\n\ninterface A<T<!UNSUPPORTED_FEATURE!>,<!>>\n\ninterface A1<T<!UNSUPPORTED_FEATURE!>,<!>/**/>\n\nfun <T<!UNSUPPORTED_FEATURE!>,<!>> foo1() {}\n\nfun <T<!UNSUPPORTED_FEATURE!>,<!>/**/> foo11() {}\n\nfun <T1,\n        T2<!UNSUPPORTED_FEATURE!>,<!>\n        > T2?.foo2() {}\n\nval <T<!UNSUPPORTED_FEATURE!>,<!>> T.bar1 get() = null\n\nvar <\n        T4<!UNSUPPORTED_FEATURE!>,<!>\n        > T4?.bar2\n    get() = null\n    set(value) {\n\n    }\n\ntypealias Foo3<T1, @Anno T2<!UNSUPPORTED_FEATURE!>,<!>> = List<T2>\n\ntypealias Foo4<T1, @Anno T2<!UNSUPPORTED_FEATURE!>,<!>/**/> = List<T2>\n\nfun main() {\n    fun <T<!UNSUPPORTED_FEATURE!>,<!>> foo10() {\n        fun <T1,T2,T3<!UNSUPPORTED_FEATURE!>,<!>> foo10() {}\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_EXPRESSION -NAME_SHADOWING\n\nfun foo1(x: Any) = when (x) {\n    Comparable::class,\n    Iterable::class,\n    String::class<!UNSUPPORTED_FEATURE!>,<!>\n        -> println(1)\n    else -> println(3)\n}\n\nfun foo2(x: Any) {\n    val z = when (val y: Int = x as Int) {\n        1<!UNSUPPORTED_FEATURE!>,<!> -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo3(x: (Any) -> Any) {\n    val z = when (val y: (Any) -> Any = x) {\n        {x: Any<!UNSUPPORTED_FEATURE!>,<!> -> x}, {y: Any<!UNSUPPORTED_FEATURE!>,<!> -> y}<!UNSUPPORTED_FEATURE!>,<!> -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo4(x: Any) {\n    val z = when (x) {\n        is Int, is Double<!UNSUPPORTED_FEATURE!>,<!> -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo5(x: Int, y: IntArray, z: IntArray) {\n    val u = when (x) {\n        in y,\n        in z<!UNSUPPORTED_FEATURE!>,<!>\n            -> println(1)\n        else -> println(3)\n    }\n}\n\nfun foo6(x: Boolean?) = when (x) {\n    true, false<!UNSUPPORTED_FEATURE!>,<!> -> println(1)\n    null<!UNSUPPORTED_FEATURE!>,<!> -> println(1)\n}\n\nfun foo7(x: Boolean?) = when (x) {\n    true, false<!UNSUPPORTED_FEATURE!>,<!>/**/ -> println(1)\n    null<!UNSUPPORTED_FEATURE!>,<!>/**/ -> println(1)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE, -UNUSED_DESTRUCTURED_PARAMETER_ENTRY, -UNUSED_ANONYMOUS_PARAMETER\n// !LANGUAGE: +TrailingCommas\n\ndata class Foo1(val x: String, val y: String, val z: String = \"\")\n\nfun main() {\n    val (x1,y1,) = Pair(1, 2)\n    val (x2, y2: Number,) = Pair(1,2)\n    val (x3,y3,z3,) = Foo1(\"\", \"\",)\n    val (x4,y4: CharSequence,) = Foo1(\"\", \"\", \"\",)\n    val (x41,y41: CharSequence,/**/) = Foo1(\"\", \"\", \"\",)\n\n    val x5: (Pair<Int, Int>, Int) -> Unit = { (x,y,),z, -> }\n    val x6: (Foo1, Int) -> Any = { (x,y,z: CharSequence,), z2: Number, -> 1 }\n    val x61: (Foo1, Int) -> Any = { (x,y,z: CharSequence,/**/), z2: Number,/**/ -> 1 }\n\n    for ((i, j) in listOf(Pair(1,2))) {}\n    for ((i: Any,) in listOf(Pair(1,2))) {}\n    for ((i: Any,/**/) in listOf(Pair(1,2))) {}\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\n//KT-1558 Exception while analyzing\npackage j\n\nfun <T : Any> T?.sure() : T = this!!\n\nfun <E> List<*>.toArray(ar: Array<E>): Array<E> = ar\n\nfun testArrays(ci: List<Int?>, cii: List<Int?>?) {\n    val c1: Array<Int?> = cii.sure().toArray(<!FUNCTION_CALL_EXPECTED!><!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>Array<!><Int?><!>)\n\n    val c2: Array<Int?> = ci.toArray(Array<Int?>(<!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>)\n\n    val c3 = Array<Int?>(<!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>\n\n    val c4 = ci.toArray<Int?>(Array<Int?>(<!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>)\n\n    val c5 = ci.toArray(Array<Int?>(<!NO_VALUE_FOR_PARAMETER, NO_VALUE_FOR_PARAMETER!>)<!>)\n\n    checkSubtype<Array<Int?>>(c1)\n    checkSubtype<Array<Int?>>(c2)\n    checkSubtype<Array<Int?>>(c3)\n    checkSubtype<Array<Int?>>(c4)\n    checkSubtype<Array<Int?>>(c5)\n}\n"
        },
        {
            "code": "// FULL_JDK\n\nimport java.util.*\n\nfun foo(<!UNUSED_PARAMETER!>o<!>: Optional<String>) {}\n\nclass Test(nullable: String?) {\n    private val nullableOptional = Optional.ofNullable(nullable)\n    fun doIt() {\n        foo(nullableOptional)\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -USELESS_ELVIS -UNUSED_EXPRESSION\n\nclass X {\n    fun toLong(): Long? = TODO()\n}\n\nfun getLong(): Long = TODO()\n\nfun test_1(list: List<X>) {\n    val props = list.map { <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Long?\")!>it.toLong()<!> ?: <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Long\")!>0<!> }\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.collections.List<kotlin.Long>\")!>props<!>\n}\n\nfun test_2(cond: Boolean) {\n    val props = if (cond) getLong() else 0\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Long\")!>props<!>\n}\n\nfun test_3(list: List<X>) {\n    val props = list.map { Pair(it.toLong() ?: 0, it.toLong() ?: 0) }\n    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.collections.List<kotlin.Pair<kotlin.Long, kotlin.Long>>\")!>props<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -INVISIBLE_MEMBER -INVISIBLE_REFERENCE -UNUSED_PARAMETER\n\ninterface Parent\nobject ChildA : Parent\nobject ChildB : Parent\n\nfun <@kotlin.internal.OnlyInputTypes T> select(a: T, b: T) {}\n\nfun test() {\n    <!TYPE_INFERENCE_ONLY_INPUT_TYPES!>select<!>(ChildA, ChildB) // should be error\n    select<Any>(ChildA, ChildB) // should be ok\n}\n"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.jvm.JvmName(\"containsAny\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T> Iterable<T>.contains1(element: T): Int = null!!\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <T> Iterable<T>.contains1(element: @kotlin.internal.NoInfer T): Boolean = null!!\n\n\nfun test() {\n    val a: Boolean = listOf(1).<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>contains1<!>(<!TYPE_MISMATCH!>\"\"<!>)\n    val b: Boolean = listOf(1).contains1(1)\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains1(element: T): Boolean = null!!\n\nclass In<in T>\n\nclass Out<out T>\n\nclass Inv<T>\n\nfun test_1(list: List<In<Number>>, x: In<Number>, y: In<Int>, z: In<Any>) {\n    list.contains1(x)\n    list.contains1(y)\n    list.contains1(z)\n}\n\nfun test_2(list: List<In<Int>>, x: In<Int>, y: In<Number>, z: In<Any>) {\n    list.contains1(x)\n    list.contains1(y)\n    list.contains1(z)\n}\n\nfun test_3(list: List<Out<Number>>, x: Out<Number>, y: Out<Int>, z: Out<Any>) {\n    list.contains1(x)\n    list.contains1(y)\n    list.contains1(z)\n}\n\nfun test_4(list: List<Out<Int>>, x: Out<Int>, y: Out<Number>, z: Out<Any>) {\n    list.contains1(x)\n    list.contains1(y)\n    list.contains1(z)\n}\n\nfun test_5(list: List<Inv<Number>>, x: Inv<Number>, y: Inv<Int>, z: Inv<Any>) {\n    list.contains1(x)\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(y)\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(z)\n}\n\nfun test_6(list: List<Inv<Int>>, x: Inv<Int>, y: Inv<Number>, z: Inv<Any>) {\n    list.contains1(x)\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(y)\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(z)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\nopen class Base()\nclass CX : Base()\nclass CY : Base()\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes T> foo(a: T, b: T) {}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes T : Any> fooA(a: T, b: T) {}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes T : Base> fooB(a: T, b: T) {}\n\n\nfun usage(x: CX, y: CY) {\n    <!TYPE_INFERENCE_ONLY_INPUT_TYPES!>foo<!>(x, y) // expected err, got err\n    <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>fooA<!>(x, y) // expected err, got ok\n    <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>fooB<!>(x, y) // expected err, got ok\n}"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <T> test1(t1: T, t2: @kotlin.internal.NoInfer T): T = t1\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <T> @kotlin.internal.NoInfer T.test2(t1: T): T = t1\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <T> test3(t1: @kotlin.internal.NoInfer T): T = t1\n\nfun usage() {\n    <!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>test1<!>(1, <!TYPE_MISMATCH!>\"312\"<!>)\n    <!OI;TYPE_MISMATCH!>1<!>.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>test2<!>(\"\")\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>test3<!>(\"\")\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <T> List<T>.contains1(e: @kotlin.internal.NoInfer T): Boolean = true\n\nfun test(i: Int?, a: Any, l: List<Int>) {\n    l.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>contains1<!>(<!TYPE_MISMATCH!>a<!>)\n    l.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>contains1<!>(<!TYPE_MISMATCH!>\"\"<!>)\n    l.<!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>contains1<!>(<!TYPE_MISMATCH!>i<!>)\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <T> assertEquals1(e1: T, e2: @kotlin.internal.NoInfer T): Boolean = true\n\nfun test(s: String) {\n    <!OI;TYPE_INFERENCE_INCORPORATION_ERROR!>assertEquals1<!>(s, <!CONSTANT_EXPECTED_TYPE_MISMATCH!>11<!>)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// Issue: KT-26698\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains1(element: T): Boolean = null!!\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.foo(element: T): T = null!!\n\nclass Inv<T>\nclass Inv2<T, R>\n\nclass In<in T>\nclass Out<out T>\n\n// -------------------------------------------------------\n\nfun test_0(x: Inv2<in Number, out Number>, list: List<Inv2<Any, Int>>) {\n    list.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>foo<!>(x)\n}\n\n// ------------------------- Inv -------------------------\n\nfun test_1(x: Inv<Number>, list: List<Inv<Number>>) {\n    list.contains1(x)\n}\n\nfun test_2(x: Inv<Number>, list: List<Inv<Int>>) {\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_3(x: Inv<Number>, list: List<Inv<Any>>) {\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_4(x: Inv<in Number>, list: List<Inv<Any>>) {\n    list.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_5(x: Inv<in Number>, list: List<Inv<Number>>) {\n    list.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_6(x: Inv<in Number>, list: List<Inv<Int>>) {\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_7(x: Inv<out Number>, list: List<Inv<Any>>) {\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_8(x: Inv<out Number>, list: List<Inv<Number>>) {\n    list.contains1(x)\n}\n\nfun test_9(x: Inv<out Number>, list: List<Inv<Int>>) {\n    list.contains1(x)\n}\n\n// ------------------------- In -------------------------\n\nfun test_11(x: In<Number>, list: List<In<Number>>) {\n    list.contains1(x)\n}\n\nfun test_12(x: In<Number>, list: List<In<Int>>) {\n    list.contains1(x)\n}\n\nfun test_13(x: In<Number>, list: List<In<Any>>) {\n    list.contains1(x)\n}\n\n// ------------------------- Out -------------------------\n\nfun test_21(x: Out<Number>, list: List<Out<Number>>) {\n    list.contains1(x)\n}\n\nfun test_22(x: Out<Number>, list: List<Out<Int>>) {\n    list.contains1(x)\n}\n\nfun test_23(x: Out<Number>, list: List<Out<Any>>) {\n    list.contains1(x)\n}\n\n// --------------------------------------------------------\n\nfun test_31(x: Inv<Number>, list: List<Inv<in Number>>) {\n    list.contains1(x)\n}\n\nfun test_32(x: Inv<Number>, list: List<Inv<in Int>>) {\n    list.contains1(x)\n}\n\nfun test_33(x: Inv<Number>, list: List<Inv<in Any>>) {\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_34(x: Inv<Number>, list: List<Inv<out Number>>) {\n    list.contains1(x)\n}\n\nfun test_35(x: Inv<Number>, list: List<Inv<out Int>>) {\n    list.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(x)\n}\n\nfun test_36(x: Inv<Number>, list: List<Inv<out Any>>) {\n    list.contains1(x)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// ISSUE: KT-29307\n\nfun test_1(map: Map<String, String>) {\n    val x = <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>map[<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>]<!> // OK\n}\n\nopen class A\n\nclass B : A()\n\nfun test_2(map: Map<A, String>) {\n    val x = <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>map[<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>]<!>\n}\n\nfun test_3(m: Map<*, String>) {\n    val x = m[42] // should be ok\n}\n\nfun test_4(m: Map<out Number, String>) {\n    val x = m.get(42) // should be ok\n}\n\nfun test_5(map: Map<B, Int>, a: A) {\n    map.get(a)\n}\n\nfun test_6(map: Map<A, Int>, b: B) {\n    map.get(b)\n}"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <T, U: T> List<@kotlin.internal.Exact T>.firstTyped(): U = throw Exception()\n\nfun test1(l: List<Number>) {\n\n    val i: Int = l.firstTyped()\n\n    val s: String = l.<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>firstTyped()<!>\n}"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes T> assertEquals1(t1: T, t2: T) {}\n\nopen class A\nclass B: A()\nclass C: A()\nclass D\n\nfun test1(a: A, b: B, c: C) {\n    assertEquals1(a, b)\n    <!TYPE_INFERENCE_ONLY_INPUT_TYPES!>assertEquals1<!>(b, c)\n\n    assertEquals1(3, 3)\n    assertEquals1(1 or 2, 2 or 1)\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <@kotlin.internal.OnlyInputTypes T> expect1(expected: T, block: () -> T) {}\n\nfun test() {\n    expect1(2) { byteArrayOf(1, 2, 3).indexOf(3) }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\nclass Inv<T>\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes K> Inv<out K>.onlyOut(e: K) {}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes K : Number> Inv<out K>.onlyOutUB(e: K) {}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun <@kotlin.internal.OnlyInputTypes K> Inv<in K>.onlyIn(e: K) {}\n\nfun test(\n    invStar: Inv<*>,\n    invOut: Inv<out Number>,\n    invIn: Inv<in Number>\n) {\n    invStar.onlyOut(\"str\")\n    invOut.onlyOut(42)\n    invOut.onlyOut(1L)\n\n    invOut.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>onlyOutUB<!>(<!NI;TYPE_MISMATCH!>\"str\"<!>)\n    invStar.<!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>onlyOutUB<!>(0)\n    invOut.onlyOutUB(42)\n    invOut.onlyOutUB(1L)\n\n    invIn.<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>onlyIn<!>(<!NI;TYPE_MISMATCH!>\"str\"<!>)\n    invIn.onlyIn(42)\n    invIn.onlyIn(1L)\n}\n\n// From KT-32157\nfun test2(value: Any?) {\n    val result = (value as? Map<*, *>)?.get(\"result\")\n}\n\n// From KT-32116\nfun test3(h: HashMap<*, *>) {\n    val a = h[\"str\"]\n    val b = h[1]\n    val c = h[\"other\"] as? Double\n}\n\n// From KT-32218\nfun test4() {\n    val map: Map<out Any, Any> = mapOf(\n        true to true,\n        1L to 1L\n    )\n    val test = map[1L]\n}\n\n// From KT-32235\n\nclass A<T> {\n    val children = mutableListOf<B<T>>()\n}\n\nclass B<T>\n\nclass Test5 {\n    var a: A<*>? = null\n    var b: B<*>? = null\n        set(value) {\n            if (value != null) {\n                val a = a\n                require(a != null && <!DEBUG_INFO_SMARTCAST!>value<!> in <!OI;DEBUG_INFO_SMARTCAST!>a<!>.children)\n            }\n            field = value\n        }\n}"
        },
        {
            "code": "//!DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.jvm.JvmName(\"containsAny\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T> Iterable<T>.contains1(element: T): Int = null!!\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains1(element: T): Boolean = null!!\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@JvmName(\"getAny\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <K, V> Map<K, V>.get1(key: Any?): Int = null!!\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npublic fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get1(key: K): V? = null!!\n\nfun test(map: Map<Int, String>) {\n    val a: Int = <!NI;TYPE_MISMATCH!>listOf(1).<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!><!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains1<!>(\"\")<!><!>\n    val b: Boolean = listOf(1).contains1(1)\n\n    val c: String? = map.<!TYPE_INFERENCE_ONLY_INPUT_TYPES!>get1<!>(\"\")\n    val d: String? = map.get1(1)\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nfun foo(first: Array<Any?>, second: Array<Any?>) = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>Pair<!>(first.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>toCollection<!>(<!NO_VALUE_FOR_PARAMETER!>)<!>, second.<!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>toCollection<!>(<!NO_VALUE_FOR_PARAMETER!>)<!>)"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nimport kotlin.reflect.KProperty\nimport kotlin.properties.ReadWriteProperty\n\nclass CleanupTestExample {\n    val cleanUpBlocks: MutableList<Pair<Any, (Any) -> Unit>> = mutableListOf()\n\n    class CleaningDelegate<T : Any?>(\n        initialValue: T? = null,\n        val cleanupBlocks: MutableList<Pair<Any, (Any) -> Unit>>,\n        val block: (T) -> Unit\n    ) : ReadWriteProperty<Any?, T> {\n        private var value: T? = initialValue\n\n        init {\n            addCleanupBlock(initialValue)\n        }\n\n        override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n            return value ?: throw IllegalStateException(\"Property ${property.name} should be initialized before get.\")\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n            addCleanupBlock(value)\n            this.value = value\n        }\n\n        fun addCleanupBlock(value: T?) {\n            if (value != null) {\n                @Suppress(\"UNCHECKED_CAST\")\n                cleanupBlocks.add((<!DEBUG_INFO_SMARTCAST!>value<!> to block) as Pair<Any, (Any) -> Unit>)\n            }\n\n        }\n    }\n\n    data class TestHolder(val num: Int)\n\n    fun <T : Any?> cleanup(initialValue: T? = null, block: (T) -> Unit) = CleaningDelegate(initialValue, cleanUpBlocks, block)\n\n    fun testWithCleanup() {\n        val testHolder = TestHolder(1)\n\n        var thing: TestHolder by CleaningDelegate(testHolder, cleanupBlocks = cleanUpBlocks, block = { println(\"cleaning up $it\") })\n        var thing2: TestHolder by cleanup(testHolder) { println(\"cleaning up $it\") }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T> foo(resources: List<T>) {\n    resources.map { runCatching { it } }.<!OI;TYPE_INFERENCE_UPPER_BOUND_VIOLATED!>mapNotNull<!> { it.getOrNull() }\n}\n\nfun <T: Any> bar(resources: List<T>) {\n    resources.map { runCatching { it } }.mapNotNull { it.getOrNull() }\n}"
        },
        {
            "code": "private class X\n\nprivate operator fun X?.plus(<!UNUSED_PARAMETER!>p<!>: Int) = X()\n\nclass C {\n    private val map = hashMapOf<String, X>()\n\n    fun f() {\n        map<!NO_SET_METHOD!>[\"\"]<!> += 1\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: K.kt\n\nopen class K : B() {\n    companion object {\n        <!ACCIDENTAL_OVERRIDE!>@JvmStatic\n        fun foo()<!> {}\n        @JvmStatic\n        fun foo(a: Any) {}\n        <!ACCIDENTAL_OVERRIDE!>@JvmStatic\n        fun bar(i: Int)<!> {}\n        @JvmStatic\n        fun bar(i: String) {}\n        @JvmStatic\n        fun baz(i: Int) {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: B.kt\n\nopen class B : A() {\n}\n\n// FILE: K.kt\n\nopen class K : C() {\n    companion object {\n        <!ACCIDENTAL_OVERRIDE!>@JvmStatic\n        fun foo()<!> {}\n        @JvmStatic\n        fun foo(a: Any) {}\n        <!ACCIDENTAL_OVERRIDE!>@JvmStatic\n        fun bar(i: Int)<!> {}\n        @JvmStatic\n        fun bar(i: String) {}\n        @JvmStatic\n        fun baz(i: Int) {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: K.kt\n\nopen class K : A() {\n    companion object {\n        <!ACCIDENTAL_OVERRIDE!>@JvmStatic\n        fun foo()<!> {}\n        @JvmStatic\n        fun foo(i: Int) {}\n        @JvmStatic\n        fun baz(i: Int) {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n// FILE: foo/A.java\n\npackage foo;\n\npublic class A {\n    private static void foo(int s) {}\n    static void bar(double s) {}\n}\n\n// FILE: K.kt\nimport foo.A\n\nopen class K : A() {\n    companion object {\n        @JvmStatic\n        fun foo(i: Int) {}\n        @JvmStatic\n        fun bar(d: Double) {}\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass A {\n    <!CONFLICTING_JVM_DECLARATIONS!>@kotlin.jvm.JvmOverloads fun foo(s: String = \"\")<!> {\n    }\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun foo()<!> {\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nopen class Base {\n    fun `foo$default`(i: Int, mask: Int, mh: Any) {}\n}\n\nobject Derived : Base() {\n    <!ACCIDENTAL_OVERRIDE!>@JvmStatic fun foo(i: Int = 0)<!> {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n<!CONFLICTING_JVM_DECLARATIONS!>@JvmName(\"bar\")\nfun foo(a: Any)<!> {}\n\n<!CONFLICTING_JVM_DECLARATIONS!>fun bar(a: Any)<!> {}\n\nclass C {\n    <!CONFLICTING_JVM_DECLARATIONS!>@JvmName(\"foo1\")\n    fun foo(list: List<Int>)<!> {}\n\n    <!CONFLICTING_JVM_DECLARATIONS!>@JvmName(\"foo1\")\n    fun foo(list: List<String>)<!> {}\n}\n\n// Conflicts in inheritance.\n\n// A1 -> B1 with accidental override\n\nopen class A1 {\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"bar\")<!>\n    open fun foo() {}\n}\n\nclass B1 : A1() {\n    <!ACCIDENTAL_OVERRIDE!>fun bar()<!> {}\n}\n\n// A2 -> B2 with intended override and conflicting JVM declarations\n\nopen class A2 {\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"bar\")<!>\n    open fun foo() {}\n}\n\nclass <!CONFLICTING_JVM_DECLARATIONS!>B2<!> : A2() {\n    override fun foo() {}\n\n    <!CONFLICTING_JVM_DECLARATIONS!>fun bar()<!> {}\n}\n\n// A3 -> B3 -> C3 with accidental override\n\nopen class A3 {\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"bar\")<!>\n    open fun foo() {}\n}\n\nopen class B3: A3() {\n}\n\nclass C3: B3() {\n    <!ACCIDENTAL_OVERRIDE!>fun bar()<!> {}\n}"
        },
        {
            "code": "open class Base {\n    fun foo() {}\n}\n\nclass Derived : Base() {\n    companion object {\n        <!ACCIDENTAL_OVERRIDE!>@JvmStatic fun foo()<!> {}\n    }\n}\n"
        },
        {
            "code": "import java.util.HashMap\n\nprivate fun <A> unaryOperation(\n        a: CompileTimeType<A>,\n        functionName: String,\n        operation: Function1<A, Any>,\n        checker: Function1<Long, Long>\n) = UnaryOperationKey(a, functionName) to Pair(operation, checker) <!UNCHECKED_CAST!>as Pair<Function1<Any?, Any>, Function1<Long, Long>><!>\n\nprivate fun <A, B> binaryOperation(\n        a: CompileTimeType<A>,\n        b: CompileTimeType<B>,\n        functionName: String,\n        operation: Function2<A, B, Any>,\n        checker: Function2<BigInteger, BigInteger, BigInteger>\n) = BinaryOperationKey(a, b, functionName) to Pair(operation, checker) <!UNCHECKED_CAST!>as Pair<Function2<Any?, Any?, Any>, Function2<BigInteger, BigInteger, BigInteger>><!>\n\nprivate data class UnaryOperationKey<A>(val f: CompileTimeType<out A>, val functionName: String)\n//HashMap<BinaryOperationKey<*, *>, Pair<Function2<Any?, Any?, Any>, Function2<BigInteger, BigInteger, BigInteger>>>\nprivate data class BinaryOperationKey<A, B>(val f: CompileTimeType<out A>, val g: CompileTimeType<out B>, val functionName: String)\n\nprivate class CompileTimeType<T>\n\nprivate val BYTE = CompileTimeType<Byte>()\nprivate val CHAR = CompileTimeType<Char>()\nprivate val BOOLEAN = CompileTimeType<Boolean>()\nprivate val DOUBLE = CompileTimeType<Double>()\nprivate val FLOAT = CompileTimeType<Float>()\nprivate val INT = CompileTimeType<Int>()\nprivate val LONG = CompileTimeType<Long>()\nprivate val SHORT = CompileTimeType<Short>()\nprivate val STRING = CompileTimeType<String>()\nprivate val ANY = CompileTimeType<Any>()\n\n\nprivate val emptyBinaryFun: Function2<BigInteger, BigInteger, BigInteger> = { <!UNUSED_ANONYMOUS_PARAMETER!>a<!>, <!UNUSED_ANONYMOUS_PARAMETER!>b<!> -> BigInteger(\"0\") }\nprivate val emptyUnaryFun: Function1<Long, Long> = { <!UNUSED_ANONYMOUS_PARAMETER!>a<!> -> 1.toLong() }\n\nprivate val unaryOperations: HashMap<UnaryOperationKey<*>, Pair<Function1<Any?, Any>, Function1<Long, Long>>>\n        = hashMapOf<UnaryOperationKey<*>, Pair<Function1<Any?, Any>, Function1<Long, Long>>>(\n        unaryOperation(BOOLEAN, \"not!\", { a -> a.not() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"minus\", { a -> a.unaryMinus() }, { a -> a.unaryMinus() }),\n        unaryOperation(BYTE, \"minus\", { a -> a.unaryMinus() }, { a -> a.unaryMinus() }),\n        unaryOperation(BYTE, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"plus\", { a -> a.unaryPlus() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(BYTE, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(CHAR, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"minus\", { a -> a.unaryMinus() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"plus\", { a -> a.unaryPlus() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(DOUBLE, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"minus\", { a -> a.unaryMinus() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"plus\", { a -> a.unaryPlus() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(FLOAT, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(INT, \"plus\", { a -> a.unaryPlus() }, emptyUnaryFun),\n        unaryOperation(INT, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(INT, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(INT, \"inv\", { a -> a.inv() }, emptyUnaryFun),\n        unaryOperation(INT, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(INT, \"minus\", { a -> a.unaryMinus() }, { a -> a.unaryMinus() }),\n        unaryOperation(INT, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(INT, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(INT, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(INT, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(LONG, \"plus\", { a -> a.unaryPlus() }, emptyUnaryFun),\n        unaryOperation(LONG, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(LONG, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(LONG, \"inv\", { a -> a.inv() }, emptyUnaryFun),\n        unaryOperation(LONG, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(LONG, \"minus\", { a -> a.unaryMinus() }, { a -> a.unaryMinus() }),\n        unaryOperation(LONG, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(LONG, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(LONG, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(LONG, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"toInt\", { a -> a.toInt() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"minus\", { a -> a.unaryMinus() }, { a -> a.unaryMinus() }),\n        unaryOperation(SHORT, \"toChar\", { a -> a.toChar() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"toLong\", { a -> a.toLong() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"plus\", { a -> a.unaryPlus() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"toFloat\", { a -> a.toFloat() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"toDouble\", { a -> a.toDouble() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"toShort\", { a -> a.toShort() }, emptyUnaryFun),\n        unaryOperation(SHORT, \"toByte\", { a -> a.toByte() }, emptyUnaryFun),\n        unaryOperation(STRING, \"toString\", { a -> a.toString() }, emptyUnaryFun)\n)\n\nprivate val binaryOperations: HashMap<BinaryOperationKey<*, *>, Pair<Function2<Any?, Any?, Any>, Function2<BigInteger, BigInteger, BigInteger>>>\n        = hashMapOf<BinaryOperationKey<*, *>, Pair<Function2<Any?, Any?, Any>, Function2<BigInteger, BigInteger, BigInteger>>>(\n        binaryOperation(BOOLEAN, BOOLEAN, \"xor\", { a, b -> a.xor(b) }, emptyBinaryFun),\n        binaryOperation(BOOLEAN, BOOLEAN, \"or\", { a, b -> a.or(b) }, emptyBinaryFun),\n        binaryOperation(BOOLEAN, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(BOOLEAN, BOOLEAN, \"and\", { a, b -> a.and(b) }, emptyBinaryFun),\n        binaryOperation(BOOLEAN, BOOLEAN, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, BYTE, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(BYTE, DOUBLE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, FLOAT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, INT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(BYTE, LONG, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(BYTE, SHORT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(BYTE, BYTE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, DOUBLE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, FLOAT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, INT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, LONG, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, SHORT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, BYTE, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(BYTE, DOUBLE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, FLOAT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, INT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(BYTE, LONG, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(BYTE, SHORT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(BYTE, BYTE, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(BYTE, DOUBLE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, FLOAT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, INT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(BYTE, LONG, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(BYTE, SHORT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(BYTE, BYTE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(BYTE, DOUBLE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, FLOAT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, INT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(BYTE, LONG, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(BYTE, SHORT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(BYTE, BYTE, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(BYTE, DOUBLE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, FLOAT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(BYTE, INT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(BYTE, LONG, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(BYTE, SHORT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(BYTE, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(CHAR, CHAR, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(CHAR, CHAR, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(CHAR, INT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(CHAR, INT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(CHAR, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, BYTE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, DOUBLE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, FLOAT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, INT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, LONG, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, SHORT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, BYTE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, DOUBLE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, FLOAT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, INT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, LONG, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, SHORT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, BYTE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, DOUBLE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, FLOAT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, INT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, LONG, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, SHORT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, BYTE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, DOUBLE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, FLOAT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, INT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, LONG, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, SHORT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, BYTE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, DOUBLE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, FLOAT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, INT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, LONG, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, SHORT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, BYTE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, DOUBLE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, FLOAT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, INT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, LONG, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, SHORT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(DOUBLE, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, BYTE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, DOUBLE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, FLOAT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, INT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, LONG, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, SHORT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, BYTE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, DOUBLE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, FLOAT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, INT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, LONG, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, SHORT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, BYTE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, DOUBLE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, FLOAT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, INT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, LONG, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, SHORT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, BYTE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, DOUBLE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, FLOAT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, INT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, LONG, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, SHORT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, BYTE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, DOUBLE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, FLOAT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, INT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, LONG, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, SHORT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, BYTE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, DOUBLE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, FLOAT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, INT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, LONG, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, SHORT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(FLOAT, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(INT, BYTE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(INT, DOUBLE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(INT, FLOAT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(INT, LONG, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(INT, SHORT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(INT, BYTE, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(INT, DOUBLE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(INT, FLOAT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(INT, LONG, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(INT, SHORT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(INT, INT, \"shl\", { a, b -> a.shl(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"ushr\", { a, b -> a.ushr(b) }, emptyBinaryFun),\n        binaryOperation(INT, BYTE, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(INT, DOUBLE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(INT, FLOAT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(INT, LONG, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(INT, SHORT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(INT, INT, \"shr\", { a, b -> a.shr(b) }, emptyBinaryFun),\n        binaryOperation(INT, BYTE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(INT, DOUBLE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(INT, FLOAT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(INT, LONG, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(INT, SHORT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(INT, BYTE, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(INT, DOUBLE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(INT, FLOAT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(INT, LONG, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(INT, SHORT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(INT, INT, \"or\", { a, b -> a.or(b) }, { a, b -> a.or(b) }),\n        binaryOperation(INT, BYTE, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(INT, DOUBLE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(INT, FLOAT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(INT, INT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(INT, LONG, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(INT, SHORT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(INT, INT, \"and\", { a, b -> a.and(b) }, { a, b -> a.and(b) }),\n        binaryOperation(INT, INT, \"xor\", { a, b -> a.xor(b) }, { a, b -> a.xor(b) }),\n        binaryOperation(INT, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(LONG, BYTE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(LONG, DOUBLE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(LONG, FLOAT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(LONG, LONG, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(LONG, SHORT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(LONG, BYTE, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(LONG, DOUBLE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(LONG, FLOAT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(LONG, LONG, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(LONG, SHORT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(LONG, INT, \"shl\", { a, b -> a.shl(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"ushr\", { a, b -> a.ushr(b) }, emptyBinaryFun),\n        binaryOperation(LONG, BYTE, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(LONG, DOUBLE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(LONG, FLOAT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(LONG, LONG, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(LONG, SHORT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(LONG, INT, \"shr\", { a, b -> a.shr(b) }, emptyBinaryFun),\n        binaryOperation(LONG, BYTE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(LONG, DOUBLE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(LONG, FLOAT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(LONG, LONG, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(LONG, SHORT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(LONG, BYTE, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(LONG, DOUBLE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(LONG, FLOAT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(LONG, LONG, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(LONG, SHORT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(LONG, LONG, \"or\", { a, b -> a.or(b) }, { a, b -> a.or(b) }),\n        binaryOperation(LONG, BYTE, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(LONG, DOUBLE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(LONG, FLOAT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(LONG, INT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(LONG, LONG, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(LONG, SHORT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(LONG, LONG, \"and\", { a, b -> a.and(b) }, { a, b -> a.and(b) }),\n        binaryOperation(LONG, LONG, \"xor\", { a, b -> a.xor(b) }, { a, b -> a.xor(b) }),\n        binaryOperation(LONG, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, BYTE, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(SHORT, DOUBLE, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, FLOAT, \"minus\", { a, b -> a.minus(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, INT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(SHORT, LONG, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(SHORT, SHORT, \"minus\", { a, b -> a.minus(b) }, { a, b -> a.subtract(b) }),\n        binaryOperation(SHORT, BYTE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, DOUBLE, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, FLOAT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, INT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, LONG, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, SHORT, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, BYTE, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(SHORT, DOUBLE, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, FLOAT, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, INT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(SHORT, LONG, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(SHORT, SHORT, \"plus\", { a, b -> a.plus(b) }, { a, b -> a.add(b) }),\n        binaryOperation(SHORT, BYTE, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(SHORT, DOUBLE, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, FLOAT, \"div\", { a, b -> a.div(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, INT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(SHORT, LONG, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(SHORT, SHORT, \"div\", { a, b -> a.div(b) }, { a, b -> a.divide(b) }),\n        binaryOperation(SHORT, BYTE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(SHORT, DOUBLE, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, FLOAT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, INT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(SHORT, LONG, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(SHORT, SHORT, \"mod\", { a, b -> a.<!DEPRECATION_ERROR!>mod<!>(b) }, { a, b -> a.mod(b) }),\n        binaryOperation(SHORT, BYTE, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(SHORT, DOUBLE, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, FLOAT, \"times\", { a, b -> a.times(b) }, emptyBinaryFun),\n        binaryOperation(SHORT, INT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(SHORT, LONG, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(SHORT, SHORT, \"times\", { a, b -> a.times(b) }, { a, b -> a.multiply(b) }),\n        binaryOperation(SHORT, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(STRING, ANY, \"plus\", { a, b -> a.plus(b) }, emptyBinaryFun),\n        binaryOperation(STRING, INT, \"get\", { a, b -> a.get(b) }, emptyBinaryFun),\n        binaryOperation(STRING, ANY, \"equals\", { a, b -> a.equals(b) }, emptyBinaryFun),\n        binaryOperation(STRING, STRING, \"compareTo\", { a, b -> a.compareTo(b) }, emptyBinaryFun)\n)\n\n//from library\nclass BigInteger(val value: String) {\n    fun add(o: BigInteger): BigInteger = o\n    fun divide(o: BigInteger): BigInteger = o\n    fun mod(o: BigInteger): BigInteger = o\n    fun multiply(o: BigInteger): BigInteger = o\n    fun subtract(o: BigInteger): BigInteger = o\n    fun or(o: BigInteger): BigInteger = o\n    fun and(o: BigInteger): BigInteger = o\n    fun xor(o: BigInteger): BigInteger = o\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\nannotation class E\n\nopen class Base {\n    @E\n    open fun foo() {}\n}\n\nclass DerivedInSameModule : Base() {\n    override fun <!EXPERIMENTAL_OVERRIDE!>foo<!>() {}\n}\n\n// FILE: usage-propagate.kt\n\npackage usage1\n\nimport api.*\n\nopen class Derived : Base() {\n    @E\n    override fun foo() {}\n}\n\nclass SubDerived : Derived()\n\n@E\nclass Derived2 : Base() {\n    override fun foo() {}\n}\n\n// FILE: usage-none.kt\n\npackage usage2\n\nimport api.*\n\nclass Derived : Base() {\n    override fun <!EXPERIMENTAL_OVERRIDE!>foo<!>() {}\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\nimport kotlin.annotation.AnnotationTarget.*\n\n@Experimental(Experimental.Level.WARNING)\n@Target(CLASS, ANNOTATION_CLASS, TYPE_PARAMETER, PROPERTY, FIELD, LOCAL_VARIABLE, VALUE_PARAMETER, CONSTRUCTOR, FUNCTION,\n        PROPERTY_GETTER, PROPERTY_SETTER, TYPE, TYPEALIAS)\nannotation class E1\n\n@Experimental(Experimental.Level.WARNING)\n<!EXPERIMENTAL_ANNOTATION_WITH_WRONG_TARGET!>@Target(FILE)<!>\nannotation class E2\n\n@Experimental(Experimental.Level.WARNING)\n<!EXPERIMENTAL_ANNOTATION_WITH_WRONG_TARGET!>@Target(EXPRESSION)<!>\n@Retention(AnnotationRetention.SOURCE)\nannotation class E3\n\n@Experimental(Experimental.Level.WARNING)\n<!EXPERIMENTAL_ANNOTATION_WITH_WRONG_TARGET!>@Target(FILE, EXPRESSION)<!>\n@Retention(AnnotationRetention.SOURCE)\nannotation class E4\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nclass C {\n    @ExperimentalAPI\n    fun function() {}\n\n    @ExperimentalAPI\n    val property: String = \"\"\n\n    @ExperimentalAPI\n    class Nested {\n        @ExperimentalAPI\n        fun nestedFunction() {}\n    }\n}\n\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\nfun use() {\n    val c: <!EXPERIMENTAL_API_USAGE!>C<!> = <!EXPERIMENTAL_API_USAGE!>C<!>()\n    c.<!EXPERIMENTAL_API_USAGE!>function<!>()\n    c.<!EXPERIMENTAL_API_USAGE!>property<!>\n    <!EXPERIMENTAL_API_USAGE!>C<!>.<!EXPERIMENTAL_API_USAGE!>Nested<!>().<!EXPERIMENTAL_API_USAGE!>nestedFunction<!>()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nclass C {\n    fun function(): String = \"\"\n    val property: String = \"\"\n    class Nested\n    inner class Inner\n}\n\n@ExperimentalAPI\nfun C.extension() {}\n\n// FILE: usage-propagate.kt\n\npackage usage1\n\nimport api.*\n\n@ExperimentalAPI\nfun useAll() {\n    val c: C = C()\n    c.function()\n    c.property\n    C.Nested()\n    c.Inner()\n    c.extension()\n}\n\n@ExperimentalAPI\nclass Use {\n    fun useAll(c: C) {\n        c.function()\n        c.property\n        C.Nested()\n        c.Inner()\n        c.extension()\n    }\n}\n\n// FILE: usage-use.kt\n\npackage usage2\n\nimport api.*\n\n@UseExperimental(ExperimentalAPI::class)\nfun useAll() {\n    val c: C = C()\n    c.function()\n    c.property\n    C.Nested()\n    c.Inner()\n    c.extension()\n}\n\n@UseExperimental(ExperimentalAPI::class)\nclass Use {\n    fun useAll(c: C) {\n        c.function()\n        c.property\n        C.Nested()\n        c.Inner()\n        c.extension()\n    }\n}\n\n// FILE: usage-none.kt\n\npackage usage3\n\nimport api.*\n\nfun use() {\n    val c: <!EXPERIMENTAL_API_USAGE!>C<!> = <!EXPERIMENTAL_API_USAGE!>C<!>()\n    c.<!EXPERIMENTAL_API_USAGE!>function<!>()\n    c.<!EXPERIMENTAL_API_USAGE!>property<!>\n    <!EXPERIMENTAL_API_USAGE!>C<!>.<!EXPERIMENTAL_API_USAGE!>Nested<!>()\n    c.<!EXPERIMENTAL_API_USAGE!>Inner<!>()\n    c.<!EXPERIMENTAL_API_USAGE!>extension<!>()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nconst val MEANING = 42\n\nannotation class Anno(val value: Int)\n\n// FILE: usage-propagate.kt\n\npackage usage1\n\nimport api.*\n\n@ExperimentalAPI\n@Anno(MEANING)\nfun usage() {}\n\n// FILE: usage-use.kt\n\n@file:UseExperimental(ExperimentalAPI::class)\npackage usage2\n\nimport api.*\n\n// TODO: there should be no warning here\n@Anno(<!EXPERIMENTAL_API_USAGE!>MEANING<!>)\nfun usage() {}\n\n// FILE: usage-none.kt\n\npackage usage3\n\nimport api.*\n\n@Anno(<!EXPERIMENTAL_API_USAGE!>MEANING<!>)\nfun usage() {}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\nannotation class ExperimentalAPI\n\ninterface I\n\n@ExperimentalAPI\nclass Impl : I\n\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\nopen class Base(val i: I)\n\n@UseExperimental(ExperimentalAPI::class)\nclass Derived : Base(Impl())\n\n@UseExperimental(ExperimentalAPI::class)\nclass Delegated : I by Impl()\n\n@UseExperimental(ExperimentalAPI::class)\nval delegatedProperty by Impl()\noperator fun I.getValue(x: Any?, y: Any?) = null\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.CLASS)\nannotation class E\n\n@E\nopen class Foo(val s: String = \"\")\n\n// FILE: usage.kt\n\nimport api.*\n\n@UseExperimental(E::class)\nclass Klass {\n    init {\n        Foo()\n    }\n}\n\nclass Constructor {\n    @UseExperimental(E::class) constructor() {\n        Foo()\n    }\n}\n\n@UseExperimental(E::class)\nval property = Foo().s\n\n@UseExperimental(E::class)\nfun function() {\n    Foo()\n}\n\nfun valueParameter(@UseExperimental(E::class) p: String = Foo().s): String {\n    @UseExperimental(E::class)\n    val localVariable: String = Foo().s\n    return localVariable\n}\n\nvar propertyAccessors: String\n    @UseExperimental(E::class)\n    get() = Foo().s\n    @UseExperimental(E::class)\n    set(value) { Foo() }\n\nfun expression(): String {\n    val s = @UseExperimental(E::class) Foo().s\n    return s\n}\n\n@UseExperimental(E::class)\ntypealias TypeAlias = Foo\n"
        },
        {
            "code": "// !DIAGNOSTICS: -NOTHING_TO_INLINE -UNUSED_PARAMETER\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\nannotation class API\n\n@API\nfun f() {}\n\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\nfun use1() {\n    <!EXPERIMENTAL_API_USAGE!>f<!>()\n}\n\nval use2 = <!EXPERIMENTAL_API_USAGE!>f<!>()\n\n// FILE: inline-usage.kt\n\npackage usage\n\nimport api.*\n\ninline fun inlineUse1() {\n    <!EXPERIMENTAL_API_USAGE!>f<!>()\n}\n\ninline var inlineUse2: Unit\n    get() {\n        <!EXPERIMENTAL_API_USAGE!>f<!>()\n    }\n    set(value) {\n        <!EXPERIMENTAL_API_USAGE!>f<!>()\n    }\n\nvar inlineUse3: Unit\n    inline get() {\n        <!EXPERIMENTAL_API_USAGE!>f<!>()\n    }\n    @API\n    inline set(value) {\n        f()\n    }\n\n@API\ninline fun inlineUse4() {\n    f()\n}\n\n// FILE: private-inline-usage.kt\n\npackage usage\n\nimport api.*\n\nprivate inline fun privateInline1() {\n    <!EXPERIMENTAL_API_USAGE!>f<!>()\n}\n\ninternal inline fun privateInline2() {\n    <!EXPERIMENTAL_API_USAGE!>f<!>()\n}\n\nprivate inline var privateInline3: Unit\n    get() {\n        <!EXPERIMENTAL_API_USAGE!>f<!>()\n    }\n    set(value) {\n        <!EXPERIMENTAL_API_USAGE!>f<!>()\n    }\n\ninternal class InternalClass {\n    inline fun privateInline4() {\n        <!EXPERIMENTAL_API_USAGE!>f<!>()\n    }\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.FUNCTION)\nannotation class ExperimentalAPI1\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.FUNCTION)\nannotation class ExperimentalAPI2\n\n@ExperimentalAPI1\nfun compilation() {}\n\n@ExperimentalAPI2\nfun runtime() {}\n\n// FILE: usage.kt\n\n@file:UseExperimental(ExperimentalAPI1::class)\npackage usage\n\nimport api.*\n\nfun use() {\n    compilation()\n    <!EXPERIMENTAL_API_USAGE!>runtime<!>()\n}\n\nclass Use {\n    fun use() {\n        compilation()\n        <!EXPERIMENTAL_API_USAGE!>runtime<!>()\n    }\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n\nannotation class NotAMarker\n\n<!USE_EXPERIMENTAL_WITHOUT_ARGUMENTS!>@UseExperimental<!>\nfun f1() {}\n\n<!USE_EXPERIMENTAL_ARGUMENT_IS_NOT_MARKER!>@UseExperimental(NotAMarker::class)<!>\nfun f2() {}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_EXPRESSION, -UNUSED_VARIABLE, -UNUSED_PARAMETER\n\nfun test() {\n    <!EXPERIMENTAL_UNSIGNED_LITERALS!>42u<!>\n    <!EXPERIMENTAL_UNSIGNED_LITERALS!>21UL<!>\n    val list = listOf(\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>1u<!>,\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>0xFFu<!>,\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>0xbbU<!>\n    )\n\n    takeAll(\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>1u<!>,\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>2u<!>,\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>3u<!>,\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>4u<!>,\n        <!EXPERIMENTAL_UNSIGNED_LITERALS!>5u<!>\n    )\n\n    @UseExperimental(ExperimentalUnsignedTypes::class) 42u\n}\n\nfun takeAll(\n    b: <!EXPERIMENTAL_API_USAGE!>UByte<!>,\n    s: <!EXPERIMENTAL_API_USAGE!>UShort<!>,\n    i: <!EXPERIMENTAL_API_USAGE!>UInt<!>,\n    l: <!EXPERIMENTAL_API_USAGE!>ULong<!>,\n    vararg uints: <!EXPERIMENTAL_API_USAGE!>UInt<!>\n) {}\n\nconst val unsignedConst = <!EXPERIMENTAL_UNSIGNED_LITERALS!>0u<!>\nconst val unsignedLongConst = <!EXPERIMENTAL_UNSIGNED_LITERALS!>0uL<!>\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !EXPERIMENTAL: api.ExperimentalAPI\n// MODULE: api\n// FILE: api.kt\n\npackage api\n\n@Experimental\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nfun function(): String = \"\"\n\n// MODULE: usage(api)\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\nfun use() {\n    function()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInAnnotations\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: api.kt\n\npackage test\n\nimport kotlin.reflect.KClass\n\n// Usages in import should be OK\nimport kotlin.Experimental.Level.*\nimport kotlin.Experimental.Level\nimport kotlin.Experimental\n\n// Usages with FQ names should be OK\n\n@kotlin.Experimental(kotlin.Experimental.Level.ERROR)\nannotation class M\n\n\n// Usages as types should be errors\n\nfun f1(e: <!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>Experimental<!>) {}\nfun f2(u: <!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>UseExperimental<!>?) {}\n\ntypealias Experimental0 = <!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>Experimental<!>\ntypealias UseExperimental0 = <!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>UseExperimental<!>\nfun f3(e: Experimental0 /* TODO */) {}\nfun f4(u: UseExperimental0 /* TODO */) {}\n\n\n// Usages as ::class literals should be errors\n\nannotation class VarargKClasses(vararg val k: KClass<*>)\n\n@VarargKClasses(\n    <!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>Experimental<!>::class,\n    <!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>UseExperimental<!>::class,\n    kotlin.<!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>Experimental<!>::class,\n    kotlin.<!EXPERIMENTAL_CAN_ONLY_BE_USED_AS_ANNOTATION!>UseExperimental<!>::class\n)\nfun f5() {}\n\n\n// Usages of markers as types should be errors\n\n@Experimental\nannotation class Marker {\n    class NestedClass\n\n    companion object {\n        const val value = 42\n    }\n}\n\nfun f6(m: <!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>) {}\nfun f7(): List<<!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>>? = null\nfun f8(): test.<!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>? = null\n\ntypealias Marker0 = <!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>\n\nfun f9(m: <!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker0<!>) {}\n\n\n// Usages of markers as qualifiers are errors as well (we can lift this restriction for select cases)\n\nfun f10(m: <!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>.NestedClass) {\n    <!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>.value\n}\n\n// FILE: usage-from-other-file.kt\n\n// Usages of markers in import statements should be OK, but not as qualifiers to import their nested classes\n\nimport test.Marker\nimport test.<!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>.NestedClass\nimport test.<!EXPERIMENTAL_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_USE_EXPERIMENTAL!>Marker<!>.Companion\n"
        },
        {
            "code": "// !API_VERSION: 1.2\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -INVISIBLE_MEMBER -INVISIBLE_REFERENCE -NEWER_VERSION_IN_SINCE_KOTLIN -UNUSED_PARAMETER\n\n@SinceKotlin(\"1.3\")\nfun newPublishedFun() {}\n\n\n@Experimental\nannotation class Marker\n\n@SinceKotlin(\"1.3\")\n@WasExperimental(Marker::class)\nfun newFunExperimentalInThePast() {}\n\n@SinceKotlin(\"1.3\")\n@WasExperimental(Marker::class)\nval newValExperimentalInThePast = \"\"\n\n@SinceKotlin(\"1.3\")\n@WasExperimental(Marker::class)\nclass NewClassExperimentalInThePast\n\n@SinceKotlin(\"1.3\")\n@WasExperimental(Marker::class)\ntypealias TypeAliasToNewClass = <!EXPERIMENTAL_API_USAGE_ERROR!>NewClassExperimentalInThePast<!>\n\n\nfun use1(\n    c1: <!EXPERIMENTAL_API_USAGE_ERROR!>NewClassExperimentalInThePast<!>,\n    t1: <!EXPERIMENTAL_API_USAGE_ERROR!>TypeAliasToNewClass<!>\n) {\n    <!UNRESOLVED_REFERENCE!>newPublishedFun<!>()\n    <!UNRESOLVED_REFERENCE!>newFunExperimentalInThePast<!>()\n    <!UNRESOLVED_REFERENCE!>newValExperimentalInThePast<!>\n    <!UNRESOLVED_REFERENCE!>NewClassExperimentalInThePast<!>()\n}\n\n@UseExperimental(Marker::class)\nfun use2(\n    c2: NewClassExperimentalInThePast,\n    t2: TypeAliasToNewClass\n) {\n    <!UNRESOLVED_REFERENCE!>newPublishedFun<!>()\n    newFunExperimentalInThePast()\n    newValExperimentalInThePast\n    NewClassExperimentalInThePast()\n}\n\n@Marker\nfun use3(\n    c3: NewClassExperimentalInThePast,\n    t3: TypeAliasToNewClass\n) {\n    <!UNRESOLVED_REFERENCE!>newPublishedFun<!>()\n    newFunExperimentalInThePast()\n    newValExperimentalInThePast\n    NewClassExperimentalInThePast()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n\n@Experimental(Experimental.Level.WARNING)\nannotation class E1\n@Experimental(Experimental.Level.WARNING)\nannotation class E3\n\ninterface Base1 {\n    @E1\n    fun foo()\n}\n\ninterface Base2 {\n    fun foo()\n}\n\ninterface Base3 {\n    @E3\n    fun foo()\n}\n\nclass DerivedA : Base1, Base2, Base3 {\n    override fun <!EXPERIMENTAL_OVERRIDE, EXPERIMENTAL_OVERRIDE!>foo<!>() {}\n}\n\nclass DerivedB : Base1, Base3 {\n    @E3\n    override fun <!EXPERIMENTAL_OVERRIDE!>foo<!>() {}\n}\n\nclass DerivedC : Base1, Base2, Base3 {\n    @E1\n    @E3\n    override fun foo() {}\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nclass C {\n    class D {\n        class E {\n            class F\n        }\n    }\n}\n\n// FILE: usage-propagate.kt\n\npackage usage1\n\nimport api.*\n\n@ExperimentalAPI\nfun use1() {\n    C.D.E.F()\n}\n\n@ExperimentalAPI\nfun use2(f: C.D.E.F) = f.hashCode()\n\n// FILE: usage-use.kt\n\npackage usage2\n\nimport api.*\n\n@UseExperimental(ExperimentalAPI::class)\nfun use1() {\n    C.D.E.F()\n}\n\n@UseExperimental(ExperimentalAPI::class)\nfun use2(f: C.D.E.F) = f.hashCode()\n\n// FILE: usage-none.kt\n\npackage usage3\n\nimport api.*\n\nfun use1() {\n    <!EXPERIMENTAL_API_USAGE!>C<!>.<!EXPERIMENTAL_API_USAGE!>D<!>.<!EXPERIMENTAL_API_USAGE!>E<!>.<!EXPERIMENTAL_API_USAGE!>F<!>()\n}\n\nfun use2(f: <!EXPERIMENTAL_API_USAGE!>C<!>.<!EXPERIMENTAL_API_USAGE!>D<!>.<!EXPERIMENTAL_API_USAGE!>E<!>.<!EXPERIMENTAL_API_USAGE!>F<!>) = f.<!EXPERIMENTAL_API_USAGE!>hashCode<!>()\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental\n@Target(AnnotationTarget.CLASS)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nclass Foo\n\ntypealias Bar = <!EXPERIMENTAL_API_USAGE_ERROR!>Foo<!>\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_VARIABLE\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.TYPEALIAS,\n        AnnotationTarget.VALUE_PARAMETER)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nfun function(): String = \"\"\n\n@ExperimentalAPI\nval property: String = \"\"\n\n@ExperimentalAPI\ntypealias Typealias = String\n\n// FILE: usage-propagate.kt\n\npackage usage1\n\nimport api.*\n\n@ExperimentalAPI\nfun useAll() {\n    function()\n    property\n    val s: Typealias = \"\"\n}\n\n@ExperimentalAPI\nclass Use {\n    fun useAll() {\n        function()\n        property\n        val s: Typealias = \"\"\n    }\n}\n\n// FILE: usage-use.kt\n\npackage usage2\n\nimport api.*\n\nfun useAll() {\n    @UseExperimental(ExperimentalAPI::class)\n    {\n        function()\n        property\n        val s: Typealias = \"\"\n    }()\n}\n\n@UseExperimental(ExperimentalAPI::class)\nclass Use {\n    fun useAll() {\n        function()\n        property\n        val s: Typealias = \"\"\n    }\n}\n\n// FILE: usage-none.kt\n\npackage usage3\n\nimport api.*\n\nfun use() {\n    <!EXPERIMENTAL_API_USAGE!>function<!>()\n    <!EXPERIMENTAL_API_USAGE!>property<!>\n    val s: <!EXPERIMENTAL_API_USAGE!>Typealias<!> = \"\"\n    s.hashCode()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.FUNCTION)\nannotation class E1\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.FUNCTION)\nannotation class E2\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.FUNCTION)\nannotation class E3\n\n@E1\nfun e1() {}\n\n@E2\nfun e2() {}\n\n@E3\nfun e3() {}\n\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\n@UseExperimental(E1::class, E2::class, E3::class)\nfun use1() {\n    e1()\n    e2()\n    e3()\n}\n\n@UseExperimental(E1::class, E3::class)\nfun use2() {\n    e1()\n    @UseExperimental(E2::class) e2()\n    e3()\n}\n\n@UseExperimental(E1::class, E2::class)\nfun use3() {\n    e1()\n    e2()\n    <!EXPERIMENTAL_API_USAGE!>e3<!>()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental api.ExperimentalAPI\n// MODULE: api\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.ERROR)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\nfun function(): String = \"\"\n\n// MODULE: usage(api)\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\nfun use() {\n    function()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage feature.experimental.self\n\n@Experimental\nannotation class ImportedMarker\n\n@ImportedMarker\nobject ImportedClass {\n    @ImportedMarker\n    fun importedObjectMember() {}\n}\n\n@ImportedMarker\nfun importedFunction() {}\n\n@ImportedMarker\nval importedProperty = Unit\n\n// FILE: usage.kt\n\nimport feature.experimental.self.ImportedMarker\nimport feature.experimental.self.ImportedClass\nimport feature.experimental.self.importedFunction\nimport feature.experimental.self.importedProperty\nimport feature.experimental.self.ImportedClass.importedObjectMember\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\n@Experimental(Experimental.Level.WARNING)\nannotation class VeryExperimentalAPI\n\n@ExperimentalAPI\n@VeryExperimentalAPI\nfun f() {}\n\n@ExperimentalAPI\nfun g() {}\n\n// FILE: usage.kt\n\n@file:UseExperimental(ExperimentalAPI::class, VeryExperimentalAPI::class)\npackage usage\n\nimport api.*\n\nfun usage() {\n    f()\n    g()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// FILE: api.kt\n\npackage api\n\n@Experimental\nannotation class E\n\nopen class Base {\n    @E\n    open fun foo() {}\n}\n\n// FILE: usage.kt\n\npackage usage\n\nimport api.*\n\nclass Derived : Base() {\n    override fun <!EXPERIMENTAL_OVERRIDE_ERROR!>foo<!>() {}\n}\n\nfun test(b: Base) {\n    b.<!EXPERIMENTAL_API_USAGE_ERROR!>foo<!>()\n}\n"
        },
        {
            "code": "// FILE: api.kt\n\n@<!EXPERIMENTAL_IS_NOT_ENABLED!>Experimental<!>\nannotation class Marker\n\n@Marker\nfun f() {}\n\n// FILE: usage.kt\n\nfun use1() {\n    <!EXPERIMENTAL_API_USAGE_ERROR!>f<!>()\n}\n\n@Marker\nfun use2() {\n    f()\n}\n\n@<!EXPERIMENTAL_IS_NOT_ENABLED!>UseExperimental<!>(Marker::class)\nfun use3() {\n    f()\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// FILE: api.kt\n\npackage api\n\n@Experimental(Experimental.Level.WARNING)\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.TYPEALIAS,\n        AnnotationTarget.VALUE_PARAMETER)\nannotation class ExperimentalAPI\n\n@ExperimentalAPI\n@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.TYPEALIAS,\n        AnnotationTarget.VALUE_PARAMETER)\nannotation class EAnno\n\n// FILE: usage-propagate.kt\n\npackage usage1\n\nimport api.*\n\n@ExperimentalAPI\n@EAnno fun function() {}\n\n@ExperimentalAPI\nfun parameter(@EAnno p: String) {}\n\n@ExperimentalAPI\nfun parameterType(p: @EAnno String) {}\n\n@ExperimentalAPI\nfun returnType(): @EAnno Unit {}\n\n@ExperimentalAPI\n@EAnno val property = \"\"\n\n@ExperimentalAPI\n@EAnno typealias Typealias = Unit\n\n@ExperimentalAPI\n@EAnno class Klass\n\n@ExperimentalAPI\nannotation class AnnotationArgument(val p: EAnno)\n\n@ExperimentalAPI\nfun insideBody() {\n    @EAnno fun local() {}\n}\n\n@ExperimentalAPI\nfun inDefaultArgument(f: () -> Unit = @EAnno fun() {}) {}\n\n@ExperimentalAPI\nval inProperty = @EAnno fun() {}\n\n@ExperimentalAPI\nval inPropertyAccessor: () -> Unit\n    get() = @EAnno fun() {}\n\n// FILE: usage-use.kt\n\npackage usage2\n\nimport api.*\n\n@UseExperimental(ExperimentalAPI::class)\n@EAnno fun function() {}\n\n@UseExperimental(ExperimentalAPI::class)\nfun parameter(@EAnno p: String) {}\n\n@UseExperimental(ExperimentalAPI::class)\nfun parameterType(p: @EAnno String) {}\n\n@UseExperimental(ExperimentalAPI::class)\nfun returnType(): @EAnno Unit {}\n\n@UseExperimental(ExperimentalAPI::class)\n@EAnno val property = \"\"\n\n@UseExperimental(ExperimentalAPI::class)\n@EAnno typealias Typealias = Unit\n\n@UseExperimental(ExperimentalAPI::class)\n@EAnno class Klass\n\n@UseExperimental(ExperimentalAPI::class)\nannotation class AnnotationArgument(val p: EAnno)\n\nfun insideBody() {\n    @UseExperimental(ExperimentalAPI::class) @EAnno fun local() {}\n}\n\nfun inDefaultArgument(@UseExperimental(ExperimentalAPI::class) f: () -> Unit = @EAnno fun() {}) {}\n\n@UseExperimental(ExperimentalAPI::class)\nval inProperty = @EAnno fun() {}\n\nval inPropertyAccessor: () -> Unit\n    @UseExperimental(ExperimentalAPI::class)\n    get() = @EAnno fun() {}\n\n// FILE: usage-none.kt\n\npackage usage3\n\nimport api.*\n\n@<!EXPERIMENTAL_API_USAGE!>EAnno<!> fun function() {}\n\nfun parameter(@<!EXPERIMENTAL_API_USAGE!>EAnno<!> p: String) {}\n\nfun parameterType(p: @<!EXPERIMENTAL_API_USAGE!>EAnno<!> String) {}\n\nfun returnType(): @<!EXPERIMENTAL_API_USAGE!>EAnno<!> Unit {}\n\n@<!EXPERIMENTAL_API_USAGE!>EAnno<!> val property = \"\"\n\n@<!EXPERIMENTAL_API_USAGE!>EAnno<!> typealias Typealias = Unit\n\n@<!EXPERIMENTAL_API_USAGE!>EAnno<!> class Klass\n\nannotation class AnnotationArgument(val p: <!EXPERIMENTAL_API_USAGE!>EAnno<!>)\n\nfun insideBody() {\n    @<!EXPERIMENTAL_API_USAGE!>EAnno<!> fun local() {}\n}\n\nfun inDefaultArgument(f: () -> Unit = @<!EXPERIMENTAL_API_USAGE!>EAnno<!> fun() {}) {}\n\nval inProperty = @<!EXPERIMENTAL_API_USAGE!>EAnno<!> fun() {}\n\nval inPropertyAccessor: () -> Unit\n    get() = @<!EXPERIMENTAL_API_USAGE!>EAnno<!> fun() {}\n"
        },
        {
            "code": "// FILE: a.kt\npackage p\n\nclass FilteringSequence\n\n// FILE: b.kt\n// SKIP_TXT\npackage kotlin.sequences\n\nimport p.*\n\ninterface I {\n    val v1: FilteringSequence\n    val <!EXPOSED_PROPERTY_TYPE!>v2<!>: <!INVISIBLE_REFERENCE!>IndexingSequence<!><String>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n\nimport kotlin.contracts.*\n\nfun test(x: Any?) {\n    if (isString(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER -NOTHING_TO_INLINE -ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS -ABSTRACT_FUNCTION_WITH_BODY -UNUSED_PARAMETER -UNUSED_VARIABLE -EXPERIMENTAL_FEATURE_WARNING\n\nimport kotlin.contracts.*\n\nfun ifInContract(x: Any?, boolean: Boolean) {\n    contract {\n        <!ERROR_IN_CONTRACT_DESCRIPTION(\"unexpected construction in contract description\")!>if (boolean) {\n            returns() implies (x is String)\n        } else {\n            returns() implies (x is Int)\n        }<!>\n    }\n}\n\nfun whenInContract(x: Any?, boolean: Boolean) {\n    contract {\n        <!ERROR_IN_CONTRACT_DESCRIPTION(\"unexpected construction in contract description\")!>when (boolean) {\n            true -> returns() implies (x is String)\n            else -> returns() implies (x is Int)\n        }<!>\n    }\n}\n\nfun forInContract(x: Any?) {\n    contract {\n        <!ERROR_IN_CONTRACT_DESCRIPTION(\"unexpected construction in contract description\")!>for (i in 0..1) {\n            returns() implies (x is String)\n        }<!>\n    }\n}\n\nfun whileInContract(x: Any?) {\n    contract {\n        <!ERROR_IN_CONTRACT_DESCRIPTION(\"unexpected construction in contract description\")!>while (false) {\n            returns() implies (x is String)\n        }<!>\n    }\n}\n\nfun doWhileInContract(x: Any?) {\n    contract {\n        <!ERROR_IN_CONTRACT_DESCRIPTION(\"unexpected construction in contract description\")!>do {\n            returns() implies (x is String)\n        } while (false)<!>\n    }\n}\n\nfun localValInContract(x: Any?) {\n    contract {\n        <!ERROR_IN_CONTRACT_DESCRIPTION(\"unexpected construction in contract description\")!>val y: Int = 42<!>\n        returns() implies (x is String)\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <reified T> referToReifiedGeneric(x: Any?) {\n    contract {\n        returns() implies (x is <!ERROR_IN_CONTRACT_DESCRIPTION(\"references to type parameters are forbidden in contracts\")!>T<!>)\n    }\n}\n\nclass Generic<T> {\n    fun referToCaptured(x: Any?) {\n        <!CONTRACT_NOT_ALLOWED(\"Contracts are allowed only for top-level functions\")!>contract<!> {\n            returns() implies (x is <!CANNOT_CHECK_FOR_ERASED!>T<!>)\n        }\n    }\n}\n\nfun referToSubstituted(x: Any?) {\n    <!ERROR_IN_CONTRACT_DESCRIPTION(\"Error in contract description\")!>contract<!> {\n        returns() implies (x is <!CANNOT_CHECK_FOR_ERASED!>Generic<String><!>)\n    }\n}\n\nfun referToSubstitutedWithStar(x: Any?) {\n    contract {\n        returns() implies (x is Generic<*>)\n    }\n}\n\ntypealias GenericString = Generic<String>\ntypealias FunctionalType = () -> Unit\ntypealias SimpleType = Int\n\nfun referToAliasedGeneric(x: Any?) {\n    <!ERROR_IN_CONTRACT_DESCRIPTION(\"Error in contract description\")!>contract<!> {\n        returns() implies (x is <!CANNOT_CHECK_FOR_ERASED!>GenericString<!>)\n    }\n}\n\nfun referToAliasedFunctionType(x: Any?) {\n    <!ERROR_IN_CONTRACT_DESCRIPTION(\"Error in contract description\")!>contract<!> {\n        returns() implies (x is <!CANNOT_CHECK_FOR_ERASED!>FunctionalType<!>)\n    }\n}\n\nfun referToAliasedSimpleType(x: Any?) {\n    contract {\n        returns() implies (x is SimpleType)\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun equalsWithVariables(x: Any?, y: Any?) {\n    contract {\n        returns() implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"only equality comparisons with 'null' allowed\")!>x == y<!>)\n    }\n}\n\nfun identityEqualsWithVariables(x: Any?, y: Any?) {\n    contract {\n        returns() implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"only equality comparisons with 'null' allowed\")!>x === y<!>)\n    }\n}\n\nfun equalConstants() {\n    contract {\n        returns() implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"only equality comparisons with 'null' allowed\"), SENSELESS_COMPARISON!>null == null<!>)\n    }\n}\n\nfun get(): Int? = null\nfun equalNullWithCall() {\n    contract {\n        returns() implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"only references to parameters are allowed in contract description\")!>get()<!> == null)\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER -UNUSED_VARIABLE -REDUNDANT_LABEL_WARNING -UNUSED_PARAMETER -NOTHING_TO_INLINE -CAST_NEVER_SUCCEEDS\n// Issues: KT-26153, KT-26191\n\nimport kotlin.contracts.*\n\nfun foo(y: Boolean) {\n    val x: Int = 42\n    <!CONTRACT_NOT_ALLOWED(\"Contract should be the first statement\")!>contract<!> {\n        returns() implies y\n    }\n}\n\ninline fun case1(block: () -> Unit) {\n    val contracts = listOf(\n        <!CONTRACT_NOT_ALLOWED!>contract<!> {\n            callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n        }, <!CONTRACT_NOT_ALLOWED!>contract<!> {\n            callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n        }\n    )\n    block()\n}\n\ninline fun case_2(block: () -> Unit) = <!CONTRACT_NOT_ALLOWED(\"Contracts are allowed only in function body block\")!>contract<!> {\n    callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n}\n\nfun case_3(block: () -> Unit) {\n    class Class {\n        fun innerFun(block2: () -> Unit) {\n            <!CONTRACT_NOT_ALLOWED(\"Contracts are allowed only for top-level functions\")!>contract<!> {\n                callsInPlace(block2, InvocationKind.EXACTLY_ONCE)\n            }\n            block2()\n        }\n    }\n    return\n}\n\ninline fun case_4(number: Int?): Boolean {\n    val cond = number != null\n    <!CONTRACT_NOT_ALLOWED!>contract<!> {\n        returns(false) implies (cond)\n    } as ContractBuilder\n    return number == null\n}\n\ninline fun case_5(cond: Boolean): Boolean {\n    run {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> {\n            returns(true) implies (cond)\n        }\n    }\n    return true\n}\n\ninline fun case_6(cond: Boolean): Boolean {\n    run {\n        val x = 10\n        <!CONTRACT_NOT_ALLOWED, CONTRACT_NOT_ALLOWED!>contract<!> {\n            returns(true) implies (cond)\n        }\n    }\n    return true\n}\n\nfun case_7(cond: Boolean): Boolean {\n    fun innerFun() {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> {\n            returns(true) implies (cond)\n        }\n    }\n    return true\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER -EXPOSED_PARAMETER_TYPE\n\nimport kotlin.contracts.*\n\nfun passLambdaValue(l: ContractBuilder.() -> Unit) {\n    contract(<!ERROR_IN_CONTRACT_DESCRIPTION(\"first argument of 'contract'-call should be a lambda expression\")!>l<!>)\n}\n\nfun passAnonymousFunction(x: Boolean) {\n    contract(<!ERROR_IN_CONTRACT_DESCRIPTION(\"first argument of 'contract'-call should be a lambda expression\")!>fun ContractBuilder.() {\n        returns() implies x\n    }<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun foo(boolean: Boolean) {\n    <!ERROR_IN_CONTRACT_DESCRIPTION(\"Error in contract description\")!>contract<!> {\n        (returns() implies (boolean)) <!UNRESOLVED_REFERENCE!>implies<!> (!boolean)\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER -NOTHING_TO_INLINE -ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS -ABSTRACT_FUNCTION_WITH_BODY -UNUSED_PARAMETER -UNUSED_VARIABLE -EXPERIMENTAL_FEATURE_WARNING\n\nimport kotlin.contracts.*\n\n\n// ============= Class =====================\nopen class Class {\n    fun member(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n    \n    inline fun inlineMember(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n    \n    abstract fun abstractMember(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED, CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n    \n    open fun openMemeber(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED, CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n    \n    suspend fun suspendMember(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n}\n\n\n// ============= Top-level =====================\nfun topLevel(x: Boolean) {\n    contract { returns() implies (x) }\n}\n\ninline fun inlineTopLevel(x: Boolean) {\n    contract { returns() implies (x) }\n}\n\nsuspend fun suspendTopLevel(x: Boolean) {\n    contract { returns() implies (x) }\n}\n\n// Top-level operator\noperator fun Boolean.plus(x: Boolean): Boolean {\n    <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    return x\n}\n\nval topLevelLambda: (Boolean) -> Unit = { x: Boolean ->\n    <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n}\n\nval topLevelAnonymousFunction = fun (x: Boolean) {\n    <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n}\n\nvar topLevelPropertyAccessors: Int? = 42\n    get() {\n        <!CONTRACT_NOT_ALLOWED, CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (field != null) }\n        return 42\n    }\n    set(value) {\n        <!CONTRACT_NOT_ALLOWED, CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (field != null) }\n    }\n\n\n// ============= Local =====================\nfun test() {\n    fun localDeclaration(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n\n    suspend fun suspendlocalDeclaration(x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n\n    val localAnonymousFunction = fun (x: Boolean) {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n\n    val localLambda: (Boolean) -> Unit = { x: Boolean ->\n        <!CONTRACT_NOT_ALLOWED!>contract<!> { returns() implies (x) }\n    }\n}"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !LANGUAGE: +UseReturnsEffect\n// Issue: KT-26386\n\nimport kotlin.contracts.*\n\nfun case_1(): Boolean {\n    contract { returns(null) implies <!ERROR_IN_CONTRACT_DESCRIPTION!>case_1()<!> }\n    return true\n}\n\nfun case_2(): Boolean {\n    contract { returns(null) implies <!ERROR_IN_CONTRACT_DESCRIPTION!>case_3()<!> }\n    return true\n}\n\nfun case_3(): Boolean {\n    contract { returns(null) implies <!ERROR_IN_CONTRACT_DESCRIPTION!>case_2()<!> }\n    return true\n}\n\nfun case_4(): Boolean {\n    kotlin.contracts.contract { returns(null) implies <!ERROR_IN_CONTRACT_DESCRIPTION!>case_1()<!> }\n    return true\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun emptyContract() {\n    <!ERROR_IN_CONTRACT_DESCRIPTION(\"Error in contract description\")!>contract<!> { }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun foo(b: Boolean): Boolean {\n    contract {\n        // pointless, can be reduced to just \"b\"\n        returns(true) implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"only equality comparisons with 'null' allowed\")!>b == true<!>)\n    }\n\n    return b\n}\n\nfun bar(b: Boolean?): Boolean {\n    contract {\n        // not pointless, but not supported yet\n        returns(true) implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"only equality comparisons with 'null' allowed\")!>b == true<!>)\n    }\n    if (b == null) throw java.lang.IllegalArgumentException(\"\")\n    return <!DEBUG_INFO_SMARTCAST!>b<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun bar(x: Int): Boolean = x == 0\n\nfun foo(x: Int): Boolean {\n    contract {\n        returns(true) implies (<!ERROR_IN_CONTRACT_DESCRIPTION(\"call-expressions are not supported yet\")!>bar(x)<!>)\n    }\n    return x == 0\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun Any?.foo(): Boolean {\n    contract {\n        returns(true) implies (<!SENSELESS_COMPARISON!><!ERROR_IN_CONTRACT_DESCRIPTION(\"only references to parameters are allowed. Did you miss label on <this>?\")!>this<!> != null<!>)\n    }\n    return this != null\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nclass Foo(val x: Int?) {\n    fun isXNull(): Boolean {\n        <!CONTRACT_NOT_ALLOWED!>contract<!> {\n            returns(false) implies (x != null)\n        }\n        return x != null\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +ReadDeserializedContracts +UseReturnsEffect\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nfun testIsNullOrBlank(x: String?) {\n    if (x.isNullOrBlank()) {\n        x<!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun testIsNotNullOrBlank(x: String?) {\n    if (!x.isNullOrBlank()) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n\n    x<!UNSAFE_CALL!>.<!>length\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +ReadDeserializedContracts +UseReturnsEffect\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nfun testRequireSmartcast(x: Any?) {\n    require(x is String)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun testRequireUnreachableCode() {\n    require(false)\n    println(\"Can't get here!\")\n}\n\nfun testRequireWithMessage(x: Any?) {\n    require(x is String) { \"x is not String!\" }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun testRequireWithFailingMessage(x: Any?) {\n    require(x is String) { throw kotlin.IllegalStateException(\"What a strange idea\") }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun tesRequireNotNullWithMessage(x: Int?) {\n    requireNotNull(x) { \"x is null!\"}\n    <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +ReadDeserializedContracts +UseCallsInPlaceEffect\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nfun testRunWithUnitReturn() {\n    val x: Int\n    run { x  = 42 }\n    println(x)\n}\n\nfun testRunWithReturnValue() {\n    val x: Int\n    val y = run {\n        x = 42\n        \"hello\"\n    }\n    println(x)\n    println(y)\n}\n\nfun testRunWithCoercionToUnit() {\n    val <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>x<!>: Int\n    run {\n        x = 42\n        \"hello\"\n    }\n}\n\nfun testRunWithReceiver(x: Int) {\n    val s: String\n    x.run {\n        s = this.toString()\n    }\n    println(s)\n}\n\nfun testWith(x: Int) {\n    val s: String\n    with(x) {\n        s = toString()\n    }\n    println(s)\n}\n\nfun testApply(x: Int) {\n    val y: Int\n    val z: Int = x.apply { y = 42 }\n    println(y)\n    println(z)\n}\n\nfun testAlso(x: Int) {\n    val y: Int\n    x.also { y = it + 1 }\n    println(y)\n}\n\nfun testLet(x: Int) {\n    val z: Int\n    val y: String = x.let {\n        z = 42\n        (it + 1).toString()\n    }\n    println(z)\n    println(y)\n}\n\nfun testTakeIf(x: Int?) {\n    val y: Int\n    x.takeIf {\n        y = 42\n        it != null\n    }\n    println(y)\n}\n\nfun testTakeUnless(x: Int?) {\n    val y: Int\n    x.takeIf {\n        y = 42\n        it != null\n    }\n    println(y)\n}\n\nfun testRepeatOnVal(x: Int) {\n    val y: Int\n    repeat(x) {\n        // reassignment instead of captured val initialization\n        <!VAL_REASSIGNMENT!>y<!> = 42\n    }\n    println(<!UNINITIALIZED_VARIABLE!>y<!>)\n}\n\nfun testRepeatOnVar(x: Int) {\n    var y: Int\n    repeat(x) {\n        // no reassignment reported\n        y = 42\n    }\n    // but here we still unsure if 'y' was initialized\n    println(<!UNINITIALIZED_VARIABLE!>y<!>)\n}\n\nfun testRepeatOnInitializedVar(x: Int) {\n    var y: Int = 24\n    repeat(x) {\n        y = 42\n    }\n    println(y)\n}"
        },
        {
            "code": "// !LANGUAGE: +ReadDeserializedContracts +UseReturnsEffect\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nfun testCheckSmartcast(x: Any?) {\n    check(x is String)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun testCheckUnreachableCode() {\n    check(false)\n    // Can't be reported without notion of 'iff'\n    println(\"Can't get here!\")\n}\n\nfun testCheckWithMessage(x: Any?) {\n    check(x is String) { \"x is not String!\" }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun testCheckWithFailingMessage(x: Any?) {\n    check(x is String) { throw kotlin.IllegalStateException(\"What a strange idea\") }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun testCheckNotNullWithMessage(x: Int?) {\n    checkNotNull(x) { \"x is null!\" }\n    <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n}\n\nfun testCheckNotNull(x: Int?) {\n    checkNotNull(x)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +ReadDeserializedContracts +UseReturnsEffect\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nfun testIsNullOrEmpty(x: String?) {\n    if (x.isNullOrEmpty()) {\n        x<!UNSAFE_CALL!>.<!>length\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun testIsNotNullOrEmpty(x: String?) {\n    if (!x.isNullOrEmpty()) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n\n    x<!UNSAFE_CALL!>.<!>length\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n//\n// ISSUE: KT-28672\n\nimport kotlin.contracts.*\n\nfun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || <!DEBUG_INFO_SMARTCAST!>this<!>.length == 0\n}\n\nfun smartcastOnReceiver(s: String?) {\n    with(s) {\n        if (isNullOrEmpty()) {\n            <!UNSAFE_CALL!>length<!>\n        }\n        else {\n            <!UNSAFE_CALL!>length<!>\n        }\n    }\n}\n\nfun mixedReceiver(s: String?) {\n    if (!s.isNullOrEmpty()) {\n        with(<!DEBUG_INFO_SMARTCAST!>s<!>) {\n            length\n        }\n    } else {\n        with(s) {\n            <!UNSAFE_CALL!>length<!>\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect +ContractsOnCallsWithImplicitReceiver\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n//\n// ISSUE: KT-28672\n\nimport kotlin.contracts.*\n\nfun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || <!DEBUG_INFO_SMARTCAST!>this<!>.length == 0\n}\n\nfun smartcastOnReceiver(s: String?) {\n    with(s) {\n        if (isNullOrEmpty()) {\n            <!UNSAFE_CALL!>length<!>\n        }\n        else {\n            <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>length<!>\n        }\n    }\n}\n\nfun mixedReceiver(s: String?) {\n    if (!s.isNullOrEmpty()) {\n        with(<!DEBUG_INFO_SMARTCAST!>s<!>) {\n            length\n        }\n    } else {\n        with(s) {\n            <!UNSAFE_CALL!>length<!>\n        }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun notIsString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun notIsInt(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is Int)\n    }\n    return x !is Int\n}\n\nfun testDeMorgan(x: Any?) {\n       // !(x !is String || x !is Int)\n       // x is String && x is Int\n    if (!(notIsString(x) || notIsInt(x))) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}\n\nfun testDeMorgan2(x: Any?) {\n        // x !is String || x !is Int\n    if (notIsString(x) || notIsInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun myAssert(condition: Boolean) {\n    contract {\n        returns() implies (condition)\n    }\n    if (!condition) throw kotlin.IllegalArgumentException(\"Assertion failed\")\n}\n\nfun testWithCatch(x: Any?) {\n    try {\n        myAssert(x is String)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    } catch (e: java.lang.IllegalArgumentException) { }\n\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun onlyTrue(b: Boolean): Boolean {\n    contract {\n        returns(true) implies (b)\n    }\n    return b\n}\n\nfun onlyFalse(b: Boolean): Boolean {\n    contract {\n        returns(false) implies (!b)\n    }\n    return b\n}\n\nfun trueAndFalse(b: Boolean): Boolean {\n    contract {\n        returns(true) implies (b)\n        returns(false) implies (!b)\n    }\n    return b\n}\n\n\n\n// ==== actual tests ====\n\nfun useOnlyTrueInTrueBranch(x: Any?) {\n    if (onlyTrue(x is String)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun useOnlyTrueInFalseBranch(x: Any?) {\n    if (onlyTrue(x !is String)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        // No smartcast here, we don't know that condition is false here\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun useOnlyFalseInTrueBranch(x: Any?) {\n    if (onlyFalse(x is String)) {\n        // No smartcast here, we don't know that condition is true here\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun useOnlyFalseInFalseBranch(x: Any?) {\n    if (onlyFalse(x !is String)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun useTrueAndFalseInTrueBranch(x: Any?) {\n    if (trueAndFalse(x is String)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun useTrueAndFalseInFalseBranch(x: Any?) {\n    if (trueAndFalse(x !is String)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun callsAndInverts(b: Boolean, block: () -> Unit): Boolean {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n        returns(true) implies (!b)\n        returns(false) implies b\n    }\n\n    block()\n    return !b\n}\n\n\n\nfun smartcastAndInitialization(x: Any?) {\n    val y: Int\n\n    if (callsAndInverts(x !is String) { y = 42 }) {\n        println(y)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    } else {\n        println(y)\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    println(y)\n}\n\nfun inPresenceOfLazy(x: Any?, unknownBoolean: Boolean) {\n    val y: Int\n\n    if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) {\n        println(<!UNINITIALIZED_VARIABLE!>y<!>)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        println(y)\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    println(y)\n}\n\nfun isPresenceOfLazy2(x: Any?, unknownBoolean: Boolean) {\n    val y: Int\n    if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        println(<!UNINITIALIZED_VARIABLE!>y<!>)\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    println(y)\n}\n\nfun isPresenceOfLazy3(x: Any?, unknownBoolean: Boolean) {\n    val y: Int\n    if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    println(<!UNINITIALIZED_VARIABLE!>y<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\n\nfun notIsString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun notIsInt(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x !is Int)\n    }\n    return x !is Int\n}\n\nfun intersectingInfo(x: Any?, y: Any?) {\n    if ((isString(x) && y is String) || (!notIsString(x) && !notIsInt(y))) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        y.<!UNRESOLVED_REFERENCE!>length<!>\n        y.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        y.<!UNRESOLVED_REFERENCE!>length<!>\n        y.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}\n\nfun intersectingInfo2(x: Any?, y: Any?) {\n    // In each arg of \"||\"-operator presented fact \"x is String\" which should lead to smartcast.\n    // Also there are 3 additional facts: \"x is Int\", \"y is String\", \"y is Int\". One\n    // of them is absent in each arg of \"||\"-operator, so they *shouldn't* lead to smartcast\n\n    if ((isString(x) && !notIsInt(x) && y is String) ||\n        (!notIsString(x) && isString(y) && y is Int) ||\n        (x is String && !notIsInt(y) && x is Int)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n        y.<!UNRESOLVED_REFERENCE!>length<!>\n        y.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n    x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    y.<!UNRESOLVED_REFERENCE!>length<!>\n    y.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun myAssert(condition: Boolean) {\n    contract {\n        returns() implies (condition)\n    }\n    if (!condition) throw kotlin.IllegalArgumentException(\"Assertion failed\")\n}\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun isInt(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is Int)\n    }\n    return x is Int\n}\n\nfun notEqualsNull(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x != null)\n    }\n    return x != null\n}\n\nfun equalsTrue(x: Boolean): Boolean {\n    contract {\n        returns(true) implies x\n    }\n    return x == true\n}\n\nfun nullWhenNotString(x: Any?): String? {\n    contract {\n        returnsNotNull() implies (x is String)\n    }\n    return x as? String\n}\n\n\n\n\n// ========== Actual tests ============\n\nfun nested1(x: Any?) {\n    if (equalsTrue(isString(x))) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun nested2(x: Any?) {\n    myAssert(equalsTrue(isString(x)))\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun nested3(x: Any?) {\n    myAssert(equalsTrue(notEqualsNull(nullWhenNotString(x))))\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun branchedAndNested(x: Any?, y: Any?) {\n    myAssert(equalsTrue(notEqualsNull(nullWhenNotString(x))) && equalsTrue(isString(y)))\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    <!DEBUG_INFO_SMARTCAST!>y<!>.length\n}\n\n\nfun br(y: Any?) {\n    if (myAssert(y is Int) == Unit && myAssert(y is String) == Unit) {\n        <!DEBUG_INFO_SMARTCAST!>y<!>.length\n        <!DEBUG_INFO_SMARTCAST!>y<!>.inc()\n    }\n}\n\nfun branchedAndNestedWithNativeOperators(x: Any?, y: Any?) {\n    myAssert(\n            equalsTrue(notEqualsNull(nullWhenNotString(x)))   // x is String\n            &&\n            (\n                    (myAssert(y is Int) == Unit && myAssert(y is String) == Unit)  // y is Int, String\n                    ||\n                    equalsTrue(isInt(y) && isString(y))                          // y is Int, String\n            )\n            &&\n            (1 == 2 || y is Int || isString(y))\n    )\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    y.<!UNRESOLVED_REFERENCE!>length<!>\n    y.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun myAssert(condition: Boolean, message: String = \"\") {\n    contract {\n        returns() implies (condition)\n    }\n    if (!condition) throw kotlin.IllegalArgumentException(message)\n}\n\nfun test(x: Any?) {\n    myAssert(x is String)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n\nimport kotlin.contracts.*\n\nfun Any.nullWhenString(): Any? {\n    contract {\n        returns(null) implies (this@nullWhenString is String)\n    }\n    return if (this is String) null else this\n}\n\nfun test(x: Int?) {\n    if (x?.nullWhenString() == null) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun testEqualsWithConstant(x: Any?) {\n    if (isString(x) == true) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun testNotEqualsWithConstant(x: Any?) {\n    if (isString(x) != true) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun unknownFunction(): Any? = 42\n\nfun testEqualsWithUnknown(x: Any?) {\n    if (isString(x) == unknownFunction()) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testNotEqualsWithUnknown(x: Any?) {\n    if (isString(x) != unknownFunction()) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testEqualsWithVariable(x: Any?, b: Boolean) {\n    if (isString(x) == b) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun testNotEqualsWithVariable(x: Any?, b: Boolean) {\n    if (isString(x) != b) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun Any?.isNull(): Boolean {\n    contract {\n        returns(false) implies (this@isNull != null)\n    }\n    return this == null\n}\n\nfun smartcastOnReceiver(x: Int?) {\n    if (x.isNull()) {\n        x<!UNSAFE_CALL!>.<!>inc()\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.dec()\n    }\n}\n\nclass UnstableReceiver {\n    var x: Int? = 42\n\n    fun smartcastOnUnstableReceiver() {\n        if (x.isNull()) {\n            x<!UNSAFE_CALL!>.<!>inc()\n        }\n        else {\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.dec()\n        }\n    }\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun myAssert(condition: Boolean) {\n    contract {\n        returns() implies (condition)\n    }\n    if (!condition) throw kotlin.IllegalArgumentException(\"Assertion failed\")\n}\n\nfun testAssertSmartcast(x: Any?) {\n    myAssert(x is String)\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\nfun testInvertedAssert(x: Any?) {\n    myAssert(x !is String)\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testSpilling(x: Any?) {\n    if (x != null) {\n        myAssert(x is String)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testAssertInIf(x: Any?) {\n    if (myAssert(x is String) == Unit) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun testTryCatch(x: Any?) {\n    try {\n        myAssert(x is String)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    } catch (e: kotlin.IllegalArgumentException) {\n\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testUncertainFlow(x: Any?) {\n    repeat(x.toString().length) {\n        myAssert(x is String)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testAtLeastOnceFlow(x: Any?) {\n    do {\n        myAssert(x is String)\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    } while (x != null)\n\n    <!DEBUG_INFO_SMARTCAST!>x<!>.<!UNREACHABLE_CODE!>length<!>\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun safeIsString(x: Any?): Boolean? {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x?.let { it is String }\n}\n\nfun elseWithNullableResult(x: Any?) {\n    when (safeIsString(x)) {\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        else -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when (safeIsString(x)) {\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        else -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when (safeIsString(x)) {\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        else -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when (safeIsString(x)) {\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        null -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        else -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun exhaustiveWithNullableResult(x: Any?) {\n    when (safeIsString(x)) {\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        null -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when (safeIsString(x)) {\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        null -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when (safeIsString(x)) {\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        null -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun exhaustive(x: Any?) {\n    when {\n        isString(x) -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        !isString(x) -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when {\n        !isString(x) -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        isString(x) -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun smartcastInElse(x: Any?) {\n    when {\n        !isString(x) -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        else -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun exhaustive(x: Any?) {\n    when (isString(x)) {\n        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n\n    when(!isString(x)) {\n        true -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        false -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun smartcastInElse(x: Any?) {\n    when (isString(x)) {\n        false -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        else -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n\n    when (!isString(x)) {\n        true -> x.<!UNRESOLVED_REFERENCE!>length<!>\n        else -> <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun f3(value: String?) {\n    if (<!USELESS_IS_CHECK!>!value.isNullOrEmpty() is Boolean<!>) {\n        value<!UNSAFE_CALL!>.<!>length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\n\nfun nullWhenString(x: Any?): Int? {\n    contract {\n        returns(null) implies (x is String)\n    }\n    return if (x is String) null else 42\n}\n\nfun nullWhenNotString(x: Any?): Int? {\n    contract {\n        returns(null) implies (x !is String)\n    }\n    return if (x !is String) null else 42\n}\n\n\n\n\n\n// ==== Actual tests =====\n\n\nfun test1(x: Any?) {\n    // condition == true <=> function returned null <=> 'x' is String\n    if (nullWhenString(x) == null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun test2(x: Any?) {\n    // Observe that condition == false <=>* function returned null <=> 'x' is String\n    // *correct only for at most binary types, which is exactly the case for nullability comparisons\n    if (nullWhenString(x) != null) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\n\nfun test3(x: Any?) {\n    // condition == false <=> function returned not-null, but we don't know anything about when function returns not-null\n    if (nullWhenNotString(x) == null) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\n// ===== Definitions ====\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\n\n// ==== Actual tests =======\n\nfun implicitAlwaysFalse(x: Any?) {\n    if (isString(x) && !isString(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun implicitAlwaysFalseSpilling(x: Any?) {\n    if (isString(x) && !isString(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun nullWhenNull(x: Int?): Int? {\n    contract {\n        returnsNotNull() implies (x != null)\n    }\n    return x?.inc()\n}\n\nfun testNullWhenNull(x: Int?) {\n    if (nullWhenNull(x) == null) {\n        x<!UNSAFE_CALL!>.<!>dec()\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.dec()\n    }\n\n    if (nullWhenNull(x) != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.dec()\n    }\n    else {\n        x<!UNSAFE_CALL!>.<!>dec()\n    }\n\n    x<!UNSAFE_CALL!>.<!>dec()\n}\n\n// NB. it is the same function as `nullWhenNull`, but annotations specifies other facet of the function behaviour\nfun notNullWhenNotNull (x: Int?): Int? {\n    contract {\n        returns(null) implies (x == null)\n    }\n    return x?.inc()\n}\n\nfun testNotNullWhenNotNull (x: Int?) {\n    if (notNullWhenNotNull(x) == null) {\n        <!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>x<!> == null<!>\n    }\n    else {\n        x<!UNSAFE_CALL!>.<!>dec()\n    }\n\n    if (notNullWhenNotNull(x) != null) {\n        x<!UNSAFE_CALL!>.<!>dec()\n    }\n    else {\n        <!SENSELESS_COMPARISON!><!DEBUG_INFO_CONSTANT!>x<!> == null<!>\n    }\n\n    x<!UNSAFE_CALL!>.<!>dec()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun trueWhenString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun trueWhenInt(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is Int)\n    }\n    return x is Int\n}\n\nfun falseWhenString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun falseWhenInt(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is Int)\n    }\n    return x !is Int\n}\n\n\n// ==== Actual tests ====\n\nfun truetrue(x: Any?) {\n    if (trueWhenString(x) && trueWhenInt(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n    x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n}\n\nfun truefalse(x: Any?) {\n    if (trueWhenString(x) && falseWhenInt(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}\n\nfun falsetrue(x: Any?) {\n    if (falseWhenString(x) && trueWhenInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}\n\nfun falsefalse(x: Any?) {\n    if (falseWhenString(x) && falseWhenInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        // Note that we can't argue that we have any of smartcasts here,\n        // because we don't know which one of both arguments was 'false' to bring us here\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun trueWhenString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun trueWhenInt(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is Int)\n    }\n    return x is Int\n}\n\nfun falseWhenString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun falseWhenInt(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is Int)\n    }\n    return x !is Int\n}\n\nfun truetrue(x: Any?) {\n    if (trueWhenString(x) || trueWhenInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}\n\nfun truefalse(x: Any?) {\n    if (trueWhenString(x) || falseWhenInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n}\n\nfun falsetrue(x: Any?) {\n    if (falseWhenString(x) || trueWhenInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n}\n\nfun falsefalse(x: Any?) {\n    if (falseWhenString(x) || falseWhenInt(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n        x.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>inc<!>()\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun safeIsString(x: Any?): Boolean? {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x?.let { it is String }\n}\n\n\n\n\nfun equalsTrue(x: Any?) {\n    if (safeIsString(x) == true) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun equalsFalse(x: Any?) {\n    if (safeIsString(x) == false) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun equalsNull(x: Any?) {\n    if (safeIsString(x) == null) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun notEqualsTrue(x: Any?) {\n    if (safeIsString(x) != true) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun notEqualsFalse(x: Any?) {\n    if (safeIsString(x) != false) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun notEqualsNull(x: Any?) {\n    if (safeIsString(x) != null) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n// !WITH_NEW_INFERENCE\n\nimport kotlin.contracts.*\n\nfun myEqualsNull(x: Int?): Boolean {\n    contract {\n        returns(false) implies (x != null)\n    }\n    return x == null\n}\n\nfun myEqualsNotNull(x: Int?): Boolean {\n    contract {\n        returns(true) implies (x != null)\n    }\n    return x != null\n}\n\nfun testBasicEquals(x: Int?) {\n    x<!UNSAFE_CALL!>.<!>inc()\n\n    if (myEqualsNull(x)) {\n        x<!UNSAFE_CALL!>.<!>inc()\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n\n    x<!UNSAFE_CALL!>.<!>inc()\n}\n\nfun testBasicNotEquals(x: Int?) {\n    x<!UNSAFE_CALL!>.<!>inc()\n\n    if (myEqualsNotNull(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n    }\n    else {\n        x<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    x<!UNSAFE_CALL!>.<!>inc()\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun trueWhenString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun falseWhenString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun unknownFunction(x: Any?) = x == 42\n\n\n\n\nfun annotatedTrue(x: Any?) {\n    if (trueWhenString(x) && unknownFunction(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedFalse(x: Any?) {\n    if (falseWhenString(x) && unknownFunction(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedTrueWithVariable(x: Any?, b: Boolean) {\n    if (trueWhenString(x) && b) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedFalseWithVariable(x: Any?, b: Boolean) {\n    if (falseWhenString(x) && b) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\n\nfun notIsString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\n\n\n\nfun testSimple(x: Any?) {\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n\n    if (isString(x)) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun testSpilling(x: Any?) {\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n\n    if (isString(x)) <!DEBUG_INFO_SMARTCAST!>x<!>.length\n\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\nfun testInversion(x: Any?) {\n    if (notIsString(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun testInversionSpilling(x: Any?) {\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n\n    if (notIsString(x)) else <!DEBUG_INFO_SMARTCAST!>x<!>.length\n\n    x.<!UNRESOLVED_REFERENCE!>length<!>\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun trueWhenString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun falseWhenString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\n\n\n\nfun annotatedTrueAndTrue(x: Any?) {\n    if (trueWhenString(x) && true) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedTrueAndFalse(x: Any?) {\n    if (trueWhenString(x) && false) {\n        // Unreachable\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedFalseAndTrue(x: Any?) {\n    if (falseWhenString(x) && true) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun annotatedFalseAndFalse(x: Any?) {\n    if (falseWhenString(x) && false) {\n        // Unreachable\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun trueWhenString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun falseWhenString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun unknownFunction(x: Any?) = x == 42\n\n\n\n\nfun annotatedTrue(x: Any?) {\n    if (trueWhenString(x) || unknownFunction(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedFalse(x: Any?) {\n    if (falseWhenString(x) || unknownFunction(x)) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun annotatedTrueWithVariable(x: Any?, b: Boolean) {\n    if (trueWhenString(x) || b) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedFalseWithVariable(x: Any?, b: Boolean) {\n    if (falseWhenString(x) || b) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun trueWhenString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun falseWhenString(x: Any?): Boolean {\n    contract {\n        returns(false) implies (x is String)\n    }\n    return x !is String\n}\n\nfun annotatedTrueOrTrue(x: Any?) {\n    if (trueWhenString(x) || true) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        // Unreachable\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedTrueOrFalse(x: Any?) {\n    if (trueWhenString(x) || false) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun annotatedFalseOrTrue(x: Any?) {\n    if (falseWhenString(x) || true) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        // Unreachable\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n\nfun annotatedFalseOrFalse(x: Any?) {\n    if (falseWhenString(x) || false) {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n    else {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun isString(x: Any?): Boolean {\n    contract {\n        returns(true) implies (x is String)\n    }\n    return x is String\n}\n\nfun incorrectPartDoesntMatter(x: Any?) {\n    if (isString(x) && <!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    else {\n        x.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun initialization() {\n    val x: Int\n    myRun {\n        x = 42\n        42\n    }\n    x.inc()\n}\n\nfun shadowing() {\n    val x = 42\n    myRun {\n        val <!NAME_SHADOWING!>x<!> = 43\n        x.inc()\n    }\n    x.inc()\n}\n\nfun nestedDefiniteAssignment() {\n    val x: Int\n    myRun {\n        val y = \"Hello\"\n        myRun {\n            x = 42\n        }\n        y.length\n    }\n    x.inc()\n}\n\nfun deeplyNestedDefiniteAssignment() {\n    val x: Int\n    myRun {\n        val y: String\n        myRun {\n            val z: String\n            myRun {\n                z = \"Hello\"\n                y = \"World\"\n                x = 42\n            }\n            z.length\n        }\n        y.length\n    }\n    x.inc()\n}\n\nfun branchingFlow(a: Any?) {\n    val x: Int\n\n    if (a is String) {\n        myRun { x = 42 }\n    }\n    else {\n        myRun { x = 43 }\n    }\n\n    x.inc()\n}\n\nfun returningValue() {\n    val x: Int\n    val hello = myRun { x = 42; \"hello\" }\n    x.inc()\n    hello.length\n}\n\nfun unknownRun(block: () -> Unit) = block()\n\nclass DefiniteInitializationInInitSection {\n    val x: Int\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val y: Int<!>\n\n    init {\n        myRun { x = 42 }\n        unknownRun { <!CAPTURED_MEMBER_VAL_INITIALIZATION!>y<!> = 239 }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T, R> T.myLet(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\nfun initializationWithReceiver(y: String) {\n    val x: Int\n    y.myLet { x = 42 }\n    x.inc()\n}\n\nfun initializationWithSafeCall(y: String?) {\n    val x: Int\n    y?.myLet { x = 42 }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun sanityCheck(x: Int, y: String): Int {\n    y.let { return x }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun myRepeat(n: Int, action: () -> Unit) {\n    contract {\n        callsInPlace(action)\n    }\n    for (i in 1..n) action()\n}\n\nfun branchingIndetermineFlow(a: Any?) {\n    val x: Int\n\n    if (a is String) {\n        myRepeat(<!DEBUG_INFO_SMARTCAST!>a<!>.length) {\n            // Val reassignment because we know that repeat's lambda called in-place\n            myRun { <!VAL_REASSIGNMENT!>x<!> = 42 }\n        }\n    }\n    else {\n        myRun { x = 43 }\n    }\n\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun nonAnonymousLambdas() {\n    val x: Int\n    val initializer = { <!CAPTURED_VAL_INITIALIZATION!>x<!> = 42 }\n    myRun(initializer)\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun multipleAssignments() {\n    val x: Int\n    myRepeat(42) {\n        // Val reassignment because we know that repeat's lambda called in-place\n        myRun { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun funWithUnknownInvocations(block: () -> Unit) = block()\n\nfun nestedIndefiniteAssignment() {\n    val x: Int\n    // Captured val initialization reported, because we don't know anything about funWithUnknownInvocations\n    funWithUnknownInvocations { myRun { <!CAPTURED_VAL_INITIALIZATION!>x<!> = 42 } }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nclass InitializationForbiddenInNonInitSection {\n    <!MUST_BE_INITIALIZED_OR_BE_ABSTRACT!>val x: Int<!>\n\n    fun setup() {\n        myRun { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun indefiniteVarReassignment(n: Int) {\n    var x: Int\n    repeat(n) {\n        myRun { x = 42 }\n    }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun nonAnonymousLambdas() {\n    // Named lambdas are not inlined, even in theory it could be done for some simple cases as this one\n    var x: Int\n    val initializer = { x = 42 }\n    myRun(initializer)\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun branchingIndetermineFlow(a: Any) {\n    var x: Int\n\n    if (a is String) {\n        repeat(<!DEBUG_INFO_SMARTCAST!>a<!>.length) {\n            myRun { x = 42 }\n        }\n    }\n    else {\n        myRun { x = 43 }\n    }\n\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun funWithUnknownInvocations(block: () -> Unit) = block()\n\nfun nestedIndefiniteAssignment() {\n    val x: Int\n    funWithUnknownInvocations { myRun { <!CAPTURED_VAL_INITIALIZATION!>x<!> = 42 } }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun reassignmentInUsualFlow() {\n    val x: Int\n    myRun { x = 42 }\n    <!VAL_REASSIGNMENT!>x<!> = 43\n    x.inc()\n}\n\nfun reassignment() {\n    val x = 42\n    myRun {\n        <!VAL_REASSIGNMENT!>x<!> = 43\n    }\n    x.inc()\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> runTwice(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n    return block();\n};\n\nfun testInitialization() {\n    var x: Int\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n    runTwice { x = 42 }\n    x.inc()\n    x = 43\n    x.inc()\n}\n\nfun repeatingFlow(n: Int) {\n    var x: Int\n    for (i in 1..n) {\n        runTwice { x = 42 }\n    }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> runTwice(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n    return block();\n};\n\nfun <T> funWithUnknownInvocations(block: () -> T) = block()\n\nfun indefiniteFlow() {\n    var x: Int\n\n    funWithUnknownInvocations { runTwice { x = 42 } }\n\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun shadowing() {\n    var x: Int\n    runTwice { val <!NAME_SHADOWING!>x<!>: Int; x = 42; x.inc() }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> runTwice(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    block()\n    return block();\n};\n\nfun <T> runOnce(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block();\n};\n\nfun valueReassignment() {\n    val x: Int\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n    runTwice { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    x.inc()\n}\n\nfun shadowing() {\n    val x: Int\n    runTwice { val <!NAME_SHADOWING!>x<!>: Int; x = 42; x.inc() }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun branchingFlow(a: Any?) {\n    val x: Int\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n    if (a is String) {\n        runTwice { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    }\n    else {\n        x = 43\n    }\n    x.inc()\n}\n\nfun branchingFlowWithMissingBranches(a: Any?) {\n    val x: Int\n    if (a is String) {\n        runTwice { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    }\n\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\nfun repeatingFlow(n: Int) {\n    val x: Int\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n\n    for (i in 1..n) {\n        runTwice { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    }\n\n    x.inc()\n}\n\nfun repeatingFlow2(n: Int) {\n    val x: Int\n\n    for (i in 1..n) {\n        runTwice { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    }\n\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> inPlace(block: () -> T): T {\n    contract {\n        callsInPlace(block)\n    }\n    return block()\n}\n\nfun reassignmentAndNoInitializaiton() {\n    val x: Int\n    inPlace { <!VAL_REASSIGNMENT!>x<!> = 42 }\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\ninline fun <T, R> T.myLet(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\ninline fun unknownRun(block: () -> Unit) = block()\n\nfun getBool(): Boolean = false\n\nfun threeLevelsReturnNoInitialization(x: Int?): Int? {\n    // Inner always jumps to outer\n    // And middle always calls inner\n    // So, in fact, middle never finished normally\n    // Hence 'y = 54' in middle is unreachable, and middle doesn't performs definite initialization\n    // Hence, outer doesn't performs definite initialization\n    val y: Int\n    myRun outer@ {\n        myRun middle@ {\n            x.myLet inner@ {\n                if (it == null) {\n                    y = 42\n                    return@outer Unit\n                }\n                else {\n                    return@outer Unit\n                }\n            }\n        }\n        // Possible to report unreachable here\n        <!UNREACHABLE_CODE!>y = 54<!>\n    }\n    return <!UNINITIALIZED_VARIABLE!>y<!>.inc()\n}\n\nfun threeLevelsReturnWithInitialization(x: Int?): Int? {\n    val y: Int\n    myRun outer@ {\n        myRun middle@ {\n            x.myLet inner@ {\n                if (it == null) {\n                    y = 42\n                    return@outer Unit\n                }\n                else {\n                    y = 34\n                    return@outer Unit\n                }\n            }\n        }\n    }\n    return y.inc()\n}\n\nfun threeLevelsReturnWithUnknown(x: Int?): Int? {\n    val y: Int\n    myRun outer@ {\n        unknownRun middle@ {\n            x.myLet inner@ {\n                if (it == null) {\n                    <!CAPTURED_VAL_INITIALIZATION!>y<!> = 42\n                    return@outer Unit\n                }\n                else {\n                    y = 34\n                    return@outer Unit\n                }\n            }\n        }\n    }\n    return <!UNINITIALIZED_VARIABLE!>y<!>.inc()\n}"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <T> Any?.myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun bad(): String {\n    val x: String? = null\n\n    x?.myRun { return \"\" }\n<!NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY_MIGRATION!>}<!>\n\nfun ok(): String {\n    val x: String? = null\n\n    x?.run { return \"non-null\" } ?: return \"null\"\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -INVISIBLE_MEMBER -INVISIBLE_REFERENCE\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun innerComputation(): Int = 42\nfun outerComputation(): Int = 52\n\nfun log() = Unit\n\nfun outerFinallyInitializes() {\n    val x: Int\n\n    try {\n        myRun {\n            try {\n                x = innerComputation()\n            } catch (e: java.lang.Exception) {\n                log()\n            }\n            // possible reassignment if innerComputation finished\n            <!VAL_REASSIGNMENT!>x<!> = 42\n            // x is ID here\n        }\n\n        // Definite reassignment here, cause can get here only if myRun finished\n        // Not reported because of repeating diagnostic\n        x = outerComputation()\n    } catch (e: java.lang.Exception) {\n        // can catch exception thrown by the inner, so x can be not initialized\n        <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n        log()\n    } finally {\n        // Possible reassignment (e.g. if everything finished)\n        // Not reported because of repeating diagnostic\n        x = 42\n    }\n\n    // Properly initialized\n    x.inc()\n}\n\nfun innerFinallyInitializes() {\n    val x: Int\n    try {\n        myRun {\n            try {\n                innerComputation()\n            } catch (e: java.lang.Exception) {\n                log()\n            } finally {\n                x = 42\n            }\n        }\n\n        // Properly initialized\n        x.inc()\n    } catch (e: java.lang.Exception) {\n        log()\n    }\n\n    // Still can be unitialized because we don't know what can happen in try-block\n    // (e.g., OutOfMemory exception could've happened even before myRun was executed)\n    <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n}\n\n\nfun innerFinallyInitializesOuterRethrows() {\n    val x: Int\n    try {\n        myRun {\n            try {\n                innerComputation()\n            } catch (e: java.lang.Exception) {\n                log()\n            } finally {\n                x = 42\n            }\n        }\n\n        // Properly initialized\n        x.inc()\n    } catch (e: java.lang.Exception) {\n        log()\n        throw e\n    }\n\n    // Guaranteed to be initialized because all catch-clauses are rethrowing\n    x.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun functionWithSideEffects(x: Int): Int = x + 1 // ...and some other useful side-effects\n\nfun log(<!UNUSED_PARAMETER!>s<!>: String) = Unit // some logging or println or whatever returning Unit\n\nfun implicitCastWithIf(s: String) {\n    myRun { if (s == \"\") functionWithSideEffects(42) else log(s) }\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun myRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n}\n\ninline fun <T> unknownRun(block: () -> T): T = block()\n\nfun throwIfNotCalled() {\n    val x: Int\n    myRun outer@ {\n        unknownRun {\n            myRun {\n                <!CAPTURED_VAL_INITIALIZATION!>x<!> = 42\n                return@outer\n            }\n        }\n        throw java.lang.IllegalArgumentException()\n    }\n    // x *is* initialized here, because if myRun was never called -> exception\n    // were thrown and control flow wouldn't be here\n    println(x)\n}\n\nfun catchThrowIfNotCalled() {\n    val x: Int\n    try {\n        myRun outer@ {\n            unknownRun {\n                myRun {\n                    <!CAPTURED_VAL_INITIALIZATION!>x<!> = 42\n                    return@outer\n                }\n            }\n            throw java.lang.IllegalArgumentException()\n        }\n    } catch (ignored: java.lang.IllegalArgumentException) { }\n\n    // x *isn't* initialized here!\n    println(<!UNINITIALIZED_VARIABLE!>x<!>)\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun myRun(block: () -> Unit): Unit {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun getBool(): Boolean = false\n\nfun withLabeledReturn() {\n    val y: Int\n\n    val x = myRun outer@ {\n        myRun { return@outer Unit }\n        <!UNREACHABLE_CODE!>y = 42<!>\n    }\n\n    println(<!UNINITIALIZED_VARIABLE!>y<!>)\n    println(x)\n}\n\nfun withLabeledReturn2(y: Int) {\n    myRun outer@ {\n        myRun { return@outer Unit }\n        <!UNREACHABLE_CODE!>println(y)<!>\n    }\n    println(y)\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun myRun(block: () -> Unit): Unit {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n}\n\nfun test() {\n    myRun { throw java.lang.IllegalArgumentException() }\n    <!UNREACHABLE_CODE!>val x: Int = 42<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun someComputation(): Int = 42\n\nfun tryCatchInlined() {\n    val x: Int\n\n    myRun {\n        try {\n            x = someComputation()\n            x.inc()\n        }\n        catch (e: java.lang.Exception) {\n            <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n        }\n    }\n    <!VAL_REASSIGNMENT!>x<!> = 42\n    x.inc()\n}\n\nfun possibleReassignmentInTryCatch() {\n    val x: Int\n\n    myRun {\n        try {\n            x = someComputation()\n            x.inc()\n        }\n        catch (e: java.lang.Exception) {\n            <!VAL_REASSIGNMENT!>x<!> = 42\n            x.inc()\n        }\n        x.inc()\n    }\n    x.inc()\n}\n\nfun tryCatchOuter() {\n    val x: Int\n    try {\n        myRun {  x = someComputation() }\n        x.inc()\n    }\n    catch (e: java.lang.Exception) {\n        <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER -UNUSED_PARAMETER\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun someComputation(): Int = 42\n\nfun report(x: Int) = Unit\n\nfun innerTryCatchFinally() {\n    val x: Int\n\n    myRun {\n        try {\n            x = someComputation()\n            report(x)\n        } catch (e: java.lang.Exception) {\n            <!VAL_REASSIGNMENT!>x<!> = 42\n            report(x)\n        } finally {\n            x = 0\n        }\n    }\n\n    x.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun innerComputation(): Int = 42\nfun outerComputation(): Int = 52\n\nfun innerTryCatchInitializes() {\n    val x: Int\n\n    try {\n        myRun {\n            try {\n                x = innerComputation()\n                x.inc()\n            }\n            catch (e: java.lang.Exception) {\n                // Potential reassignment because x.inc() could threw\n                <!VAL_REASSIGNMENT!>x<!> = 42\n                x.inc()\n            }\n        }\n        // Can get here only when inlined lambda exited properly, i.e. x is initialized\n        x.inc()\n        outerComputation()\n\n    } catch (e: java.lang.Exception) {\n        // Can get here if innerComputation() threw an exception that wasn't catched by the inner catch (x is not initialized)\n        // OR if outerComputation() threw an exception (x is initialized because we reach outer computation only when inner finished ok)\n        // So, x=I? here\n        <!UNINITIALIZED_VARIABLE!>x<!>.inc()\n\n        // Potential reasignment\n        x = 42\n    }\n    // Here x=I because outer try-catch either exited normally (x=I) or catched exception (x=I, with reassingment, though)\n    x.inc()\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\nfun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun foo(x: Int): Int = x + 1\n\nfun typeMismatchInLambda(y: String): Int {\n    val x = myRun { foo(<!TYPE_MISMATCH!>y<!>) }\n    return x\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun throwInLambda(): Int {\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>x<!> =<!> myRun { throw java.lang.IllegalArgumentException(); <!UNREACHABLE_CODE!>42<!> }\n    <!UNREACHABLE_CODE!>return x<!>\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun exitOnlyThroughLocalReturns(b: Boolean) {\n    var x: Int\n    var s: String\n\n    myRun {\n        if (b) {\n            x = 42\n            return@myRun\n        }\n\n        if (!b) {\n            s = \"hello\"\n            x = 42\n            return@myRun\n        }\n        else {\n            s = \"world\"\n            x = 239\n        }\n    }\n\n    x.inc()\n    <!UNINITIALIZED_VARIABLE!>s<!>.length\n}\n\nfun exitOnlyThroughNonLocalReturns(b: Boolean?) {\n    var x: Int\n    var <!ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE!>s<!>: String\n    myRun {\n        if (b == null) {\n            x = 42\n            return\n        }\n\n        if (<!DEBUG_INFO_SMARTCAST!>b<!>.not()) {\n            x = 54\n        }\n\n        if (<!UNINITIALIZED_VARIABLE!>x<!> == 42) {\n            return\n        }\n        else {\n            x = 42\n            s = \"hello\"\n            return\n        }\n    }\n\n    <!UNREACHABLE_CODE!>x.inc()<!>\n    <!UNREACHABLE_CODE!>s.length<!>\n}\n\nfun nonLocalReturnAndOrdinaryExit(b: Boolean) {\n    var x: Int\n    var s: String\n    myRun {\n        if (b) {\n            x = 42\n            return\n        }\n        x = 54\n        s = \"hello\"\n    }\n    x.inc()\n    s.length\n}"
        },
        {
            "code": "// !LANGUAGE: +AllowContractsForCustomFunctions +UseCallsInPlaceEffect\n// !USE_EXPERIMENTAL: kotlin.contracts.ExperimentalContracts\n// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER\n\nimport kotlin.contracts.*\n\ninline fun <T> myRun(block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun getBoolean(): Boolean = false\n\nfun test() {\n    val x: Int\n\n    if (getBoolean())\n        myRun {\n            while (getBoolean()) {\n                do {\n                    myRun {\n                        if (getBoolean()) {\n                            x = 42 // No reassignment because of break\n                        }\n                        else {\n                            x = 43 // No reassignment because of break\n                        }\n                    }\n                    break\n                } while (<!UNREACHABLE_CODE!>getBoolean()<!>)\n                // Loop executed exectly once, initializing x\n                myRun { x.inc() }\n\n                myRun { <!VAL_REASSIGNMENT!>x<!> = 42 }\n                break\n            }\n            // x is I?D here because loop could've been execited\n            // VAL_REASSIGNMENT isn't reported because of repeating diagnostic\n            x = 42\n            // x is ID now\n        }\n    else\n        myRun {\n            x = 42\n        }\n    // x is ID because both branches are ID\n\n    x.inc()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nimport java.util.*\nfun foo() {\n    val al = ArrayList<String>()\n    al.size\n    al.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains<!>(<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    al.contains(\"\")\n\n    al.remove(\"\")\n    al.removeAt(1)\n\n    val hs = HashSet<String>()\n    hs.size\n    hs.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>contains<!>(<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    hs.contains(\"\")\n\n    hs.remove(\"\")\n\n\n    val hm = HashMap<String, Int>()\n    hm.size\n    hm.<!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>containsKey<!>(<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>)\n    hm.containsKey(\"\")\n\n    <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES!>hm[<!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>]<!>\n    hm[\"\"]\n\n    hm.remove(\"\")\n}"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n\ninterface B {\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    fun test()<!> {}\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    abstract fun test2(s: String = \"\")<!>\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    abstract fun test3()<!>\n\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    abstract val prop: String<!>\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    abstract val prop2: String<!>\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    val prop3: String<!>\n        get() = \"\"\n\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    var prop4: String<!>\n        get() = \"\"\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\ninterface A {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    fun test()<!> {\n\n    }\n}\n\ninterface B{\n    fun test()\n}\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface <!JVM_DEFAULT_THROUGH_INHERITANCE!>AB<!><!> : A, B\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface <!JVM_DEFAULT_THROUGH_INHERITANCE!>BA<!><!> : B, A\n\nclass C : A, B {\n    override fun test() {\n        super<A>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}\n\nclass D : B, A {\n    override fun test() {\n        super<A>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class <!JVM_DEFAULT_THROUGH_INHERITANCE!>E<!><!>: B, A {\n    fun foo() {\n        super<A>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n\nabstract class A {\n\n    <!JVM_DEFAULT_NOT_IN_INTERFACE!>@JvmDefault<!>\n    fun test() {}\n\n    <!JVM_DEFAULT_NOT_IN_INTERFACE!>@JvmDefault<!>\n    abstract fun test2(s: String = \"\")\n\n    <!JVM_DEFAULT_NOT_IN_INTERFACE!>@JvmDefault<!>\n    abstract fun test3()\n}\n\nobject B {\n\n    <!JVM_DEFAULT_NOT_IN_INTERFACE!>@JvmDefault<!>\n    fun test() {}\n\n    <!JVM_DEFAULT_NOT_IN_INTERFACE!>@JvmDefault<!>\n    fun test2(<!UNUSED_PARAMETER!>s<!>: String = \"\") {}\n}\n"
        },
        {
            "code": "// !JVM_DEFAULT_MODE: enable\n// !JVM_TARGET: 1.8\n\n// FILE: 1.kt\n\ninterface KotlinInterface : JavaInterface {\n    @JvmDefault\n    override fun test() {}\n\n    <!NON_JVM_DEFAULT_OVERRIDES_JAVA_DEFAULT!>override fun testForNonDefault()<!> {}\n\n    override fun testAbstract() {}\n}\n\ninterface KotlinInterface2 : JavaInterface, KotlinInterface {\n    @JvmDefault\n    override fun test() {}\n\n    override fun testForNonDefault() {}\n\n    override fun testAbstract() {}\n}\n\n\ninterface KotlinInterfaceForIndirect : JavaInterface {\n\n}\n\ninterface KotlinInterfaceIndirectInheritance : KotlinInterfaceForIndirect {\n\n    @JvmDefault\n    override fun test() {}\n\n    <!NON_JVM_DEFAULT_OVERRIDES_JAVA_DEFAULT!>override fun testForNonDefault()<!> {}\n\n    override fun testAbstract() {}\n}\n\nopen class KotlinClass : JavaInterface {\n    override fun test() {}\n\n    override fun testForNonDefault() {}\n\n    override fun testAbstract() {}\n}\n\ninterface KotlinInterfaceX  {\n\n    fun test() {}\n\n    fun testForNonDefault() {}\n\n    fun testAbstract() {}\n}\n\ninterface KotlinInterfaceManySuper: JavaInterface, KotlinInterfaceX {\n    @JvmDefault\n    override fun test() {}\n\n    <!NON_JVM_DEFAULT_OVERRIDES_JAVA_DEFAULT!>override fun testForNonDefault()<!> {}\n\n    override fun testAbstract() {}\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n// !JVM_DEFAULT_MODE: enable\n\ninterface B {\n\n    @JvmDefault\n    fun test() {}\n\n    @JvmDefault\n    abstract fun test2(s: String = \"\")\n\n    @JvmDefault\n    abstract fun test3()\n\n\n    @JvmDefault\n    abstract val prop: String\n\n    @JvmDefault\n    abstract val prop2: String\n\n    @JvmDefault\n    val prop3: String\n        get() = \"\"\n\n    @JvmDefault\n    var prop4: String\n        get() = \"\"\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n// !JVM_DEFAULT_MODE: enable\n\ninterface B {\n\n    @JvmDefault\n    val prop1: String\n    <!WRONG_ANNOTATION_TARGET!>@JvmDefault<!> get() = \"\"\n\n\n    var prop2: String\n        <!WRONG_ANNOTATION_TARGET!>@JvmDefault<!> get() = \"\"\n        <!WRONG_ANNOTATION_TARGET!>@JvmDefault<!> set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\ninterface A {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    fun test()<!>\n}\n\ninterface B{\n    fun test() {\n    }\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface AB<!>: A, B\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface BA<!>: B, A\n\nclass C : A, B {\n    override fun test() {\n        super<B>.test()\n    }\n}\n\nclass D : B, A {\n    override fun test() {\n        super<B>.test()\n    }\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>class E<!>: B, A {\n    fun foo() {\n        super<B>.test()\n    }\n}"
        },
        {
            "code": "// !JVM_TARGET: 1.6\n\ninterface B {\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    fun test() {}\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    abstract fun test2(s: String = \"\")\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    abstract fun test3()\n\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    abstract val prop: String\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    abstract val prop2: String\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    val prop3: String\n        get() = \"\"\n\n    <!JVM_DEFAULT_IN_JVM6_TARGET!>@JvmDefault<!>\n    var prop4: String\n        get() = \"\"\n        set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\ninterface A {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    fun test()<!> {\n    }\n}\n\ninterface B{\n    fun test() {\n    }\n}\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface <!JVM_DEFAULT_THROUGH_INHERITANCE!>AB<!><!>: A, B\n\n<!MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED!>interface <!JVM_DEFAULT_THROUGH_INHERITANCE!>BA<!><!>: B, A\n\n\ninterface C : A, B {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    override fun test()<!> {\n        super<B>.test()\n        super<A>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}\n\ninterface D : B, A {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    override fun test()<!> {\n        super<B>.test()\n        super<A>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}"
        },
        {
            "code": "// !JVM_DEFAULT_MODE: enable\n// !JVM_TARGET: 1.8\n\npublic interface KInterface {\n    @JvmDefault\n    fun test(): String {\n        return \"OK\";\n    }\n\n    @JvmDefault\n    val property: String\n        get() = \"OK\"\n\n\n    fun testNonDefault(): String {\n        return \"OK\";\n    }\n\n    val propertyNonDefault: String\n        get() = \"OK\"\n}\n\n// FILE: 1.kt\n\ninterface KotlinInterface : KInterface {\n    @JvmDefault\n    fun fooo() {\n        super.test()\n        super.property\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinInterface.test()\n                super@KotlinInterface.property\n\n                super@KotlinInterface.testNonDefault()\n                super@KotlinInterface.propertyNonDefault\n            }\n        }\n    }\n\n    @JvmDefault\n    val propertyy: String\n        get() {\n            super.test()\n            super.property\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinInterface.test()\n                    super@KotlinInterface.property\n\n                    super@KotlinInterface.testNonDefault()\n                    super@KotlinInterface.propertyNonDefault\n                }\n            }\n            return \"\"\n        }\n\n    fun foooNonDefault() {\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n                super@KotlinInterface.testNonDefault()\n                super@KotlinInterface.propertyNonDefault\n            }\n        }\n    }\n\n    val propertyyNonDefault: String\n        get() {\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                    super@KotlinInterface.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n                    super@KotlinInterface.testNonDefault()\n                    super@KotlinInterface.propertyNonDefault\n                }\n            }\n            return \"\"\n        }\n\n\n}\n\ninterface KotlinInterfaceIndirectInheritance : KotlinInterface {\n    @JvmDefault\n    fun foooo() {\n        super.test()\n        super.property\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinInterfaceIndirectInheritance.test()\n                super@KotlinInterfaceIndirectInheritance.property\n\n                super@KotlinInterfaceIndirectInheritance.testNonDefault()\n                super@KotlinInterfaceIndirectInheritance.propertyNonDefault\n            }\n        }\n    }\n\n    @JvmDefault\n    val propertyyy: String\n        get() {\n            super.test()\n            super.property\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinInterfaceIndirectInheritance.test()\n                    super@KotlinInterfaceIndirectInheritance.property\n\n                    super@KotlinInterfaceIndirectInheritance.testNonDefault()\n                    super@KotlinInterfaceIndirectInheritance.propertyNonDefault\n                }\n            }\n            return \"\"\n        }\n\n    fun fooooNonDefault() {\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n        super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n                super@KotlinInterfaceIndirectInheritance.testNonDefault()\n                super@KotlinInterfaceIndirectInheritance.propertyNonDefault\n            }\n        }\n    }\n\n    val propertyyyNonDefault: String\n        get() {\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n            super.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>test<!>()\n                    super@KotlinInterfaceIndirectInheritance.<!INTERFACE_CANT_CALL_DEFAULT_METHOD_VIA_SUPER!>property<!>\n\n                    super@KotlinInterfaceIndirectInheritance.testNonDefault()\n                    super@KotlinInterfaceIndirectInheritance.propertyNonDefault\n                }\n            }\n            return \"\"\n        }\n}\n\nopen class KotlinClass : KInterface {\n    fun foo() {\n        super.test()\n        super.property\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinClass.test()\n                super@KotlinClass.property\n\n                super@KotlinClass.testNonDefault()\n                super@KotlinClass.propertyNonDefault\n            }\n        }\n    }\n\n    val xproperty: String\n        get() {\n            super.test()\n            super.property\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinClass.test()\n                    super@KotlinClass.property\n\n                    super@KotlinClass.testNonDefault()\n                    super@KotlinClass.propertyNonDefault\n                }\n            }\n\n            return \"\"\n        }\n}\n\nclass KotlinClassIndirectInheritance : KotlinClass() {\n    fun foo2() {\n        super.test()\n        super.property\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinClassIndirectInheritance.test()\n                super@KotlinClassIndirectInheritance.property\n\n                super@KotlinClassIndirectInheritance.testNonDefault()\n                super@KotlinClassIndirectInheritance.propertyNonDefault\n            }\n        }\n\n    }\n\n    val property2: String\n        get() {\n            super.test()\n            super.property\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinClassIndirectInheritance.test()\n                    super@KotlinClassIndirectInheritance.property\n\n                    super@KotlinClassIndirectInheritance.testNonDefault()\n                    super@KotlinClassIndirectInheritance.propertyNonDefault\n                }\n            }\n            return \"\"\n        }\n}\n\nclass KotlinClassIndirectInheritance2 : KotlinInterfaceIndirectInheritance {\n    fun foo() {\n        super.test()\n        super.property\n\n        super.testNonDefault()\n        super.propertyNonDefault\n\n        object  {\n            fun run () {\n                super@KotlinClassIndirectInheritance2.test()\n                super@KotlinClassIndirectInheritance2.property\n\n                super@KotlinClassIndirectInheritance2.testNonDefault()\n                super@KotlinClassIndirectInheritance2.propertyNonDefault\n            }\n        }\n    }\n\n    val xproperty: String\n        get() {\n            super.test()\n            super.property\n\n            super.testNonDefault()\n            super.propertyNonDefault\n\n            object  {\n                fun run () {\n                    super@KotlinClassIndirectInheritance2.test()\n                    super@KotlinClassIndirectInheritance2.property\n\n                    super@KotlinClassIndirectInheritance2.testNonDefault()\n                    super@KotlinClassIndirectInheritance2.propertyNonDefault\n                }\n            }\n            return \"\"\n        }\n}\n\nfun test() {\n    KotlinClass().test()\n    KotlinClass().property\n    KotlinClass().propertyNonDefault\n    KotlinClassIndirectInheritance2().test()\n    KotlinClassIndirectInheritance2().testNonDefault()\n    KotlinClassIndirectInheritance2().propertyyy\n    KotlinClassIndirectInheritance2().propertyyyNonDefault\n\n    KotlinClass().test()\n    KotlinClass().testNonDefault()\n    KotlinClass().property\n    KotlinClass().propertyNonDefault\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n// !JVM_DEFAULT_MODE: enable\n\ninterface A {\n    @JvmDefault\n    val test: String\n        get() = \"OK\"\n}\n\ninterface Abstract : A {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override val test: String<!>\n}\n\ninterface ANonDefault {\n    val test: String\n        get() = \"ANonDefault\"\n}\n\ninterface B: A {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override val test: String<!>\n        get() = \"B\"\n}\n\ninterface C: ANonDefault, A {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override val test: String<!>\n        get() = \"C\"\n}\n\ninterface D: A, ANonDefault {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override val test: String<!>\n        get() = \"C\"\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n// FILE: 1.kt\ninterface A {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    fun test()<!> {\n    }\n}\n\n// FILE: 2.kt\ninterface <!JVM_DEFAULT_THROUGH_INHERITANCE!>B<!> : A {\n\n}\n\ninterface C : B {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    override fun test()<!> {\n        super.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}\n\nopen class Foo : B {\n    override fun test() {\n        super.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n    }\n}\nopen class <!JVM_DEFAULT_THROUGH_INHERITANCE!>Foo2<!> : B\n\nopen class Bar : Foo2() {\n    override fun test() {\n        super.test()\n    }\n}\n\nopen class Bar2 : Bar() {\n    override fun test() {\n        super.test()\n    }\n}\n\nclass ManySupers: Foo2(), B {\n    fun foo() {\n        super<Foo2>.test()\n        super<<!QUALIFIED_SUPERTYPE_EXTENDED_BY_OTHER_SUPERTYPE!>B<!>>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>test<!>()\n    }\n}\n\nclass <!JVM_DEFAULT_THROUGH_INHERITANCE!>ManySupers2<!>: Foo2(), C {\n    fun foo() {\n        super<Foo2>.test()\n        super<C>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>test<!>()\n    }\n}\n\n<!MANY_IMPL_MEMBER_NOT_IMPLEMENTED!>class <!JVM_DEFAULT_THROUGH_INHERITANCE!>ManySupers3<!><!>: Bar2(), C {\n    fun foo() {\n        super<Bar2>.test()\n        super<C>.<!USAGE_OF_JVM_DEFAULT_THROUGH_SUPER_CALL!>test<!>()\n        <!AMBIGUOUS_SUPER!>super<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>test<!>()\n    }\n}"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n// !JVM_DEFAULT_MODE: enable\n\ninterface A {\n    @JvmDefault\n    fun test() {}\n}\n\ninterface Abstract : A {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test()<!>\n}\n\ninterface ANonDefault {\n    fun test() {}\n}\n\ninterface B: A {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test()<!> {}\n}\n\ninterface C: ANonDefault, A {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test()<!> {}\n}\n\ninterface D: A, ANonDefault {\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test()<!> {}\n}\n\nclass Foo : A {\n    override fun test() {}\n}\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n\ninterface A {\n    <!JVM_DEFAULT_IN_DECLARATION!>@JvmDefault\n    fun test()<!> {\n    }\n}\n\ninterface <!JVM_DEFAULT_THROUGH_INHERITANCE!>B<!> : A {\n\n}\n\n\nopen class <!JVM_DEFAULT_THROUGH_INHERITANCE!>Foo<!> : B\nopen class <!JVM_DEFAULT_THROUGH_INHERITANCE!>Foo2<!> : B, A\n\nopen class FooNoError : B {\n    override fun test() {\n    }\n}\nopen class Foo2NoError : B, A {\n    override fun test() {\n    }\n}\n\nclass Bar : Foo()\nclass Bar2 : Foo(), A\nclass Bar3 : Foo(), B\n\nopen class BarWithJvmDefault : B {\n    <!JVM_DEFAULT_NOT_IN_INTERFACE!>@JvmDefault<!>\n    override fun test() {\n    }\n}\n\nclass BarWithJvmDefaultSuper: BarWithJvmDefault()\n"
        },
        {
            "code": "// !JVM_TARGET: 1.8\n// !JVM_DEFAULT_MODE: enable\n\ninterface A<T> {\n    @JvmDefault\n    fun test(p: T) {\n    }\n}\n\ninterface ANonDefault {\n    fun test(p: String) {}\n}\n\ninterface B<T> : A<T> {\n\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test(p: T)<!>\n    {}\n}\n\ninterface C<T> : A<T>, ANonDefault {\n\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test(p: T)<!>\n    {}\n\n    override fun test(p: String) {\n    }\n}\n\ninterface C1 : C<String> {\n    override fun test(p: String) {\n\n    }\n}\n\ninterface C2 : C<String>, ANonDefault {\n    override fun test(p: String) {\n\n    }\n}\n\ninterface D<T> : ANonDefault, A<T> {\n\n    <!JVM_DEFAULT_REQUIRED_FOR_OVERRIDE!>override fun test(p: T)<!>\n    {}\n\n    override fun test(p: String) {\n    }\n}\n\ninterface D1 : D<String> {\n    override fun test(p: String) {\n\n    }\n}\n\ninterface D2 : ANonDefault, D<String> {\n    override fun test(p: String) {\n\n    }\n}\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nconst val CONST = 1\nfun foo() = 1\nval nonConst = foo()\n\nannotation class ValidAnn(\n    val p1: Int = 1 + CONST,\n    val p2: String = \"\",\n    val p3: KClass<*> = String::class,\n    val p4: IntArray = intArrayOf(1, 2, 3),\n    val p5: Array<String> = arrayOf(\"abc\"),\n    val p6: Array<KClass<*>> = arrayOf(Int::class)\n)\n\nval nonConstKClass = String::class\n\nannotation class InvalidAnn(\n    val p1: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>foo()<!>,\n    val p2: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>nonConst<!>,\n    val p3: KClass<*> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>nonConstKClass<!>\n)\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nopen class A\nclass B1 : A()\nclass B2 : A()\n\nannotation class Ann1(val arg: KClass<in A>)\n\n@Ann1(A::class)\nclass MyClass1\n\n@Ann1(Any::class)\nclass MyClass1a\n\n@Ann1(<!TYPE_MISMATCH!>B1::class<!>)\nclass MyClass2\n\nannotation class Ann2(val arg: KClass<in B1>)\n\n@Ann2(A::class)\nclass MyClass3\n\n@Ann2(B1::class)\nclass MyClass4\n\n@Ann2(<!TYPE_MISMATCH!>B2::class<!>)\nclass MyClass5\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nimport kotlin.reflect.KClass\n\nopen class A\nclass B1 : A()\nclass B2 : A()\n\nannotation class Ann1(val arg: Array<KClass<out A>>)\n\n@Ann1(arrayOf(A::class))\nclass MyClass1\n\n@Ann1(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>Any::class<!>)<!>)\nclass MyClass1a\n\n@Ann1(arrayOf(B1::class))\nclass MyClass2\n\nannotation class Ann2(val arg: Array<KClass<out B1>>)\n\n@Ann2(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>A::class<!>)<!>)\nclass MyClass3\n\n@Ann2(arrayOf(B1::class))\nclass MyClass4\n\n@Ann2(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>B2::class<!>)<!>)\nclass MyClass5\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nopen class A\nclass B : A()\n\nannotation class Ann1(val arg: KClass<A>)\n\n@Ann1(A::class)\nclass MyClass1\n\n@Ann1(<!TYPE_MISMATCH!>Any::class<!>)\nclass MyClass1a\n\n@Ann1(<!TYPE_MISMATCH!>B::class<!>)\nclass MyClass2\n\nannotation class Ann2(val arg: KClass<B>)\n\n@Ann2(<!TYPE_MISMATCH!>A::class<!>)\nclass MyClass3\n\n@Ann2(B::class)\nclass MyClass4\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nimport kotlin.reflect.KClass\n\nopen class A\nclass B1 : A()\nclass B2 : A()\n\nannotation class Ann1(val arg: Array<KClass<in A>>)\n\n@Ann1(arrayOf(A::class))\nclass MyClass1\n\n@Ann1(arrayOf(Any::class))\nclass MyClass1a\n\n@Ann1(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>B1::class<!>)<!>)\nclass MyClass2\n\nannotation class Ann2(val arg: Array<KClass<in B1>>)\n\n@Ann2(arrayOf(A::class))\nclass MyClass3\n\n@Ann2(arrayOf(B1::class))\nclass MyClass4\n\n@Ann2(<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>B2::class<!>)<!>)\nclass MyClass5\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nannotation class Ann1(val arg: KClass<*>)\nannotation class Ann2(vararg val arg: KClass<*>)\nannotation class Ann3(val arg: Array<KClass<*>>)\n\nclass A1\nclass A2\n\n@Ann1(A1::class)\n@Ann2(A1::class, A2::class)\n@Ann3(arrayOf(A1::class, A2::class))\nclass MyClass1\n\n@Ann1(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!><!UNRESOLVED_REFERENCE!>A3<!>::class<!>)\nclass MyClass2\n\nval x = A1::class\n@Ann1(<!ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL!>x<!>)\nclass MyClass3\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nopen class A\nclass B1 : A()\nclass B2 : A()\n\nannotation class Ann1(val arg: KClass<out A>)\n\n@Ann1(A::class)\nclass MyClass1\n\n@Ann1(<!TYPE_MISMATCH!>Any::class<!>)\nclass MyClass1a\n\n@Ann1(B1::class)\nclass MyClass2\n\nannotation class Ann2(val arg: KClass<out B1>)\n\n@Ann2(<!TYPE_MISMATCH!>A::class<!>)\nclass MyClass3\n\n@Ann2(B1::class)\nclass MyClass4\n\n@Ann2(<!TYPE_MISMATCH!>B2::class<!>)\nclass MyClass5\n"
        },
        {
            "code": "import kotlin.jvm.Synchronized\n\ninterface My {\n    <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> fun foo()\n\n    <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> fun bar() = 1\n\n    <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> fun baz(): String {\n        return \"abc\"\n    }\n\n    var v: String\n        <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> get() = \"\"\n        <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\nabstract class Your {\n    <!SYNCHRONIZED_ON_ABSTRACT!>@Synchronized<!> abstract fun foo()\n\n    @Synchronized fun bar() = 1\n\n    @Synchronized open fun baz(): String {\n        return \"xyz\"\n    }\n\n    var v: String\n        @Synchronized get() = \"\"\n        @Synchronized set(<!UNUSED_PARAMETER!>value<!>) {}\n}\n\n@Synchronized fun gav() = 1\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nannotation class B(vararg val args: String)\n\n@B(*<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, \"b\")<!>)\nfun test() {\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\n// FILE: b.kt\n@A(*<!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>arrayOf(<!NI;CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>, \"b\")<!>)\nfun test() {\n}\n"
        },
        {
            "code": "class A {\n\n    <!CONFLICTING_JVM_DECLARATIONS!>@JvmField val clash<!> = 1;\n\n    companion object {\n        <!CONFLICTING_JVM_DECLARATIONS!>val clash<!> = 1;\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +JvmFieldInInterface\n\ninterface A {\n\n    companion object {\n        @JvmField\n        val c = 3\n    }\n}\n\n\ninterface B {\n\n    companion object {\n        @JvmField\n        val c = 3\n\n        @JvmField\n        val a = 3\n    }\n}\n\ninterface C {\n    companion object {\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        val c = 3\n\n        val a = 3\n    }\n}\n\ninterface D {\n    companion object {\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        var c = 3\n    }\n}\n\n\ninterface E {\n    companion object {\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        private val a = 3\n\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        internal val b = 3\n\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        protected val c = 3\n    }\n}\n\n\ninterface F {\n    companion object {\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> val a = 3\n    }\n}\n"
        },
        {
            "code": "@file:kotlin.jvm.JvmMultifileClass\n@file:JvmName(\"SomeName\")\n\n<!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\nval c = 4\n\n<!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\nvar g = 5\n\nclass C {\n    @JvmField\n    var g = 5\n}"
        },
        {
            "code": "// !LANGUAGE: +NestedClassesInAnnotations +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n<!WRONG_ANNOTATION_TARGET!>@kotlin.jvm.JvmField<!>\nfun foo() {\n    <!WRONG_ANNOTATION_TARGET!>@kotlin.jvm.JvmField<!> val x = \"A\"\n}\n\nannotation class DemoAnnotation\n\n<!WRONG_ANNOTATION_TARGET!>@JvmField<!>\nabstract class C : I{\n\n    <!WRONG_ANNOTATION_TARGET!>@kotlin.jvm.JvmField<!> constructor(s: String) {\n    }\n\n    <!WRONG_ANNOTATION_TARGET!>@kotlin.jvm.JvmField<!> private fun foo(s: String = \"OK\") {\n    }\n\n    <!INAPPLICABLE_JVM_FIELD, WRONG_ANNOTATION_TARGET!>@JvmField<!> val a: String by lazy { \"A\" }\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!> open val b: Int = 3\n\n    <!WRONG_ANNOTATION_TARGET!>@JvmField<!> abstract val c: Int\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    val customGetter: String = \"\"\n        get() = field\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    val explicitDefaultGetter: String = \"\"\n        get\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    var explicitDefaultSetter: String = \"\"\n        set\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    val explicitDefaultAnnotatedGetter: String = \"\"\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@DemoAnnotation<!> get\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    var explicitDefaultAnnotatedSetter: String = \"\"\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@DemoAnnotation<!> set\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    var customSetter: String = \"\"\n        set(s) {\n            field = s\n        }\n\n    <!WRONG_ANNOTATION_TARGET!>@JvmField<!>\n    val noBackingField: String\n        get() = \"a\"\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    final override val ai = 3\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    private val private = 3\n}\n\ninterface I {\n    <!WRONG_ANNOTATION_TARGET!>@JvmField<!> val ai: Int\n    <!WRONG_ANNOTATION_TARGET!>@JvmField<!> val bi: Int\n        get() = 5\n}\n\nclass G {\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    lateinit var lateInit: String\n\n    <!INAPPLICABLE_JVM_FIELD!>@delegate:JvmField<!>\n    val s: String by lazy { \"s\" }\n}\n\n<!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\nconst val Const = 4\n\n@JvmField\nvar i = 5\n\nclass H {\n    companion object {\n        @JvmField\n        var c = 3\n    }\n}\n\ninterface K {\n\n    val i: Int\n    val j: Int\n\n    companion object {\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        var c = 3\n\n        var x = 3\n    }\n}\n\nclass KK : K {\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    override val i: Int = 0\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    override final val j: Int = 0\n}\n\nopen class KKK : K {\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    override val i: Int = 0\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    override final val j: Int = 0\n}\n\nannotation class L {\n    companion object {\n        <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n        var c = 3\n    }\n}\n\nobject O {\n    @JvmField\n    val c = 3\n}\n\n<!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\nprivate val private = 3\n\ninline class Foo(val x: Int)\n\nobject IObject {\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    val c: Foo = Foo(42)\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    val u = <!EXPERIMENTAL_UNSIGNED_LITERALS!>42u<!>\n\n    <!INAPPLICABLE_JVM_FIELD!>@JvmField<!>\n    private val r: Result<Int> = TODO()\n}\n"
        },
        {
            "code": "<!EXPLICIT_METADATA_IS_DISALLOWED!>@Metadata<!>\nclass A\n\n<!EXPLICIT_METADATA_IS_DISALLOWED!>@Metadata(extraString = \"_\")<!>\nannotation class B(val m: Metadata)\n\n<!EXPLICIT_METADATA_IS_DISALLOWED, WRONG_ANNOTATION_TARGET!>@Metadata(extraInt = 0)<!>\n@B(Metadata())\nfun f() {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !LANGUAGE: +JvmStaticInInterface\n// !JVM_TARGET: 1.8\ninterface B {\n    companion object {\n        @JvmStatic fun a1() {\n\n        }\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic private fun a2()<!> {\n\n        }\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic protected fun a3()<!> {\n\n        }\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic internal fun a4()<!> {\n\n        }\n\n        @JvmStatic\n        var foo = 1\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        var foo1<!> = 1\n            protected set\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        var foo2<!> = 1\n            private set\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        private var foo3<!> = 1\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        protected var foo4<!> = 1\n\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        protected var foo5<!> = 1\n\n        @JvmStatic\n        val foo6 = 1\n\n        val foo7 = 1\n        @JvmStatic get\n\n        private var foo8 = 1\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@JvmStatic<!> <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>public<!> set\n\n        public var foo9 = 1\n        <!JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic private set<!>\n\n    }\n\n}"
        },
        {
            "code": "// !LANGUAGE: -JvmStaticInInterface\n// !DIAGNOSTICS: -UNUSED_VARIABLE\nclass A {\n    companion object {\n        @JvmStatic fun a1() {\n\n        }\n    }\n\n    object A {\n        @JvmStatic fun a2() {\n\n        }\n    }\n\n    fun test() {\n        val s = object {\n            <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a3()<!> {\n\n            }\n        }\n    }\n\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a4()<!> {\n\n    }\n}\n\ninterface B {\n    companion object {\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a1()<!> {\n\n        }\n    }\n\n    object A {\n        @JvmStatic fun a2() {\n\n        }\n    }\n\n    fun test() {\n        val s = object {\n            <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a3()<!> {\n\n            }\n        }\n    }\n\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a4()<!> {\n\n    }\n}"
        },
        {
            "code": "class A {\n    <!WRONG_ANNOTATION_TARGET!>@JvmStatic<!> constructor() {}\n    inner class B {\n        <!WRONG_ANNOTATION_TARGET!>@JvmStatic<!> constructor() {}\n    }\n}\n\nclass C <!WRONG_ANNOTATION_TARGET!>@JvmStatic<!> constructor()"
        },
        {
            "code": "// !LANGUAGE: -JvmStaticInInterface\n// !DIAGNOSTICS: -UNUSED_VARIABLE\nfun main() {\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a()<!>{\n\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\nabstract class A {\n\n    open fun a() {}\n\n    abstract fun b()\n\n    open fun c() {}\n}\n\nobject B: A() {\n\n    <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic override fun a()<!> {}\n\n    <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic override fun b()<!> {}\n\n    <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic final override fun c()<!> {}\n\n    @JvmStatic <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> fun d() {}\n}\n\nclass C {\n\n    companion object: A() {\n        @JvmStatic override fun a() {}\n\n        @JvmStatic override fun b() {}\n\n        @JvmStatic final override fun c() {}\n\n        @JvmStatic <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> fun d() {}\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +JvmStaticInInterface\nclass A(<!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic val z: Int<!>) {\n\n}"
        },
        {
            "code": "// !LANGUAGE: -JvmStaticInInterface\nclass A(<!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic val z: Int<!>) {\n\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !LANGUAGE: +JvmStaticInInterface\nclass A {\n    companion object {\n        @JvmStatic fun a1() {\n\n        }\n    }\n\n    object A {\n        @JvmStatic fun a2() {\n\n        }\n    }\n\n    fun test() {\n        val s = object {\n            <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic fun a3()<!> {\n\n            }\n        }\n    }\n\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic fun a4()<!> {\n\n    }\n}\n\ninterface B {\n    companion object {\n        <!JVM_STATIC_IN_INTERFACE_1_6!>@JvmStatic fun a1()<!> {\n\n        }\n    }\n\n    object A {\n        @JvmStatic fun a2() {\n\n        }\n    }\n\n    fun test() {\n        val s = object {\n            <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic fun a3()<!> {\n\n            }\n        }\n    }\n\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic fun a4()<!> {\n\n    }\n}"
        },
        {
            "code": "// !LANGUAGE: +JvmStaticInInterface\n// !DIAGNOSTICS: -UNUSED_VARIABLE\nfun main() {\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic fun a()<!>{\n\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !LANGUAGE: +JvmStaticInInterface\ninterface B {\n    companion object {\n        <!JVM_STATIC_IN_INTERFACE_1_6!>@JvmStatic fun a1()<!> {\n\n        }\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic private fun a2()<!> {\n\n        }\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic protected fun a3()<!> {\n\n        }\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic internal fun a4()<!> {\n\n        }\n\n        <!JVM_STATIC_IN_INTERFACE_1_6!>@JvmStatic\n        var foo<!> = 1\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        var foo1<!> = 1\n            protected set\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        var foo2<!> = 1\n            private set\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        private var foo3<!> = 1\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        protected var foo4<!> = 1\n\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic\n        protected var foo5<!> = 1\n\n        <!JVM_STATIC_IN_INTERFACE_1_6!>@JvmStatic\n        val foo6<!> = 1\n\n        val foo7 = 1\n        <!JVM_STATIC_IN_INTERFACE_1_6!>@JvmStatic get<!>\n\n        private var foo8 = 1\n        <!JVM_STATIC_IN_INTERFACE_1_6!><!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@JvmStatic<!> <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>public<!> set<!>\n\n        public var foo9 = 1\n        <!JVM_STATIC_IN_INTERFACE_1_6, JVM_STATIC_ON_NON_PUBLIC_MEMBER!>@JvmStatic private set<!>\n\n    }\n\n}"
        },
        {
            "code": "// !LANGUAGE: -JvmStaticInInterface\n// !DIAGNOSTICS: -UNUSED_VARIABLE\ninterface B {\n    companion object {\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic fun a1()<!> {\n\n        }\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic private fun a2()<!> {\n\n        }\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic protected fun a3()<!> {\n\n        }\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic internal fun a4()<!> {\n\n        }\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        var foo<!> = 1\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        var foo1<!> = 1\n            protected set\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        var foo2<!> = 1\n            private set\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        private var foo3<!> = 1\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        protected var foo4<!> = 1\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        protected var foo5<!> = 1\n\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic\n        val foo6<!> = 1\n\n        val foo7 = 1\n            <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic get<!>\n\n        private var foo8 = 1\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!><!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@JvmStatic<!> <!SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY!>public<!> set<!>\n\n        public var foo9 = 1\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic private set<!>\n    }\n\n}"
        },
        {
            "code": "// !LANGUAGE: -JvmStaticInInterface\n// !DIAGNOSTICS: -UNUSED_VARIABLE\nopen class B {\n    public open val base1 : Int = 1\n    public open val base2 : Int = 1\n}\n\nclass A {\n    companion object : B() {\n        var p1:Int = 1\n            @JvmStatic set(<!UNUSED_PARAMETER!>p<!>: Int) {\n                p1 = 1\n            }\n\n        @JvmStatic val z = 1;\n\n        @JvmStatic override val base1: Int = 0\n\n        override val base2: Int = 0\n            @JvmStatic get\n    }\n\n    object A : B() {\n        var p:Int = 1\n            @JvmStatic set(<!UNUSED_PARAMETER!>p1<!>: Int) {\n                p = 1\n            }\n\n        @JvmStatic val z = 1;\n\n        <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic override val base1: Int<!> = 0\n\n        @JvmStatic <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> fun f() {}\n\n        override val base2: Int = 0\n            <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic get<!>\n    }\n\n    var p:Int = 1\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic set(<!UNUSED_PARAMETER!>p1<!>: Int)<!> {\n            p = 1\n        }\n\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_CLASS_COMPANION!>@JvmStatic val z2<!> = 1;\n}"
        },
        {
            "code": "// !LANGUAGE: +JvmStaticInInterface\n// !DIAGNOSTICS: -UNUSED_VARIABLE\nopen class B {\n    public open val base1 : Int = 1\n    public open val base2 : Int = 1\n}\n\nclass A {\n    companion object : B() {\n        var p1:Int = 1\n            @JvmStatic set(<!UNUSED_PARAMETER!>p<!>: Int) {\n                p1 = 1\n            }\n\n        @JvmStatic val z = 1;\n\n        @JvmStatic override val base1: Int = 0\n\n        override val base2: Int = 0\n            @JvmStatic get\n    }\n\n    object A : B() {\n        var p:Int = 1\n            @JvmStatic set(<!UNUSED_PARAMETER!>p1<!>: Int) {\n                p = 1\n            }\n\n        @JvmStatic val z = 1;\n\n        <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic override val base1: Int<!> = 0\n\n        @JvmStatic <!NON_FINAL_MEMBER_IN_OBJECT!>open<!> fun f() {}\n\n        override val base2: Int = 0\n            <!OVERRIDE_CANNOT_BE_STATIC!>@JvmStatic get<!>\n    }\n\n    var p:Int = 1\n        <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic set(<!UNUSED_PARAMETER!>p1<!>: Int)<!> {\n            p = 1\n        }\n\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@JvmStatic val z2<!> = 1;\n}"
        },
        {
            "code": "class A {\n\n    companion object {\n\n        <!JVM_STATIC_ON_CONST_OR_JVM_FIELD!>@JvmStatic const val z<!> = 1;\n\n        <!JVM_STATIC_ON_CONST_OR_JVM_FIELD!>@JvmStatic @JvmField val x<!> = 1;\n    }\n\n}\n\n\nobject B {\n\n    <!JVM_STATIC_ON_CONST_OR_JVM_FIELD!>@JvmStatic const val z<!> = 1;\n\n    <!JVM_STATIC_ON_CONST_OR_JVM_FIELD!>@JvmStatic @JvmField val x<!> = 1;\n}\n"
        },
        {
            "code": "// FILE: b.kt\n@A(<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>1<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>1.0<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>false<!>) fun foo1() {}\n\n@A(<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>2<!>, x = true, b = 2.0) fun foo2() {}\n\n@A(x = true, b = 3.0, a = 4) fun foo3() {}\n\n\n"
        },
        {
            "code": "// FILE: b.kt\n@A(\"v1\", <!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>1<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>1.0<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>false<!>) fun foo1() {}\n\n@A(\"v2\", <!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>2<!>, x = true, b = 2.0) fun foo2() {}\n\n@A(\"v2\", x = true, b = 3.0, a = 4) fun foo3() {}\n@A(value = \"v2\", x = true, b = 3.0, a = 4) fun foo4() {}\n"
        },
        {
            "code": "// FILE: b.kt\n@A(<!CONSTANT_EXPECTED_TYPE_MISMATCH, POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>false<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>1.0<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>false<!>) fun foo1() {}\n\n@A(<!CONSTANT_EXPECTED_TYPE_MISMATCH, POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>2.0<!>, x = true, b = 2.0) fun foo2() {}\n"
        },
        {
            "code": "// FILE: b.kt\n@A(<!CONSTANT_EXPECTED_TYPE_MISMATCH, POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>false<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>1.0<!>,\n<!POSITIONED_VALUE_ARGUMENT_FOR_JAVA_ANNOTATION!>false<!>, <!TOO_MANY_ARGUMENTS!>1<!>, <!TOO_MANY_ARGUMENTS!>2<!>) fun foo1() {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -JAVA_LANG_CLASS_PARAMETER_IN_ANNOTATION\npackage a.b.c\n\n@kotlin.Deprecated(\"aaa\")\n@ann1(kotlin.Deprecated(\"aaa\"))\n\n<!REPEATED_ANNOTATION!>@a.b.c.ann1()<!>\n@ann2(a.b.c.ann1())\n\n@A.IAnn()\n@ann3(A.IAnn())\n\n<!REPEATED_ANNOTATION!>@a.b.c.A.IAnn()<!>\n<!REPEATED_ANNOTATION!>@ann3(a.b.c.A.IAnn())<!>\n\n@annArray(kotlin.arrayOf(\"a\"))\nfun test() = 1\n\nannotation class ann1(val p: Deprecated = kotlin.Deprecated(\"aaa\"))\nannotation class ann2(val p: ann1 = a.b.c.ann1())\nannotation class ann3(val p: A.IAnn = A.IAnn(), val p2: A.IAnn = a.b.c.A.IAnn())\n\nannotation class annArray(val p: Array<String> = kotlin.arrayOf(\"a\"))\n\nclass A {\n    annotation class IAnn\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER\nimport kotlin.jvm.Volatile\nimport kotlin.properties.Delegates\n\nclass My {\n    <!VOLATILE_ON_VALUE!>@Volatile<!> val x = 0\n    // ok\n    @Volatile var y = 1\n\n    <!VOLATILE_ON_DELEGATE!>@delegate:Volatile<!> var z: String by Delegates.observable(\"?\") { prop, old, new -> old.hashCode() }\n\n    <!VOLATILE_ON_VALUE!>@field:Volatile<!> val w = 2\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See KT-15839\n\nval x = \"1\".let(@<!NI;DEBUG_INFO_MISSING_UNRESOLVED!>Suppress<!>(\"DEPRECATION\") Integer::parseInt)"
        },
        {
            "code": "interface Test {\n    <!JVM_STATIC_NOT_IN_OBJECT_OR_COMPANION!>@get:JvmStatic\n    val a: Int<!>\n\n    <!INAPPLICABLE_JVM_NAME!>@get:JvmName(\"1\")<!>\n    val b: Int\n\n    <!SYNCHRONIZED_IN_INTERFACE!>@get:Synchronized<!>\n    val c: Int\n\n    <!OVERLOADS_INTERFACE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@get:JvmOverloads<!>\n    val d: Int\n}\n"
        },
        {
            "code": "@file:JvmName(\"MultifileClass\")\n@file:JvmMultifileClass\n<!ANNOTATION_IS_NOT_APPLICABLE_TO_MULTIFILE_CLASSES!>@file:FileAnn<!>\n<!ANNOTATION_IS_NOT_APPLICABLE_TO_MULTIFILE_CLASSES!>@file:FileBinaryAnn<!>\n@file:FileSourceAnn\n\n@Target(AnnotationTarget.FILE)\n@Retention(AnnotationRetention.RUNTIME)\npublic annotation class FileAnn\n\n@Target(AnnotationTarget.FILE)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class FileBinaryAnn\n\n@Target(AnnotationTarget.FILE)\n@Retention(AnnotationRetention.SOURCE)\npublic annotation class FileSourceAnn\n\n\n"
        },
        {
            "code": "// FILE: test.kt\n@file:JvmName(\"MultifileClass\")\n@file:JvmMultifileClass\n<!ANNOTATION_IS_NOT_APPLICABLE_TO_MULTIFILE_CLASSES!>@file:JavaAnn<!>\n<!ANNOTATION_IS_NOT_APPLICABLE_TO_MULTIFILE_CLASSES!>@file:JavaClassAnn<!>\n@file:JavaSourceAnn\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n<!ILLEGAL_JVM_NAME!>@JvmName(\"\")<!>\nfun foo(a: Any) {}\n\n<!ILLEGAL_JVM_NAME!>@JvmName(\".\")<!>\nfun foo() {}\n\n<!ILLEGAL_JVM_NAME!>@JvmName(\"/\")<!>\nfun fooSlash() {}\n\n<!ILLEGAL_JVM_NAME!>@JvmName(\"<\")<!>\nfun fooLT() {}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n\n@JvmName(\"a\")\nfun foo() {}\n\n@JvmName(\"b\")\nfun Any.foo() {}\n\n<!WRONG_ANNOTATION_TARGET!>@JvmName(\"c\")<!>\nval px = 1\n\n<!WRONG_ANNOTATION_TARGET!>@JvmName(\"d\")<!>\nval Any.px : Int\n    get() = 1\n\nval valx: Int\n    @JvmName(\"e\")\n    get() = 1\n\nvar varx: Int\n    @JvmName(\"f\")\n    get() = 1\n    @JvmName(\"g\")\n    set(v) {}\n\nvar vardef: Int = 1\n    @JvmName(\"h\")\n    get\n    @JvmName(\"i\")\n    set\n\n<!WRONG_ANNOTATION_TARGET!>@JvmName(\"C\")<!>\nclass C <!WRONG_ANNOTATION_TARGET!>@JvmName(\"primary\")<!> constructor() {\n    <!WRONG_ANNOTATION_TARGET!>@JvmName(\"ctr\")<!> constructor(x: Int): this() {}\n\n    @JvmName(\"a\")\n    fun foo() {}\n\n    @JvmName(\"b\")\n    fun Any.foo() {}\n\n    <!WRONG_ANNOTATION_TARGET!>@JvmName(\"c\")<!>\n    val px = 1\n\n    <!WRONG_ANNOTATION_TARGET!>@JvmName(\"d\")<!>\n    val Any.px : Int\n    get() = 1\n\n    val valx: Int\n    @JvmName(\"e\")\n    get() = 1\n\n    var varx: Int\n    @JvmName(\"f\")\n    get() = 1\n    @JvmName(\"g\")\n    set(v) {}\n}\n\nfun foo1() {\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"a\")<!>\n    fun foo() {}\n\n    <!WRONG_ANNOTATION_TARGET!>@JvmName(\"a\")<!>\n    val x = 1\n}\n\nabstract class AB {\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"AB_absFun1\")<!>\n    abstract fun absFun1()\n\n    abstract fun absFun2()\n\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"AB_openFun\")<!>\n    open fun openFun() {}\n}\n\nclass D: AB() {\n    override fun absFun1() {}\n\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"D_absFun2\")<!>\n    override fun absFun2() {}\n\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"D_openFun\")<!>\n    final override fun openFun() {}\n\n    @JvmName(\"D_finalFun\")\n    fun finalFun() {}\n}\n\ninterface Intf {\n    <!INAPPLICABLE_JVM_NAME!>@get:JvmName(\"getBar\")<!> // no error in IDE\n    <!INAPPLICABLE_JVM_NAME!>@set:JvmName(\"setBar\")<!> // no error in IDE\n    var foo: Int\n}"
        },
        {
            "code": "// !LANGUAGE: +InlineClasses\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline class Foo(val x: Int) {\n    <!INAPPLICABLE_JVM_NAME!>@JvmName(\"other\")<!>\n    fun simple() {}\n}\n\n<!INAPPLICABLE_JVM_NAME!>@JvmName(\"bad\")<!>\nfun bar(f: Foo) {}\n\n@JvmName(\"good\")\nfun baz(r: Result<Int>) {}"
        },
        {
            "code": "// !DIAGNOSTICS: -INVISIBLE_MEMBER -INVISIBLE_REFERENCE\n\n// FILE: b.kt\n<!JVM_PACKAGE_NAME_CANNOT_BE_EMPTY!>@file:JvmPackageName(\"\")<!>\npackage b\nfun b() {}\n\n// FILE: c.kt\n<!JVM_PACKAGE_NAME_MUST_BE_VALID_NAME!>@file:JvmPackageName(\"invalid-fq-name\")<!>\npackage c\nfun c() {}\n\n// FILE: d.kt\n<!JVM_PACKAGE_NAME_NOT_SUPPORTED_IN_FILES_WITH_CLASSES!>@file:JvmPackageName(\"d\")<!>\npackage d\nclass D\nfun d() {}\n\n// FILE: e.kt\n@file:JvmPackageName(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>)\npackage e\nfun e() {}\n\n// FILE: f.kt\n@file:JvmPackageName(<!EXPRESSION_EXPECTED_PACKAGE_FOUND!>f<!>)\npackage f\nconst val name = \"f\"\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER\nimport kotlin.properties.Delegates\n\nclass My {\n    <!JVM_SYNTHETIC_ON_DELEGATE!>@delegate:JvmSynthetic<!> val s: String by lazy { \"s\" }\n\n    // Both Ok\n    @get:JvmSynthetic val t: String by lazy { \"t\" }\n    @set:JvmSynthetic var z: String by Delegates.observable(\"?\") { prop, old, new -> old.hashCode() }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n// FILE: test.kt\npackage test\n\nimport kotlin.internal.*\n\nconst val ZERO = 0\nconst val ONE = 1\n\nfun zero() = 0\nval one = 1\n\nval test0 = apiVersionIsAtLeast(0, 0, 0)\nval testConstVals = apiVersionIsAtLeast(ONE, ONE, ZERO)\nval testConstExprs = apiVersionIsAtLeast(ONE + 0, 1 + 0, ((0 + 1 + 0)))\nval testNonConstExprs = apiVersionIsAtLeast(<!API_VERSION_IS_AT_LEAST_ARGUMENT_SHOULD_BE_CONSTANT!>one<!>, <!API_VERSION_IS_AT_LEAST_ARGUMENT_SHOULD_BE_CONSTANT!>zero()<!>, <!API_VERSION_IS_AT_LEAST_ARGUMENT_SHOULD_BE_CONSTANT!>one + 1<!>)\n\n// FILE: apiVersionIsAtLeast.kt\npackage kotlin.internal\n\nfun apiVersionIsAtLeast(epic: Int, major: Int, minor: Int): Boolean =\n        false"
        },
        {
            "code": "// !LANGUAGE: +ProhibitJvmOverloadsOnConstructorsOfAnnotationClasses\n\nannotation class A1 <!OVERLOADS_ANNOTATION_CLASS_CONSTRUCTOR!>@JvmOverloads<!> constructor(val x: Int = 1)\nannotation class A2 <!OVERLOADS_ANNOTATION_CLASS_CONSTRUCTOR!>@JvmOverloads<!> constructor()"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass C {\n    <!OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS!>@kotlin.jvm.JvmOverloads<!> constructor() {\n    }\n\n    <!OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS!>@kotlin.jvm.JvmOverloads<!> fun foo(s: String) {}\n}"
        },
        {
            "code": "// !LANGUAGE: -ProhibitJvmOverloadsOnConstructorsOfAnnotationClasses\n\nannotation class A1 <!OVERLOADS_ANNOTATION_CLASS_CONSTRUCTOR_WARNING!>@JvmOverloads<!> constructor(val x: Int = 1)\nannotation class A2 <!OVERLOADS_ANNOTATION_CLASS_CONSTRUCTOR_WARNING!>@JvmOverloads<!> constructor()\n"
        },
        {
            "code": "interface T {\n    <!OVERLOADS_INTERFACE!>@kotlin.jvm.JvmOverloads<!> fun foo(s: String = \"OK\")\n\n    <!OVERLOADS_INTERFACE!>@kotlin.jvm.JvmOverloads<!> fun bar(s: String = \"OK\") {\n    }\n}\n\n\nabstract class C {\n    <!OVERLOADS_ABSTRACT!>@kotlin.jvm.JvmOverloads<!> abstract fun foo(s: String = \"OK\")\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nclass C {\n    <!OVERLOADS_PRIVATE!>@kotlin.jvm.JvmOverloads<!> private fun foo(s: String = \"OK\") {\n    }\n\n    @kotlin.jvm.JvmOverloads fun bar(s: String = \"OK\") {\n    }\n}\n\nfun foo() {\n    <!OVERLOADS_LOCAL!>@kotlin.jvm.JvmOverloads<!> fun quux(s: String = \"OK\") {\n    }\n\n    class D {\n        <!OVERLOADS_LOCAL!>@kotlin.jvm.JvmOverloads<!> fun foo(s: String = \"OK\") {\n        }\n    }\n\n    val <!UNUSED_VARIABLE!>x<!> = object {\n        <!OVERLOADS_LOCAL!>@kotlin.jvm.JvmOverloads<!> fun foo(s: String = \"OK\") {\n        }\n    }\n}"
        },
        {
            "code": "// Please make sure that this test is consistent with the blackbox test \"annotationsOnLateinitAccessors.kt\"\n\nimport kotlin.reflect.KProperty\n\nannotation class Ann\nannotation class AnnRepeat\n\nclass LateinitProperties {\n    @get:Ann\n    lateinit var y0: String\n\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n    private lateinit var y1: String\n}\n"
        },
        {
            "code": "@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Ann(val i: Int)\nannotation class AnnIA(val ia: IntArray)\nannotation class AnnSA(val sa: Array<String>)\n\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>MyClass().i<!>)\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>)\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i2<!>)\n@AnnIA(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>ia<!>)\n@AnnSA(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>sa<!>)\nclass Test {\n    val i = 1\n    @Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>) val i2 = 1\n}\n\nvar i = 1\nval i2 = foo()\n\nfun foo(): Int = 1\n\n@AnnSA(emptyArray())\nclass MyClass {\n    val i = 1\n}\n\nval ia: IntArray = intArrayOf(1, 2)\nval sa: Array<String> = arrayOf(\"a\", \"b\")\n\nannotation class Ann2\n"
        },
        {
            "code": "val nonConst = 1\n\nconst val constConst = <!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>nonConst * nonConst + 2<!>\n\nannotation class Ann(val x: Int, val y: String)\n\n@Ann(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>nonConst<!>, <!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>\"${nonConst}\"<!>)\nfun foo1() {}\n\n@Ann(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>nonConst + constConst<!>, \"${constConst}\")\nfun foo2() {}\n\nannotation class ArrayAnn(val x: IntArray)\n\n@ArrayAnn(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(1, constConst, <!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>nonConst<!>)<!>)\nfun foo3() {}\n"
        },
        {
            "code": "@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Ann(val i: IntArray)\n\n@Ann(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>)<!>)\n@Ann(intArrayOf(i2))\n@Ann(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)<!>)\n@Ann(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>, i2, <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)<!>)\n@Ann(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION, TYPE_MISMATCH!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>, i2, <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)<!>)<!>)\nclass Test\n\nvar i = 1\nconst val i2 = 1\nval i3 = foo()\n\nfun foo(): Int = 1\n\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class AnnAnn(val i: Array<Ann>)\n@AnnAnn(arrayOf(Ann(intArrayOf(1))))\n@AnnAnn(<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>arrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>iAnn<!>)<!>)\nclass TestAnn\nval iAnn = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann(intArrayOf(1))<!>\n"
        },
        {
            "code": "@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class Ann(vararg val i: Int)\n\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>)\n@Ann(i2)\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)\n@Ann(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>, i2, <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)\n@Ann(*<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>)<!>)\n@Ann(*intArrayOf(i2))\n@Ann(*<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)<!>)\n@Ann(*<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>intArrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i<!>, i2, <!ANNOTATION_ARGUMENT_MUST_BE_CONST!>i3<!>)<!>)\nclass Test\n\nvar i = 1\nconst val i2 = 1\nval i3 = foo()\n\nfun foo(): Int = 1\n\n@Retention(AnnotationRetention.SOURCE)\n@Repeatable\nannotation class AnnAnn(vararg val i: Ann)\n@AnnAnn(*arrayOf(Ann(1)))\n@AnnAnn(*<!NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION!>arrayOf(<!ANNOTATION_ARGUMENT_MUST_BE_CONST!>iAnn<!>)<!>)\nclass TestAnn\nval iAnn = <!ANNOTATION_CLASS_CONSTRUCTOR_CALL!>Ann(1)<!>\n"
        },
        {
            "code": "<!STRICTFP_ON_CLASS!>@kotlin.jvm.Strictfp<!> class A {\n\n}\n\n<!STRICTFP_ON_CLASS!>@kotlin.jvm.Strictfp<!> object B {\n\n}\n\n<!STRICTFP_ON_CLASS!>@kotlin.jvm.Strictfp<!> interface C {\n\n}\n\nfun foo() {\n    <!STRICTFP_ON_CLASS!>@kotlin.jvm.Strictfp<!> class D\n\n    <!STRICTFP_ON_CLASS!>@kotlin.jvm.Strictfp<!> object: Any() {}\n}"
        },
        {
            "code": "// Please make sure that this test is consistent with the blackbox test \"annotationsOnNonExistentAccessors.kt\"\n\nimport kotlin.reflect.KProperty\n\nannotation class Ann\nannotation class AnnRepeat\n\nclass Foo(\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!> private val y0: Int,\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!> private vararg val y1: String\n) {\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n    private val x1 = \"\"\n\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@set:Ann<!>\n    private var x2 = \"\"\n\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@setparam:Ann<!>\n    private var x3 = \"\"\n\n    @setparam:[<!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>Ann<!> <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>AnnRepeat<!>]\n    private var x4 = \"\"\n\n    @get:Ann\n    internal val x5 = \"\"\n\n    @get:Ann\n    protected val x6 = \"\"\n\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n    private val x7: String = \"\"\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@AnnRepeat<!> get\n\n    @get:Ann\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@set:Ann<!>\n    private var x8: String = \"\"\n        get() { return \"\" }\n\n    @get:Ann\n    @set:Ann\n    private var x9: String = \"\"\n        get() { return \"\" }\n        set(f) { field = f }\n}\n\nprivate class EffetivelyPrivate private constructor(\n    @get:Ann val x0: Int,\n    @get:Ann protected val x1: Int,\n    @get:Ann internal val x2: Int\n) {\n    private class Nested {\n        @get:Ann\n        val fofo = 0\n    }\n}\n\nclass PrivateToThis<in I> {\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@set:Ann<!>\n    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@setparam:Ann<!>\n    private var x0: I = TODO()\n}\n\nclass Statics {\n    companion object {\n        @JvmField\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n        val x0 = \"\"\n\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n        const val x1 = \"\"\n\n        @JvmStatic\n        @get:Ann\n        val x2 = \"\"\n\n        @JvmStatic\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n        private val x3 = \"\"\n\n        @JvmStatic\n        <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>\n        private val x4 = \"\"\n    }\n}\n\nprivate class Other(@param:Ann private val param: Int) {\n    @property:Ann\n    @field:Ann\n    private val other = \"\"\n\n    private fun @receiver:Ann Int.receiver() {}\n\n    @delegate:Ann\n    @get:Ann\n    private val delegate by CustomDelegate()\n}\n\nclass CustomDelegate {\n    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name\n}\n\n@Retention(AnnotationRetention.SOURCE)\nannotation class SourceAnn\n\nclass WithSource {\n    @get:SourceAnn\n    @set:SourceAnn\n    @setparam:SourceAnn\n    private var x0 = \"\"\n\n    private val x1 = \"\"\n        @SourceAnn get\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: +JvmStaticInInterface\n// !JVM_TARGET: 1.8\n\ninterface I {\n    companion object {\n        @Synchronized fun syncFun() {}\n\n        <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> @JvmStatic fun syncFunJvmStatic() {}\n\n        var syncProp: String\n            @Synchronized get() = \"\"\n            @Synchronized set(value) {}\n\n        @JvmStatic var syncPropJvmStatic: String\n            <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> get() = \"\"\n            <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> set(value) {}\n\n        var syncPropJvmStaticAccessors: String\n            <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> @JvmStatic get() = \"\"\n            <!SYNCHRONIZED_IN_INTERFACE!>@Synchronized<!> @JvmStatic set(value) {}\n    }\n}\n"
        },
        {
            "code": "// FILE: b.kt\n@A(\"1\", \"2\", \"3\") fun test1() {}\n\n@A(\"4\") fun test2() {}\n\n@A(*arrayOf(\"5\", \"6\"), \"7\") fun test3() {}\n\n@A(\"1\", \"2\", \"3\", x = String::class) fun test4() {}\n\n@A(\"4\", y = 2) fun test5() {}\n\n@A(*arrayOf(\"5\", \"6\"), \"7\", x = Any::class, y = 3) fun test6() {}\n\n@A() fun test7() {}\n\n@A fun test8() {}\n\n@A(x = Any::class, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>*arrayOf(\"5\", \"6\")<!>, <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"7\"<!>, y = 3) fun test9() {}\n@A(x = Any::class, value = [\"5\", \"6\"], <!MIXING_NAMED_AND_POSITIONED_ARGUMENTS!>\"7\"<!>, y = 3) fun test10() {}\n@A(x = Any::class, value = [\"5\", \"6\", \"7\"], y = 3) fun test11() {}\n"
        },
        {
            "code": "import kotlin.reflect.KClass\n\nannotation class Ann(\n        val a: Array<String> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>arrayOf(readOnly)<!>,\n        val b: Array<String> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>arrayOf(withGetter)<!>,\n        val c: Array<String> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>arrayOf(func())<!>,\n        val d: IntArray = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>intArrayOf(ONE, twoWithGetter)<!>,\n        val e: IntArray = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>intArrayOf(ONE + twoWithGetter)<!>,\n        val f: Array<String> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>arrayOf(mutable)<!>,\n        val g: Array<String> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>arrayOf(mutableWithGetter)<!>,\n        val h: Array<KClass<*>> = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>arrayOf(WithLateinit.kClass)<!>\n)\n\nconst val ONE = 1\n\nval twoWithGetter\n    get() = 2\n\nval readOnly = \"\"\n\nval withGetter\n    get() = \"\"\n\nfun func() = \"\"\n\nvar mutable = \"\"\n\nvar mutableWithGetter\n    get() = \"\"\n    set(<!UNUSED_PARAMETER!>x<!>) = TODO()\n\nobject WithLateinit {\n    lateinit var kClass: KClass<*>\n}"
        },
        {
            "code": "// FILE: b.kt\n@A(\"1\", \"2\", \"3\", y = 1) fun test1() {}\n\n@A(\"4\", y = 2) fun test2() {}\n\n@A(*arrayOf(\"5\", \"6\"), \"7\", y = 3) fun test3() {}\n\n@A(\"1\", \"2\", \"3\", x = String::class, y = 4) fun test4() {}\n\n@A(\"4\", y = 5) fun test5() {}\n\n@A(*arrayOf(\"5\", \"6\"), \"7\", x = Any::class, y = 6) fun test6() {}\n\n@A(y = 7) fun test7() {}\n\n@A(\"8\", \"9\", \"10\"<!NO_VALUE_FOR_PARAMETER!>)<!> fun test8() {}\n"
        },
        {
            "code": "annotation class A\nannotation class A1(val x: Int)\n\nannotation class B(\n        val a: A = A(),\n        val x: Int = <!ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT!>A1(42).x<!>,\n        val aa: Array<A> = arrayOf(A())\n)"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !IGNORE_DATA_FLOW_IN_ASSERT\n// SKIP_TXT\n// WITH_RUNTIME\n\nfun test1(s: String?) {\n    assert(s!!.isEmpty())\n    s<!NI;UNNECESSARY_SAFE_CALL!>?.<!>length\n}\n\nfun test2(s: String?) {\n    assert(s!!.isEmpty())\n    s<!NI;UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.length\n}\n\nfun test3(s: String?) {\n    assert(s!!.isEmpty())\n    <!NI;DEBUG_INFO_SMARTCAST!>s<!><!OI;UNSAFE_CALL!>.<!>length\n}\n\nfun test4() {\n    val s: String? = null;\n    assert(s!!.isEmpty())\n    s<!NI;UNNECESSARY_SAFE_CALL!>?.<!>length\n}\n\nfun test5() {\n    val s: String? = null;\n    assert(s!!.isEmpty())\n    s<!NI;UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.length\n}\n\nfun test6() {\n    val s: String? = null;\n    assert(s!!.isEmpty())\n    <!NI;DEBUG_INFO_SMARTCAST!>s<!><!OI;UNSAFE_CALL!>.<!>length\n}\n\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !IGNORE_DATA_FLOW_IN_ASSERT\n// SKIP_TXT\n// WITH_RUNTIME\n\ninterface A {}\n\nclass B: A {\n    fun bool() = true\n}\n\nfun test1(a: A) {\n    assert((a as B).bool())\n    <!NI;DEBUG_INFO_SMARTCAST!>a<!>.<!OI;UNRESOLVED_REFERENCE!>bool<!>()\n}\n\nfun test2() {\n    val a: A? = null;\n    assert((a as B).bool())\n    <!NI;DEBUG_INFO_SMARTCAST!>a<!><!NI;UNNECESSARY_SAFE_CALL!>?.<!><!OI;UNRESOLVED_REFERENCE!>bool<!>()\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun test(mc: MutableCollection<out CharSequence>) {\n    mc.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>mc<!>)\n\n    mc.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>arrayListOf<CharSequence>()<!>)\n    mc.addAll(arrayListOf())\n\n    mc.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>listOf(\"\")<!>)\n    mc.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>listOf<String>(\"\")<!>)\n    mc.addAll(<!NI;TYPE_MISMATCH, OI;TYPE_MISMATCH_DUE_TO_TYPE_PROJECTIONS!>listOf<CharSequence>(\"\")<!>)\n\n    mc.addAll(emptyList())\n    mc.addAll(emptyList<Nothing>())\n}\n"
        },
        {
            "code": "import java.io.InputStream\n\nfun InputStream.test() {\n    readBytes()\n\n    <!DEPRECATION!>readBytes<!>(1)\n}\n"
        },
        {
            "code": "// FILE: a.kt\nfun main(args: Array<String>) {}\n\n// FILE: b.kt\nfun main(args: Array<String>) {}\n\n// FILE: c.kt\nfun foo() { <!OVERLOAD_RESOLUTION_AMBIGUITY!>main<!>(arrayOf(\"a\", \"b\")) }"
        },
        {
            "code": "// !CHECK_TYPE\n// !LANGUAGE: -AdditionalBuiltInsMembers\n// !WITH_NEW_INFERENCE\n// SKIP_TXT\n// FULL_JDK\n\nclass A : java.util.ArrayList<String>() {\n    // `stream` is defined in ArrayList, so it was impossible to override it in 1.0\n    <!NOTHING_TO_OVERRIDE!>override<!> fun stream(): java.util.stream.Stream<String> = super.<!UNRESOLVED_REFERENCE!>stream<!>()\n\n    // `sort` is defined in ArrayList, so it was possible to override it in 1.0\n    override fun sort(c: Comparator<in String>?) {\n        super.sort(c)\n    }\n}\n\nclass A1 : java.util.ArrayList<String>() {\n    // `stream` is defined in ArrayList, so it was possible to declare it in 1.0 without an 'override' keyword\n    fun stream(): java.util.stream.Stream<String> = super.<!UNRESOLVED_REFERENCE!>stream<!>()\n\n    // `sort` is defined in ArrayList, so it was impossible to declare it in 1.0 without an 'override' keyword\n    fun <!VIRTUAL_MEMBER_HIDDEN!>sort<!>(c: Comparator<in String>?) {\n        super.sort(c)\n    }\n}\n\ninterface A2 : List<String> {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun stream(): java.util.stream.Stream<String> = null!!\n}\n\nclass B : <!OI;NONE_APPLICABLE!>Throwable<!>(<!NI;TOO_MANY_ARGUMENTS!>\"\"<!>, <!NI;TOO_MANY_ARGUMENTS!>null<!>, <!NI;TOO_MANY_ARGUMENTS!>false<!>, <!NI;TOO_MANY_ARGUMENTS!>false<!>)\n\nclass B1 : RuntimeException() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun fillInStackTrace(): Throwable { // 'override' keyword must be prohibited, as it was in 1.0.x\n        return this\n    }\n}\n\nclass A3(val x: List<String>) : List<String> by x\n\nfun Throwable.fillInStackTrace() = 1\n\nfun foo(x: List<String>, y: Throwable, z: A3) {\n    x.<!UNRESOLVED_REFERENCE!>stream<!>()\n    java.util.ArrayList<String>().<!UNRESOLVED_REFERENCE!>stream<!>()\n\n    y.fillInStackTrace() checkType { _<Int>() }\n\n    HashMap<String, Int>().getOrDefault(Any(), null)\n\n    // Falls back to extension in stdlib\n    y.printStackTrace()\n\n    z.<!UNRESOLVED_REFERENCE!>stream<!>()\n}\n\ninterface X {\n    fun foo(): Int = 1\n    val hidden: Boolean\n}\n\nclass Y : X {\n    // There should not be UNSUPPORTED_FEATURE diagnostic\n    override fun foo() = 1\n    override var hidden: Boolean = true\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nabstract class A : MutableList<String> {\n    override fun sort(/*0*/ p0: java.util.Comparator<in String>) {\n        <!NI;SUPER_CANT_BE_EXTENSION_RECEIVER!>super<!>.<!NI;DEPRECATION_ERROR, OI;DEFAULT_METHOD_CALL_FROM_JAVA6_TARGET_ERROR!>sort<!>(p0)\n    }\n}\n\nfun foo(x: MutableList<String>, y: java.util.ArrayList<String>, z: A, p: java.util.Comparator<in String>) {\n    x.<!DEPRECATION_ERROR!>sort<!>(p)\n    y.<!DEPRECATION_ERROR!>sort<!>(p)\n\n    z.<!DEPRECATION_ERROR!>sort<!>(p)\n}\n\nfun bar(x: MutableList<String>, y: java.util.ArrayList<String>, z: A) {\n    x.<!DEPRECATION_ERROR!>sort<!> { a, b -> a.length - b.length }\n    y.<!DEPRECATION_ERROR!>sort<!> { a, b -> a.length - b.length }\n\n    z.<!DEPRECATION_ERROR!>sort<!> { a, b -> a.length - b.length }\n}\n"
        },
        {
            "code": "import kotlin.collections.map as map1\nimport kotlin.Array as KotlinArray\n\nfun f() {\n    listOf(1).map1 { it.hashCode() }\n    listOf(1).<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>map<!> { <!UNRESOLVED_REFERENCE!>it<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>hashCode<!>() }\n}\n\nfun g(<!UNUSED_PARAMETER!>a1<!>: KotlinArray<Int>, <!UNUSED_PARAMETER!>a2<!>: <!UNRESOLVED_REFERENCE!>Array<!><Int>){}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\nimport java.util.*\n\nfun bar(): String? = null\n\nfun foo() {\n    var x = ArrayList<String?>()\n    x.add(null)\n    x.add(bar())\n    x.add(\"\")\n\n    x[0] = null\n    x[0] = bar()\n    x[0] = \"\"\n\n    val b1: MutableList<String?> = x\n    val b2: MutableList<String> = <!TYPE_MISMATCH!>x<!>\n    val b3: List<String?> = x\n\n    val b4: Collection<String?> = x\n    val b6: MutableCollection<String?> = x\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// JAVAC_EXPECTED_FILE\n\nimport java.util.*;\n\n// FILE: b.kt\n\nfun bar(): String? = null\n\nfun foo() {\n    var x = A<String>()\n    x.add(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.add(<!TYPE_MISMATCH!>bar()<!>)\n    x.add(\"\")\n\n    x[0] = <!NULL_FOR_NONNULL_TYPE!>null<!>\n    x[0] = <!TYPE_MISMATCH!>bar()<!>\n    x[0] = \"\"\n\n    val b1: MutableList<String?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableList<String> = x\n    val b3: List<String?> = x\n\n    val b4: Collection<String?> = x\n    val b6: MutableCollection<String?> = <!TYPE_MISMATCH!>x<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\nimport java.util.*\n\nfun bar(): String? = null\n\nfun fooHashSet() {\n    var x = HashSet<String>()\n    x.add(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.add(<!TYPE_MISMATCH!>bar()<!>)\n    x.add(\"\")\n\n    val b1: MutableSet<String?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableSet<String> = x\n    val b3: Set<String?> = x\n\n    val b4: Collection<String?> = x\n    val b6: MutableCollection<String?> = <!TYPE_MISMATCH!>x<!>\n}\n\nfun fooTreeSet() {\n    var x = TreeSet<String>()\n    x.add(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.add(<!TYPE_MISMATCH!>bar()<!>)\n    x.add(\"\")\n\n    val b1: MutableSet<String?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableSet<String> = x\n    val b3: Set<String?> = x\n\n    val b4: Collection<String?> = x\n    val b6: MutableCollection<String?> = <!TYPE_MISMATCH!>x<!>\n}\n\nfun fooLinkedHashSet() {\n    var x = LinkedHashSet<String>()\n    x.add(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.add(<!TYPE_MISMATCH!>bar()<!>)\n    x.add(\"\")\n\n    val b1: MutableSet<String?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableSet<String> = x\n    val b3: Set<String?> = x\n\n    val b4: Collection<String?> = x\n    val b6: MutableCollection<String?> = <!TYPE_MISMATCH!>x<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\nimport java.util.*\nimport java.util.concurrent.*\n\nfun bar(): String? = null\nval nullableInt: Int? = null\n\nfun hashMapTest() {\n    var x: HashMap<String, Int> = HashMap<String, Int>()\n    x.put(<!NULL_FOR_NONNULL_TYPE!>null<!>, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(<!TYPE_MISMATCH!>bar()<!>, 1)\n    x.put(\"\", 1)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;NULL_FOR_NONNULL_TYPE!>null<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;TYPE_MISMATCH!>bar()<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[\"\"]<!> = <!NI;TYPE_MISMATCH!>nullableInt<!>\n    x[\"\"] = 1\n\n    val b1: MutableMap<String, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String, Int> = x\n    val b3: Map<String?, Int> = <!TYPE_MISMATCH!>x<!>\n    val b4: Map<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b5: Map<String, Int?> = x\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b8: Int? = x.get(\"\")\n}\n\nfun treeMapTest() {\n    var x: TreeMap<String, Int> = TreeMap<String, Int>()\n    x.put(<!NULL_FOR_NONNULL_TYPE!>null<!>, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(<!TYPE_MISMATCH!>bar()<!>, 1)\n    x.put(\"\", 1)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;NULL_FOR_NONNULL_TYPE!>null<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;TYPE_MISMATCH!>bar()<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[\"\"]<!> = <!NI;TYPE_MISMATCH!>nullableInt<!>\n    x[\"\"] = 1\n\n    val b1: MutableMap<String, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String, Int> = x\n    val b3: Map<String?, Int> = <!TYPE_MISMATCH!>x<!>\n    val b4: Map<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b5: Map<String, Int?> = x\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b8: Int? = x.get(\"\")\n}\n\nfun concurrentHashMapTest() {\n    var x: ConcurrentHashMap<String, Int> = ConcurrentHashMap<String, Int>()\n    x.put(<!NULL_FOR_NONNULL_TYPE!>null<!>, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(<!TYPE_MISMATCH!>bar()<!>, 1)\n    x.put(\"\", 1)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;NULL_FOR_NONNULL_TYPE!>null<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;TYPE_MISMATCH!>bar()<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[\"\"]<!> = <!NI;TYPE_MISMATCH!>nullableInt<!>\n    x[\"\"] = 1\n\n    val b1: MutableMap<String, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String, Int> = x\n    val b3: Map<String?, Int> = <!TYPE_MISMATCH!>x<!>\n    val b4: Map<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b5: Map<String, Int?> = x\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b8: Int? = x.get(\"\")\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// JAVAC_EXPECTED_FILE\n\nimport java.util.*;\n\n// FILE: b.kt\n\nfun bar(): String? = null\n\nfun foo() {\n    var x = A<String>()\n    x.add(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.add(<!TYPE_MISMATCH!>bar()<!>)\n    x.add(\"\")\n\n    val b1: Collection<String?> = x\n    val b2: MutableCollection<String?> = <!TYPE_MISMATCH!>x<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\nimport java.util.*\n\nfun bar(): String? = null\n\nfun foo() {\n    var x = ArrayList<String>()\n    x.add(<!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.add(<!TYPE_MISMATCH!>bar()<!>)\n    x.add(\"\")\n\n    x[0] = <!NULL_FOR_NONNULL_TYPE!>null<!>\n    x[0] = <!TYPE_MISMATCH!>bar()<!>\n    x[0] = \"\"\n\n    val b1: MutableList<String?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableList<String> = x\n    val b3: List<String?> = x\n\n    val b4: Collection<String?> = x\n    val b6: MutableCollection<String?> = <!TYPE_MISMATCH!>x<!>\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\nimport java.util.*\n\nfun bar(): String? = null\nval nullableInt: Int? = null\n\nfun hashMapTest() {\n    var x: HashMap<String?, Int> = HashMap<String?, Int>()\n    x.put(null, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(bar(), 1)\n    x.put(\"\", 1)\n\n    x[null] = 1\n    x[bar()] = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[\"\"]<!> = <!NI;TYPE_MISMATCH!>nullableInt<!>\n    x[\"\"] = 1\n\n    val b1: MutableMap<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String?, Int> = x\n    val b3: Map<String?, Int> = x\n    val b4: Map<String?, Int?> = x\n    val b5: Map<String, Int?> = <!TYPE_MISMATCH!>x<!>\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x[null]<!>\n    val b8: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b9: Int? = x.get(\"\")\n}\n\nfun treeMapTest() {\n    var x: TreeMap<String?, Int> = TreeMap<String?, Int>()\n    x.put(null, <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(\"\", <!NULL_FOR_NONNULL_TYPE!>null<!>)\n    x.put(bar(), 1)\n    x.put(\"\", 1)\n\n    x[null] = 1\n    x[bar()] = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[\"\"]<!> = <!NI;TYPE_MISMATCH!>nullableInt<!>\n    x[\"\"] = 1\n\n    val b1: MutableMap<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String?, Int> = x\n    val b3: Map<String?, Int> = x\n    val b4: Map<String?, Int?> = x\n    val b5: Map<String, Int?> = <!TYPE_MISMATCH!>x<!>\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b8: Int? = x.get(\"\")\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\nimport java.util.*\n\nfun bar(): String? = null\nval nullableInt: Int? = null\n\nfun hashMapTest() {\n    var x: HashMap<String, Int?> = HashMap<String, Int?>()\n    x.put(<!NULL_FOR_NONNULL_TYPE!>null<!>, null)\n    x.put(\"\", null)\n    x.put(<!TYPE_MISMATCH!>bar()<!>, 1)\n    x.put(\"\", 1)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;NULL_FOR_NONNULL_TYPE!>null<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;TYPE_MISMATCH!>bar()<!>]<!> = 1\n    x[\"\"] = nullableInt\n    x[\"\"] = 1\n\n    val b1: MutableMap<String, Int> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String, Int?> = x\n    val b3: Map<String, Int> = <!TYPE_MISMATCH!>x<!>\n    val b4: Map<String, Int?> = x\n    val b5: Map<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b8: Int? = x.get(\"\")\n}\n\nfun treeMapTest() {\n    var x: TreeMap<String, Int?> = TreeMap<String, Int?>()\n    x.put(<!NULL_FOR_NONNULL_TYPE!>null<!>, null)\n    x.put(\"\", null)\n    x.put(<!TYPE_MISMATCH!>bar()<!>, 1)\n    x.put(\"\", 1)\n\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;NULL_FOR_NONNULL_TYPE!>null<!>]<!> = 1\n    <!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>x[<!NI;TYPE_MISMATCH!>bar()<!>]<!> = 1\n    x[\"\"] = nullableInt\n    x[\"\"] = 1\n\n    val b1: MutableMap<String, Int> = <!TYPE_MISMATCH!>x<!>\n    val b2: MutableMap<String, Int?> = x\n    val b3: Map<String, Int> = <!TYPE_MISMATCH!>x<!>\n    val b4: Map<String, Int?> = x\n    val b5: Map<String?, Int?> = <!TYPE_MISMATCH!>x<!>\n\n    val b6: Int = <!TYPE_MISMATCH!>x[\"\"]<!>\n    val b7: Int = <!TYPE_MISMATCH!>x.get(\"\")<!>\n\n    val b8: Int? = x.get(\"\")\n}\n"
        },
        {
            "code": "\n// FILE: main.kt\n\nclass <!UNSUPPORTED(\"Inheritance of a Java member referencing 'kotlin.jvm.functions.FunctionN': fun foo(w: FunctionN<*>!): Unit defined in A\")!>B<!> : A()\n\nfun foo() {\n    <!UNSUPPORTED(\"Inheritance of a Java member referencing 'kotlin.jvm.functions.FunctionN': fun foo(w: FunctionN<*>!): Unit defined in A\")!>object<!> : A() {}\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nclass A : java.util.concurrent.ConcurrentHashMap<String, Int>() {\n    operator fun contains(<!UNUSED_PARAMETER!>x<!>: Char): Boolean = true\n}\nclass B : java.util.concurrent.ConcurrentHashMap<String, Int>() {\n    override fun contains(value: Any?): Boolean {\n        return super.contains(value)\n    }\n}\n\nclass C : java.util.concurrent.ConcurrentHashMap<String, Int>() {\n    operator override fun contains(value: Any?): Boolean {\n        return super.contains(value)\n    }\n}\n\nfun main() {\n    val hm = java.util.concurrent.ConcurrentHashMap<String, Int>()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> hm\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> hm\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> hm\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> hm\n\n    hm.contains(\"\")\n    hm.contains(1)\n\n    \"\" in (hm as Map<String, Int>)\n    \"\" !in (hm as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (hm as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (hm as Map<String, Int>)\n\n    val a = A()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> a\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> a\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> a\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> a\n\n    ' ' in a\n    ' ' !in a\n    a.contains(\"\")\n    a.contains(1)\n\n    \"\" in (a as Map<String, Int>)\n    \"\" !in (a as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (a as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (a as Map<String, Int>)\n\n    val b = B()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> b\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> b\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> b\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> b\n\n    b.contains(\"\")\n    b.contains(1)\n\n    \"\" in (b as Map<String, Int>)\n    \"\" !in (b as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (b as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (b as Map<String, Int>)\n\n    // Actually, we could've allow calls here because the owner explicitly declared as operator, but semantics is still weird\n    val c = C()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> c\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> c\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>!in<!> c\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR!>in<!> c\n\n    c.contains(\"\")\n    c.contains(1)\n\n    \"\" in (c as Map<String, Int>)\n    \"\" !in (c as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (c as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (c as Map<String, Int>)\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER\n\n// FILE: KI.kt\n\ninterface KI {\n    fun manyParams(x: (String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String) -> Unit)\n}\n\n// FILE: main.kt\n\nfun <T> any(): T = null!!\n\nfun main() {\n    val a: A = <!DEPRECATION_ERROR!>A<!>(null)\n\n    a.<!DEPRECATION_ERROR!>field<!>.hashCode();\n    a.<!DEPRECATION_ERROR!>field<!> = null;\n\n    a.<!DEPRECATION_ERROR!>foo<!>(null)\n    a.<!DEPRECATION_ERROR!>bar<!>()\n    a.<!DEPRECATION_ERROR!>baz<!>(listOf())\n\n    a.<!DEPRECATION_ERROR!>manyParams<!>(null)\n    a.<!NONE_APPLICABLE!>manyParams<!>(any<kotlin.jvm.functions.FunctionN<Unit>>())\n\n    // Potentially, this would have better to forbid calling manyParams, too.\n    // But it might be complicated because we need to match that it is an override\n    // Seems to be fine because `A::manyParams` is anyway an override in JVM and can be called with (a as K)\n    a.manyParams {\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32 ->\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ProhibitConcurrentHashMapContains\n// !WITH_NEW_INFERENCE\n// FULL_JDK\n\nclass A : java.util.concurrent.ConcurrentHashMap<String, Int>() {\n    operator fun contains(<!UNUSED_PARAMETER!>x<!>: Char): Boolean = true\n}\nclass B : java.util.concurrent.ConcurrentHashMap<String, Int>() {\n    override fun contains(value: Any?): Boolean {\n        return super.contains(value)\n    }\n}\n\nclass C : java.util.concurrent.ConcurrentHashMap<String, Int>() {\n    operator override fun contains(value: Any?): Boolean {\n        return super.contains(value)\n    }\n}\n\nfun main() {\n    val hm = java.util.concurrent.ConcurrentHashMap<String, Int>()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> hm\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> hm\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> hm\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> hm\n\n    hm.contains(\"\")\n    hm.contains(1)\n\n    \"\" in (hm as Map<String, Int>)\n    \"\" !in (hm as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (hm as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (hm as Map<String, Int>)\n\n    val a = A()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> a\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> a\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> a\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> a\n\n    ' ' in a\n    ' ' !in a\n    a.contains(\"\")\n    a.contains(1)\n\n    \"\" in (a as Map<String, Int>)\n    \"\" !in (a as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (a as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (a as Map<String, Int>)\n\n    val b = B()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> b\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> b\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> b\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> b\n\n    b.contains(\"\")\n    b.contains(1)\n\n    \"\" in (b as Map<String, Int>)\n    \"\" !in (b as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (b as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (b as Map<String, Int>)\n\n    // Actually, we could've allow calls here because the owner explicitly declared as operator, but semantics is still weird\n    val c = C()\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> c\n    \"\" <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> c\n    1 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>!in<!> c\n    2 <!CONCURRENT_HASH_MAP_CONTAINS_OPERATOR_ERROR!>in<!> c\n\n    c.contains(\"\")\n    c.contains(1)\n\n    \"\" in (c as Map<String, Int>)\n    \"\" !in (c as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>in<!> (c as Map<String, Int>)\n    1 <!NI;TYPE_INFERENCE_ONLY_INPUT_TYPES, OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>!in<!> (c as Map<String, Int>)\n}\n\n"
        },
        {
            "code": "// KT-9051: Allow smart cast for captured variables if they are not modified\n\nfun foo(y: String?) {\n    var x: String? = \"\"\n    if (x != null) {\n        y?.let { x = null }\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.length // Smart cast is not possible\n    }\n}\n"
        },
        {
            "code": "// Based on KT-9033\nfun f(s: String) = s\n\nfun foo(s: String?) {\n    s?.let { f(<!DEBUG_INFO_SMARTCAST!>s<!>) }\n    s?.let { f(it) }\n}"
        },
        {
            "code": "// KT-9051: Allow smart cast for captured variables if they are not modified\n\nfun foo(y: String) {\n    var x: String? = <!VARIABLE_WITH_REDUNDANT_INITIALIZER!>null<!>\n    y.let { x = it }\n    x<!UNSAFE_CALL!>.<!>length // Smart cast is not possible\n}\n"
        },
        {
            "code": "// KT-9051: Allow smart cast for captured variables if they are not modified\n\nfun foo(y: String?) {\n    var x: String? = null\n    y?.let { x = it }\n    x<!UNSAFE_CALL!>.<!>length // Smart cast is not possible\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// KT-7186: False \"Type mismatch\" error\n\nfun indexOfMax(a: IntArray): Int? {\n    var maxI: Int? = null\n    a.forEachIndexed { i, value ->\n        if (maxI == null || value >= a[<!NI;SMARTCAST_IMPOSSIBLE, SMARTCAST_IMPOSSIBLE!>maxI<!>]) {\n            maxI = i\n        }\n    }\n    return maxI\n}"
        },
        {
            "code": "// KT-9051: Allow smart cast for captured variables if they are not modified\n\nfun bar(z: String?) = z\n\nfun foo(y: String?) {\n    var x: String? = \"\"\n    if (x != null) {\n        bar(y?.let { x = null; it })<!UNSAFE_CALL!>.<!>length\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.length // Smart cast is not possible\n    }\n}\n"
        },
        {
            "code": "val test: Int = listOf<Any>().map {\n    when (it) {\n        is Int -> <!DEBUG_INFO_SMARTCAST!>it<!>\n        else -> throw AssertionError()\n    }\n}.sum()"
        },
        {
            "code": "// KT-7186: False \"Type mismatch\" error\n\nfun indexOfMax(a: IntArray): Int? {\n    var maxI: Int? = 0\n    a.forEachIndexed { i, value ->\n        if (value >= a[<!TYPE_MISMATCH!>maxI<!>]) {\n            maxI = i\n        }\n        else if (value < 0) {\n            maxI = null\n        }\n    }\n    return maxI\n}"
        },
        {
            "code": "fun foo(y: String?) {\n    var x: String? = \"\"\n    if (x != null) {\n        with(y?.let { x = null; it }) {\n            this<!UNSAFE_CALL!>.<!>length\n            <!SMARTCAST_IMPOSSIBLE!>x<!>.length\n        }\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.length\n    }\n}\n"
        },
        {
            "code": "// KT-9051: Allow smart cast for captured variables if they are not modified\n\nfun foo(y: String?) {\n    var x: String? = null\n    if (x != null) {\n        y?.let { x = it }\n        <!SMARTCAST_IMPOSSIBLE!>x<!>.length // not-null or not-null\n    }\n}\n"
        },
        {
            "code": "class My(val x: Int?) {\n    val y: Int? by lazy {\n        var z = x\n        while (z != null) {\n            z = <!DEBUG_INFO_SMARTCAST!>z<!>.hashCode()\n            if (<!DEBUG_INFO_SMARTCAST!>z<!> < 0) return@lazy z\n            if (z == 0) z = null\n        }\n        return@lazy null\n    }\n}"
        },
        {
            "code": "// KT-9051: Allow smart cast for captured variables if they are not modified\n\nfun foo(y: String?) {\n    var x: String? = \"\"\n    if (x != null) {\n        y?.let { x != y }\n        // x is not changed, smart cast is possible\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n}\n"
        },
        {
            "code": "import kotlin.jvm.*\n\ninterface Tr {\n    <!EXTERNAL_DECLARATION_IN_INTERFACE!>external fun foo()<!>\n    <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY, EXTERNAL_DECLARATION_IN_INTERFACE!>external fun bar()<!> {}\n\n    companion object {\n        external fun foo()\n        <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun bar()<!> {}\n    }\n}"
        },
        {
            "code": "import kotlin.jvm.*\n\nexternal fun <<!REIFIED_TYPE_PARAMETER_NO_INLINE!>reified<!> T> foo()\n<!EXTERNAL_DECLARATION_CANNOT_BE_INLINED!>inline external fun <reified T> bar()<!>"
        },
        {
            "code": "import kotlin.jvm.*\n\nabstract class C {\n    <!EXTERNAL_DECLARATION_CANNOT_BE_INLINED!><!NOTHING_TO_INLINE!>inline<!> external fun foo()<!>\n}\n\nfun test() {\n    abstract class Local {\n        <!EXTERNAL_DECLARATION_CANNOT_BE_INLINED!><!NOTHING_TO_INLINE!>inline<!> external fun foo()<!>\n    }\n}"
        },
        {
            "code": "import kotlin.jvm.*\n\nabstract class C {\n    <!EXTERNAL_DECLARATION_CANNOT_BE_ABSTRACT!>abstract<!> external fun foo()\n}\n\nfun test() {\n    abstract class Local {\n        <!EXTERNAL_DECLARATION_CANNOT_BE_ABSTRACT!>abstract<!> external fun foo()\n    }\n}"
        },
        {
            "code": "import kotlin.jvm.*\n\n<!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun foo()<!> {}\n\nclass C {\n    <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun foo()<!> {}\n\n    companion object {\n        <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun foo()<!> {}\n    }\n}\n\nobject O {\n    <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun foo()<!> {}\n}\n\nfun test() {\n    class Local {\n        <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun foo()<!> {}\n    }\n\n    object {\n        <!EXTERNAL_DECLARATION_CANNOT_HAVE_BODY!>external fun foo()<!> {}\n    }\n}"
        },
        {
            "code": "class A {\n    <!WRONG_MODIFIER_TARGET!>external<!> constructor() {}\n    inner class B {\n        <!WRONG_MODIFIER_TARGET!>external<!> constructor() {}\n    }\n\n    <!WRONG_MODIFIER_TARGET!>external<!> constructor(<!UNUSED_PARAMETER!>x<!>: Int)\n}\n\nclass C <!WRONG_MODIFIER_TARGET!>external<!> constructor()"
        },
        {
            "code": "<!WRONG_MODIFIER_TARGET!>external class A<!>\n\n<!WRONG_MODIFIER_TARGET!>external val foo: Int = 23<!>\n\nclass B {\n    <!WRONG_MODIFIER_TARGET!>external class A<!>\n\n    <!WRONG_MODIFIER_TARGET!>external val foo: Int = 23<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nimport java.util.*\n\nfun <T> nullable(x: T): T? = x\n\n@Suppress(\"UNUSED_PARAMETER\")\nfun <T> select(x1: T, x2: T): T = x1\n\nval test1 =\n        listOf(1, 2, 3).mapNotNullTo(ArrayList()) {\n            if (true) nullable(it) else null\n        }\n\nval test2: MutableList<Int?> =\n        listOf(1, 2, 3).mapNotNullTo(ArrayList()) {\n            if (true) nullable(it) else null\n        }\n\nval test3: MutableList<Int> =\n        listOf(1, 2, 3).mapNotNullTo(ArrayList()) {\n            if (true) nullable(it) else null\n        }\n\nval test4: Collection<Int> =\n        listOf(1, 2, 3).flatMapTo(LinkedHashSet()) {\n            listOf(it)\n        }\n\nval test5: Collection<Int> =\n        listOf(1, 2, 3).<!OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>flatMapTo(<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>LinkedHashSet<!>()) { // TODO\n            if (true) listOf(it) else listOf(it)\n        }<!>\n\nval test6: Collection<Int> =\n        listOf(1, 2, 3).flatMapTo(LinkedHashSet<Int>()) {\n            if (true) listOf(it) else listOf(it)\n        }\n\nval test7: Collection<Int> =\n        listOf(1, 2, 3).flatMapTo(LinkedHashSet()) {\n            select(listOf(it), listOf(it))\n        }"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// FILE: test.kt\n\ninterface Base {\n    var x: String\n}\n\nopen class Foo : Base {\n    override lateinit var x: String\n    private lateinit var y: String\n\n    var nonLateInit: Int = 1\n\n    fun ok() {\n        val b: Boolean = this::x.isInitialized\n\n        val otherInstance = Foo()\n        otherInstance::x.isInitialized\n\n        (this::x).isInitialized\n        (@Suppress(\"ALL\") (this::x)).isInitialized\n\n        object {\n            fun local() {\n                class Local {\n                    val xx = this@Foo::x.isInitialized\n                    val yy = this@Foo::y.isInitialized\n                }\n            }\n        }\n    }\n\n    fun onLiteral() {\n        val p = this::x\n        p.<!LATEINIT_INTRINSIC_CALL_ON_NON_LITERAL!>isInitialized<!>\n    }\n\n    fun onNonLateinit() {\n        this::nonLateInit.<!LATEINIT_INTRINSIC_CALL_ON_NON_LATEINIT!>isInitialized<!>\n    }\n\n    inline fun inlineFun() {\n        this::x.<!LATEINIT_INTRINSIC_CALL_IN_INLINE_FUNCTION!>isInitialized<!>\n\n        object {\n            val z = this@Foo::x.isInitialized\n        }\n    }\n\n    inner class InnerSubclass : Foo() {\n        fun innerOk() {\n            // This is access to Foo.x declared lexically above\n            this@Foo::x.isInitialized\n\n            // This is access to InnerSubclass.x which is inherited from Foo.x\n            this::x.isInitialized\n        }\n    }\n}\n\nfun onNonAccessible() {\n    Foo()::x.<!LATEINIT_INTRINSIC_CALL_ON_NON_ACCESSIBLE_PROPERTY!>isInitialized<!>\n}\n\nfun onNonLateinit() {\n    Foo()::nonLateInit.<!LATEINIT_INTRINSIC_CALL_ON_NON_LATEINIT!>isInitialized<!>\n}\n\nobject Unrelated {\n    fun onNonAccessible() {\n        Foo()::x.<!LATEINIT_INTRINSIC_CALL_ON_NON_ACCESSIBLE_PROPERTY!>isInitialized<!>\n    }\n}\n\nclass FooImpl : Foo() {\n    fun onNonAccessible() {\n        this::x.<!LATEINIT_INTRINSIC_CALL_ON_NON_ACCESSIBLE_PROPERTY!>isInitialized<!>\n    }\n}\n\n// FILE: other.kt\n\nclass OtherFooImpl : Foo() {\n    fun onNonAccessible() {\n        this::x.<!LATEINIT_INTRINSIC_CALL_ON_NON_ACCESSIBLE_PROPERTY!>isInitialized<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\n<!SYNCHRONIZED_ON_INLINE!>@Synchronized<!>\ninline fun foo(f: () -> Unit): Unit = f()\n\nvar bar: String\n    <!SYNCHRONIZED_ON_INLINE!>@Synchronized<!>\n    inline get() = \"\"\n    <!SYNCHRONIZED_ON_INLINE!>@Synchronized<!>\n    inline set(value) {}\n\ninline var baz: String\n    <!SYNCHRONIZED_ON_INLINE!>@Synchronized<!>\n    get() = \"\"\n    <!SYNCHRONIZED_ON_INLINE!>@Synchronized<!>\n    set(value) {}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nvar longWords = 0\nval smallWords = hashSetOf<String>()\n\nfun test1(word: String) =\n        run {\n            if (word.length > 4) {\n                <!OI;IMPLICIT_CAST_TO_ANY!>longWords++<!>\n            }\n            else {\n                <!OI;IMPLICIT_CAST_TO_ANY!>smallWords.add(word)<!>\n            }\n        }\n\nfun test2(word: String) =\n        run {\n            if (word.length > 4) {\n                <!INVALID_IF_AS_EXPRESSION!>if<!> (word.startsWith(\"a\")) <!OI;IMPLICIT_CAST_TO_ANY!>longWords++<!>\n            }\n            else {\n                <!OI;IMPLICIT_CAST_TO_ANY!>smallWords.add(word)<!>\n            }\n        }\n\nfun test3(word: String) =\n        run {\n            if (word.length > 4) {\n                longWords++\n            }\n            else {\n                System.out?.println(word) // Unit?\n            }\n        }"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: -Coroutines -ReleaseCoroutines\n\n<!UNSUPPORTED_FEATURE!>suspend<!> fun suspendHere(): String = \"OK\"\n\nfun builder(c: <!UNSUPPORTED_FEATURE!>suspend<!> () -> Unit) {\n\n}\n\nfun box(): String {\n    var result = \"\"\n\n    <!UNSUPPORTED_FEATURE!>builder<!> {\n        suspendHere()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// SKIP_TXT\n\nimport kotlin.reflect.*\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class A<!>: <!SUPERTYPE_IS_KSUSPEND_FUNCTION_TYPE!>KSuspendFunction0<Unit><!> {}"
        },
        {
            "code": "// FILE: main.kt\ninterface A {\n    <!CONFLICTING_OVERLOADS!>suspend fun foo()<!>\n    <!CONFLICTING_OVERLOADS!>fun foo()<!>\n}\n\ninterface B : A {\n    <!CONFLICTING_OVERLOADS, CONFLICTING_OVERLOADS!>suspend override fun foo()<!> {\n\n    }\n\n    <!CONFLICTING_OVERLOADS, CONFLICTING_OVERLOADS!>override fun foo()<!> {\n\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_TXT\n// WITH_RUNTIME\n\nimport kotlin.coroutines.*\n\ninterface Job : CoroutineContext.Element {}\ninterface Deferred<out T> : Job {\n    suspend fun await(): T\n}\nfun <T> async(<!UNUSED_PARAMETER!>block<!>: suspend () -> T): Deferred<T> = TODO()\n\nsuspend fun fib(n: Long) =\n    async {\n        when {\n            n < 2 -> n\n            else -> <!TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM!><!DEBUG_INFO_MISSING_UNRESOLVED!>fib<!>(<!DEBUG_INFO_MISSING_UNRESOLVED!>n<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>-<!> 1)<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>await<!>() <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>+<!> fib(n - 2).<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>await<!>()\n        }\n    }"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines\n// SKIP_TXT\n\nimport kotlin.coroutines.experimental.coroutineContext\n\nsuspend fun test() {\n    <!UNSUPPORTED!>coroutineContext<!>\n}\n"
        },
        {
            "code": "// !API_VERSION: 1.2\n// !DIAGNOSTICS: -PRE_RELEASE_CLASS, -UNUSED_PARAMETER\n// !LANGUAGE: +ReleaseCoroutines\n// !WITH_NEW_INFERENCE\n// SKIP_TXT\n\n<!UNSUPPORTED!>suspend<!> fun dummy() {}\n\n// TODO: Forbid\nfun builder(c: <!UNSUPPORTED!>suspend<!> () -> Unit) {}\n\n<!UNSUPPORTED!>suspend<!> fun test1() {\n    kotlin.coroutines.<!UNRESOLVED_REFERENCE!>coroutineContext<!>\n\n    kotlin.coroutines.experimental.<!UNSUPPORTED!>coroutineContext<!>\n\n    <!UNSUPPORTED!>suspend<!> {}()\n\n    dummy()\n\n    val c: <!UNSUPPORTED!>suspend<!> () -> Unit = {}\n    c()\n\n    <!UNSUPPORTED!>builder<!> {}\n}\n\nfun test2() {\n    kotlin.coroutines.experimental.<!DEPRECATION, UNSUPPORTED!>buildSequence<!><Int> {\n        <!DEPRECATION!>yield<!>(1)\n    }\n    kotlin.sequences.<!UNRESOLVED_REFERENCE!>buildSequence<!><Int> {\n        <!UNRESOLVED_REFERENCE!>yield<!>(1)\n    }\n}\n\n<!UNSUPPORTED!>suspend<!> fun test3(): Unit = kotlin.coroutines.experimental.<!DEPRECATION!>suspendCoroutine<!> { _ -> Unit }\n\n<!UNSUPPORTED!>suspend<!> fun test4(): Unit = kotlin.coroutines.<!UNRESOLVED_REFERENCE!>suspendCoroutine<!> { <!OI;CANNOT_INFER_PARAMETER_TYPE!>_<!> -> Unit }\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nsuspend fun foo() = 1\n\nsuspend fun bar(\n        x: Int = 2 + <!UNSUPPORTED!>foo<!>(),\n        y: suspend () -> Int = { foo() },\n        z: () -> Int = { <!NON_LOCAL_SUSPENSION_POINT!>foo<!>() },\n        w: Int = myInline { <!UNSUPPORTED!>foo<!>() },\n        v: Any? = object {\n            fun x() = <!NON_LOCAL_SUSPENSION_POINT!>foo<!>()\n            suspend fun y() = foo()\n        }\n) {}\n\ninline fun myInline(x: () -> Unit) = 1\n"
        },
        {
            "code": "// !ALLOW_RESULT_RETURN_TYPE\n\nfun result(): Result<Int> = TODO()\nval resultP: Result<Int> = result()\n\nfun f(r1: Result<Int>?) {\n    r1 <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> <!UNUSED_EXPRESSION!>0<!>\n}"
        },
        {
            "code": "// SKIP_TXT\nfun bar() {\n    suspend {\n        <!RETURN_FOR_BUILT_IN_SUSPEND!>return@suspend<!>\n    }\n\n    suspend {\n        run {\n            <!RETURN_FOR_BUILT_IN_SUSPEND!>return@suspend<!>\n        }\n    }\n\n    suspend l@{\n        return@l\n    }\n\n    suspend suspend@{\n        return@suspend\n    }\n\n    val <!UNUSED_VARIABLE!>x<!> = suspend@{\n        suspend {\n            // Might be resolved to outer lambda, but doesn't make sense because suspend-lambdas here is noinline\n            <!RETURN_FOR_BUILT_IN_SUSPEND!>return<!LABEL_NAME_CLASH!>@suspend<!><!>\n        }\n    }\n}\n"
        },
        {
            "code": "// COMMON_COROUTINES_TEST\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n}\n\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.Continuation\nclass K1 : JavaClass()\n\nclass K2 : JavaClass() {\n    override suspend fun foo(x: Int): String = \"\"\n}\n\nclass K3 : JavaClass() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: Int, y: Continuation<String>): Any? = null\n}\n\nfun builder(<!UNUSED_PARAMETER!>block<!>: suspend () -> Unit) {}\n\nfun main(x: Continuation<String>) {\n    JavaClass().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(5, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K1().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(6, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K2().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(7, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K3().foo(8, x)\n\n    builder {\n        JavaClass().foo(1)\n        K1().foo(2)\n        K2().foo(3)\n        K3().foo(4)\n\n        JavaClass().foo(5, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K1().foo(6, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K2().foo(7, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K3().foo(8, x)\n    }\n}\n"
        },
        {
            "code": "interface AsyncVal { suspend fun getVal(): Int = 1}\ninterface SyncVal { fun getVal(): Int = 1 }\n\n<!CONFLICTING_INHERITED_MEMBERS!>class MixSuspend<!> : AsyncVal, SyncVal {\n\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nimport kotlin.reflect.KProperty\n\nclass A {\n    suspend <!UNSUPPORTED!>operator<!> fun get(x: Int) = 1\n    suspend <!UNSUPPORTED!>operator<!> fun set(x: Int, v: String) {}\n\n    <!UNSUPPORTED!>operator<!> suspend fun contains(y: String): Boolean = true\n\n    suspend operator fun unaryPlus() = this\n    suspend operator fun unaryMinus() = this\n    suspend operator fun not() = this\n    suspend operator fun inc() = this\n    suspend operator fun dec() = this\n\n    suspend operator fun plus(a: A) = a\n    suspend operator fun minus(a: A) = a\n    suspend operator fun times(a: A) = a\n    suspend operator fun div(a: A) = a\n    suspend operator fun rem(a: A) = a\n    suspend operator fun rangeTo(a: A) = a\n\n    suspend operator fun invoke(a: A) = a\n\n    suspend operator fun compareTo(a: A) = hashCode().compareTo(a.hashCode())\n\n    suspend operator fun iterator() = this\n    suspend operator fun hasNext() = false\n    suspend operator fun next() = this\n\n    suspend <!UNSUPPORTED!>operator<!> fun contains(b: A) = this == b\n    suspend <!UNSUPPORTED!>operator<!> fun get(a: A) = a\n    suspend <!INAPPLICABLE_OPERATOR_MODIFIER!>operator<!> fun equals(a: A) = a === this\n    suspend <!UNSUPPORTED!>operator<!> fun set(a: A, b: A) {}\n\n    suspend <!UNSUPPORTED!>operator<!> fun provideDelegate(a: A, p: KProperty<*>) = a\n    suspend <!UNSUPPORTED!>operator<!> fun getValue(a: A, p: KProperty<*>) = a\n    suspend <!UNSUPPORTED!>operator<!> fun setValue(a: A, p: KProperty<*>, b: A) {}\n}\n\nclass B\nsuspend <!UNSUPPORTED!>operator<!> fun B.get(x: Int) =1\nsuspend <!UNSUPPORTED!>operator<!> fun B.set(x: Int, v: String) {}\n\n<!UNSUPPORTED!>operator<!> suspend fun B.contains(y: String): Boolean = true\n\nclass C {\n    suspend fun get(x: Int) = 1\n    suspend fun set(x: Int, v: String) {}\n\n    suspend fun contains(y: String): Boolean = true\n}\n\nclass D\nsuspend fun D.get(x: Int) =1\nsuspend fun D.set(x: Int, v: String) {}\n\nsuspend fun D.contains(y: String): Boolean = true\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\nimport kotlin.experimental.ExperimentalTypeInference\n\nclass GenericController<T> {\n    suspend fun yield(t: T) {}\n}\n\nfun <S> generate(@BuilderInference g: suspend GenericController<S>.() -> Unit): List<S> = TODO()\n\n@BuilderInference\nsuspend fun <S> GenericController<List<S>>.yieldGenerate(g: suspend GenericController<S>.() -> Unit): Unit = TODO()\n\nval test1 = generate {\n    // TODO: KT-15185\n    <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR, OI;TYPE_MISMATCH!>yieldGenerate<!> {\n        yield(4)\n    }\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Controller<T> {\n    suspend fun yield(t: T) {}\n}\n\nfun <S> generate(g: suspend Controller<S>.() -> Unit): S = TODO()\n\nval test1 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    apply {\n        yield(4)\n    }\n}\n\nval test2 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(B)\n    apply {\n        yield(C)\n    }\n}\n\nval test3 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    this.<!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>let<!> {\n        yield(B)\n    }\n\n    apply {\n        yield(C)\n    }\n}\n\ninterface A\nobject B : A\nobject C : A"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_ANONYMOUS_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass GenericController<T> {\n    suspend fun yield(t: T) {}\n}\n\nfun <S> generate(g: suspend GenericController<S>.(S) -> Unit): S = TODO()\n\nval test1 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(4)\n}\n\nval test2 = generate<Int> {\n    yield(4)\n}\n\nval test3 = generate { bar: Int ->\n    yield(4)\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// FILE: annotation.kt\n// NI_EXPECTED_FILE\n\npackage kotlin\n\nannotation class BuilderInference\n\n// FILE: test.kt\n\nclass Builder<T> {\n    fun add(t: T) {}\n}\n\nfun <S> build(@BuilderInference g: Builder<S>.() -> Unit): List<S> = TODO()\nfun <S> wrongBuild(g: Builder<S>.() -> Unit): List<S> = TODO()\n\nfun <S> Builder<S>.extensionAdd(s: S) {}\n\n@BuilderInference\nfun <S> Builder<S>.safeExtensionAdd(s: S) {}\n\nval member = build {\n    add(42)\n}\n\nval memberWithoutAnn = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>wrongBuild<!> {\n    add(42)\n}\n\nval extension = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>build<!> {\n    <!NI;NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE!>extensionAdd(\"foo\")<!>\n}\n\nval safeExtension = build {\n    safeExtensionAdd(\"foo\")\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\nimport kotlin.experimental.ExperimentalTypeInference\n\ninterface Base\n\ninterface Controller<T> : Base {\n    suspend fun yield(t: T) {}\n}\n\nfun <S> generate(@BuilderInference g: suspend Controller<S>.() -> Unit): S = TODO()\n\nfun Base.baseExtension() {}\nfun Controller<out Any?>.outNullableAnyExtension() {}\nfun Controller<out Any>.outAnyExtension() {}\nfun Controller<Any?>.invNullableAnyExtension() {}\nfun <S> Controller<S>.genericExtension() {}\n\n@BuilderInference\nfun Controller<String>.safeExtension() {}\n\nval test1 = generate {\n    yield(\"foo\")\n    baseExtension()\n}\n\nval test2 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    baseExtension()\n}\n\nval test3 = generate {\n    yield(42)\n    outNullableAnyExtension()\n}\n\nval test4 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    outNullableAnyExtension()\n}\n\nval test5 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(42)\n    outAnyExtension()\n}\n\nval test6 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(\"bar\")\n    invNullableAnyExtension()\n}\n\nval test7 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(\"baz\")\n    genericExtension<Int>()\n}\n\nval test8 = generate {\n    safeExtension()\n}"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\nimport kotlin.experimental.ExperimentalTypeInference\n\nclass GenericController<T> {\n    suspend fun yield(t: T) {}\n    fun notYield(t: T) {}\n\n    suspend fun yieldBarReturnType(t: T) = t\n    fun barReturnType(): T = TODO()\n}\n\nfun <S> generate(@BuilderInference g: suspend GenericController<S>.() -> Unit): List<S> = TODO()\n\nval test1 = generate {\n    yield(3)\n}\n\nval test2 = generate {\n    yield(3)\n    notYield(3)\n}\n\nval test3 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(3)\n    <!NI;NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE!>yieldBarReturnType(3)<!>\n}\n\nval test4 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(3)\n    <!NI;NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE!>barReturnType()<!>\n}"
        },
        {
            "code": "// !LANGUAGE: -ExperimentalBuilderInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Builder<T> {\n    suspend fun add(t: T) {}\n}\n\nfun <S> build(g: suspend Builder<S>.() -> Unit): List<S> = TODO()\nfun <S> wrongBuild(g: Builder<S>.() -> Unit): List<S> = TODO()\n\nfun <S> Builder<S>.extensionAdd(s: S) {}\n\nsuspend fun <S> Builder<S>.safeExtensionAdd(s: S) {}\n\nval member = build {\n    add(42)\n}\n\nval memberWithoutAnn = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>wrongBuild<!> {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>add<!>(42)\n}\n\nval extension = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>build<!> {\n    <!NI;NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE!>extensionAdd(\"foo\")<!>\n}\n\nval safeExtension = build {\n    safeExtensionAdd(\"foo\")\n}\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n\n// FILE: a.kt\n\npackage a\n\nprivate class Queue {\n    private companion object\n}\n\n// FILE: b/Queue.java\n\npackage b;\n\npublic class Queue {\n    public static Queue empty() { return null; }\n}\n\n// FILE: c.kt\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\npackage c\n\nimport a.*\nimport b.Queue\nimport kotlin.experimental.ExperimentalTypeInference\n\ninterface Inv<T> {\n    fun emit(e: T)\n}\n\nfun <T> invBuilder(@BuilderInference block: Inv<T>.() -> Unit) {}\n\nfun test() {\n    invBuilder {\n        val q = Queue.empty()\n        emit(42)\n    }\n}\n\n"
        },
        {
            "code": "// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\nimport kotlin.experimental.ExperimentalTypeInference\n\nclass Controller<T> {\n    suspend fun yield(t: T) {}\n}\n\nfun <S> generate(@BuilderInference g: suspend Controller<S>.() -> Unit): S = TODO()\n\nclass A\n\nval test1 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(<!NO_COMPANION_OBJECT!>A<!>)\n}\n\nval test2: Int = <!NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>generate {\n    yield(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>A()<!>)\n}<!>"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\nclass Controller<T : Number> {\n    suspend fun yield(t: T) {}\n}\n\nfun <S : Number> generate(g: suspend Controller<S>.() -> Unit): S = TODO()\n\nval test = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(\"foo\")\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\nimport kotlin.experimental.ExperimentalTypeInference\n\ninterface Base<K>\n\ninterface Controller<T> : Base<T> {\n    suspend fun yield(t: T) {}\n}\n\ninterface SpecificController<T> : Base<String> {\n    suspend fun yield(t: T) {}\n}\n\nfun <S> generate(@BuilderInference g: suspend Controller<S>.() -> Unit): S = TODO()\nfun <S> generateSpecific(@BuilderInference g: suspend SpecificController<S>.() -> Unit): S = TODO()\n\nfun Base<*>.starBase() {}\nfun Base<String>.stringBase() {}\n\nval test1 = generate {\n    starBase()\n    yield(\"foo\")\n}\n\nval test2 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    starBase()\n}\n\nval test3 = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    yield(\"bar\")\n    stringBase()\n}\n\nval test4 = generateSpecific {\n    yield(42)\n    starBase()\n}\n\nval test5 = generateSpecific {\n    yield(42)\n    stringBase()\n}\n\nval test6 = <!NI;NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER, OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generateSpecific<!> {\n    stringBase()\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_TXT\nclass StateMachine<Q> internal constructor() {\n    fun getInputStub(): Q = null <!UNCHECKED_CAST!>as Q<!>\n}\n\nfun <T> stateMachine(<!UNUSED_PARAMETER!>block<!>: suspend StateMachine<T>.() -> Unit): StateMachine<T> {\n    return StateMachine<T>()\n}\n\nclass Problem<F>(){\n    fun getInputStub(): F = null <!UNCHECKED_CAST!>as F<!>\n\n    fun createStateMachine(): StateMachine<F> = stateMachine {\n        val letter = getInputStub()\n        if (letter is Any)\n            println(\"yes\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !WITH_NEW_INFERENCE\n// NI_EXPECTED_FILE\n\n// FILE: annotation.kt\n\npackage kotlin\n\nannotation class BuilderInference\n\n// FILE: test.kt\n\nclass GenericController<T> {\n    suspend fun yield(t: T) {}\n}\n\nsuspend fun <S> GenericController<S>.extensionYield(s: S) {}\n\n@BuilderInference\nsuspend fun <S> GenericController<S>.safeExtensionYield(s: S) {}\n\nfun <S> generate(@BuilderInference g: suspend GenericController<S>.() -> Unit): List<S> = TODO()\n\nval normal = generate {\n    yield(42)\n}\n\nval extension = <!OI;TYPE_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>generate<!> {\n    <!NI;NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE!>extensionYield(\"foo\")<!>\n}\n\nval safeExtension = generate {\n    safeExtensionYield(\"foo\")\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !USE_EXPERIMENTAL: kotlin.Experimental\n\nimport kotlin.reflect.KSuspendFunction0\nimport kotlin.reflect.KSuspendFunction1\nimport kotlin.reflect.KFunction0\nimport kotlin.reflect.KFunction1\n\nfun test0(serialize: KSuspendFunction0<Unit>) {}\nfun test1(serialize: KSuspendFunction1<Int, Unit>) {}\n\nsuspend fun foo() {}\nsuspend fun bar(x: Int) {}\n\nfun test() {\n    test0(::foo)\n    test1(<!TYPE_MISMATCH!>::foo<!>)\n\n    test0(<!TYPE_MISMATCH!>::bar<!>)\n    test1(::bar)\n}"
        },
        {
            "code": "fun bar(d: Delegate): String {\n    val x: String by <!ILLEGAL_SUSPEND_FUNCTION_CALL!>d<!>\n    return x\n}\n\nclass Delegate {\n    suspend <!UNSUPPORTED!>operator<!> fun getValue(thisRef: Any?, property: Any?): String = \"\"\n}\n"
        },
        {
            "code": "// FILE: main.kt\ninterface A {\n    suspend fun foo()\n    fun bar()\n}\n\ninterface B : A {\n    <!CONFLICTING_OVERLOADS!><!NOTHING_TO_OVERRIDE!>override<!> fun foo()<!> {\n\n    }\n\n    <!CONFLICTING_OVERLOADS!><!NOTHING_TO_OVERRIDE!>override<!> suspend fun bar()<!> {\n\n    }\n}\n\ninterface C : A {\n    suspend override fun foo() {\n\n    }\n\n    override fun bar() {\n\n    }\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class D<!> : J {\n    suspend override fun foo() {\n\n    }\n}\n\n"
        },
        {
            "code": "// SKIP_TXT\n// FILE: test.kt\n\npackage kotlin.test\n\nannotation class IrrelevantClass\n\npublic typealias Test = IrrelevantClass\n\n// FILE: main.kt\n\nimport kotlin.test.Test\n\nclass A {\n    @Test\n    <!UNSUPPORTED!>suspend<!> fun test() {}\n}\n\n@Test\n<!UNSUPPORTED!>suspend<!> fun test() {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: -Coroutines -ReleaseCoroutines\n\n<!UNSUPPORTED_FEATURE!>suspend<!> fun suspendHere(): String = \"OK\"\n\nfun builder(c: <!UNSUPPORTED_FEATURE!>suspend<!> () -> Unit) {\n\n}\n\nfun box(): String {\n    var result = \"\"\n\n    <!UNSUPPORTED_FEATURE!>builder<!> {\n        suspendHere()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nimport kotlin.coroutines.*\n\nfun ordinal() {\n    kotlin.coroutines.<!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!>\n    <!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!>\n}\n\nsuspend fun named() {\n    kotlin.coroutines.coroutineContext\n    coroutineContext\n}\n\nclass A {\n    val coroutineContextNew = kotlin.coroutines.<!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!>\n    val context = <!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!>\n}\n\nclass Controller {\n    fun ordinal() {\n        kotlin.coroutines.<!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!>\n        <!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!>\n    }\n\n    suspend fun named() {\n        kotlin.coroutines.coroutineContext\n        coroutineContext\n    }\n\n    suspend fun severalArgs(s: String, a: Any) {\n        kotlin.coroutines.coroutineContext\n        coroutineContext\n    }\n}\n\nfun builder(c: () -> CoroutineContext) = {}\nfun builderSuspend(c: suspend () -> CoroutineContext) = {}\n\nfun builderSeveralArgs(c: (Int, Int, Int) -> CoroutineContext) = {}\nfun builderSuspendSeveralArgs(c: suspend (Int, Int, Int) -> CoroutineContext) = {}\n\nfun test() {\n    builder { kotlin.coroutines.<!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!> }\n    builder { <!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!> }\n    builderSuspend { kotlin.coroutines.coroutineContext }\n    builderSuspend { coroutineContext }\n    builderSeveralArgs { _, _, _ -> kotlin.coroutines.<!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!> }\n    builderSeveralArgs { _, _, _ -> <!ILLEGAL_SUSPEND_PROPERTY_ACCESS!>coroutineContext<!> }\n    builderSuspendSeveralArgs { _, _, _ -> kotlin.coroutines.coroutineContext }\n    builderSuspendSeveralArgs { _, _, _ -> coroutineContext }\n}\n"
        },
        {
            "code": "import Host.bar\n\nobject Host {\n    suspend fun bar() {}\n}\n\nsuspend fun foo() {}\n\nfun noSuspend() {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>()\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>bar<!>()\n}\n\nclass A {\n    init {\n        <!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>()\n        <!ILLEGAL_SUSPEND_FUNCTION_CALL!>bar<!>()\n    }\n}\n\nval x = <!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>()\nval y = <!ILLEGAL_SUSPEND_FUNCTION_CALL!>bar<!>()"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines +ExperimentalBuilderInference\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// SKIP_TXT\n\n@file:UseExperimental(ExperimentalTypeInference::class)\n\nimport kotlin.experimental.ExperimentalTypeInference\n\n@kotlin.coroutines.RestrictsSuspension\nclass RestrictedController<T> {\n    suspend fun yield(<!UNUSED_PARAMETER!>x<!>: T) {}\n\n    suspend fun anotherYield(x: T) {\n        yield(x)\n        this.yield(x)\n\n        yield2(x)\n        this.yield2(x)\n\n        with(this) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(x)\n            this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(x)\n\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(x)\n            this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(x)\n        }\n    }\n}\n\nfun <T> buildSequence(@BuilderInference <!UNUSED_PARAMETER!>c<!>: suspend RestrictedController<T>.() -> Unit) {}\n\n@BuilderInference\nsuspend fun <T> RestrictedController<T>.yield2(<!UNUSED_PARAMETER!>x<!>: T) {}\n\nfun test() {\n    buildSequence<Int> a@{\n        buildSequence<Int> b@{\n            yield(1)\n            yield2(1)\n            this@b.yield(1)\n            this@b.yield2(1)\n\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(2) // Should be error\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(2) // Should be error\n\n            with(this) {\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(3)\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(3)\n\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(3)\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(3)\n            }\n        }\n    }\n\n    buildSequence<Int> {\n        buildSequence<String> {\n            yield(\"a\")\n            yield2(\"a\")\n            this.yield(\"b\")\n            this.yield2(\"b\")\n\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(1) // Should be error\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(1) // Should be error\n\n            with(this) {\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n            }\n        }\n    }\n\n    buildSequence<Int> a@{\n        yield(1)\n        yield2(1)\n        buildSequence {\n            yield(\"\")\n            yield2(\"\")\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(1)\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(1)\n\n            with(this) {\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n            }\n        }\n    }\n\n    buildSequence<String> {\n        yield(\"\")\n        RestrictedController<String>().<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"1\")\n    }\n}\n"
        },
        {
            "code": "// COMMON_COROUTINES_TEST\n@COROUTINES_PACKAGE.RestrictsSuspension\nclass RestrictedController\n\nsuspend fun Any?.extFun() {}\nsuspend fun suspendFun() {}\n\nfun generate(<!UNUSED_PARAMETER!>c<!>: suspend RestrictedController.() -> Unit) {}\n\nfun test() {\n    generate {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extFun<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>suspendFun<!>()\n    }\n}\n"
        },
        {
            "code": "// COMMON_COROUTINES_TEST\n// SKIP_TXT\n@COROUTINES_PACKAGE.RestrictsSuspension\nclass RestrictedController {\n    suspend fun yield() {}\n}\n\nfun generate(<!UNUSED_PARAMETER!>c<!>: suspend RestrictedController.() -> Unit) {}\n\nfun runBlocking(<!UNUSED_PARAMETER!>x<!>: suspend () -> Unit) {}\n\nfun test() {\n    generate {\n        runBlocking {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -SUSPENSION_CALL_MUST_BE_USED_AS_RETURN_VALUE\n// COMMON_COROUTINES_TEST\n\n@COROUTINES_PACKAGE.RestrictsSuspension\nclass RestrictedController {\n    suspend fun member() {}\n}\n\nsuspend fun RestrictedController.extension() {}\n\nfun generate(f: suspend RestrictedController.() -> Unit) {}\n\nfun test() {\n    generate() l@ {\n        member()\n        extension()\n\n        this.member()\n        this.extension()\n\n        val foo = this\n        foo.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        foo.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extension<!>()\n\n        this@l.member()\n        this@l.extension()\n\n        with(1) {\n            this@l.member()\n            this@l.extension()\n        }\n    }\n}\n\nsuspend fun RestrictedController.l() {\n    member()\n    extension()\n\n    this.member()\n    this.extension()\n\n    val foo = this\n    foo.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n    foo.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extension<!>()\n\n    this@l.member()\n    this@l.extension()\n\n    with(1) {\n        this@l.member()\n        this@l.extension()\n    }\n\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ReleaseCoroutines -ExperimentalBuilderInference\n// !DIAGNOSTICS: -EXPERIMENTAL_FEATURE_WARNING\n// !WITH_NEW_INFERENCE\n// SKIP_TXT\n\n@kotlin.coroutines.experimental.RestrictsSuspension\nclass RestrictedController<T> {\n    suspend fun yield(<!UNUSED_PARAMETER!>x<!>: T) {}\n\n    suspend fun anotherYield(x: T) {\n        yield(x)\n        this.yield(x)\n\n        yield2(x)\n        this.yield2(x)\n\n        with(this) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(x)\n            this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(x)\n\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(x)\n            this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(x)\n        }\n    }\n}\n\nfun <T> buildSequence(<!UNUSED_PARAMETER!>c<!>: suspend RestrictedController<T>.() -> Unit) {}\nsuspend fun <T> RestrictedController<T>.yield2(<!UNUSED_PARAMETER!>x<!>: T) {}\n\nfun test() {\n    buildSequence<Int> a@{\n        buildSequence<Int> b@{\n            yield(1)\n            yield2(1)\n            this@b.yield(1)\n            this@b.yield2(1)\n\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(2) // Should be error\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(2) // Should be error\n\n            with(this) {\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(3)\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(3)\n\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(3)\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(3)\n            }\n        }\n    }\n\n    buildSequence<Int> {\n        buildSequence<String> {\n            yield(\"a\")\n            yield2(\"a\")\n            this.yield(\"b\")\n            this.yield2(\"b\")\n\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(1) // Should be error\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(1) // Should be error\n\n            with(this) {\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n            }\n        }\n    }\n\n    buildSequence<Int> a@{\n        yield(1)\n        yield2(1)\n        buildSequence {\n            yield(\"\")\n            yield2(\"\")\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(1)\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(1)\n\n            <!NI;NON_APPLICABLE_CALL_FOR_BUILDER_INFERENCE!>with(this) {\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"\")\n\n                <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n                this@with.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield2<!>(\"\")\n            }<!>\n        }\n    }\n\n    buildSequence<String> {\n        yield(\"\")\n        RestrictedController<String>().<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>yield<!>(\"1\")\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -SUSPENSION_CALL_MUST_BE_USED_AS_RETURN_VALUE\n// COMMON_COROUTINES_TEST\n\ninterface SuperInterface\n\n@COROUTINES_PACKAGE.RestrictsSuspension\nopen class RestrictedController : SuperInterface\n\nclass SubClass : RestrictedController()\n\nsuspend fun topLevel() {}\n\nclass A {\n    suspend fun member() {}\n}\n\nfun generate1(f: suspend SuperInterface.() -> Unit) {}\nfun generate2(f: suspend RestrictedController.() -> Unit) {}\nfun generate3(f: suspend SubClass.() -> Unit) {}\n\nfun A.test() {\n    generate1 {\n        topLevel()\n        member()\n        with(A()) {\n            topLevel()\n            member()\n        }\n    }\n    generate2 {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        }\n    }\n    generate3 {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        }\n    }\n\n    suspend fun SuperInterface.fun1() {\n        topLevel()\n        member()\n        with(A()) {\n            topLevel()\n            member()\n        }\n    }\n    suspend fun RestrictedController.fun2() {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        }\n    }\n    suspend fun SubClass.fun3() {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>topLevel<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n        }\n    }\n\n}\n\n"
        },
        {
            "code": "// COMMON_COROUTINES_TEST\n// SKIP_TXT\n@COROUTINES_PACKAGE.RestrictsSuspension\nclass RestrictedController {\n    suspend fun member() {\n        ext()\n        member()\n        memberExt()\n    }\n\n    suspend fun RestrictedController.memberExt() {\n        ext()\n        member()\n        memberExt()\n    }\n}\n\nsuspend fun RestrictedController.ext() {\n    ext()\n    member()\n    memberExt()\n}\n\nfun generate(<!UNUSED_PARAMETER!>c<!>: suspend RestrictedController.() -> Unit) {}\n\nfun runBlocking(<!UNUSED_PARAMETER!>x<!>: suspend () -> Unit) {}\n\nfun test() {\n    generate a@{\n        ext()\n        member()\n        memberExt()\n\n        this@a.ext()\n        this@a.member()\n        this@a.memberExt()\n\n        generate b@{\n            ext()\n            member()\n            memberExt()\n\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>ext<!>()\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memberExt<!>()\n\n            this@b.ext()\n            this@b.member()\n            this@b.memberExt()\n        }\n\n        runBlocking {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>ext<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memberExt<!>()\n\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>ext<!>()\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>member<!>()\n            this@a.<!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memberExt<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -SUSPENSION_CALL_MUST_BE_USED_AS_RETURN_VALUE\n// COMMON_COROUTINES_TEST\n\ninterface SuperInterface\n\n@COROUTINES_PACKAGE.RestrictsSuspension\nopen class RestrictedController : SuperInterface\n\nclass SubClass : RestrictedController()\n\nsuspend fun Any?.extAny() {}\nsuspend fun SuperInterface.extSuper() {}\nsuspend fun RestrictedController.ext() {}\nsuspend fun SubClass.extSub() {}\n\nclass A {\n    suspend fun Any?.memExtAny() {}\n    suspend fun SuperInterface.memExtSuper() {}\n    suspend fun RestrictedController.memExt() {}\n    suspend fun SubClass.memExtSub() {}\n}\n\n\nfun generate1(f: suspend SuperInterface.() -> Unit) {}\nfun generate2(f: suspend RestrictedController.() -> Unit) {}\nfun generate3(f: suspend SubClass.() -> Unit) {}\n\nfun A.test() {\n    generate1 {\n        extAny()\n        memExtAny()\n        extSuper()\n        memExtSuper()\n        with(A()) {\n            extAny()\n            memExtAny()\n            extSuper()\n            memExtSuper()\n        }\n    }\n    generate2 {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n\n        ext()\n        memExt()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n            ext()\n            memExt()\n        }\n    }\n    generate3 {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n\n        ext()\n        memExt()\n        extSub()\n        memExtSub()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n            ext()\n            memExt()\n            extSub()\n            memExtSub()\n        }\n    }\n\n    suspend fun SuperInterface.fun1() {\n        extAny()\n        memExtAny()\n        extSuper()\n        memExtSuper()\n        with(A()) {\n            extAny()\n            memExtAny()\n            extSuper()\n            memExtSuper()\n        }\n    }\n    suspend fun RestrictedController.fun2() {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n\n        ext()\n        memExt()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n            ext()\n            memExt()\n        }\n    }\n    suspend fun SubClass.fun3() {\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n        <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n\n        ext()\n        memExt()\n        extSub()\n        memExtSub()\n        with(A()) {\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtAny<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>extSuper<!>()\n            <!ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL!>memExtSuper<!>()\n            ext()\n            memExt()\n            extSub()\n            memExtSub()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_VARIABLE\n// !WITH_NEW_INFERENCE\n\nsuspend fun <V> await(f: V): V = f\n\nfun <T> genericBuilder(c: suspend () -> T): T = null!!\n\nfun foo() {\n    var result = \"\"\n    genericBuilder<String> {\n        <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>try {\n            await(\"\")\n        } catch(e: Exception) {\n            <!OI;EXPECTED_TYPE_MISMATCH!>result = \"fail\"<!>\n        }<!>\n    }\n}\n"
        },
        {
            "code": "interface Foo {\n    val foo: suspend () -> Unit\n}\n\ninterface Bar<T> {\n    val bar: T\n}\n\nclass Test1 : Foo {\n    override val <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE!>foo<!> = {}\n}\n\nclass Test2 : Foo {\n    override val foo: suspend () -> Unit = {}\n}\n\nclass Test3 : Bar<suspend () -> Unit> {\n    override val <!PROPERTY_TYPE_MISMATCH_ON_OVERRIDE!>bar<!> = {}\n}\n\nclass Test4 : Bar<suspend () -> Unit> {\n    override val bar: suspend () -> Unit = {}\n}"
        },
        {
            "code": "fun test1(sfn: suspend () -> Unit) = <!ILLEGAL_SUSPEND_FUNCTION_CALL!>sfn<!>()\nfun test2(sfn: suspend () -> Unit) = sfn.<!ILLEGAL_SUSPEND_FUNCTION_CALL!>invoke<!>()\n"
        },
        {
            "code": "typealias Action = () -> Unit\n\ninterface SAM {\n    fun run()\n}\n\ntypealias Test1 = suspend () -> Unit\ntypealias Test2 = suspend Int.() -> Unit\ntypealias Test3 = <!WRONG_MODIFIER_TARGET!>suspend<!> Function0<Unit>\ntypealias Test4 = <!WRONG_MODIFIER_TARGET!>suspend<!> Action\ntypealias Test5 = List<suspend () -> Unit>\ntypealias Test6 = <!WRONG_MODIFIER_TARGET!>suspend<!> List<() -> Unit>\ntypealias Test7 = <!WRONG_MODIFIER_TARGET!>suspend<!> SAM\ntypealias Test8 = <!WRONG_MODIFIER_TARGET!>suspend<!> kotlin.coroutines.SuspendFunction0<Unit>\ntypealias Test9 = suspend (() -> Unit) -> Unit\ntypealias Test10 = suspend (suspend () -> Unit) -> Unit\ntypealias Test11 = suspend () -> (suspend () -> Unit)\ntypealias Test12 = suspend (suspend (() -> Unit)) -> Unit\ntypealias Test13 = @A() suspend () -> Unit\ntypealias Test14 = @A suspend () -> Unit\ntypealias Test15 = (@A() suspend () -> Unit)?\ntypealias Test16 = (@A suspend () -> Unit)?\ntypealias Test17 = @A suspend RS.() -> Unit\ntypealias Test18 = (suspend () -> Unit)?\n\ninterface Supertype1 : <!SUPERTYPE_IS_SUSPEND_FUNCTION_TYPE!>suspend () -> Unit<!> {\n\n}\n\ninterface Supertype2 : <!SUPERTYPE_IS_SUSPEND_FUNCTION_TYPE!>suspend String.() -> Unit<!> {\n\n}\n\n@Target(AnnotationTarget.TYPE)\nannotation class A\n\ninterface RS\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\ninline fun foo1(<!INLINE_SUSPEND_FUNCTION_TYPE_UNSUPPORTED!>x: suspend () -> Unit<!>) {}\ninline fun foo2(crossinline x: suspend () -> Unit) {}\n<!NOTHING_TO_INLINE!>inline<!> fun foo3(noinline x: suspend () -> Unit) {}\n<!NOTHING_TO_INLINE!>inline<!> fun foo4(<!INCOMPATIBLE_MODIFIERS!>noinline<!> <!INCOMPATIBLE_MODIFIERS!>crossinline<!> x: suspend () -> Unit) {}\n\nsuspend inline fun bar1(x: <!REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE!>suspend<!> () -> Unit) {}\nsuspend inline fun bar2(crossinline x: suspend () -> Unit) {}\nsuspend inline fun bar3(noinline x: suspend () -> Unit) {}\nsuspend inline fun bar4(<!INCOMPATIBLE_MODIFIERS!>noinline<!> <!INCOMPATIBLE_MODIFIERS!>crossinline<!> x: suspend () -> Unit) {}\n\nsuspend fun baz() {\n    foo1 {\n        return@baz\n    }\n\n    foo2 {\n        <!RETURN_NOT_ALLOWED!>return@baz<!>\n    }\n\n    foo3 {\n        <!RETURN_NOT_ALLOWED!>return@baz<!>\n    }\n\n    foo4 {\n        <!RETURN_NOT_ALLOWED!>return@baz<!>\n    }\n\n    bar1 {\n        return@baz\n    }\n\n    bar2 {\n        <!RETURN_NOT_ALLOWED!>return@baz<!>\n    }\n\n    bar3 {\n        <!RETURN_NOT_ALLOWED!>return@baz<!>\n    }\n\n    bar4 {\n        <!RETURN_NOT_ALLOWED!>return@baz<!>\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n\nfun useSuspendFn(sfn: suspend () -> Unit) = sfn\nfun useFn(fn: () -> Unit) = fn\n\nfun ambiguous(sfn: suspend () -> Unit) = sfn\nfun ambiguous(fn: () -> Unit) = fn\n\nfun test1(sfn: suspend () -> Unit) = useFn(<!TYPE_MISMATCH!>sfn<!>)\nfun test2(fn: () -> Unit) = useSuspendFn(<!TYPE_MISMATCH!>fn<!>)\n\nfun test3(sfn: suspend () -> Unit) = useSuspendFn(sfn)\nfun test4(): suspend () -> Unit = useSuspendFn {}\nfun test5() = useSuspendFn {}\n\nfun test5(sfn: suspend () -> Unit) = ambiguous(sfn)\nfun test6(fn: () -> Unit) = ambiguous(fn)\nfun test7(): () -> Unit = <!OVERLOAD_RESOLUTION_AMBIGUITY!>ambiguous<!> {}"
        },
        {
            "code": "// JAVAC_SKIP\ntypealias Test1 = <!UNRESOLVED_REFERENCE!>SuspendFunction0<!><Unit>\ntypealias Test2 = kotlin.<!UNRESOLVED_REFERENCE!>SuspendFunction0<!><Unit>\ntypealias Test3 = kotlin.coroutines.SuspendFunction0<Unit>"
        },
        {
            "code": "suspend fun foo1(q: suspend () -> Unit) = q()\nsuspend fun foo2(x: suspend (Int) -> String) = x(1)\n\n\nsuspend fun foo3(y: suspend String.(Int) -> Double) = \"\".y(1)\nsuspend fun String.foo4(y: suspend String.(Int) -> Double) = \"\".y(1)\n\nfun noSuspend(x: suspend (Int) -> String) {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>x<!>(1)\n}\n"
        },
        {
            "code": "val test1: (suspend () -> Unit)? = null\nval test2: <!WRONG_MODIFIER_TARGET!>suspend<!> (() -> Unit)? = null\nval test3: <!WRONG_MODIFIER_TARGET!>suspend<!> ( (() -> Unit)? ) = null\n\nfun foo() {\n    test1?.<!ILLEGAL_SUSPEND_FUNCTION_CALL!>invoke<!>()\n    test2?.<!ILLEGAL_SUSPEND_FUNCTION_CALL!>invoke<!>()\n    test3?.<!ILLEGAL_SUSPEND_FUNCTION_CALL!>invoke<!>()\n}"
        },
        {
            "code": "// COMMON_COROUTINES_TEST\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n}\n\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.Continuation\nclass K1 : JavaClass()\n\nclass K2 : JavaClass() {\n    override suspend fun foo(x: Int): String = \"\"\n}\n\nclass K3 : JavaClass() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: Int, y: Continuation<String>): Any? = null\n}\n\nfun builder(<!UNUSED_PARAMETER!>block<!>: suspend () -> Unit) {}\n\nfun main(x: Continuation<String>) {\n    JavaClass().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(5, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K1().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(6, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K2().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(7, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K3().foo(8, x)\n\n    builder {\n        JavaClass().foo(1)\n        K1().foo(2)\n        K2().foo(3)\n        K3().foo(4)\n\n        JavaClass().foo(5, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K1().foo(6, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K2().foo(7, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K3().foo(8, x)\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\nimport Host.suspendFromObject\n\nsuspend fun suspendHere() = 1\nsuspend fun <T> another(a: T) = 1\n\nobject Host {\n    suspend fun suspendFromObject() = 1\n}\n\nfun <T> builder(c: suspend () -> Unit) { }\n\ninline fun run(x: () -> Unit) {}\n\ninline fun runCross(crossinline x: () -> Unit) {}\n\nfun noinline(x: () -> Unit) {}\n\nfun foo() {\n    var result = 1\n    builder<String> {\n        suspendHere()\n        suspendFromObject()\n        \n        another(\"\")\n        another(1)\n\n        result += suspendHere()\n        result += suspendFromObject()\n\n        run {\n            result += suspendHere()\n            result += suspendFromObject()\n            \n            run {\n                suspendHere()\n                suspendFromObject()\n            }\n        }\n\n        runCross {\n            result += <!NON_LOCAL_SUSPENSION_POINT!>suspendHere<!>()\n            result += <!NON_LOCAL_SUSPENSION_POINT!>suspendFromObject<!>()\n            runCross {\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendHere<!>()\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendFromObject<!>()\n            }\n        }\n\n        noinline {\n            result += <!NON_LOCAL_SUSPENSION_POINT!>suspendHere<!>()\n            result += <!NON_LOCAL_SUSPENSION_POINT!>suspendFromObject<!>()\n            noinline {\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendHere<!>()\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendFromObject<!>()\n            }\n        }\n\n        class A {\n            fun bar() {\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendHere<!>()\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendFromObject<!>()\n            }\n        }\n\n        object : Any() {\n            fun baz() {\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendHere<!>()\n                <!NON_LOCAL_SUSPENSION_POINT!>suspendFromObject<!>()\n            }\n        }\n\n        builder<Int> {\n            suspendHere()\n            suspendFromObject()\n\n            another(1)\n            another(\"\")\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// COMMON_COROUTINES_TEST\n// !WITH_NEW_INFERENCE\nimport COROUTINES_PACKAGE.*\n\nclass Controller {\n    suspend fun noParams() {\n\n    }\n    suspend fun yieldString(value: String) {}\n\n    suspend fun <V> await(f: () -> V): V = f()\n\n    suspend fun <V> await(f: Int): V = null!!\n\n    suspend fun severalParams(x: String, y: Int) = 1.0\n}\n\nfun builder(c: suspend Controller.() -> Unit) {}\n\nfun test() {\n    builder {\n        noParams()\n        yieldString(\"abc\") checkType { _<Unit>() }\n        yieldString(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) checkType { _<Unit>() }\n\n        await<String> { \"123\" } checkType { _<String>() }\n\n        // Inference from lambda return type\n        await { 123 } checkType { _<Int>() }\n\n        // Inference from expected type\n        checkSubtype<String>(await(567))\n\n        await<Double>(123) checkType { _<Double>() }\n\n        severalParams(\"\", 89) checkType { _<Double>() }\n\n        // TODO: should we allow somehow to call with passing continuation explicitly?\n        severalParams(\"\", 89, <!TOO_MANY_ARGUMENTS!>6.9<!>) checkType { <!TYPE_MISMATCH!>_<!><Unit>() }\n        severalParams(\"\", 89, <!TOO_MANY_ARGUMENTS!>this <!CAST_NEVER_SUCCEEDS!>as<!> Continuation<Double><!>) checkType { <!TYPE_MISMATCH!>_<!><Unit>() }\n    }\n}\n"
        },
        {
            "code": "// COMMON_COROUTINES_TEST\n// FILE: I.kt\n\ninterface I {\n    suspend fun foo(x: Int): String\n}\n\n// FILE: main.kt\n\nimport COROUTINES_PACKAGE.Continuation\nclass K1 : JavaClass()\n\nclass K2 : JavaClass() {\n    override suspend fun foo(x: Int): String = \"\"\n}\n\nclass K3 : JavaClass() {\n    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: Int, y: Continuation<String>): Any? = null\n}\n\nfun builder(<!UNUSED_PARAMETER!>block<!>: suspend () -> Unit) {}\n\nfun main(x: Continuation<String>) {\n    JavaClass().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(5, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K1().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(6, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K2().<!ILLEGAL_SUSPEND_FUNCTION_CALL!>foo<!>(7, <!TOO_MANY_ARGUMENTS!>x<!>)\n    K3().foo(8, x)\n\n    builder {\n        JavaClass().foo(1)\n        K1().foo(2)\n        K2().foo(3)\n        K3().foo(4)\n\n        JavaClass().foo(5, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K1().foo(6, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K2().foo(7, <!TOO_MANY_ARGUMENTS!>x<!>)\n        K3().foo(8, x)\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -ReleaseCoroutines\n// !DIAGNOSTICS: -UNUSED_PARAMETER -EXPERIMENTAL_FEATURE_WARNING\n// !CHECK_TYPE\n// !WITH_NEW_INFERENCE\n// SKIP_TXT\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nclass Controller {\n    suspend fun noParams(): Unit = suspendCoroutineUninterceptedOrReturn {\n        if (hashCode() % 2 == 0) {\n            it.resume(Unit)\n            COROUTINE_SUSPENDED\n        }\n        else {\n            Unit\n        }\n    }\n    suspend fun yieldString(value: String) = suspendCoroutineUninterceptedOrReturn<Int> {\n        it.resume(1)\n        it checkType { _<Continuation<Int>>() }\n        it.<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>resume<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\n\n        // We can return anything here, 'suspendCoroutineUninterceptedOrReturn' is not very type-safe\n        // Also we can call resume and then return the value too, but it's still just our problem\n        \"Not-int\"\n    }\n}\n\nfun builder(c: suspend Controller.() -> Unit) {}\n\nfun test() {\n    builder {\n        noParams() checkType { _<Unit>() }\n        yieldString(\"abc\") checkType { _<Int>() }\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// SKIP_TXT\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\nclass Controller {\n    suspend fun noParams(): Unit = suspendCoroutineUninterceptedOrReturn {\n        if (hashCode() % 2 == 0) {\n            it.resume(Unit)\n            COROUTINE_SUSPENDED\n        }\n        else {\n            Unit\n        }\n    }\n    suspend fun yieldString(value: String) = suspendCoroutineUninterceptedOrReturn<Int> {\n        it.resume(1)\n        it checkType { _<Continuation<Int>>() }\n        it.<!OI;TYPE_INFERENCE_CONFLICTING_SUBSTITUTIONS!>resume<!>(<!NI;TYPE_MISMATCH!>\"\"<!>)\n\n        // We can return anything here, 'suspendCoroutineUninterceptedOrReturn' is not very type-safe\n        // Also we can call resume and then return the value too, but it's still just our problem\n        \"Not-int\"\n    }\n}\n\nfun builder(c: suspend Controller.() -> Unit) {}\n\nfun test() {\n    builder {\n        noParams() checkType { _<Unit>() }\n        yieldString(\"abc\") checkType { _<Int>() }\n    }\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n// COMMON_COROUTINES_TEST\n\nfun test(<!UNUSED_PARAMETER!>c<!>: <!UNRESOLVED_REFERENCE!>Continuation<!><Unit>) {}\n\n// FILE: 2.kt\nimport COROUTINES_PACKAGE.*\n\nfun test2(<!UNUSED_PARAMETER!>c<!>: Continuation<Unit>) {}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -UNUSED_EXPRESSION, -UNUSED_VARIABLE\n// !LANGUAGE: +InlineClasses\n\ntypealias ResultAlias<T> = Result<T>\n\ninline class InlineResult<out T>(private val r: Result<T>)\n\nfun params(\n    r1: Result<Int>,\n    r2: Result<Int>?,\n    r3: ResultAlias<String>,\n    r4: List<Result<Int>>,\n    r5: InlineResult<Int>,\n    <!FORBIDDEN_VARARG_PARAMETER_TYPE!>vararg<!> r6: Result<Int>\n) {}\n\nclass CtorParams(r1: Result<Int>)\n\nfun returnTypePublic(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\ninternal fun returnTypeInternal(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\nprivate fun returnTypePrivate(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\nfun returnTypeNullable(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int>?<!> = TODO()\nfun returnTypeAlias(): <!RESULT_CLASS_IN_RETURN_TYPE!>ResultAlias<Int><!> = TODO()\nfun <!RESULT_CLASS_IN_RETURN_TYPE!>returnInferred<!>(r1: Result<Int>, r2: ResultAlias<Int>, b: Boolean) = if (b) r1 else r2\n\nfun returnTypeInline(): InlineResult<Int> = TODO()\nfun returnContainer(): List<Result<Int>> = TODO()\n\nval topLevelP: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\nval <!RESULT_CLASS_IN_RETURN_TYPE!>topLevelPInferred<!> = topLevelP\ninternal val topLevelPInternal: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n\nprivate val topLevelPPrivate: Result<Int> = TODO()\nprivate val topLevelPPrivateInferred = topLevelP\n\nprivate val topLevelPPrivateCustomGetter: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!>\n    get() = TODO()\n\nval asFunctional: () -> Result<Int> = TODO()\n\nopen class PublicCls(\n    val r1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<String><!>,\n    val r2: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int>?<!>,\n    val r3: <!RESULT_CLASS_IN_RETURN_TYPE!>ResultAlias<Int><!>,\n    val r4: <!RESULT_CLASS_IN_RETURN_TYPE!>ResultAlias<Int>?<!>,\n\n    val r5: InlineResult<Int>,\n\n    internal val r6: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!>,\n\n    private val r7: Result<Int>,\n    val r8: List<Result<Int>>\n) {\n    val p1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n    var p2: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n    val p3: <!RESULT_CLASS_IN_RETURN_TYPE!>ResultAlias<Int>?<!> = TODO()\n\n    val <!RESULT_CLASS_IN_RETURN_TYPE!>p4<!> = p1\n\n    internal val p5: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n\n    private var p6: Result<Int> = TODO()\n\n    internal val <!RESULT_CLASS_IN_RETURN_TYPE!>p7<!> = p1\n    protected val <!RESULT_CLASS_IN_RETURN_TYPE!>p8<!> = p1\n\n    fun returnInCls(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n    protected fun returnInClsProtected(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n    private fun returnInClsPrivate(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n}\n\ninternal open class InternalCls(\n    val r1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!>,\n    val r2: <!RESULT_CLASS_IN_RETURN_TYPE!>ResultAlias<Int>?<!>,\n\n    val r3: List<Result<Int>>\n) {\n    companion object {\n        val cr1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n\n        private val cr2: Result<Int> = TODO()\n    }\n\n    val <!RESULT_CLASS_IN_RETURN_TYPE!>p1<!> = r1\n    val p2: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<String><!> = TODO()\n\n    protected val <!RESULT_CLASS_IN_RETURN_TYPE!>p3<!> = p1\n\n    fun returnInInternal(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n    protected fun returnInClsProtected(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n}\n\nprivate class PrivateCls(\n    val r1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!>,\n    val r2: <!RESULT_CLASS_IN_RETURN_TYPE!>ResultAlias<Int>?<!>,\n    val r3: List<Result<Int>>\n) {\n    companion object {\n        val cr1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n        private val cr2: Result<Int> = TODO()\n    }\n\n    val <!RESULT_CLASS_IN_RETURN_TYPE!>p1<!> = r1\n    val p2: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<String><!> = TODO()\n\n    fun returnInPrivate(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n}\n\nfun local(r: Result<Int>) {\n    val l1: Result<Int>? = null\n    val l2 = r\n\n    fun localFun(): <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = TODO()\n\n    class F {\n        val p1: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int><!> = r\n        val <!RESULT_CLASS_IN_RETURN_TYPE!>p2<!> = r\n    }\n}\n\nfun <T> resultInGenericFun(r: Result<Int>): T = r <!UNCHECKED_CAST!>as T<!>\n\nval asFunPublic: () -> Result<Int> = TODO()\nprivate val asFun: () -> Result<Int>? = TODO()\n"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines\n// SKIP_TXT\n\nimport kotlin.suspend as suspendLambda\n\nfun bar() {\n    <!UNRESOLVED_REFERENCE!>suspend<!> {\n        println()\n    }\n\n    kotlin.<!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspend<!> {\n\n    }\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspendLambda<!> {\n        println()\n    }\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspendLambda<!>() {\n        println()\n    }\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspendLambda<!>({ println() })\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspendLambda<!><Unit> {\n        println()\n    }\n\n    val <!UNUSED_VARIABLE!>w<!>: (suspend () -> Int) -> Any? = ::<!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspendLambda<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_EXPRESSION\n\nfun <T> id(x: T): T = x\n\nprivate val asFun: () -> Result<Int>? = TODO()\nprivate val Int.intResult: <!RESULT_CLASS_IN_RETURN_TYPE!>Result<Int>?<!>\n    get() = null\n\nfun returnInt(): Int? = 0\n\n\nfun nullableOperators(r1: Result<Int>?, b: Boolean) {\n    if (b) {\n        r1<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>!!<!>\n        asFun()<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>!!<!>\n        returnInt()?.intResult<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>!!<!>.toString()\n    }\n\n    if (b) {\n        id(r1)<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>!!<!>\n    }\n\n    if (b) {\n        r1<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?.<!>toString()\n        r1<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?.<!>let { }\n        returnInt()?.intResult<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?.<!>toString()\n        asFun()<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?.<!>toString()\n        id(r1)<!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?.<!>toString()\n    }\n\n    if (b) {\n        r1 <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> 0\n        r1 <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> r1\n        asFun() <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> r1 <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> 0\n        id(asFun()) <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> 0\n\n        returnInt() ?: returnInt() ?: asFun() <!RESULT_CLASS_WITH_NULLABLE_OPERATOR!>?:<!> 0\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n\ninline fun go1(f: () -> String) = f()\ninline suspend fun go2(f: () -> String) = f()\n\nfun builder(c: suspend () -> Unit) {}\n\nsuspend fun String.id(): String = this\n\nfun box() {\n    val x = \"f\"\n    builder {\n        go1(<!TYPE_MISMATCH!>x::id<!>)\n        go2(<!TYPE_MISMATCH!>x::id<!>)\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: -FunctionTypesWithBigArity\n// !DIAGNOSTICS: -UNUSED_PARAMETER\n// SKIP_TXT\n\nclass A {\n    suspend fun foo(\n        p00: Long = 1, p01: A = A(), p02: A = A(), p03: A = A(), p04: A = A(), p05: A = A(), p06: A = A(), p07: A = A(), p08: A = A(), p09: A = A(),\n        p10: A = A(), p11: A = A(), p12: A = A(), p13: A = A(), p14: A = A(), p15: A = A(), p16: A = A(), p17: A = A(), p18: A = A(), p19: A = A(),\n        p20: A = A(), p21: A = A(), p22: A = A(), p23: A = A(), p24: A = A(), p25: A = A(), p26: A = A(), p27: A = A(), p28: A = A(), p29: String\n    ): String {\n        return p29\n    }\n}\n\nsuspend fun expectsLambdaWithBigArity(c: suspend <!UNSUPPORTED_FEATURE!>(Long, Long, Long, Long, Long, Long, Long, Long, Long, Long,\n                                                  Long, Long, Long, Long, Long, Long, Long, Long, Long, Long,\n                                                  Long, Long, Long, Long, Long, Long, Long, Long, Long, String) -> String<!>): String {\n    return c.invoke(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \"OK\")\n}\n"
        },
        {
            "code": "// SKIP_TXT\n// COMMON_COROUTINES_TEST\n\nimport COROUTINES_PACKAGE.coroutineContext\n\nval c = ::<!UNSUPPORTED!>coroutineContext<!>\n\nfun test() {\n    c()\n}\n\nsuspend fun test2() {\n    c()\n}"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\ninterface Inv\nclass Impl : Inv\n\nclass Scope<InterfaceT, ImplementationT : InterfaceT>(private val implClass: <!UNRESOLVED_REFERENCE!>j<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Class<!><ImplementationT>) {\n    fun foo(c: Collection<InterfaceT>) {\n        val <!UNUSED_VARIABLE!>hm<!> = c.asSequence()\n            .filter(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>implClass<!>::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>isInstance<!>)\n            .<!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>map<!>(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>implClass<!>::<!CALLABLE_REFERENCE_RESOLUTION_AMBIGUITY!>cast<!>)\n            .<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>toSet<!>()\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +Coroutines\n// !DIAGNOSTICS: -USELESS_IS_CHECK\n// SKIP_TXT\n\nfun test() {\n    suspend {} is <!UNRESOLVED_REFERENCE!>SuspendFunction0<!><*>\n    suspend {} is kotlin.coroutines.SuspendFunction0<*>\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !CHECK_TYPE\n// !DIAGNOSTICS: -UNUSED_PARAMETER -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_VARIABLE\n\nfun builder(c: suspend () -> Int) = 1\nfun <T> genericBuilder(c: suspend () -> T): T = null!!\nfun unitBuilder(c: suspend () -> Unit) = 1\nfun emptyBuilder(c: suspend () -> Unit) = 1\n\nfun <T> manyArgumentsBuilder(\n        c1: suspend () -> Unit,\n        c2: suspend () -> T,\n        c3: suspend () -> Int\n):T = null!!\n\nfun severalParamsInLambda(c: suspend (String, Int) -> Unit) {}\n\nfun foo() {\n    builder({ 1 })\n    builder { 1 }\n\n    val x = { 1 }\n    builder(<!TYPE_MISMATCH!>x<!>)\n    builder({1} <!UNCHECKED_CAST!>as (suspend () -> Int)<!>)\n\n    var i: Int = 1\n    i = genericBuilder({ 1 })\n    i = genericBuilder { 1 }\n    genericBuilder { 1 }\n    genericBuilder<Int> { 1 }\n    genericBuilder<Int> { <!NI;TYPE_MISMATCH, TYPE_MISMATCH!>\"\"<!> }\n\n    val y = { 1 }\n    <!OI;TYPE_INFERENCE_PARAMETER_CONSTRAINT_ERROR!>genericBuilder<!>(<!TYPE_MISMATCH!>y<!>)\n\n    unitBuilder {}\n    unitBuilder { <!UNUSED_EXPRESSION!>1<!> }\n    unitBuilder({})\n    unitBuilder({ <!UNUSED_EXPRESSION!>1<!> })\n\n    manyArgumentsBuilder({}, { \"\" }) { 1 }\n\n    val s: String = manyArgumentsBuilder({}, { \"\" }) { 1 }\n\n    manyArgumentsBuilder<String>({}, { \"\" }, { 1 })\n    manyArgumentsBuilder<String>({}, { <!CONSTANT_EXPECTED_TYPE_MISMATCH, NI;CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!> }, { 2 })\n\n    severalParamsInLambda { <!NAME_SHADOWING!>x<!>, <!NAME_SHADOWING!>y<!> ->\n        x checkType { _<String>() }\n        y checkType { _<Int>() }\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines\n// SKIP_TXT\n\nfun <R> suspend(block: suspend () -> R): suspend () -> R = block\n\nclass A {\n    infix fun <R> suspend(block: suspend () -> R): suspend () -> R = block\n}\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann\n\nfun bar() {\n    <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    @Ann <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> @Ann {\n        println()\n    }\n\n    suspend() {\n        println()\n    }\n\n    suspend({ println() })\n\n    suspend<Unit> {\n        println()\n    }\n\n    val <!UNUSED_VARIABLE!>w<!>: (suspend () -> Int) -> Any? = ::suspend\n\n    A().<!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    A().suspend() {\n        println()\n    }\n\n    A().suspend({ println() })\n\n    A().suspend<Unit> {\n        println()\n    }\n\n    with(A()) {\n        <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n            println()\n        }\n\n        suspend() {\n            println()\n        }\n\n        suspend({ println() })\n\n        suspend<Unit> {\n            println()\n        }\n    }\n\n    A() <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    A() suspend ({\n        println()\n    })\n}\n"
        },
        {
            "code": "// !API_VERSION: 1.0\n// SKIP_TXT\n\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\n<!UNSUPPORTED!>suspend<!> fun foo(): Unit = <!UNRESOLVED_REFERENCE!>suspendCoroutine<!> {\n    <!UNRESOLVED_REFERENCE!>it<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>resume<!>(Unit)\n}\n\n<!UNSUPPORTED!>suspend<!> fun bar(): Unit = <!UNRESOLVED_REFERENCE!>suspendCoroutineUninterceptedOrReturn<!> {\n    <!UNRESOLVED_REFERENCE!>it<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>resume<!>(Unit)\n    <!UNRESOLVED_REFERENCE!>COROUTINE_SUSPENDED<!>\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -USELESS_IS_CHECK\n// !LANGUAGE: +NewInference\n// SKIP_TXT\n\nimport kotlin.concurrent.withLock\n\nval lock = java.util.concurrent.locks.ReentrantLock()\n\nfun builder(c: suspend () -> Unit) {}\n\nsuspend fun getLock() = lock\n\nsuspend fun suspensionPoint() {}\n\nfun test() {\n    builder {\n        synchronized(lock) {\n            <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n        }\n\n        synchronized(lock) label@{\n            <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n        }\n\n        synchronized(lock, { <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>() })\n\n        synchronized(getLock()) {\n            println(\"\")\n        }\n        synchronized(suspend { getLock() } ()) {\n            println(\"\")\n        }\n        synchronized(run { getLock() }) {\n            println(\"\")\n        }\n        lock.withLock {\n            <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n        }\n    }\n}\n\nsuspend fun run() {\n    synchronized(lock) {\n        <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n    }\n}\n\nsuspend fun ifWhenAndOtherNonsence() {\n    synchronized(lock) {\n        if (lock == Any()) {\n            when (1) {\n                is Int -> {\n                    return@synchronized 1 + <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>returnsInt<!>()\n                }\n                else -> {}\n            }\n        } else {}\n    }\n}\n\nsuspend fun returnsInt(): Int = 0"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER, -USELESS_IS_CHECK\n// SKIP_TXT\nimport kotlin.concurrent.withLock\n\nval lock = java.util.concurrent.locks.ReentrantLock()\n\nfun builder(c: suspend () -> Unit) {}\n\nsuspend fun getLock() = lock\n\nsuspend fun suspensionPoint() {}\n\nfun test() {\n    builder {\n        synchronized(lock) {\n            <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n        }\n\n        synchronized(lock) label@{\n            <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n        }\n\n        synchronized(lock, { <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>() })\n\n        synchronized(getLock()) {\n            println(\"\")\n        }\n        synchronized(suspend { getLock() } ()) {\n            println(\"\")\n        }\n        synchronized(run { getLock() }) {\n            println(\"\")\n        }\n        lock.withLock {\n            <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n        }\n    }\n}\n\nsuspend fun run() {\n    synchronized(lock) {\n        <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>suspensionPoint<!>()\n    }\n}\n\nsuspend fun ifWhenAndOtherNonsence() {\n    synchronized(lock) {\n        if (lock == Any()) {\n            when (1) {\n                is Int -> {\n                    return@synchronized 1 + <!SUSPENSION_POINT_INSIDE_CRITICAL_SECTION!>returnsInt<!>()\n                }\n                else -> {}\n            }\n        } else {}\n    }\n}\n\nsuspend fun returnsInt(): Int = 0"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !CHECK_TYPE\n// !WITH_NEW_INFERENCE\nsuspend fun noParams() {\n}\n\nsuspend fun yieldString(value: String) {}\n\nsuspend fun <V> await(f: () -> V) = f()\n\nsuspend fun <V> await(f: Int): V = null!!\n\nsuspend fun severalParams(x: String, y: Int) = 1.0\n\nsuspend fun String.stringReceiver(y: Int) = 1.0\n\nsuspend fun Any.anyReceiver(y: Int) = 1.0\n\nfun builder(c: suspend () -> Unit) {}\n\nfun test() {\n    builder {\n        noParams()\n        yieldString(\"abc\") checkType { _<Unit>() }\n        yieldString(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>1<!>) checkType { _<Unit>() }\n\n        await<String> { \"123\" } checkType { _<String>() }\n\n        // Inference from lambda return type\n        await { 123 } checkType { _<Int>() }\n\n        // Inference from expected type\n        checkSubtype<String>(await(567))\n\n        await<Double>(123) checkType { _<Double>() }\n\n        severalParams(\"\", 89) checkType { _<Double>() }\n        // TODO: should we allow somehow to call with passing continuation explicitly?\n        severalParams(\"\", 89, <!TOO_MANY_ARGUMENTS!>6.9<!>) checkType { <!NI;DEBUG_INFO_UNRESOLVED_WITH_TARGET, NI;UNRESOLVED_REFERENCE_WRONG_RECEIVER, OI;TYPE_MISMATCH!>_<!><Unit>() }\n\n        \"\".stringReceiver(1)\n        Any().anyReceiver(1)\n\n        with(\"\") {\n            stringReceiver(2)\n        }\n    }\n}\n"
        },
        {
            "code": "// SKIP_TXT\nclass A {\n    suspend operator fun component1(): String = \"K\"\n}\n\nfun foo(<!UNUSED_PARAMETER!>c<!>: suspend (A) -> Unit) {}\n\nfun bar() {\n    foo {\n        (x) ->\n        x.length\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines\n// SKIP_TXT\n\nfun <R> suspend(block: R) = block\n\nclass A {\n    infix fun <R> suspend(block: R) = block\n}\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann\n\nfun bar() {\n    <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    @Ann <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> @Ann {\n        println()\n    }\n\n    suspend() {\n        println()\n    }\n\n    suspend({ println() })\n\n    suspend<suspend () -> Unit> {\n        println()\n    }\n\n    suspend<Nothing?>(null)\n\n    val <!UNUSED_VARIABLE!>w<!>: (Any?) -> Any? = ::suspend\n\n    A().<!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    A().suspend() {\n        println()\n    }\n\n    A().suspend({ println() })\n\n    A().suspend<suspend () -> Unit> {\n        println()\n    }\n\n    A().suspend<Nothing?>(null)\n\n    with(A()) {\n        <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n            println()\n        }\n\n        suspend() {\n            println()\n        }\n\n        suspend({ println() })\n\n        suspend<suspend () -> Unit> {\n            println()\n        }\n\n        suspend<Nothing?>(null)\n    }\n\n    A() <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {\n        println()\n    }\n\n    A() suspend ({\n        println()\n    })\n\n    A() suspend \"\"\n}\n"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n// !USE_EXPERIMENTAL: kotlin.Experimental\n// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER -UNUSED_VARIABLE\n\nimport kotlin.experimental.ExperimentalTypeInference\n\nfun test1() {\n    <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>sequence<!> {\n        val a: Array<Int> = arrayOf(1, 2, 3)\n        val b = arrayOf(1, 2, 3)\n    }\n}\n\nfun test2() = <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>sequence<!> { arrayOf(1, 2, 3) }\n\n\nclass Foo<T>\n\nfun <T> f1(f: Foo<T>.() -> Unit) {}\n\n@UseExperimental(ExperimentalTypeInference::class)\nfun <T> f2(@BuilderInference f: Foo<T>.() -> Unit) {\n}\n\nfun test3() {\n    <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>f1<!> {\n        val a: Array<Int> = arrayOf(1, 2, 3)\n    }\n\n    <!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>f2<!> {\n        val a: Array<Int> = arrayOf(1, 2, 3)\n    }\n}\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\n// Function is suspend\n// parameter is inline\n// parameter is NOT suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is NOT allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\nsuspend inline fun test(c: () -> Unit) {\n    c()\n    val o = object: Runnable {\n        override fun run() {\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>()\n        }\n    }\n    val l = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>() }\n    c.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>startCoroutine<!>(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun builder(c: suspend () -> Unit) {}\n\nfun box() {\n    builder {\n        test {\n            calculate()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\n// Function is NOT suspend\n// parameter is inline\n// parameter is NOT suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is NOT allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\n\ninline fun test(c: () -> Unit) {\n    c()\n    val o = object : Runnable {\n        override fun run() {\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>()\n        }\n    }\n    val l = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>() }\n    c.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>startCoroutine<!>(EmptyContinuation)\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    builder {\n        test {\n            calculate()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -NOTHING_TO_INLINE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\n// Function is suspend\n// parameter is inline\n// parameter is suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is NOT allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\nsuspend inline fun test(c: <!REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE!>suspend<!> () -> Unit) {\n    c()\n    val o = object: SuspendRunnable {\n        override suspend fun run() {\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>()\n        }\n    }\n    val l: suspend () -> Unit = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>() }\n    <!USAGE_IS_NOT_INLINABLE!>c<!>.startCoroutine(EmptyContinuation)\n}\n\nfun builder(c: suspend () -> Unit) {\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    builder {\n        test {\n            calculate()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\n// Function is NOT suspend\n// parameter is noinline\n// parameter is NOT suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls NOT possible inside lambda matching to the parameter\ninline fun test(noinline c: () -> Unit) {\n    c()\n    val o = object: Runnable {\n        override fun run() {\n            c()\n        }\n    }\n    val l = { c() }\n    c.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>startCoroutine<!>(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    test {\n        <!ILLEGAL_SUSPEND_FUNCTION_CALL!>calculate<!>()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -NOTHING_TO_INLINE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\n// Function is suspend\n// parameter is crossinline\n// parameter is suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\nsuspend inline fun test(crossinline c: suspend () -> Unit) {\n    c()\n    val o = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n        }\n    }\n    val l: suspend () -> Unit = { c() }\n    <!USAGE_IS_NOT_INLINABLE!>c<!>.startCoroutine(EmptyContinuation)\n}\n\nfun builder(c: suspend () -> Unit) {}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    builder {\n        test {\n            calculate()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -NOTHING_TO_INLINE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\n// Function is NOT suspend\n// parameter is noinline\n// parameter is suspend\n// Block is NOT allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\n\ninline fun test(noinline c: suspend () -> Unit)  {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>c<!>()\n    val o = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n        }\n    }\n    val l: suspend () -> Unit = { c() }\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    test {\n        calculate()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -NOTHING_TO_INLINE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\n// Function is NOT suspend\n// parameter is crossinline\n// parameter is suspend\n// Block is NOT allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\n\ninline fun test(crossinline c: suspend () -> Unit)  {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>c<!>()\n    val o = object : SuspendRunnable {\n        override suspend fun run() {\n            c()\n        }\n    }\n    val l: suspend () -> Unit = { c() }\n    <!USAGE_IS_NOT_INLINABLE!>c<!>.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    test {\n        calculate()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -NOTHING_TO_INLINE -UNUSED_PARAMETER\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\ninterface SuspendRunnable {\n    suspend fun run()\n}\n\n// Function is NOT suspend\n// parameter is inline\n// parameter is suspend\n// Block is NOT allowed to be called inside the body of owner inline function\n// Block is NOT allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls possible inside lambda matching to the parameter\n\ninline fun test(<!INLINE_SUSPEND_FUNCTION_TYPE_UNSUPPORTED!>c: suspend () -> Unit<!>) {\n    <!ILLEGAL_SUSPEND_FUNCTION_CALL!>c<!>()\n    val o = object: SuspendRunnable {\n        override suspend fun run() {\n            <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>()\n        }\n    }\n    val l: suspend () -> Unit = { <!NON_LOCAL_RETURN_NOT_ALLOWED!>c<!>() }\n    <!USAGE_IS_NOT_INLINABLE!>c<!>.startCoroutine(EmptyContinuation)\n}\n\nfun builder(c: suspend () -> Unit) {}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    test {\n        calculate()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// COMMON_COROUTINES_TEST\n// WITH_COROUTINES\n// SKIP_TXT\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\n// Function is NOT suspend\n// parameter is crossinline\n// parameter is NOT suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls NOT possible inside lambda matching to the parameter\n\ninline fun test(crossinline c: () -> Unit) {\n    c()\n    val o = object: Runnable {\n        override fun run() {\n            c()\n        }\n    }\n    val l = { c() }\n    c.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>startCoroutine<!>(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    test {\n        <!ILLEGAL_SUSPEND_FUNCTION_CALL!>calculate<!>()\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\n// Function is suspend\n// parameter is crossinline\n// parameter is NOT suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls NOT possible inside lambda matching to the parameter\nsuspend inline fun test(crossinline c: () -> Unit) {\n    c()\n    val o = object : Runnable {\n        override fun run() {\n            c()\n        }\n    }\n    val l = { c() }\n    c.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>startCoroutine<!>(EmptyContinuation)\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    builder {\n        test {\n            <!NON_LOCAL_SUSPENSION_POINT!>calculate<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE -NOTHING_TO_INLINE\n// COMMON_COROUTINES_TEST\n// SKIP_TXT\n// WITH_COROUTINES\nimport COROUTINES_PACKAGE.*\nimport COROUTINES_PACKAGE.intrinsics.*\nimport helpers.*\n\n// Function is suspend\n// parameter is noinline\n// parameter is NOT suspend\n// Block is allowed to be called inside the body of owner inline function\n// Block is allowed to be called from nested classes/lambdas (as common crossinlines)\n// It is NOT possible to call startCoroutine on the parameter\n// suspend calls NOT possible inside lambda matching to the parameter\nsuspend inline fun test(noinline c: () -> Unit) {\n    c()\n    val o = object : Runnable {\n        override fun run() {\n            c()\n        }\n    }\n    val l = { c() }\n    c.<!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>startCoroutine<!>(EmptyContinuation)\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun calculate() = \"OK\"\n\nfun box() {\n    builder {\n        test {\n            <!NON_LOCAL_SUSPENSION_POINT!>calculate<!>()\n        }\n    }\n}\n"
        },
        {
            "code": "// !LANGUAGE: +ReleaseCoroutines\n// SKIP_TXT\n\nfun bar() {\n    suspend {\n        println()\n    }\n\n    @Ann suspend {\n        println()\n    }\n\n    suspend @Ann {\n        println()\n    }\n\n    kotlin.<!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspend<!> {\n\n    }\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspend<!>() {\n        println()\n    }\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspend<!>({ println() })\n\n    <!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspend<!><Unit> {\n        println()\n    }\n\n    val <!UNUSED_VARIABLE!>w<!>: (suspend () -> Int) -> Any? = ::<!NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND!>suspend<!>\n}\n\n@Target(AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\nannotation class Ann\n\nfun main(suspend: WLambdaInvoke) {\n\n    <!MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND!>suspend<!> {}\n}\n\nclass WLambdaInvoke {\n    operator fun invoke(<!UNUSED_PARAMETER!>l<!>: () -> Unit) {}\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER\n// !LANGUAGE: warn:Coroutines -ReleaseCoroutines\n\n<!EXPERIMENTAL_FEATURE_WARNING!>suspend<!> fun suspendHere(): String = \"OK\"\n\nfun builder(c: <!EXPERIMENTAL_FEATURE_WARNING!>suspend<!> () -> Unit) {\n\n}\n\nfun box(): String {\n    var result = \"\"\n\n    <!EXPERIMENTAL_FEATURE_WARNING!>builder<!> {\n        suspendHere()\n    }\n\n    return result\n}\n"
        },
        {
            "code": "// Reproduces exception in TypeResolver.kt: EA-66870\n\nimport java.util.ArrayList\n\nabstract class J {\n    public abstract fun <T : Collection<S>, S : List<<!WRONG_MODIFIER_TARGET!>in<!> *>> foo(x: T)\n    fun bar() {\n        val s = ArrayList<ArrayList<Int>>()\n        foo(s)\n    }\n}"
        },
        {
            "code": "class A {\n    fun bar() {\n        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                                    <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                                        <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                                            <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                                                <!UNRESOLVED_REFERENCE_WRONG_RECEIVER!>div<!> {\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                    <!UNRESOLVED_REFERENCE!>+<!>(<!UNRESOLVED_REFERENCE!>foo<!> ?: \"\")\n                                                                                                }\n                                                                                            }\n                                                                                        }\n                                                                                    }\n                                                                                }\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "data class A(val x: Int) {\n    fun toArray(): IntArray =\n            intArrayOf(x)\n\n    override fun <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>toString<!>() =\n            toArray().takeWhile { it != -1 } // .joinToString()\n}\n"
        },
        {
            "code": "// FILE: 1.kt\n\nfun useJ(j: J) {\n    j(42)\n}\n\nfun jj() {\n    useJ(<!TYPE_MISMATCH!>{}<!>)\n}\n"
        },
        {
            "code": "<!ILLEGAL_JVM_NAME!>@JvmName(<!NO_VALUE_FOR_PARAMETER!>)<!><!>\nfun foo() {}\n\n<!ILLEGAL_JVM_NAME!>@JvmName(<!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>)<!>\nfun bar() {}\n\n@JvmName(\"a\", <!TOO_MANY_ARGUMENTS!>\"b\"<!>)\nfun baz() {}\n"
        },
        {
            "code": "fun foo1(p: Pair<Int?, Int>): Int {\n    if (p.first != null) return p.first!!\n    return p.second\n}\n\nfun foo2(p: Pair<Int?, Int>): Int {\n    if (p.first != null) return <!SMARTCAST_IMPOSSIBLE!>p.first<!>\n    return p.second\n}\n"
        },
        {
            "code": "class A {\n    val x = arrayListOf<(A<<!SYNTAX!><!>>) -> Unit>()\n\n    // Here we got an exception during type comparison\n    fun foo(){\n        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>.add {}\n    }\n\n}\n"
        },
        {
            "code": "class O : Function2<Int, String, Unit> {\n    override fun invoke(p1: Int, p2: String) {\n    }\n}\n\nfun test() {\n    val a = fun(<!UNUSED_ANONYMOUS_PARAMETER!>o<!>: O) {\n    }\n    a <!TYPE_MISMATCH!>{}<!>\n}\n\n<!ABSTRACT_MEMBER_NOT_IMPLEMENTED!>class Ext<!> : <!SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE!>String.() -> Unit<!> {\n}\n\nfun test2() {\n    val <!UNUSED_VARIABLE!>f<!>: Ext = <!TYPE_MISMATCH!>{}<!>\n}\n"
        },
        {
            "code": "fun foo(c : Collection<String>) = {\n    c.filter{\n        val s : String? = bar()\n        if (s == null) <!UNUSED_EXPRESSION!>false<!> // here!\n        zoo(<!TYPE_MISMATCH!>s<!>)\n    }\n}\n\nfun bar() : String? = null\nfun zoo(<!UNUSED_PARAMETER!>s<!> : String) : Boolean = true"
        },
        {
            "code": "// !LANGUAGE: +NewInference\n\nfun main() {\n    val list = listOf(A())\n    list.forEach(A::<!EXPERIMENTAL_API_USAGE_ERROR!>foo<!>)\n    list.forEach {\n        it.<!EXPERIMENTAL_API_USAGE_ERROR!>foo<!>()\n    }\n}\n\nclass A {\n    @ExperimentalTime\n    fun foo() {\n        println(\"a\")\n    }\n}\n\n@<!EXPERIMENTAL_IS_NOT_ENABLED!>Experimental<!>(level = <!EXPERIMENTAL_IS_NOT_ENABLED!>Experimental<!>.Level.ERROR)\nannotation class ExperimentalTime\n"
        },
        {
            "code": "open class VeryBase {\n    protected fun baz() {}\n}\n\nopen class Base {\n    protected fun foo() { \n        bar() // Ok\n        baz() // Ok\n    }\n\n    inner class Inner {\n        fun fromInner() {\n            foo() // Ok\n            bar() // Ok\n            gav() // Ok\n            baz() // Ok\n        }\n    }\n\n    class NestedDerived : Base() {\n        fun fromNestedDerived() {\n            foo() // Ok\n            bar() // Ok\n            gav() // Ok\n            baz() // Ok\n        }\n    }\n    \n    companion object : VeryBase() {\n        var prop = 42\n            protected set\n\n        protected fun bar() {}\n\n        @JvmStatic protected fun gav() {}       \n\n        class Nested {\n            fun fromNested() {\n                bar() // Ok\n                gav() // Ok\n            }\n        }\n    }\n}\n\nclass Derived : Base() {\n    fun test() {\n        foo() // Ok\n        gav() // Ok\n        <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>bar<!>()\n        <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>baz<!>()\n        <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>prop<!> = 0\n    }\n\n    inner class DerivedInner {\n        fun fromDerivedInner() {\n            foo() // Ok\n            gav() // Ok\n            <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>bar<!>()\n            <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>baz<!>()\n            <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>prop<!> = 0\n        }\n    }\n\n    companion object {\n        fun test2() {\n            gav() // Ok\n            <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>bar<!>()\n            <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>baz<!>()\n            <!SUBCLASS_CANT_CALL_COMPANION_PROTECTED_NON_STATIC!>prop<!> = 0\n        }\n    }\n}\n\nclass Other {\n    fun test(base: Base, derived: Derived) {\n        base.<!INVISIBLE_MEMBER!>foo<!>()\n        base.<!UNRESOLVED_REFERENCE!>gav<!>()\n        base.<!UNRESOLVED_REFERENCE!>bar<!>()\n        derived.<!INVISIBLE_MEMBER!>foo<!>()\n        derived.<!UNRESOLVED_REFERENCE!>gav<!>()\n        derived.<!UNRESOLVED_REFERENCE!>bar<!>()\n    }\n}\n\nfun top(base: Base, derived: Derived) {\n    base.<!INVISIBLE_MEMBER!>foo<!>()\n    base.<!UNRESOLVED_REFERENCE!>bar<!>()\n    base.<!UNRESOLVED_REFERENCE!>gav<!>()\n    derived.<!INVISIBLE_MEMBER!>foo<!>()\n    derived.<!UNRESOLVED_REFERENCE!>bar<!>()\n    derived.<!UNRESOLVED_REFERENCE!>gav<!>()\n}\n"
        },
        {
            "code": "// !LANGUAGE: -DefaultImportOfPackageKotlinComparisons\n\nfun foo() = <!UNRESOLVED_REFERENCE!>compareBy<!><String> { <!UNRESOLVED_REFERENCE!>it<!>.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>length<!> }\n"
        },
        {
            "code": "fun f(a: Array<out Number>) = a.isArrayOf<Int>()\n\nfun f1(a: Array<out Number>) = <!USELESS_IS_CHECK!>a is Array<*><!>\n\nfun f2(a: Array<out Number>) = a is <!CANNOT_CHECK_FOR_ERASED!>Array<Int><!>"
        },
        {
            "code": "fun ff(a: Any) = a is Array<*> && <!DEBUG_INFO_SMARTCAST!>a<!>.isArrayOf<String>()"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// See also KT-10386\ninterface A\nclass B : A\nfun foo1(list: List<A>, arg: B?): Boolean {\n    // Type mismatch\n    return arg <!TYPE_INFERENCE_ONLY_INPUT_TYPES!>in<!> list // resolved to extension\n}\nfun foo2(list: List<A>, arg: B?): Boolean {\n    // FAKE: no cast needed\n    return arg as A? in list\n}\nfun foo3(list: List<A>, arg: B?): Boolean {\n    // No warning but KNPE risk\n    return arg!! in list\n}\n// But\nfun foo4(list: List<A>, arg: B): Boolean {\n    // Ok\n    return arg in list\n}"
        },
        {
            "code": "// !LANGUAGE: -ProperForInArrayLoopRangeVariableAssignmentSemantic\n// !DIAGNOSTICS: -UNUSED_VALUE\n// SKIP_TXT\n\nfun testObjectArray() {\n    var xs = arrayOf(\"a\", \"b\", \"c\")\n    for (x in xs) {\n        println(x)\n        <!ASSIGNMENT_TO_ARRAY_LOOP_VARIABLE!>xs<!> = arrayOf(\"d\", \"e\", \"f\")\n    }\n}\n\nfun testPrimitiveArray() {\n    var xs = intArrayOf(1, 2, 3)\n    for (x in xs) {\n        println(x)\n        <!ASSIGNMENT_TO_ARRAY_LOOP_VARIABLE!>xs<!> = intArrayOf(4, 5, 6)\n    }\n}\n\nvar global = arrayOf(\"a\", \"b\", \"c\")\n\nfun testGlobalArray() {\n    for (x in global) {\n        println(x)\n        global = arrayOf(\"d\", \"e\", \"f\")\n    }\n}\n\nfun testAssignmentNotInLoop() {\n    var xs = intArrayOf(1, 2, 3)\n    println(xs)\n    xs = intArrayOf(7, 8, 9)\n    for (x in xs) {\n        println(x)\n    }\n    xs = intArrayOf(4, 5, 6)\n    println(xs)\n}"
        },
        {
            "code": "// !LANGUAGE: -ProperForInArrayLoopRangeVariableAssignmentSemantic\n// !DIAGNOSTICS: -UNUSED_VALUE\n// SKIP_TXT\n\nfun testArrayCapturedInLocalFun() {\n    var xs = arrayOf(\"a\", \"b\", \"c\")\n\n    fun updateXs() {\n        xs = arrayOf(\"d\", \"e\", \"f\")\n    }\n\n    for (x in xs) {\n        println(x)\n        updateXs()\n    }\n}\n\nfun testArrayCapturedInLabmda() {\n    var xs = arrayOf(\"a\", \"b\", \"c\")\n\n    val updateXs = { xs = arrayOf(\"d\", \"e\", \"f\") }\n\n    for (x in xs) {\n        println(x)\n        updateXs()\n    }\n}\n\nfun testArrayCapturedInInlineLambda() {\n    var xs = arrayOf(\"a\", \"b\", \"c\")\n\n    for (x in xs) {\n        println(x)\n        run {\n            xs = arrayOf(\"d\", \"e\", \"f\")\n        }\n    }\n}\n\nfun testArrayCapturedInLocalObject() {\n    var xs = arrayOf(\"a\", \"b\", \"c\")\n\n    val updateXs = object : () -> Unit {\n        override fun invoke() {\n            xs = arrayOf(\"d\", \"e\", \"f\")\n        }\n    }\n\n    for (x in xs) {\n        println(x)\n        updateXs()\n    }\n}\n\nfun testArrayCapturedInLocalClass() {\n    var xs = arrayOf(\"a\", \"b\", \"c\")\n\n    class LocalClass {\n        fun updateXs() {\n            xs = arrayOf(\"d\", \"e\", \"f\")\n        }\n    }\n\n    val updater = LocalClass()\n\n    for (x in xs) {\n        println(x)\n        updater.updateXs()\n    }\n}\n\nfun testCapturedInLambdaAfterLoop() {\n    // NB false positive\n    var xs = intArrayOf(1, 2, 3)\n    for (x in xs) {\n        println(x)\n        <!ASSIGNMENT_TO_ARRAY_LOOP_VARIABLE!>xs<!> = intArrayOf(4, 5, 6)\n    }\n    val lambda = { xs = intArrayOf() }\n    lambda()\n}\n\nfun testCapturedInLambdaInLoopAfterAssignment() {\n    // NB false positive\n    var xs = intArrayOf(1, 2, 3)\n    for (x in xs) {\n        println(x)\n        <!ASSIGNMENT_TO_ARRAY_LOOP_VARIABLE!>xs<!> = intArrayOf(4, 5, 6)\n        val lambda = { xs = intArrayOf() }\n        lambda()\n    }\n}\n\nfun testCapturedInNonChangingClosure() {\n    // NB false positive\n    var xs = intArrayOf(1, 2, 3)\n    val lambda = { println(xs) }\n    for (x in xs) {\n        println(x)\n        <!ASSIGNMENT_TO_ARRAY_LOOP_VARIABLE!>xs<!> = intArrayOf(4, 5, 6)\n        lambda()\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER\n// SKIP_TXT\n// Related issue: KT-28370\n\nclass ExcA : Exception()\nclass ExcB : Exception()\n\nfun test1(s: String?) {\n    var t2: Boolean? = true\n    if (t2 != null) {\n        try {\n            t2 = null\n        }\n        catch (e: Exception) {\n            requireNotNull(s)\n        }\n        t2<!UNSAFE_CALL!>.<!>not()\n        s<!UNSAFE_CALL!>.<!>length\n    }\n}\n\nfun test2(s: String?) {\n    var t2: Boolean? = true\n    if (t2 != null) {\n        try {\n            t2 = null\n        }\n        finally {\n            requireNotNull(s)\n            t2 = true\n        }\n        <!DEBUG_INFO_SMARTCAST!>t2<!>.not()\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n}\n\nfun test3() {\n    var s: String? = null\n    s = \"\"\n    try {\n\n    }\n    catch (e: Exception) {\n        s = null\n        return\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}\n\nfun test4() {\n    var s: String? = null\n    s = \"\"\n    try {\n\n    }\n    catch (e: ExcA) {\n        s = null\n        return\n    }\n    catch (e: ExcB) {\n\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}\n\nfun test5(s: String?) {\n    try {\n        requireNotNull(s)\n    }\n    catch (e: ExcA) {\n        return\n    }\n    catch (e: ExcB) {\n\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test6(s: String?) {\n    try {\n        requireNotNull(s)\n    }\n    catch (e: Exception) {\n        return\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +NewDataFlowForTryExpressions\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER\n// Related issue: KT-28370\n\nfun test1(s1: String?) {\n    var s: String? = null\n    s = \"\"\n    try {\n        s = \"\"\n        requireNotNull(s1)\n    }\n    catch (e: Exception) {\n        return\n    }\n    finally {\n        <!OI;DEBUG_INFO_SMARTCAST!>s<!><!NI;UNSAFE_CALL!>.<!>length\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "// !WTIH_NEW_INFERENCE\n// SKIP_TXT\n\nclass ExcA : Exception()\nclass ExcB : Exception()\n\nfun test0(x: Int?) {\n    val y = try {\n        x\n    } finally {\n\n    }\n\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n        y<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    if (y != null) {\n        x<!UNSAFE_CALL!>.<!>inc()\n        <!DEBUG_INFO_SMARTCAST!>y<!>.inc()\n    }\n}\n\nfun test1(x: Int?) {\n    val y = try {\n        x\n    }\n    catch (e: Exception) {\n        42\n    }\n\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n        y<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    if (y != null) {\n        x<!UNSAFE_CALL!>.<!>inc()\n        <!DEBUG_INFO_SMARTCAST!>y<!>.inc()\n    }\n}\n\nfun test2(x: Int?) {\n    val y = try {\n        x\n    }\n    catch (e: Exception) {\n        x\n    }\n\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n        y<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    if (y != null) {\n        x<!UNSAFE_CALL!>.<!>inc()\n        <!DEBUG_INFO_SMARTCAST!>y<!>.inc()\n    }\n}\n\nfun test3(x: Int?) {\n    val y = try {\n        x\n    } catch (e: Exception) {\n        return\n    }\n\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n        y<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    if (y != null) {\n        x<!UNSAFE_CALL!>.<!>inc()\n        <!DEBUG_INFO_SMARTCAST!>y<!>.inc()\n    }\n}\n\nfun test5(x: Int?) {\n    val y = try {\n        x\n    }\n    catch (e: ExcA) {\n        return\n    }\n    catch (e: ExcB) {\n        x\n    }\n\n    if (x != null) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.inc()\n        y<!UNSAFE_CALL!>.<!>inc()\n    }\n\n    if (y != null) {\n        x<!UNSAFE_CALL!>.<!>inc()\n        <!DEBUG_INFO_SMARTCAST!>y<!>.inc()\n    }\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_TXT\n\nclass ExcA : Exception()\n\nclass ExcB(val map: Map<Int, Int>) : Exception()\n\nfun test0(): List<Int> = run {\n    try {\n        emptyList()\n    } finally {\n        <!UNUSED_EXPRESSION!>\"\"<!>\n        fun foo() {}\n    }\n}\n\nfun test1(): Map<Int, Int> = run {\n    try {\n        emptyMap()\n    } catch (e: ExcA) {\n        emptyMap()\n    } catch (e: ExcB) {\n        e.map\n    } finally {\n        <!UNUSED_EXPRESSION!>\"\"<!>\n    }\n}\n\nfun test2(): Map<Int, Int> = run {\n    <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>try {\n        emptyMap()\n    } catch (e: ExcA) {\n        <!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH, OI;TYPE_INFERENCE_EXPECTED_TYPE_MISMATCH!>mapOf(<!NI;TYPE_MISMATCH, NI;TYPE_MISMATCH!>\"\" to \"\"<!>)<!>\n    }<!>\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// SKIP_TXT\n\nclass ExcA : Exception()\n\nclass ExcB : Exception()\n\nfun test2() {\n    val s: String? = <!NI;TYPE_MISMATCH!>try {\n        \"\"\n    }\n    catch (e: ExcA) {\n        null\n    }\n    catch (e: ExcB) {\n        <!OI;CONSTANT_EXPECTED_TYPE_MISMATCH!>10<!>\n    }<!>\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test3() {\n    val s: String? = try {\n        \"\"\n    }\n    catch (e: ExcA) {\n        null\n    }\n    catch (e: ExcB) {\n        return\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test4() {\n    val s: String? = try {\n        \"\"\n    }\n    catch (e: ExcA) {\n        null\n    }\n    finally {\n        <!UNUSED_EXPRESSION!>\"\"<!>\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test5() {\n    <!UNREACHABLE_CODE!>val <!UNUSED_VARIABLE!>s<!>: String? =<!> try {\n        \"\"\n    }\n    catch (e: ExcA) {\n        null\n    }\n    finally {\n        return\n    }\n    <!UNREACHABLE_CODE!>s<!UNSAFE_CALL!>.<!>length<!>\n}\n\nfun test6() {\n    val s: String? = try {\n        \"\"\n    }\n    catch (e: ExcA) {\n        return\n    }\n    catch (e: ExcB) {\n        return\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test7() {\n    val s: String? = try {\n        \"\"\n    }\n    catch (e: ExcA) {\n        \"\"\n    }\n    catch (e: ExcB) {\n        \"\"\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test8() {\n    val s = try {\n        \"\"\n    } catch (e: ExcA) {\n        null\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test9() {\n    val s = try {\n        \"\"\n    } catch (e: ExcA) {\n        \"\"\n    }\n    s.length\n}\n\nfun test10() {\n    val x = try {\n        \"\"\n    } finally {\n        <!UNUSED_EXPRESSION!>42<!>\n    }\n    x.length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +NewDataFlowForTryExpressions\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER\n// SKIP_TXT\n// Related issue: KT-28370\n\nclass ExcA : Exception()\nclass ExcB : Exception()\n\nfun test1(s: String?) {\n    var t2: Boolean? = true\n    if (t2 != null) {\n        try {\n            t2 = null\n        }\n        catch (e: Exception) {\n            requireNotNull(s)\n        }\n        t2<!UNSAFE_CALL!>.<!>not()\n        s<!UNSAFE_CALL!>.<!>length\n    }\n}\n\nfun test2(s: String?) {\n    var t2: Boolean? = true\n    if (t2 != null) {\n        try {\n            t2 = null\n        }\n        finally {\n            requireNotNull(s)\n            t2 = true\n        }\n        <!DEBUG_INFO_SMARTCAST!>t2<!>.not()\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n}\n\nfun test3() {\n    var s: String? = null\n    s = \"\"\n    try {\n\n    }\n    catch (e: Exception) {\n        s = null\n        return\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}\n\nfun test4() {\n    var s: String? = null\n    s = \"\"\n    try {\n\n    }\n    catch (e: ExcA) {\n        s = null\n        return\n    }\n    catch (e: ExcB) {\n\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}\n\nfun test5(s: String?) {\n    try {\n        requireNotNull(s)\n    }\n    catch (e: ExcA) {\n        return\n    }\n    catch (e: ExcB) {\n\n    }\n    s<!UNSAFE_CALL!>.<!>length\n}\n\nfun test6(s: String?) {\n    try {\n        requireNotNull(s)\n    }\n    catch (e: Exception) {\n        return\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER\n// Related issue: KT-28370\n\nfun test1(s1: String?) {\n    var s: String? = null\n    s = \"\"\n    try {\n        s = \"\"\n        requireNotNull(s1)\n    }\n    catch (e: Exception) {\n        return\n    }\n    finally {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n}"
        },
        {
            "code": "// !WTIH_NEW_INFERENCE\n// SKIP_TXT\n\nclass MyException : Exception() {\n    val myField = \"field\"\n\n    fun myFun() {}\n}\n\nfun test1() {\n    val <!UNUSED_VARIABLE!>e<!> = \"something\"\n    try {}\n    catch (e: Exception) {\n        e.message\n        e.<!UNRESOLVED_REFERENCE!>length<!>\n    }\n}\n\nfun test2() {\n    try {}\n    catch (e: Exception) {\n        val <!NAME_SHADOWING!>e<!> = \"something\"\n        e.<!UNRESOLVED_REFERENCE!>message<!>\n        e.length\n    }\n}\n\nfun test3() {\n    try {}\n    catch (e: MyException) {\n        e.myField\n    }\n}\n\nfun test4() {\n    try {}\n    catch (e: Exception) {\n        val <!REDECLARATION, UNUSED_VARIABLE!>a<!> = 42\n        val <!NAME_SHADOWING, REDECLARATION, UNUSED_VARIABLE!>a<!> = \"foo\"\n    }\n}\n\nfun test5() {\n    try {}\n    catch (e: Exception) {\n        val <!UNUSED_VARIABLE!>a<!>: Int = 42\n        try {}\n        catch (e: MyException) {\n            e.myFun()\n            val <!NAME_SHADOWING!>a<!>: String = \"\"\n            a.length\n        }\n    }\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !LANGUAGE: +NewDataFlowForTryExpressions\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER\n// SKIP_TXT\n// Related issue: KT-28370\n\nclass ExcA : Exception()\nclass ExcB : Exception()\n\nfun test1() {\n    var x: String? = null\n    x = \"\"\n\n    try {\n        x = null\n    } catch (e: Exception) {\n        <!OI;DEBUG_INFO_SMARTCAST!>x<!><!NI;UNSAFE_CALL!>.<!>length // smartcast shouldn't be allowed (OOME could happen after `x = null`)\n        throw e\n    }\n    finally {\n        // smartcast shouldn't be allowed, `x = null` could've happened\n        <!OI;DEBUG_INFO_SMARTCAST!>x<!><!NI;UNSAFE_CALL!>.<!>length\n    }\n    // smartcast shouldn't be allowed, `x = null` could've happened\n    <!OI;DEBUG_INFO_SMARTCAST!>x<!><!NI;UNSAFE_CALL!>.<!>length\n}\n\n// With old DFA of try/catch info about unsound smartcasts after try\n//  removes only if there is at least one catch branch that not returns Nothing\nfun test2() {\n    var x: String? = null\n    x = \"\"\n\n    try {\n        x = null\n    } catch (e: Exception) {\n        // BAD\n        <!OI;DEBUG_INFO_SMARTCAST!>x<!><!NI;UNSAFE_CALL!>.<!>length\n    }\n    finally {\n        x<!UNSAFE_CALL!>.<!>length\n    }\n    x<!UNSAFE_CALL!>.<!>length\n}\n\nfun test3() {\n    var t2: Boolean? = true\n    if (t2 != null) { // or `t2 is Boolean`\n        try {\n            throw Exception()\n        } catch (e: Exception) {\n            t2 = null\n        }\n        <!OI;DEBUG_INFO_SMARTCAST!>t2<!><!NI;UNSAFE_CALL!>.<!>not() // wrong smartcast, NPE\n    }\n}\n\nfun test4() {\n    var t2: Boolean? = true\n    if (t2 != null) { // or `t2 is Boolean`\n        try {\n            t2 = null\n        } finally { }\n        <!OI;DEBUG_INFO_SMARTCAST!>t2<!><!NI;UNSAFE_CALL!>.<!>not() // wrong smartcast, NPE\n    }\n}\n\nfun test5() {\n    var s1: String? = null\n    var s2: String? = null\n    s1 = \"\"\n    s2 = \"\"\n    try {\n        TODO()\n    }\n    catch (e: ExcA) {\n        s1 = \"\"\n    }\n    catch (e: ExcB) {\n        s2 = null\n        return\n    }\n    finally {\n        <!OI;DEBUG_INFO_SMARTCAST!>s1<!><!NI;UNSAFE_CALL!>.<!>length\n        <!OI;DEBUG_INFO_SMARTCAST!>s2<!><!NI;UNSAFE_CALL!>.<!>length\n    }\n    <!OI;DEBUG_INFO_SMARTCAST!>s1<!><!NI;UNSAFE_CALL!>.<!>length\n    <!DEBUG_INFO_SMARTCAST!>s2<!>.length\n}\n\nfun test6(s1: String?, s2: String?) {\n    var s: String? = null\n    s = \"\"\n    try {\n        s = null\n        requireNotNull(s1)\n    }\n    catch (e: Exception) {\n        return\n    }\n    finally {\n        <!OI;DEBUG_INFO_SMARTCAST!>s<!><!NI;UNSAFE_CALL!>.<!>length\n        requireNotNull(s2)\n    }\n    <!OI;DEBUG_INFO_SMARTCAST!>s<!><!NI;UNSAFE_CALL!>.<!>length\n    <!NI;DEBUG_INFO_SMARTCAST!>s1<!><!OI;UNSAFE_CALL!>.<!>length\n    <!DEBUG_INFO_SMARTCAST!>s2<!>.length\n}"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_VALUE -VARIABLE_WITH_REDUNDANT_INITIALIZER\n// SKIP_TXT\n// Related issue: KT-28370\n\nclass ExcA : Exception()\nclass ExcB : Exception()\n\nfun test1() {\n    var x: String? = null\n    x = \"\"\n\n    try {\n        x = null\n    } catch (e: Exception) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length // smartcast shouldn't be allowed (OOME could happen after `x = null`)\n        throw e\n    }\n    finally {\n        // smartcast shouldn't be allowed, `x = null` could've happened\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    // smartcast shouldn't be allowed, `x = null` could've happened\n    <!DEBUG_INFO_SMARTCAST!>x<!>.length\n}\n\n// With old DFA of try/catch info about unsound smartcasts after try\n//  removes only if there is at least one catch branch that not returns Nothing\nfun test2() {\n    var x: String? = null\n    x = \"\"\n\n    try {\n        x = null\n    } catch (e: Exception) {\n        <!DEBUG_INFO_SMARTCAST!>x<!>.length\n    }\n    finally {\n        x<!UNSAFE_CALL!>.<!>length\n    }\n    x<!UNSAFE_CALL!>.<!>length\n}\n\nfun test3() {\n    var t2: Boolean? = true\n    if (t2 != null) { // or `t2 is Boolean`\n        try {\n            throw Exception()\n        } catch (e: Exception) {\n            t2 = null\n        }\n        <!DEBUG_INFO_SMARTCAST!>t2<!>.not() // wrong smartcast, NPE\n    }\n}\n\nfun test4() {\n    var t2: Boolean? = true\n    if (t2 != null) { // or `t2 is Boolean`\n        try {\n            t2 = null\n        } finally { }\n        <!DEBUG_INFO_SMARTCAST!>t2<!>.not() // wrong smartcast, NPE\n    }\n}\n\nfun test5() {\n    var s1: String? = null\n    var s2: String? = null\n    s1 = \"\"\n    s2 = \"\"\n    try {\n        TODO()\n    }\n    catch (e: ExcA) {\n        s1 = \"\"\n    }\n    catch (e: ExcB) {\n        s2 = null\n        return\n    }\n    finally {\n        <!DEBUG_INFO_SMARTCAST!>s1<!>.length\n        <!DEBUG_INFO_SMARTCAST!>s2<!>.length\n    }\n    <!DEBUG_INFO_SMARTCAST!>s1<!>.length\n    <!DEBUG_INFO_SMARTCAST!>s2<!>.length\n}\n\nfun test6(s1: String?, s2: String?) {\n    var s: String? = null\n    s = \"\"\n    try {\n        s = null\n        requireNotNull(s1)\n    }\n    catch (e: Exception) {\n        return\n    }\n    finally {\n        <!DEBUG_INFO_SMARTCAST!>s<!>.length\n        requireNotNull(s2)\n    }\n    <!DEBUG_INFO_SMARTCAST!>s<!>.length\n    s1<!UNSAFE_CALL!>.<!>length\n    <!DEBUG_INFO_SMARTCAST!>s2<!>.length\n}"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_VARIABLE\n\nfun <T> foo() {\n    val x = arrayOfNulls<<!TYPE_PARAMETER_AS_REIFIED!>T<!>>(5)\n}\n\ninline fun <reified T> bar() {\n    val x = arrayOfNulls<T>(5)\n}\n\nfun baz() {\n    bar<Int>()\n    val x: Array<Int?> = arrayOfNulls(5)\n}\n"
        },
        {
            "code": "// !WITH_NEW_INFERENCE\n\nfun <T> fail1(): Array<T> = <!TYPE_PARAMETER_AS_REIFIED!>Array<!>(1) { null!! }\nfun <T> ok1(block: () -> Array<T>): Array<T> = block()\ninline fun <reified T> ok2(): Array<T> = Array(1) { null!! }\n\n\nfun <T> fail2(): Array<T> = ok1 { Array<<!TYPE_PARAMETER_AS_REIFIED!>T<!>>(1) {  null!! } }\nfun <T> ok3(block: () -> Array<T>): Array<T> = ok1 { block() }\ninline fun <reified T> ok4(): Array<T> = ok1 { Array<T>(1) { null!! } }\n\nfun <T> fail3(block: () -> T): Pair<Array<T>, Array<T>> = Pair(<!NI;TYPE_PARAMETER_AS_REIFIED, TYPE_PARAMETER_AS_REIFIED!>arrayOf<!>(\n        block()), <!NI;TYPE_PARAMETER_AS_REIFIED, TYPE_PARAMETER_AS_REIFIED!>arrayOf<!>()\n)\ninline fun <reified T> ok5(block: () -> T): Pair<Array<T>, Array<T>> = Pair(\n        arrayOf(block()), arrayOf()\n)\n\n"
        },
        {
            "code": "// !DIAGNOSTICS: -UNUSED_PARAMETER -UNREACHABLE_CODE -UNUSED_VARIABLE -DEPRECATION\n// !WITH_NEW_INFERENCE\n\ninline fun<reified T> foo(block: () -> T): String = block().toString()\n\ninline fun <reified T: Any> javaClass(): Class<T> = T::class.java\n\nfun box() {\n    val a = <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION, UNSUPPORTED!>arrayOf<!>(null!!)\n    val b = <!UNSUPPORTED!>Array<!><<!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>Nothing?<!>>(5) { null!! }\n    val c = <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>foo<!>() { null!! }\n    val d = foo<Any> { null!! }\n    val e = <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>foo<!> { \"1\" <!CAST_NEVER_SUCCEEDS!>as<!> Nothing }\n    val e1 = <!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>foo<!> { \"1\" <!CAST_NEVER_SUCCEEDS!>as<!> Nothing? }\n\n    val f = javaClass<<!REIFIED_TYPE_FORBIDDEN_SUBSTITUTION!>Nothing<!>>()\n}\n"
        },
        {
            "code": "class Inv<T>\n\ninline operator fun <reified T> Inv<T>.invoke() {}\n\noperator fun <K> Inv<K>.get(<!UNUSED_PARAMETER!>i<!>: Int): Inv<K> = this\n\nfun <K> test(a: Inv<K>) {\n    <!TYPE_PARAMETER_AS_REIFIED!>a[1]()<!>\n}"
        },
        {
            "code": "// SKIP_TXT\n\npublic class Foo1 () {}\npublic class Foo2 constructor() {}\npublic class Foo3 public constructor() {}\npublic class Foo4 private constructor() {}\n\npublic class Foo5 {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>constructor<!>() {}\n}\n\npublic class Foo6 {\n    public constructor() {}\n}"
        },
        {
            "code": "// SKIP_TXT\n\npublic class Foo(<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>val bar<!>: Int, private var bar2: String, internal var bar3: Long, public var bar4: Int) {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>var simple<!>: Int = 10\n    public var simple2: Int = 10\n\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>val withGetter<!>: Int\n        get() = 10\n\n    public val withGetter2: Int\n        get() = 10\n\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>var getterAndSetter<!>: Int = 10\n        get() = field\n        set(v) { field = v }\n\n    public var getterAndSetter2: Int = 10\n        get() = field\n        set(v) { field = v }\n}"
        },
        {
            "code": "// SKIP_TXT\n\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>fun foo<!>() {}\n\npublic fun foo2() {}\n\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>fun <!NO_EXPLICIT_RETURN_TYPE_IN_API_MODE!>bar<!><!>() = 10\npublic fun <!NO_EXPLICIT_RETURN_TYPE_IN_API_MODE!>bar2<!>() = 10\npublic fun bar3(): Int = 10\n"
        },
        {
            "code": "// SKIP_TXT\n\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>class Foo1<!>() {}\n\npublic class Foo2() {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>fun method<!>() {}\n    public fun method2() {}\n    private fun method3() {}\n\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>fun <!NO_EXPLICIT_RETURN_TYPE_IN_API_MODE!>implicit<!><!>() = 10\n    public fun <!NO_EXPLICIT_RETURN_TYPE_IN_API_MODE!>implicit2<!>() = 10\n    public fun implicit3(): Int = 10\n}\n\npublic data class FooData(val i: Int, val s: String)\n\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>data class FooData2<!>(val i: Int, val s: String)\n\npublic class WithNested {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>class Nested<!> {}\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>inner class Inner<!> {}\n}"
        },
        {
            "code": "// SKIP_TXT\n\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>interface I1<!> {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>fun i<!>()\n}\n\npublic interface I2 {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>fun i<!>()\n}\n\npublic interface I3 {\n    public fun i()\n    public val v: Int\n}\n\npublic interface I4 {\n    public fun i(): Int\n    public val v: Int\n}\n\npublic class Impl: I3 {\n    override fun i() {}\n    override val v: Int\n        get() = 10\n}\n\npublic class Impl2: I4 {\n    override fun <!NO_EXPLICIT_RETURN_TYPE_IN_API_MODE!>i<!>() = 10\n    override val <!NO_EXPLICIT_RETURN_TYPE_IN_API_MODE!>v<!> = 10\n}\n\nprivate class PrivateImpl: I4 {\n    override fun i() = 10\n    override val v = 10\n}\n"
        },
        {
            "code": "// !DIAGNOSTICS: -EXPERIMENTAL_FEATURE_WARNING\n// SKIP_TXT\n\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>inline class Value1<!>(<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>val inner<!>: Int)\npublic inline class Value2(<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>val inner<!>: Int)\n<!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>inline class Value3<!>(public val inner: Int)\npublic inline class Value4(public val inner: Int)"
        },
        {
            "code": "// SKIP_TXT\n\npublic class Bar {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>companion object<!> {}\n}\n\npublic class Bar2 {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>companion object MyCompanion<!> {}\n}\n\npublic class Bar3 {\n    <!NO_EXPLICIT_VISIBILITY_IN_API_MODE!>object NestedObject<!> {}\n}"
        },
        {
            "code": "abstract class A : <!DEPRECATION!>Throwable<!>(1.0) {}\n\nfun foo() {\n    <!DEPRECATION!>Throwable<!>(1.5)\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n// SKIP_TXT\n\nfun foo(s: String) {\n    s.isBlank()\n    s.lines().checkType { _<List<String>>() }\n    s.repeat(1)\n\n    // We don't have `strip` extension, so leave it for a while in gray list\n    s.<!DEPRECATION!>strip<!>()\n}\n"
        },
        {
            "code": "// !CHECK_TYPE\n\ninterface A : MutableCollection<String> {\n    // Override of deprecated function could be marked as deprecated too\n    override fun nonExistingMethod(x: String) = \"\"\n}\n\nfun foo(x: MutableCollection<Int>, y: Collection<String>, z: A) {\n    x.<!DEPRECATION!>nonExistingMethod<!>(1).checkType { _<String>() }\n    y.<!DEPRECATION!>nonExistingMethod<!>(\"\")\n    z.<!DEPRECATION!>nonExistingMethod<!>(\"\")\n}\n"
        }
    ]
}